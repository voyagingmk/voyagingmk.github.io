<!DOCTYPE html>
<html>
  <head>
    <title>Wyman的技术博客 – 伪技术宅，兴趣点：服务器编程、游戏开发、人工智能</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
    <meta name="baidu-site-verification" content="0OpfO1OtHA" />
    
    <meta name="description" content="伪技术宅，兴趣点：服务器编程、游戏开发、人工智能">
    <meta property="og:description" content="伪技术宅，兴趣点：服务器编程、游戏开发、人工智能" />
    
    <meta name="author" content="Wyman的技术博客" />

    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Wyman的技术博客 - 伪技术宅，兴趣点：服务器编程、游戏开发、人工智能" href="/feed.xml" />

    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-65954265-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/index.html',
		  'title': ''
		});
	</script>
	<!-- End Google Analytics -->
	<!-- Baidu Analytics -->
	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?0dc968591d8c64196a37eca9ca4f86b3";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
	<!-- End Baidu Analytics -->

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="http://www.qiujiawei.com/images/avatar.jpg" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Wyman的技术博客</a></h1>
            <p class="site-description">伪技术宅，兴趣点：服务器编程、游戏开发、人工智能</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <h3>Tags: <div id="tag-cloud">
  <a href="/tag/c%2B%2B.html" class="set-1">c++</a> <a href="/tag/gamejam.html" class="set-1">gamejam</a> <a href="/tag/jekyll.html" class="set-1">jekyll</a> <a href="/tag/leetcode.html" class="set-5">leetcode</a> <a href="/tag/linear-algebra.html" class="set-3">linear algebra</a> <a href="/tag/math.html" class="set-1">math</a> <a href="/tag/maths.html" class="set-1">maths</a> <a href="/tag/matrix.html" class="set-3">matrix</a> <a href="/tag/nopoll.html" class="set-1">nopoll</a> <a href="/tag/pbrt.html" class="set-1">pbrt</a> <a href="/tag/quaternion.html" class="set-1">quaternion</a> <a href="/tag/raytrace.html" class="set-1">raytrace</a>
</div>
</h3>
<div class="posts">
  
    <article class="post">

      <h1><a href="/understanding-quaternions/">Understanding Quaternions 中文翻译《理解四元数》</a></h1>
      <div class="date">
        Written on September 30, 2015
      </div>
      <div class="entry">
        <p>原文地址:<a href="http://www.3dgep.com/understanding-quaternions/">http://www.3dgep.com/understanding-quaternions/</a></p>

<h2>正文</h2>

<p>在这篇文章中我会尝试用简单的方式去解释四元数的概念，即用可视化的方式解释四元数以及几种对四元数的操作。我将把矩阵、欧拉角和四元数放在一起比较，并解释什么时候该用四元数、什么时候该用欧拉角或矩阵。</p>

<h3>内容结构</h3>

<ul>
<li>介绍</li>
<li>复数

<ul>
<li>复数的加减</li>
<li>复数的系数缩放</li>
<li>复数的积</li>
<li>复数的平方</li>
<li>共轭复数</li>
<li>复数的绝对值</li>
<li>两复数的商</li>
</ul></li>
<li>i的幂</li>
<li>复数平面

<ul>
<li>旋转数（Rotors)</li>
</ul></li>
<li>四元数

<ul>
<li>作为有序数的四元数</li>
<li>四元数的加减</li>
<li>四元数的积</li>
<li>实四元数</li>
<li>四元数的系数缩放</li>
<li>纯四元数</li>
<li>四元数的加法形式</li>
<li>单位四元数</li>
<li>四元数的二元形式</li>
<li>共轭四元数</li>
<li>四元数范数</li>
<li>四元数规范化</li>
<li>四元数的逆</li>
<li>四元数的点乘</li>
</ul></li>
<li>旋转</li>
<li>四元数的插值

<ul>
<li>SLERP

<ul>
<li>四元数的差</li>
<li>四元数求幂运算</li>
<li>四元数的分数差</li>
<li>考虑？</li>
</ul></li>
<li>SQUARD</li>
</ul></li>
<li>结论</li>
<li>下载Demo</li>
<li>引用</li>
</ul>

      </div>

      <a href="/understanding-quaternions/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/pbrt-chapter2/">PBRT《章2》阅读笔记</a></h1>
      <div class="date">
        Written on September 28, 2015
      </div>
      <div class="entry">
        <p>最近在看线代的公开课，顺便也把PBRT这个坑开了，合在一起学。</p>

<p>本文的cpp代码均来自<a href="https://github.com/mmp/pbrt-v2">https://github.com/mmp/pbrt-v2</a>，木有修改。只为方便读者阅读。</p>

      </div>

      <a href="/pbrt-chapter2/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/linear-algebra-6/"><复习向>线性代数之矩阵的特征值、特征向量、特征矩阵、迹</a></h1>
      <div class="date">
        Written on September 26, 2015
      </div>
      <div class="entry">
        <h2>定义</h2>

<p>设A是数域F上的n阶矩阵，如果存在数域F中的一个数\(\lambda \)与数域上F的非零向量\(\alpha \)，使得：
\[ A\alpha = \lambda \alpha \]
则称\(\lambda \)为A的一个<strong>特征值(根)</strong>(eigenvalue)，称\(\alpha \)为A的属于特征值\(\lambda \)的<strong>特征向量</strong>(eigenvector)。</p>

<p>\( A\alpha \)和\(\alpha \)平行（即在同一个直线上。</p>

<p>\(\lambda E - A\)为A的<strong>特征矩阵</strong>，行列式\(f(\lambda ) = |\lambda E - A|\)为A的<strong>特征多项式</strong>，\(|\lambda E - A| = 0\)为A的<strong>特征方程</strong>,\((\lambda E - A)X=0\)是A关于该\(\lambda \)的<strong>齐次线性方程组</strong>。</p>

<p>A的主对角线上元素之和称为A的<strong>迹</strong>(trace)，记为tr(A)，即</p>

<p>\[ tr(A) = a_{11} + a_{11} + \cdots + a_{nn} \]</p>

<p>迹和特征值有很重要的联系：</p>

<p>\[ tr(A) = \lambda _{1} + \lambda _{2} + \cdots + \lambda _{n} \]</p>

<p>迹还和A的行列式有关系：</p>

<p>\[ |A| = \lambda _{1}\lambda _{2}\cdots \lambda _{n} \]</p>

      </div>

      <a href="/linear-algebra-6/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/linear-algebra-5/"><复习向>线性代数之正交矩阵</a></h1>
      <div class="date">
        Written on September 26, 2015
      </div>
      <div class="entry">
        <h2>基础知识</h2>

<p>标准正交向量组（Orthonormal vectors）的点积(内积)性质：</p>

<p>\( q_{i}^{T}q_{j} = 0 \) <strong>if</strong> \( i\neq j \)</p>

<p>\( q_{i}^{T}q_{j} = 1 \) <strong>if</strong> \( i = j \)</p>

<p>其中每个正交向量的长度\(||q_{i}||=1\)。</p>

<p>标准正交向量组成的矩阵是：</p>

<p>\( Q = \) \(  \left[ \begin{matrix} q_{1}&amp;\cdots&amp;q_{n}\\ \end{matrix} \right] \)</p>

<p>注意，列向量的分量数量未知，Q所以不一定是方阵。</p>

<p>\( Q^{T}Q =  \left[ \begin{matrix} q_{1}^{T}\\ \vdots\\ q_{n}^{T}\\ \end{matrix} \right] \left[ \begin{matrix} q_{1}&amp;\cdots&amp;q_{n}\\ \end{matrix} \right] = I \)</p>

<p>当Q是方阵时，显然Q有逆矩阵，且\( Q^{-1} = Q^{T} \)。</p>

<p>比如当Q为3阶单位矩阵I的置换矩阵时：</p>

<p>\( Q^{T}Q =  \left[ \begin{matrix} 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ 1&amp;0&amp;0\\ \end{matrix} \right] \left[ \begin{matrix} 0&amp;0&amp;1\\ 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ \end{matrix} \right] = I \)</p>

<p>或者三角函数作为元素的二阶Q：</p>

<p>\( Q^{T}Q =  \left[ \begin{matrix} cos\theta&amp;-sin\theta\\ sin\theta&amp;cos\theta\\ \end{matrix} \right]  \left[ \begin{matrix} cos\theta&amp;sin\theta\\ -sin\theta&amp;cos\theta\\ \end{matrix} \right] = I \)</p>

<h2>定义</h2>

<ul>
<li><p>如果实数域上的方阵A满足 \( A^{T}A = I \)，则称A为正交矩阵</p></li>
<li><p>当A的列向量的长度都为1时，称A为标准正交矩阵Q。</p></li>
</ul>

<h2>定理</h2>

<ul>
<li>当\(A^{-1} = A^{T}\)成立时A是正交矩阵</li>
<li>A的列(或行)向量组是\(R^{n}\)的一组标准正交基时，A是正交矩阵</li>
<li>正交矩阵A的行列式为1或-1</li>
<li>如果A是正交矩阵，则\(A^{-1},A^{T},A^{*}\)都是正交矩阵</li>
<li>如果A、B都是正交矩阵，那么AB也是正交矩阵</li>
</ul>

<h2>正交矩阵怎么用？</h2>

<p>在上一篇文章中，讲到了投影矩阵的各种公式，其中有一条是：</p>

<p>\[ A^{T}A\hat{x} = A^{T}b \]</p>

<p>这个戴着帽子的x是未知量，要求它的值，就需要再变换下：</p>

<p>\[ \hat{x} = (A^{T}A)^{-1}A^{T}b \]</p>

<p>那么问题来了：右边的式子有点复杂，又要算矩阵乘法又要算逆矩阵，是不是可以简化呢？</p>

<p>答案是可以，且要用到正交矩阵。因为A是由一组线性无关的列向量组成，当把这组向量转换为标准正交向量组时，就得到了标准正交矩阵Q。拿Q代入上面的式子，得到：</p>

<p>\[ Q^{T}Q\hat{x} = Q^{T}b \]</p>

<p>再根据上述的Q的公式，干掉左边的2个Q，得到：</p>

<p>\[ \hat{x} = Q^{T}b \]</p>

<p>瞬间豁然开朗。</p>

<p>但是还有一个问题，怎么从A得到Q呢？</p>

<h2>矩阵的正交化算法</h2>

<p>因为从A可以得到Q，所以必然某个矩阵R，使得 A = QR 成立，这个过程叫做A的QR分解（QR decomposition)。</p>

<h3>先举一个二维的例子：</h3>

<p>设 a1 = (3,4)、a2 = (4,3)，显然a1和a2线性无关（不在同一条直线上），且a1和a2的长度都不是1。a1、a2是二维空间的一组基(basis)。</p>

<p>a1,a2对应的矩阵为：</p>

<p>\[ A =  \left[ \begin{matrix} a_{1}&amp;a_{2}\\ \end{matrix} \right] =  \left[ \begin{matrix} 3&amp;4\\ 4&amp;3\\ \end{matrix} \right] \]</p>

<p>显然，A是一个方阵。接下来就是实现A的QR分解。</p>

<p>标准正交矩阵，可以分为2个步骤实现：</p>

<ol>
<li>正交化(orthogonal)</li>
<li>标准化(normalize)</li>
</ol>

<p>二维空间下，让2个向量正交化，即等于是要找出2个互相垂直的向量。怎么找最简单呢？因为这样的向量组无限多，于是a1或a2都可以是某组正交向量的其中一个向量。</p>

<p>那么，我们可以让a1作为一个正交向量，然后再找出一个与a1垂直的向量，就得到一组正交向量了。</p>

<p>设u1、u2为要求的标准正交向量组，n1、n2代表a1、a2的单位向量，那么可以有：</p>

<p>\[ u_{1} = n_{1} \]</p>

<p>u2怎么求？很简单，利用投影矩阵的知识即可完成。因为a2和a1线性无关，那么a2在a1上有且只有一个投影点p2，算出这个投影点p2，就能快速得到a2关于a1的error向量：</p>

<p>\[ e_{2} = a_{2} - p_{2} \]</p>

<p>为什么要算e2向量？因为e2向量的一个重要性质是，e2和a1是互相垂直的，换句话说就是，<strong>e2和a1正交!</strong>。有了e2，将其单位化后，就是u2了。</p>

<p>求u2的步骤：</p>

<ul>
<li>先求n1，即a1的单位向量</li>
</ul>

<p>\[ n_{1} = \dfrac { a_{1} }{ ||a_{1}|| } \] </p>

<ul>
<li>求出a2的投影点p2</li>
</ul>

<p>\[ p_{2} = n_{1}\dfrac { n_{1}^{T}a_{2} }{  n_{1}^{T} n_{1} } = n_{1}(n_{1}^{T}a_{2}) \] </p>

<p>那个分母为什么可以去掉呢？这是因为n1是单位向量，\( n_{1}^{T} n_{1} \)是n1的内积，显然这个内积等于1。</p>

<ul>
<li>求e2</li>
</ul>

<p>\[ e_{2} = a_{2} - p_{2} = a_{2} - n_{1}(n_{1}^{T}a_{2}) \]</p>

<ul>
<li>单位化e2，得到u2</li>
</ul>

<p>\[ u_{2} = \dfrac { e_{2} }{ ||e_{2}|| } \]</p>

<p>好了，公式出来了，拿上面的例子验证下：</p>

<p>\[ u_{1} = n_{1} = \dfrac { a_{1} }{ ||a_{1}|| } = (\dfrac {3}{5},\dfrac {4}{5} ) \]</p>

<p>\[ e_{2} = a_{2} - p_{2} = a_{2} - n_{1}(n_{1}^{T}a_{2}) = (\dfrac {28}{25},\dfrac {-21}{25}) \]</p>

<p>\[ u_{2} = \dfrac { e_{2} }{ ||e_{2}|| } = (\dfrac {4}{5},\dfrac {-3}{5}) \]</p>

<p>\[ u_{1} \cdot u_{2} = (\dfrac {3}{5},\dfrac {4}{5}) \cdot (\dfrac {4}{5},\dfrac {-3}{5}) = 0 \]</p>

<p>u1和u2的内积为0，且长度均为1，所以U1和u2是一组标准正交向量。</p>

<p>\[ Q =  \left[ \begin{matrix} u_{1}&amp;u_{2}\\ \end{matrix} \right] \]</p>

<h3>高维时的通用QR解法</h3>

<p>上面是维度为2时的QR分解过程，接下来谈谈3维以及n维的情况。</p>

<p>当维度为3时，还是比较好想象的，我们分步构想下QR分解过程：</p>

<ul>
<li>A矩阵由3个线性无关的向量构成，A的列空间是一个三维空间，即三维空间的任意一个点都可以通过线性组合这3个向量得到</li>
<li>设3个向量为a1、a2、a3，先对a1、a2进行正交化运算，过程和上述的一致，除了\(a_{i}\)变成了3个分量。</li>
<li>正交化a1、a2，就得到了a1、a2对应的平面空间的一组标准正交基u1、u2</li>
<li>于是原问题变成：求解u1、u2、a3的正交化。u1和u2已经是标准正交向量，不用管它们，问题就是求出u3。</li>
<li>a3是在u1、u2对应的平面<strong>之外</strong>的一个点，a3在这个平面上有且只有一个投影点p3，将它求出来</li>
<li>再求出\( e_{3} = a_{3} - p_{3} \)就得到了a3的error向量，该向量垂直于u1、u2平面！</li>
<li>将e3标准化后，就得到了u3</li>
</ul>

<p>n&gt;3维的情况，可以用归纳法解出。</p>

<p>高维情况下的QR分解，公式如下：</p>

<p>\[ A =  \left[ \begin{matrix} a_{1}&amp;a_{2}&amp;\cdots&amp;a_{n}\\ \end{matrix} \right] \]
\[ A =  \left[ \begin{matrix} u_{1}&amp;u_{2}&amp;\cdots&amp;u_{n}\\ \end{matrix} \right] \left[ \begin{matrix} a_{1}\cdot u_{1}&amp;a_{2}\cdot u_{1}&amp;\cdots &amp;a_{n}\cdot u_{1}\\ 0&amp;a_{2}\cdot u_{2}&amp;\cdots &amp;a_{n}\cdot u_{2}\\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots\\ 0&amp;0&amp;\cdots &amp;a_{n}\cdot u_{n}\\ \end{matrix} \right] = QR \]</p>

<p>Q是标准正交矩阵，R是上三角矩阵。</p>

<p>证明过程略，不过可以简单分析下这公式的正确性。</p>

<p>Q乘以R的结果是A矩阵，那么可以得到：</p>

<p>\[ a_{1} = u_{1}(a_{1}\cdot u_{1}) \]</p>

<p>这个式子，是不是很眼熟，其实就是投影公式：</p>

<p>\[ p_{1} = a_{1} = u_{1}\dfrac { u_{1}^{T}a_{1} }{  u_{1}^{T} u_{1} } = u_{1}(u_{1}^{T}a_{1}) = u_{1}(a_{1}\cdot u_{1}) \] </p>

<p>（后面的内积有2种写法，同个意思，不用在意）</p>

<p>这个式子说明，经过QR分解后，a1的投影点还是a1，且在u1上。（但a1不一定等于u1）</p>

<p>我把a2也写出来：</p>

<p>\[ a_{2} = u_{1}(a_{2}\cdot u_{1}) + u_{2}(a_{2}\cdot u_{2}) \]</p>

<p>类似a1，a2 = a2在u1的投影 + a2在u2的投影。（注意：a2一定不在u上，因为这样a1和a2就线性有关了；a2不一定在u2上）</p>

<p>然后a3，就不用写了，显然a3 = a3在u1的投影 + a3在u2的投影 + a3在u2的投影。</p>

<p>\(a_{n}\)以此类推。所以这个公式是OK的。</p>

<p>总结一下：</p>

<p>要对A做QR分解，得从A本身出发，算出各个标准正交向量，并且这是一个迭代的过程：从a1算出u1，再通过a2和u1得到u2，接着，\(u_{n}\)都可以通过\(a_{n}\)和前面算出来的\(u_{i}\ \ (i&lt;n)\)得到。</p>

<p>如果QR分解的目的只是为了得到Q矩阵，那么R矩阵是没什么卵用的，因为R矩阵本身也包含了目标变量n，所以没办法用\(Q=AR^{-1}\)公式求Q矩阵。</p>

      </div>

      <a href="/linear-algebra-5/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/linear-algebra-4/"><复习向>线性代数之投影矩阵</a></h1>
      <div class="date">
        Written on September 26, 2015
      </div>
      <div class="entry">
        <h2>投影矩阵是what？</h2>

<p>先给出结论：投影矩阵P（projection），可以把一个向量b，投影到一个“空间”上，投影点称为p，从p到b的向量称为e，e = b - p，e的含义是误差向量（error）。</p>

<p>再举例子帮助读者理解：</p>

<h2>上述的“空间”为一维时</h2>

<p>一个向量b，投影到一个一维的空间，显然，这个空间是一条直线，设直线为单位向量a，那么这个投影其实就是找到这个直线上离b最近的点p，误差向量e就是b到p的距离。因为p在a上，所以有：</p>

<p>p = ax（p和a都是向量，x是一个值）【式子1】</p>

<p>然后，因为p是b在a上的投影，那么意味着，a与e成90度角，当2个向量互相垂直时，他们的点积（或 内积、 dot product）等于0，于是有：</p>

<p>\[ a^{T}e = 0 \]</p>

<p>\[ a^{T}(b-xa) = 0 \]</p>

<p>再变换一下，得到：</p>

<p>\[ xa^{T}a = a^{T}b  \]</p>

<p>\[ x = \dfrac { a^{T}b }{ a^{T}a } \]</p>

<p>根据【式子1】，最后得到：</p>

<p>\[ p = a\dfrac { a^{T}b }{ a^{T}a } 【式子2】 \] </p>

<p>看，式子左边的p是投影向量，右边有b和a，b是原向量，a是空间向量。所以这个式子隐含了一个变换关系：从b通过某种变换能够得到p。所谓的投影矩阵P（注意，是大写），就在这个式子里面了。</p>

<p>投影矩阵P应该有这样的效果：</p>

<p>\[ p = Pb  \]</p>

<p>P作用于任意一个向量b，能够得到b在某个空间的投影点p。</p>

<p>注意: <strong>P是一个矩阵，不是一个数！</strong></p>

<p>【式子2】应该要变换成什么样子，才能变出一个矩阵呢？答案如下：</p>

<p>\[ p = \dfrac { aa^{T} }{ a^{T}a }b \] </p>

<p>投影矩阵P：</p>

<p>\[ P = \dfrac { aa^{T} }{ a^{T}a } \] </p>

<p>式子右边是一个矩阵，这是因为分子是\(aa^{T}\)，这不是一个数，而是一个矩阵（分母才是一个数）。（顺序很重要！）</p>

<p>投影矩阵P的2条重要性质：</p>

<ul>
<li><p>\( P = P^{T} \)</p></li>
<li><p>\( P^{n} = P \) , n为正整数</p></li>
</ul>

<p>第二条性质说明，投影点p再次经过同一个投影变换，依然还是p。这样的矩阵称为幂等矩阵。</p>

<h2>投影的实际意义?</h2>

<p>为什么要找投影点，这是因为，当我们要计算线性方程组 \( Ax=b \)的解时，它可能是无解的。怎么办呢？既然没有正解，就找最优解！最优解就是找一个和b最近的p，并求解\( A\hat{x}=p \)。</p>

<h2>上述的“空间”为二维时</h2>

<p>一个向量b，投影到一个二维的空间，显然，这个空间是一个平面。一个平面，可以由2个线性无关（independant)的向量\(a_{1}\)和\(a_{2}\)确定。a1和a2是这个平面的一组基（basis）。</p>

<p>一组基可以写成矩阵的形式：</p>

<p>\[ A = [ \ a_{1}\ \ a_{2} ] \ \] 【式子3】</p>

<p>和一维情况做一个对比：</p>

<p>投影点p，在一维时 p = ax。那么，在二维平面上呢？显然，p可以由这个平面的基得到：\( p = \hat{x_{1}}a_{1}+x_{2}a_{2} \)。</p>

<p>根据【式子3】可以得到：</p>

<p>\[ p = A\hat{x} \]</p>

<p>\[ e = b - p = b - A\hat{x} \]</p>

<p>上述一维的情况时的那个e，在二维时也是一样的，e会垂直于这个空间，也就是e和这个平面是垂直的。</p>

<p>因为e和平面垂直，平面的基是\(a_{1}\)和\(a_{2}\)，即a与\(a_{1}\)和\(a_{2}\)垂直，所以：</p>

<p>\[ a_{1}^{T}(b - A\hat{x}) = 0 \]</p>

<p>\[ a_{2}^{T}(b - A\hat{x}) = 0 \]</p>

<p>\[  \left[ \begin{matrix} a_{1}^{T}\\ a_{2}^{T}\\ \end{matrix} \right] (b - A\hat{x}) =  \left[ \begin{matrix} 0\\ 0\\ \end{matrix} \right] \]</p>

<p>\[ A^{T}(b - A\hat{x}) = 0 \]</p>

<p>\[ A^{T}A\hat{x} = A^{T}b \]</p>

<p>这和一维情况的其中一个式子很像，对吧。 但\(A^{T}A\)是一个高维的东西，它不是一个数，而是一个矩阵。</p>

<p>再变换一下，得到：</p>

<p>\[ \hat{x} = (A^{T}A)^{-1}A^{T}b \]</p>

<p>所以投影点p和b的变换公式就是：</p>

<p>\[ p = A\hat{x} = A(A^{T}A)^{-1}A^{T}b \]</p>

<p>抽出投影矩阵：</p>

<p>\[ P = A(A^{T}A)^{-1}A^{T} 【式子4】\]</p>

<p>这条式子，中间的括号假如可以去掉的话，就变成了：</p>

<p>\[ P = A A^{-1} (A^{T})^{-1} A^{T} \]</p>

<p>\[ P = II = I \]</p>

<p>为什么P变成了单位矩阵I呢？这是因为把\( (A^{T}A)^{-1} \)解开的前提是<strong>A是一个方阵</strong>。但就现在这个二维平面的例子而言，A由2个基构成（（每个基有3个分量），A并不是方阵，所以是不能解开的。上述的变换是错误的。</p>

<p>当A是方阵时，意味着有3个基，而又因为基之间线性无关，所以方阵A不可能只是代表一个平面空间，实际上，A代表的是一个三维空间。所以，一个在三维空间的点b，投影到三维空间后，当然还是b。所以A是方阵时，投影矩阵就是单位矩阵I。</p>

<p>当A不是方阵时，要按照【式子4】去求投影矩阵P。</p>

<p>另外，在高维情况下，P的那2条性质依然成立。</p>

      </div>

      <a href="/linear-algebra-4/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/cpp-1/">More Effective C++ 笔记</a></h1>
      <div class="date">
        Written on September  6, 2015
      </div>
      <div class="entry">
        <h2>基础议题(basics)</h2>

<h3>条款1：仔细区别pointers和references</h3>

<ul>
<li>使用引用，可以不做null判断</li>
<li>当需要考虑“不指向任何对象”的可能性时，或是考虑“在不同时间指向不同对象”的能力时，你就应该采用pointer，前一种情况可以将pointer设为null，后一种情况可以改变pointer所指对象。</li>
<li>当确定“总是会代表某个对象”，而且“一旦代表了该对象就不能够再改变”，那么应该选用reference。</li>
<li>总是令operator[]返回一个reference。</li>
</ul>

<h3>条款2：最好使用C++转型操作符</h3>

<ul>
<li>需要使用类型转换时，先考虑能不能用static_cast</li>
<li>不能用static_cast的情况有：

<ul>
<li>移除表达式的常量性(constness)或变易性(volatileness) [用const_cast]</li>
<li>继承体系的转型 [用dynamic_cast]</li>
</ul></li>
<li>const_cast无法进行继承体系的向下转型(cast down)</li>
<li>dynamic_cast无法用在缺乏虚函数的类型身上，也不能改变常量性</li>
<li>reinterpret_cast不具移植性，是平台相关的</li>
</ul>

<h3>条款3：绝对不要以多态(polymorphically)方式处理数组</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">printBSTArray</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">BST</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">numElements</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numElements</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">BST</span> <span class="n">BSTArray</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">BalanceBST</span> <span class="n">bBSTArray</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">printBSTArray</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="n">BSTArray</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span><span class="c1">//OK</span>
<span class="n">printBSTArray</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="n">bBSTArray</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span><span class="c1">//Not OK</span>
</code></pre></div>
<p>array[i]其实是一个“指针算术表达式”的简写；它代表的其实是* (array+i)。array所指内存和array+i所指内存的距离是i<em>sizeof(数组中的单个元素)。而因为printBSTArray中，声明了array的元素的类型为BST，所以距离是i</em>sizeof(BST)。但当传入的是BalanceBST的数组时，就会出错了。</p>

<p>在删除数组时，也有这个问题，C++语言规范中说，通过base class指针删除一个由derived classes objects构成的数组，其结果未定义。</p>

<p>总的一句话：多态和指针算术不能混用，数组对象几乎总是会涉及指针的算法运算，所以数组和多态不要混用。</p>

<h3>条款4：非必要不提供 default constructor</h3>

<ul>
<li>有default constructor时，可以避免3个问题，一是类数组的初始化不支持带参数的构造函数，二是一些c++模板库，要求被实例化的目标类型必须要有default constructor，三是类的虚继承体系中，如果基类没有default constructor，那么每一层的子类都必须了解基类的构造函数。</li>
<li>反过来看，使用default constructor时，可能会增加了类的复杂度，因为不能保证每个字段都有意义（default constructor导致赋予字段一个缺省值，这个缺省值可能是多余的）。并且，使用这些字段的调用者，都需要做一个“测试”，测试字段是否真的被初始化了。</li>
</ul>

<h2>操作符(operators)</h2>

<h3>条款5：对定制的“类型转换函数”保持警觉</h3>

<ul>
<li><p>用一个普通函数来替代类型转换操作符。因为这种操作符重载是&quot;隐式(implicit)&quot;的：
<code>c
class Rational{
public:
operator double() const; //not good
double asDouble() const; //good
}
</code></p></li>
<li><p>单自变量构造函数，前面要加一个explicit声明。</p></li>
<li><p>用proxy classes 技术时，可以使用隐式类型转换，因为不能连续执行多个类型转换行为（详情见条款30）。</p></li>
</ul>

<h3>条款6：区别 increment/decrement操作符的前置和后置形式</h3>

<ul>
<li>后置式应以其前置式为基础（即后置式的函数体的累加实现，是调用了前置式）。</li>
<li>后置式的返回类型必须加const，从而禁止obj++++这种写法。</li>
<li>后置式的函数声明的参数要带一个毫无意义的int，只是用来和前置式做区分。</li>
<li>虽然禁止obj+++++，但是++++obj是允许的。</li>
</ul>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">UPInt</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">UPInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span><span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">){};</span>
    <span class="n">UPInt</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">++</span><span class="p">(){</span>
        <span class="n">m_num</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="n">UPInt</span> <span class="n">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
        <span class="n">UPInt</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
        <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span> 
        <span class="k">return</span> <span class="n">oldValue</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="nf">get</span><span class="p">(){</span>
        <span class="k">return</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="p">}</span>   
<span class="p">};</span>
</code></pre></div>
<h3>条款7：千万不要重载&amp;&amp;、||和, 操作符</h3>

<p>直接贴上我写的一个代码片段：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">class</span> <span class="n">Boolean</span><span class="p">{</span>
    <span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_bool</span><span class="p">;</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">Boolean</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="n">m_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">m_bool</span><span class="p">(</span><span class="n">b</span><span class="p">){};</span>
    <span class="kt">bool</span> <span class="n">operator</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">){</span>
        <span class="k">if</span><span class="p">((</span><span class="kt">bool</span><span class="p">)(</span><span class="o">*</span><span class="n">this</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">){</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">operator</span> <span class="nf">bool</span><span class="p">(){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;get:&quot;</span><span class="o">&lt;&lt;</span><span class="n">m_name</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">m_bool</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Boolean</span> <span class="n">a</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">Boolean</span> <span class="n">b</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;a &amp;&amp; b = &quot;</span><span class="o">&lt;&lt;</span><span class="n">result</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>运行结果为:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="nl">get</span><span class="p">:</span><span class="n">b</span>
<span class="nl">get</span><span class="p">:</span><span class="n">a</span>
<span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
<p>a &amp;&amp; b这个表达式，b先求值了，这不反人类么。</p>

<p>所以：</p>

<ul>
<li>&amp;&amp; || , 被重载后，“函数调用语义” 会取代 “骡死式语义”。前者的求值顺序是未定义的（C++规范里没有定义），后者必然是从左至右。</li>
</ul>

<h3>条款8：了解各种不同意义的new和delete</h3>

<h4>关于new</h4>

<ul>
<li>new operator是指：</li>
</ul>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">string</span> <span class="o">*</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
</code></pre></div>
<p>这样子的代码里的new。这个操作符是由语言内建的，就像sizeof一样，不能被改变意义，总是做相同的事情。它的动作分为2个方面，第一，它分配足够的内存，用来放置某类型的对象；第二，它调用一个constructor，为刚才分配的内存中的那个对象设定初值。new operator总是做这两件事，你无法改变其行为。</p>

<ul>
<li>operator new的一般用法，用来分配且仅分配内存（不调用构造函数）：</li>
</ul>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;iostream&gt;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">class</span> <span class="n">Widget</span><span class="p">{</span>
    <span class="kt">char</span> <span class="n">member</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;\0&#39;</span><span class="p">};</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">Widget</span><span class="p">(){};</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="p">(){</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;member=&quot;</span><span class="o">&lt;&lt;</span><span class="n">member</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">rawMemory</span> <span class="o">=</span> <span class="n">operator</span> <span class="n">new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Widget</span><span class="p">));</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rawMemory</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="o">&lt;&lt;</span><span class="n">rawMemory</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">Widget</span> <span class="o">*</span> <span class="n">widget</span> <span class="o">=</span> <span class="p">(</span><span class="n">Widget</span><span class="o">*</span><span class="p">)</span> <span class="n">rawMemory</span><span class="p">;</span>
    <span class="n">widget</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>输出：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">8</span><span class="p">,</span><span class="mh">0x306850</span>
<span class="n">member</span><span class="o">=</span><span class="n">Pm0</span>
</code></pre></div>
<ul>
<li>placement new 用法：</li>
</ul>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;iostream&gt;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">class</span> <span class="n">Widget</span><span class="p">{</span>
    <span class="kt">char</span> <span class="n">member</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;\0&#39;</span><span class="p">};</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="n">Widget</span><span class="p">(){};</span>
<span class="p">};</span>

<span class="n">Widget</span><span class="o">*</span> <span class="nf">constructWidgetInBuf</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">new</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="n">Widget</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Widget</span><span class="p">)];</span>
    <span class="n">Widget</span> <span class="o">*</span> <span class="n">w</span> <span class="o">=</span> <span class="n">constructWidgetInBuf</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&quot;,&quot;</span><span class="o">&lt;&lt;</span><span class="n">buf</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>输出：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="mi">2</span><span class="p">,</span><span class="n">a</span>
</code></pre></div>
<ul>
<li>使用策略：如果你希望将对象产生于heap内存，请使用new operator。它不但分配内存而且为该对象调用一个constructor。如果你只是打算分配内存，请调用operator new，那就没有任何constructor会被调用。如果你打算在heap objects产生时自己决定内存分配方式，请写一个自己的operator new（重载），并使用new operator，它将会自动调用你所写的operator new。如果你打算在已分配的内存中构造对象，请使用placement new。</li>
</ul>

<h4>关于delete</h4>

<ul>
<li>类似new，delete也分为 delete operator 和 operator delete。</li>
<li>当成对使用operator new、operator delete时，相当于C的malloc和free。</li>
</ul>

<h4>关于数组</h4>

<ul>
<li>array new指的是：</li>
</ul>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="n">new</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div>
<p>这样子的代码里的new operator，由于诞生的是数组，所以内存是由一个兄弟函数：operator new[]负责分配。</p>

<ul>
<li><p>array new 不仅要分配多个对象的内存(operator new[])，且要对每一个对象的内存调用一次default constructor。</p></li>
<li><p>array delete(即 operator delete[])，类似array new，不过它是先调用每个对象的dtor，再调用 operator delete[]以释放内存。</p></li>
</ul>

<h2>异常</h2>

<p>大概读了一遍这些条款，最后作者的结论是，能不使用异常就不使用异常，这是因为使用异常会有附加的性能开销。但是具体的影响值不明朗，和具体的编译器有关系。</p>

<h3>条款9：利用destructors避免泄露资源</h3>

<p>问题：C++函数调用过程中，如果出现异常，就会导致这个函数的后续代码不被执行。想一想，如果函数开头new了一个对象，在函数末尾会delete这个对象，而异常出现在中间，那么这个对象就不会被析构，于是内存发生泄露。</p>

<p>解决之道就是，用智能指针来管理堆对象，因为智能指针是局部变量，当异常发生时，局部变量是会正常析构的，而，智能指针所绑定的heap对象，会在智能指针析构时也顺带析构。那么这个问题就算是解决了。（真的吗？）</p>

<p>想一下，如果是在智能指针绑定那个对象（取得资源）过程中发生异常，或者是在资源被析构时发生异常，确定不会出问题吗？</p>

<p>很不幸，确实问题并没有完美解决。</p>

<h3>条款10：在constructors内阻止资源泄露（resource leak）</h3>

<p>首先要知道一个事实：C++不自动清理那些“构造期间抛出异常”的对象。</p>

<p>所以，构造函数的编写要小心，要确保构造过程中抛出异常时，仍能对已初始化的变量进行回收处理，避免泄露。</p>

<p>解决方法：使用trycatch，确保构造函数所有可能被抛出的异常都能够捕获到，在catch里释放资源，并，再把异常往上继续抛出。</p>

<p>这个事情实际上并不简单。比如，如果构造函数使用了初始化列表，而初始化列表代码中使用了new，这个new就没法写trycatch了。如果初始化列表有2个变量A、B，A成功拿到对对象，和B的对象构造失败（bad_alloc），A的堆对象就没机会释放了，就悲剧了。（针对这个情况，可以把new操作封装在某个成员函数里，然后在这个成员函数写trycatch，初始化列表调用这个成员函数即可）。</p>

<p>更明智的做法是，把这种“需要获得对对象的成员变量”，改成使用智能指针。还是那2个A、B，当B出事时，A因为是一个智能指针成员变量，且已经完整构造，A会正常析构，析构的时候会正常地把堆对象也释放。</p>

<h3>条款11：禁止异常流出destructors之外</h3>

<p>析构函数在2种情况下会被调用：一，对象在正常状态下被销毁；二，对象呗异常处理机制销毁。</p>

<p>如果异常流出析构函数，当程序是处在上述第二种情况时，会导致程序被terminate。</p>

<p>解决办法是，在析构函数里写trycatch，捕获一切可能的异常，并把catch留空，即，捕获异常后不做任何事情。</p>

<p>另外一个不让异常流出析构函数的理由是，如果析构过程中，某个敌方抛出异常，并传播到上层，那么这个析构函数的后续代码就没有被执行，这个析构函数就没有完成它负责的任务。</p>

<h3>条款12：了解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”之间的差异</h3>

<p>事实：一个对象被抛出作为异常时，总是会发生复制。（即使声明为static；即使是by reference方式）</p>

<h3>条款13：以by reference方式捕捉异常</h3>

<h3>条款14：明智运用exception specifications</h3>

<h3>条款15：了解异常处理的成本</h3>

<p>为了能够在运行时期处理异常，程序需要做大量记录工作：在每一个执行点，必须能够确认“如果发生异常，哪些对象需要析构”，他们必须在每一个try语句块的进入点和离开点做记号，针对每个try语句块必须记录对应的catch子句及能偶处理的异常类型。</p>

<p>运行时期的比对工作（以确保符合exception specifications)不是免费的；异常被抛出时销毁适当对象并找出正确的catch子句也不是免费的。</p>

<p>第二个成本是，try语句块。代码会膨胀，效率也会下降。（这还是没有异常出现时就有这个开销了）</p>

<h2>效率</h2>

<h3>条款16：谨记80-20法则</h3>

<p>2个点：</p>

<ul>
<li>理性地优化代码来提升程序性能。有的代码优化了，并不一定能带来质的性能提升；要找到性能瓶颈之处才行。</li>
<li>利用profiler工具来找到性能瓶颈。</li>
</ul>

<h3>条款17：考虑使用lazy evaluation（缓式评估）</h3>

<p>其实就是“能拖就拖”，减少不必要的计算。</p>

<ul>
<li>引用计数 &amp;&amp; 区分读和写</li>
</ul>

<p>考虑这样的代码：</p>

<p>string s1 =&quot;hello&quot;; string s2 = s1;</p>

<p>执行s2=s1时，执行了一次复制构造函数。这个调用是否昂贵？这个调用是否可以避免？事实上，要具体情况具体考虑。如果s2只是被“读”，而不会被“修改”，那么s2只需要存一个指向s1的引用即可，不应该创建一个副本。<strong>在你真正需要之前，不必着急为某物做一个副本。</strong></p>

<ul>
<li>Lazy Fetching（缓式取出）</li>
</ul>

<p>简单地说，就是读取数据库数据时，能少拿一点就少拿一点，能不拿就不拿。</p>

<p>比如我自己在使用redis（KV数据库），就可以把一个class实例（有多个成员变量），用hash表来存。使用这个实例时（读or写），不直接hgetall或hsetall（全部读写），而是用hget或hset（单个读写）。</p>

<ul>
<li>Lazy Expression Evaluation（表达式换评估）</li>
</ul>

<p>Lazy Evaluation的反义词是Eager Evaluation（急式评估）。
贴书中的例子：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">Matrix</span> <span class="nf">m1</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="n">Matrix</span> <span class="nf">m2</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">);</span>
<span class="n">Matrix</span> <span class="n">m3</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span><span class="p">;</span>
</code></pre></div>
<p>m3是m1和m2的合，这是一个百万级的加法操作。如果m3的值实际上是不会被程序用到，那么这个计算就应该被忽略。</p>

<p>一般来说，定义了m3，应该下文就会用到m3。那么m3的计算就在所难免了，但如果是这样的情况：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">m3</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>
<p>显然，按照这一个条款的指示，应该使得，m3.at(2,2)执行时，只计算(2,2)处的值，而不计算其他的值。</p>

<h3>条款18：分期摊还预期的计算成本</h3>

<p>如果预期到某个操作必然要执行，就可以考虑把这个计算提前，甚至计算结果可以被复用。（caching法）</p>

<p>另一种做法是Prefetching（预先取出）。具体就是说，做一个计算时，可以一次过做多一些（batch）。比如磁盘的块读取，或者动态数组的内存动态扩张。</p>

<h3>条款19：了解临时对象的来源</h3>

<p>当程序产生一个non-heap object而没有为它命名，便诞生了一个临时对象。（匿名对象）</p>

<p>一般有2种情况产生临时对象：</p>

<ul>
<li>隐式类型转换。比如传参时参数有可能被自动转换。</li>
<li>函数返回对象。返回的变量的类型和函数的返回类型不同时发生。</li>
</ul>

<p>第一种类型，只当对象以by value的方式传递，或当对象被传递给一个reference-to-const参数时，才会发生。如果对象被传递给一个reference-to-non-const参数，并不会发生此类转换。</p>

<p>第二种情况，感觉这本书的分析过时了，c++11的右值引用，应该是解决这个情况的最有力武器。</p>

<h3>条款20：协助完成“返回值优化”</h3>

<p>撇开c++11，对于返回by value的函数，最佳的return写法是，return后面紧跟一个类构造函数。</p>

<p>这样做可能可以让编译器优化掉这个构造函数产生的临时对象。
（这一招叫做return value optimization）。</p>

<h3>条款21：利用重载技术（overload）避免隐式类型转换（implicit type conversions）</h3>

<p>很显然，就是通过增加定制的重载函数（函数参数类型和实际的参数类型一致），避免不必要的类型转换开销。</p>

<h3>条款22：考虑以操作符复合形式（op=）取代其独身形式（op）</h3>

<p>大部分程序员都希望，如果他们能够这样写：</p>

<p>x = x + y</p>

<p>他们也能够写成这样：</p>

<p>x += y</p>

<p>一般而言，复合操作符比其对应的独身版本效率高，因为独身版本通常返回一个新对象，而我们必须因此负担一个临时对象的构造和析构成本。</p>

<p>另外，如果同时提供某个操作符的复合形式和独身形式，便允许你的客户在效率与便利性之间做取舍。（虽然这个选择不易）</p>

<p>比如：</p>

<p>d = a + b + c;</p>

<p>和：</p>

<p>d = 0; d += a; d += b; d += c;</p>

<p>后者要比前者效率要高，因为没有复制对象。</p>

<h3>条款23：考虑使用其他程序库</h3>

<p>以iosteam和stdio这2个官方库来说明，不同的库有不同的性能。选择一个适合的库，也是提升性能的好方法。</p>

<h3>条款24：了解virtual functions、multiple inheritance、virtual base classes、runtime type identification的成本</h3>

      </div>

      <a href="/cpp-1/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/linear-algebra-3/"><复习向>线性代数之矩阵与行列式(3)</a></h1>
      <div class="date">
        Written on August 31, 2015
      </div>
      <div class="entry">
        <h1>行列式的求解</h1>

<p>从行列式的定义出发去求行列式，是一个简单但低效的方法。而实际上，解决数学问题的途径往往有多种。这里，我将介绍其中一种比较常见的快速解法：<strong>PLU分解</strong>。</p>

<h2>PLU的LU</h2>

<p>要理解PLU，得先搞懂LU分解。（这里分享一个外教的讲解视频，简单好理解：<a href="https://www.youtube.com/watch?v=UlWcofkUDDU">https://www.youtube.com/watch?v=UlWcofkUDDU</a> 能翻墙的同学就直接看吧。)</p>

<p>LU分别代表：Lower Triangular Matrix 和 Upper Triangular Matrix，即下三角矩阵和上三角矩阵。</p>

<p>下面手动演示下LU分解过程：</p>

<p>设A：</p>

<p>\[ A =  \left[ \begin{matrix} 9&amp;6&amp;0\\ 6&amp;5&amp;4\\ 3&amp;4&amp;10\\ \end{matrix} \right] \]</p>

<p>要把A分解成LU，第一步是先用高斯消元法，把A变成阶梯型矩阵U：</p>

<ul>
<li>\( R2 -= R1 * a_{10}/a_{00} = R1 * 6/9 \)</li>
</ul>

<p>\[ A_{0} =  \left[ \begin{matrix} 9&amp;6&amp;0\\ 0&amp;1&amp;4\\ 3&amp;4&amp;10\\ \end{matrix} \right] = E_{0}A =  \left[ \begin{matrix} 1&amp;0&amp;0\\ -6/9&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{matrix} \right]
 \left[ \begin{matrix} 9&amp;6&amp;0\\ 6&amp;5&amp;4\\ 3&amp;4&amp;10\\ \end{matrix} \right] \]</p>

<ul>
<li>\( R3 -= R1 * a_{20}/a_{00} = R1 * 3/9 \)</li>
</ul>

<p>\[ A_{1} =  \left[ \begin{matrix} 9&amp;6&amp;0\\ 0&amp;1&amp;4\\ 0&amp;2&amp;10\\ \end{matrix} \right] = E_{1}A_{0} =  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ -3/9&amp;0&amp;1\\ \end{matrix} \right]
 \left[ \begin{matrix} 9&amp;6&amp;0\\ 0&amp;1&amp;4\\ 3&amp;4&amp;10\\ \end{matrix} \right]  \]</p>

<ul>
<li>\( R3 -= R2 * a_{21}/a_{11} = R1 * 2/1 \)</li>
</ul>

<p>\[ U = A_{2} =  \left[ \begin{matrix} 9&amp;6&amp;0\\ 0&amp;1&amp;4\\ 0&amp;0&amp;2\\ \end{matrix} \right] = E_{2}A_{1} =  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;-2/1&amp;1\\ \end{matrix} \right]
 \left[ \begin{matrix} 9&amp;6&amp;0\\ 0&amp;1&amp;4\\ 0&amp;2&amp;10\\ \end{matrix} \right]  \]</p>

<ul>
<li><p>因此得：\( U = E_{2}A_{1} = E_{2}E_{1}A_{0} = E_{2}E_{1}E_{0}A \)</p></li>
<li><p>再调换下，得到：\( A = E_{0}^{-1}E_{1}^{-1}E_{2}^{-1}U \)</p></li>
<li><p>所以， \( L = E_{0}^{-1}E_{1}^{-1}E_{2}^{-1} \)</p></li>
</ul>

<p>要得到最终的L，需要算3个\(E_{x}\)矩阵的逆矩阵，看似麻烦，其实很简单，因为\(E_{x}\)有这样的性质：</p>

<p>\[  \left[ \begin{matrix} 1&amp;0&amp;0\\ a&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;0&amp;0\\ -a&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{matrix} \right] \]</p>

<p>\[  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ a&amp;0&amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ -a&amp;0&amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{matrix} \right] \]</p>

<p>\[  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;a&amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;-a&amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{matrix} \right] \]</p>

<p>所以：</p>

<p>\[ L = E_{0}^{-1}E_{1}^{-1}E_{2}^{-1} =  \left[ \begin{matrix} 1&amp;0&amp;0\\ 6/9&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 3/9&amp;0&amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;2/1&amp;1\\ \end{matrix} \right] \]</p>

<p>只要搞定右边的3矩阵乘法运算，就能得到L。而又因为：</p>

<p>\[  \left[ \begin{matrix} 1&amp;0&amp;0\\ a_{1}&amp;1&amp;0\\ b_{1}&amp;c_{1}&amp;1\\ \end{matrix} \right] \left[ \begin{matrix} 1&amp;0&amp;0\\ a_{2}&amp;1&amp;0\\ b_{2}&amp;c_{2}&amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;0&amp;0\\ a_{1}+a_{2}&amp;1&amp;0\\ b_{1}+a_{2}c_{2}+b_{2}&amp;c_{1}+c_{2}&amp;1\\ \end{matrix} \right]
\]</p>

<p>所以，L的结果可以迅速得到：</p>

<p>\[ L = E_{0}^{-1}E_{1}^{-1}E_{2}^{-1} =  \left[ \begin{matrix} 1&amp;0&amp;0\\ 6/9&amp;1&amp;0\\ 3/9&amp;2/1&amp;1\\ \end{matrix} \right]  \]</p>

<p>于是，A的LU分解完成了：</p>

<p>\[ A = LU =  \left[ \begin{matrix} 1&amp;0&amp;0\\ 6/9&amp;1&amp;0\\ 3/9&amp;2/1&amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 9&amp;6&amp;0\\ 0&amp;1&amp;4\\ 0&amp;0&amp;2\\ \end{matrix} \right]  \]</p>

<h2>PLU的P</h2>

<p>这里的P，指的是Permutation Matrix，置换矩阵。</p>

<p>何谓置换矩阵？其实就是经过一系列初等变换的单位矩阵，且元素\( a_{ij} = 0 or 1 \)。</p>

<p>置换矩阵的作用，是用来交换某个矩阵的行（列）顺序。</p>

<p>比如：</p>

<p>\[ P =  \left[ \begin{matrix} 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ 1&amp;0&amp;0\\ \end{matrix} \right]\ \  A =  \left[ \begin{matrix} 3&amp;4&amp;0\\ 1&amp;2&amp;9\\ 0&amp;5&amp;6\\ \end{matrix} \right] \]</p>

<p>\[ PA =  \left[ \begin{matrix} 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ 1&amp;0&amp;0\\ \end{matrix} \right]  \left[ \begin{matrix} 3&amp;4&amp;0\\ 1&amp;2&amp;9\\ 0&amp;5&amp;6\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;2&amp;9\\ 0&amp;5&amp;6\\ 3&amp;4&amp;0\\ \end{matrix} \right] \]</p>

<p>\[ AP =  \left[ \begin{matrix} 3&amp;4&amp;0\\ 1&amp;2&amp;9\\ 0&amp;5&amp;6\\ \end{matrix} \right]  \left[ \begin{matrix} 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ 1&amp;0&amp;0\\ \end{matrix} \right]  =  \left[ \begin{matrix} 0&amp;3&amp;4\\ 9&amp;1&amp;2\\ 6&amp;0&amp;5\\ \end{matrix} \right] \]</p>

<p>从这个例子就可以看出，P左乘A时，改变了A的行的顺序；P右乘A时，改变了A的列的顺序。</p>

<h2>PA = LU？</h2>

<p>为什么要先对A做P置换后，再做LU分解？这是因为不这样做的话，LU会不稳定(stability)。</p>

<p>举个例子：</p>

<p>\[ A =  \left[ \begin{matrix} 10^{-20}&amp;1\\ 1&amp;1\\ \end{matrix} \right]  =  \left[ \begin{matrix} 1&amp;0\\ 10^{20}&amp;1\\ \end{matrix} \right] \left[ \begin{matrix} 10^{-20}&amp;1\\ 0&amp;1-10^{20}\\ \end{matrix} \right] = L_{0}U_{0} \]</p>

<p>直接分解后得到的L、U矩阵，出现了<strong>大数</strong>，程序员读者们肯定会意识到:&quot;大数！这不是要越界的节奏吗！&quot;。所以这是不能接受的。</p>

<p>而神奇的是，对A做一些P置换后，再来LU分解，是可以变稳定的：</p>

<p>\[ PA =  \left[ \begin{matrix} 0&amp;1\\ 1&amp;0\\ \end{matrix} \right] \left[ \begin{matrix} 10^{-20}&amp;1\\ 1&amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;1\\ 10^{-20}&amp;1\\ \end{matrix} \right]  =  \left[ \begin{matrix} 1&amp;0\\ 10^{-20}&amp;1\\ \end{matrix} \right] \left[ \begin{matrix} 1&amp;1\\ 0&amp;1-10^{-20}\\ \end{matrix} \right] = L_{1}U_{1} \]</p>

<p>L、U中没有出现大数，于是认为这样的分解是稳定的。</p>

<p>PA的P，需要对P做一些检测后才可以得到，策略就是：沿着对角线从左上角到右下角遍历A，并检测当前列的最大元素在下方的哪一行（当前行上方的行保持不变），找到后就将当前行和目标行交换，并记录下一个\(E_{i}\)。最后按顺序算\(E_{i}\)的乘积就得到了P。</p>

<h2>A的行列式</h2>

<p>在<a href="http://yiqizhumeng.com:4000/linear-algebra/">&lt;复习向&gt;线性代数之矩阵与行列式(1)</a>中，已经提到了一条行列式公式：</p>

<p>\[ det(AB) = det(A)det(B) \]</p>

<p>而，\( PA = LU \)又可以变成 \( A = P^{-1}LU \)，所以：</p>

<p>\[ det(A) = det(P^{-1}LU) = det(P^{-1})det(L)det(U) \]</p>

<p>可以进一步将这个式子简化：</p>

<ul>
<li>L、U矩阵分别是下三角矩阵和上三角矩阵，它们的行列式等于对角线上元素的乘积</li>
<li>L矩阵上的元素都为1</li>
</ul>

<p>于是有：</p>

<p>\[ det(A) = det(P^{-1})u_{11}u_{22}\cdots u_{nn} \]</p>

<p>因为： \( PP^{-1} = PP^{T} =  1 \)，\( det(P_T) = det(P) \)，所以问题变成了求det(P)。</p>

<p>P怎么求？首先，P相当于多个\(E_i\)矩阵的乘积，而又有\( det(E_i)=-1 \)  (行列式的基本性质：交换行列式的两行，行列式变号），所以有：</p>

<p>\[ P = E_t\cdots E_2E_1 \implies \det(P) = \prod^t_{i=1}\det(E_i)=(-1)^t \]</p>

<p>于是：</p>

<p>\[ det(A) = det(P^{-1}LU) = det(P)u_{11}u_{22}\cdots u_{nn} = (-1)^{t}u_{11}u_{22}\cdots u_{nn} \]</p>

<h2>总结</h2>

<p>矩阵的分解(factorization)有很多种，PA=LU只是其中一种，但此类分解法都离不开<strong>高斯消元</strong>这把大杀器。理解好高斯消元是关键。</p>

<p>P.S. 已经有人证明了，任何方阵都存在它的PLU分解:<a href="">http://arxiv.org/pdf/math/0506382v1.pdf</a>。</p>

      </div>

      <a href="/linear-algebra-3/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/linear-algebra-2/"><复习向>线性代数之矩阵与行列式(2)</a></h1>
      <div class="date">
        Written on August 29, 2015
      </div>
      <div class="entry">
        <h1>行列式的意义</h1>

<p>貌似一般的线性代数教科书并没有告诉读者行列式的实际意义，只是教会了读者行列式的定义和计算方法。（起码我所阅读的线性代数课本没有提及）</p>

<p>那么在这里我简单地介绍一下。</p>

<h2>一阶行列式</h2>

<p>要说行列式的意义，得先从行列式的&quot;|&quot;符号谈起。下面是一阶方阵的行列式：</p>

<p>\[ |x| = x \]</p>

<p>是不是想到什么？一阶方阵，其实就是一个数，且它的行列式等于这个数。且，一阶方列式的写法，恰好就是高中数学里的绝对值写法！</p>

<p>想一下绝对值的<strong>几何意义</strong>：指明了一个实数（这里不提虚数）距离数轴原点的大小。</p>

<h2>二阶行列式</h2>

<p>现在看一下二阶行列式：</p>

<p>\( \left| \begin{matrix} x_{0}\ x_{1}\\ y_{0}\ y_{1}\\ \end{matrix} \right| \)</p>

<p>再变成用向量来表示：</p>

<p>\( |\ \alpha\ \beta\ | \)</p>

<p>于是，二阶行列式等于2个向量的&quot;绝对值&quot;。那么，对于2个向量，这个绝对值是什么？</p>

<p>首先，搬出向量的夹角公式：</p>

<p>\[ cos\theta = \dfrac {\alpha \cdot\ \beta } {|\alpha |\times|\beta |} \]</p>

<p>从上面的式子可以推出：</p>

<p>\[ sin\theta = \sqrt{1 - \dfrac {(\alpha \cdot\ \beta )^{2}} {|\alpha |^{2}\times |\beta |^{2}} } \]</p>

<p>\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ |\alpha |^{2} \times |\beta |^{2} - (\alpha \cdot\ \beta )^{2} } \]</p>

<p>\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ (x_{0}^{2} + y_{0}^{2})\times (x_{1}^{2} + y_{1}^{2}) - (x_{0}x_{1}+y_{0}y_{1})^{2} } \]</p>

<p>\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ x_{0}^{2}x_{1}^{2} + x_{0}^{2}y_{1}^{2} + y_{0}^{2}x_{1}^{2} + y_{0}^{2}y_{1}^{2} - x_{0}^{2}x_{1}^{2} - x_{0}x_{1}y_{0}y_{1} - y_{0}^{2}y_{1}^{2} } \]</p>

<p>\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ x_{0}^{2}y_{1}^{2} + x_{1}^{2}y_{0}^{2} - 2x_{0}x_{1}y_{0}y_{1} } \]</p>

<p>\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ (x_{0}y_{1} - x_{1}y_{0})^{2} } \]</p>

<p>\[ |\alpha |\times |\beta |\times sin\theta = x_{0}y_{1} - x_{1}y_{0} \]</p>

<p>\[ |\alpha |\times |\beta |\times sin\theta =     \left| \begin{matrix} x_{0}\ x_{1}\\ y_{0}\ y_{1}\\ \end{matrix} \right| = |\ \alpha\ \beta\ | \]</p>

<p>注意到了吗，这个式子的左边，赫然是平行四边形的面积公式！</p>

<p>所以，二阶行列式的几何意义就是<strong>2个向量组成的平行四边形的面积</strong>。</p>

<p><img src="../images/2015.8/parallelogram.svg" alt="parallelogram.png"></p>

<h2>三阶行列式</h2>

<p>通过上面的分析，可以知道行列式在几何数学中是有某种意义的，那么三阶行列式又是什么东西呢？</p>

<p>三阶行列式：</p>

<p>\( \left| \begin{matrix} x_{0}\ x_{1}\ x_{2}\\ y_{0}\ y_{1}\ y_{2}\\ z_{0}\ z_{1}\ z_{2}\\ \end{matrix} \right| \)</p>

<p>再变成用向量来表示：</p>

<p>\( |\ \alpha\ \beta\ \gamma\ | \)</p>

<p>3个3维向量，想到了什么呢？没错，就是3维空间中的3个向量！</p>

<p>设 \( \alpha = (1,0,0)^{T} \) \( \beta = (0,1,0)^{T} \) \( \gamma = (0,0,1)^{T} \) ， 即相当于3维正交坐标系的3条轴的单位向量。这样的3个单位向量组成的行列式，值等于1。</p>

<p>另外，巧合的是，这3个单位向量组成的正方体，体积也为1。实际上，3阶行列式确实等价于平行六面体的体积。</p>

<p>证明过程（暂无）。</p>

<p><img src="../images/2015.8/parallelepiped.svg" alt="parallelogram.png"></p>

      </div>

      <a href="/linear-algebra-2/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/linear-algebra/"><复习向>线性代数之矩阵与行列式(1)</a></h1>
      <div class="date">
        Written on August 25, 2015
      </div>
      <div class="entry">
        <h2>矩阵的基本性质</h2>

<p>我对矩阵的定义：一个含有x个元素的数组(x&gt;=1)，以n个数为一段，将把这个数组按顺序分成m段，并按顺序排成m行，就构成了一个矩阵。<strong>数组</strong>和<strong>分段</strong>是构成一个矩阵的充分必要条件。</p>

<p>这个定义是从程序实现角度考虑的。一个矩阵可以用二维数组Array[m][n]来存放，也可以用一维数组Array[m*n]来存放，在不考虑实现语言之前，我更倾向于使用一维数组。</p>

<p>矩阵的定义虽然不复杂，但是聪明的数学家对矩阵进行了各种研究，导致产生了非常多的概念、术语、定理、推论：</p>

<ol>
<li>当m == n时，矩阵可以被称为<strong>n阶矩阵</strong>，或<strong>n阶方阵</strong></li>
<li>矩阵A的m、n和矩阵B的m、n相等时，称A和B为<strong>同阶矩阵</strong>或<strong>同型矩阵</strong></li>
<li>大写字母<strong>O</strong>代表元素全为0的矩阵</li>
<li>矩阵的加法运算满足以下运算律:

<ol>
<li>交换律 <strong>A + B = B + A</strong></li>
<li>结合律 <strong>( A + B ) + C = A + ( B + C )</strong></li>
<li><strong>A + O = O + A</strong></li>
<li><strong>A + (-A) = (-A) + A = O</strong></li>
</ol></li>
<li>矩阵的数乘运算满足以下运算律:

<ol>
<li><strong>k ( A + B ) = kA + kB</strong></li>
<li><strong>( k + t ) A = kA + tA</strong></li>
<li><strong>k ( tA ) = ( kt ) A</strong></li>
<li><strong>1 * A = A</strong></li>
</ol></li>
<li>矩阵的加法和数乘运算统称为矩阵的<strong>线性运算</strong></li>
<li>矩阵之间允许乘法运算：C = AB。但有一个前提：
左矩阵A的列数必须等于右矩阵B的行数</li>
<li>做矩阵相乘运算要注意的一些特性：

<ol>
<li>AB 有意义时， BA 不一定有意义</li>
<li>AB 和 BA 都有意义时，并不意味着 AB = BA（不满足交换律），但存在使得此等式成立的2个矩阵</li>
<li>不满足消除率。两个非零矩阵的乘积可能是零矩阵，即 AB = O 成立时，并不能推出 A = O 或 B = O</li>
<li>满足结合律：

<ol>
<li><strong>( AB ) C = A ( BC )</strong></li>
<li><strong>k ( AB ) = ( kA ) B = A ( kB )</strong></li>
<li><strong>A ( B + C ) = AB + AC</strong></li>
<li><strong>( B + C ) A = BA + CA</strong></li>
</ol></li>
</ol></li>
<li>矩阵可以做幂运算：

<ol>
<li>\( \mathbf{ A^{k}A^{t} = A^{k+t} } \)</li>
<li>\( \mathbf{ (A^{k})^{t} = A^{kt} } \)</li>
<li>若 AB = BA，则 \( \mathbf{ (AB)^{k} = A^{k}B^{k} } \)</li>
<li>注意，即使 \( \mathbf{ A^{k} = O } \)，也并不意味着\( \mathbf{  A = O } \)</li>
</ol></li>
</ol>

<h2>矩阵的转置</h2>

<p>将\( m\times n \)矩阵 A = \( a_{ij} \)的行和列互换，得到的\( n\times m \)矩阵，称为矩阵A的转置矩阵，简称A的转置，记为\( A^{T} \)。</p>

<p>矩阵的转置有以下性质：</p>

<ol>
<li>\( \mathbf{ (A^{T})^{T} = A }  \)</li>
<li>\( \mathbf{ (A+B)^{T}=A^{T}+B^{T} } \)</li>
<li>\( \mathbf{ (kA)^{T}=kA^{T} } \)</li>
<li>\( \mathbf{ (AB)^{T}=B^{T}A^{T} } \)</li>
</ol>

<h2>方阵的行列式</h2>

<p>定义行列式之前，先定义2个概念：排列和逆序数</p>

<h3>排列</h3>

<p>由n个不同的数\(1,2,\cdots,n\)组成的一个有序数组\( i_{1}i_{2}\cdots i_{n} \)称为一个n级排列,简称为排列</p>

<p>由数\(1,2,\cdots,n\)构成的不同的n级排列共有\( n! \)个。</p>

<p>例:</p>

<ul>
<li>1234、3421是4级排列</li>
<li>25314是5级排列</li>
</ul>

<h3>逆序数</h3>

<p>在一个n级排列\( i_{1}i_{2}\cdots i_{n} \)中，若数\( i_{t}&gt;i_{s} \)，则称数\( i_{t} \) 与 \( i_{s} \)构成一个逆序，一个n级排序中逆数的总数称为该排列的逆序数，记为
\( \gamma (i_{1}i_{2}\cdots i_{n}) \)</p>

<p>例:</p>

<p>5级排列25314的逆序数:</p>

<p>\( \gamma (25314) \) = 0 + 0 + 1 + 3 + 1 = 5</p>

<p>逆序数为奇数的排列称为<strong>奇排列</strong>，逆序数为偶数的排列称为<strong>偶排列</strong>。</p>

<p>相关定理：</p>

<ul>
<li>n个不同的数\(1,2,\cdots,n\)的n！个n级排列中，奇偶排列各占一半</li>
</ul>

<p>交换一个排列中某2个不同的元素，称为一次<strong>对换</strong>。</p>

<p>例：</p>

<p>\( 31542\overset{(5,2)}{\longrightarrow}31245 \)</p>

<p>相关定理：</p>

<ul>
<li>任意一个排列经过一次对换后，奇偶性改变</li>
</ul>

<h3>行列式</h3>

<p>定义：由 \( n^{2} \)个元素\( a_{ij} \) 排成n行n列组成的式子：</p>

<p>\( \left| \begin{matrix} a_{11}\ a_{12}\ \ldots\ a_{1n}\\ a_{21}\ a_{22}\ \ldots\ a_{2n}\\ \vdots\ \ \ \ \ \vdots\ \ \ \ \ \vdots\ \ \ \ \ \vdots\ \ \ \ \\ a_{n1}\ a_{n2}\ \ldots\ a_{nn}\\ \end{matrix} \right| \)
\( = \sum _{ j_{1}j_{2}\ldots j_{n} }(-1)^{\gamma (j_{1}j_{2}\ldots j_{n} ) }a_{1 j_{1}}a_{2 j_{2} }\ldots a_{n j_{n} } \)</p>

<p>它的计算结果被称为行列式(Determinant)。</p>

<p>注意，行列式是一个数，而不是一个矩阵。
这个式子也被称为行列式的展开式。</p>

<p>行列式的性质：</p>

<ol>
<li>\( D^{T} = D \)</li>
<li>交换行列式的两行(列)，行列式变号</li>
<li>用数k乘行列式的某一行(列)，等于用数k乘此行列式</li>
<li>若行列式有一行(列)的元素全为零，则行列式等于零</li>
<li>若行列式有两行(列)的对应元素成比例，则行列式等于零</li>
<li>若行列式的某一行(列)各元素都是两数之和，即 \( a_{ij} = b_{ij} + c_{ij} \)，则 \( D_{a} = D_{b} + D_{c} \)</li>
<li>将行列式某一行(列)所有元素都乘以数k后加到另一行(列)对应位置的元素上，行列式的值不变</li>
</ol>

<p>行列式按某一行(列)展开:</p>

<p>代数余子式的定义:</p>

<p>在n阶行列式 D = det( \( a_{ij} \) )中，划去元素\( a_{ij} \)所在的第i行和第j列后，余下的元素按原来的相对位置构成的n-1阶行列式，称为D中元素\( a_{ij} \)的余子式，记为\( M_{ij} \)。</p>

<p>再记\( A_{ij} =(-1)^{i+j}M_{ij} \)，称\( A_{ij} \)为元素\( a_{ij} \)的代数余子式。</p>

<p>引理:</p>

<p>若n阶行列式 D = det( \( a_{ij} \) )中，第i行除\( a_{ij} \)外的其他元素都为零，则该行列式等于\( a_{ij} \)与它的代数余子式的乘积，即：</p>

<p>\[ D = det( a_{ij} ) = a_{ij}A_{ij} \] </p>

<p>行列式的展开:</p>

<p>n阶行列式 D = det( \( a_{ij} \) )等于它的任意一行(列)的各元素与其对应的代数余子式乘积之和，即</p>

<p>\[ D = a_{i1}A_{i1} + a_{i2}A_{i2} + \cdots + a_{in}A_{in} \] </p>

<p>\[ D = a_{1j}A_{1j} + a_{2j}A_{2j} + \cdots + a_{nj}A_{nj} \]</p>

<h2>行列式与转置矩阵之间的一些公式：</h2>

<ol>
<li>\( \mathbf{ |A^{T}| = |A| } \)</li>
<li>\( \mathbf{ |kA| = k^{n}|A| } \)</li>
<li>\( \mathbf{ |AB| = |A||B| } \)</li>
<li>\( \mathbf{ |AB| = |BA| } \)</li>
<li>\( \mathbf{ |A^{n}| = |A|^{n} } \)</li>
</ol>

<h2>线性方程组与行列式</h2>

<p>含有n个未知量、n个方程的线性方程组</p>

<p>\[ a_{11}x_{1} + a_{12}x_{2} + \cdots + a_{1n}x_{n} = b_{1} \]
\[ a_{21}x_{1} + a_{22}x_{2} + \cdots + a_{2n}x_{n} = b_{2} \]
\[ \cdots\cdots \]
\[ a_{n1}x_{1} + a_{n2}x_{2} + \cdots + a_{nn}x_{n} = b_{n} \]</p>

<p>系数\( a_{ij} \)构成的行列式称为该方程组的系数行列式D</p>

<p>克拉默(Cramer)法则：若系数行列式 \( D\neq 0 \)，则方程组有唯一解，其解为：
\[ x_{i} = \dfrac {D_{j}} {D} \]</p>

<p>\( D_{j} \)是将系数行列式D中第j列的元素\( a_{1j},a_{2j},\cdots a_{nj} \)对应地换成方程组右端的常数项\( b_{1j},b_{2j},\cdots b_{nj} \)，而其余各列保持不变得到的行列式。</p>

<p>当\( b_{i} \)=0时，上面的线性方程组为：</p>

<p>\[ a_{11}x_{1} + a_{12}x_{2} + \cdots + a_{1n}x_{n} = 0 \]
\[ a_{21}x_{1} + a_{22}x_{2} + \cdots + a_{2n}x_{n} = 0 \]
\[ \cdots\cdots \]
\[ a_{n1}x_{1} + a_{n2}x_{2} + \cdots + a_{nn}x_{n} = 0 \]</p>

<p>称为<strong>齐次线性方程组</strong>。齐次线性方程组必然有零解( \( x_{i} = 0 \) ）。</p>

<p>定理：若齐次线性方程组的系数行列式 \( D\neq 0 \)，则只有零解； 若有非零解，则\( D = 0 \)。</p>

      </div>

      <a href="/linear-algebra/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/raytrace/">实现了一个C++11 Based的光线追踪渲染器demo</a></h1>
      <div class="date">
        Written on August  4, 2015
      </div>
      <div class="entry">
        <p>本demo是根据Milo的一篇文章实现的：<a href="http://www.cnblogs.com/miloyip/archive/2010/03/29/1698953.html">用JavaScript玩转计算机图形学1，光线追踪入门</a>。</p>

<p>原文是js版本，我用c++实现了一个。
代码在：https://github.com/voyagingmk/raytrace_demo</p>

<p>渲染效果图：(1000 x 1000)</p>

<p><img src="../images/2015.8/1.png" alt="1.png"></p>

      </div>

      <a href="/raytrace/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-87/">leetcode题解 problem87 Scramble String</a></h1>
      <div class="date">
        Written on July 24, 2015
      </div>
      <div class="entry">
        <h3>题解：</h3>

<p>设s1，s2是两个长度都为len的字符串（把s1、s2当做字符数组理解）</p>

<p>设状态量res[n][i][j]，(n &lt; len, i &lt;= n, j &lt;= n), 元素是bool值</p>

<p>res的含义：</p>

<p><strong>长度为n，以i位置为起点的子串s1[i, i + n], 以j位置为起点的子串s2[i, i + n], res[n][i][j]标志了这2个子串是不是Scramble</strong></p>

<p>那么很显然，res[len-1][0][0]就是我们要的解。</p>

<p>状态转移方程：</p>

<p><strong>res[n][i][j] = ( res[k][i][j] &amp;&amp; res[n - k][i + k][j + k] ) || ( res[k][i][j + n - k] &amp;&amp; res[n - k][i + k][j] )</strong>    ** (1&lt;=k&lt;n) **</p>

<p>这个式子看起来很吓人。先做个分解：</p>

<p>设 A = res[k][i][j] &amp;&amp; res[n - k][i + k][j + k] = A1 &amp;&amp; A2</p>

<p>设 B = res[k][i][j + n - k] &amp;&amp; res[n - k][i + k][j] = B1 &amp;&amp; B2</p>

<p>设 C = res[n][i][j] = A || B</p>

<p>也就是说，只要A、B中有一个为T，那么C就为T; 而A、B为T的条件分别是，A1和A2同时为真、B1和B2同时为真。</p>

<p>A1、A2、B1、B2的含义是什么呢？举例说明一下：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">great</span>
<span class="n">rgtae</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="err">时：</span>
<span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>           <span class="o">&amp;&amp;</span>     <span class="n">res</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span>
   <span class="n">g</span><span class="o">|****</span>                          <span class="o">*|</span><span class="n">reat</span>
   <span class="n">r</span><span class="o">|****</span>                          <span class="o">*|</span><span class="n">gtae</span>
   <span class="n">A1</span> <span class="o">=</span> <span class="n">F</span>                          <span class="n">A2</span> <span class="o">=</span> <span class="n">F</span>

<span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span>   <span class="o">&amp;&amp;</span>      <span class="n">res</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
   <span class="n">g</span><span class="o">|****</span>                          <span class="o">*|</span><span class="n">reat</span>
   <span class="o">****|</span><span class="n">e</span>                          <span class="n">rgta</span><span class="o">|*</span>
   <span class="n">B1</span> <span class="o">=</span> <span class="n">F</span>                          <span class="n">B2</span> <span class="o">=</span> <span class="n">F</span>

<span class="err">显然</span> <span class="n">C</span> <span class="o">=</span> <span class="n">A</span> <span class="o">||</span> <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span> <span class="o">&amp;&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">F</span> <span class="o">&amp;&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="o">=</span> <span class="n">F</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="err">时：</span>
<span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>           <span class="o">&amp;&amp;</span>     <span class="n">res</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span>
   <span class="n">gr</span><span class="o">|***</span>                          <span class="o">**|</span><span class="n">eat</span>
   <span class="n">rg</span><span class="o">|***</span>                          <span class="o">**|</span><span class="n">tae</span>
   <span class="n">A1</span> <span class="o">=</span> <span class="n">T</span>                          <span class="n">A2</span> <span class="o">=</span> <span class="n">T</span>

<span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span>   <span class="o">&amp;&amp;</span>      <span class="n">res</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
   <span class="n">gr</span><span class="o">|***</span>                          <span class="o">**|</span><span class="n">eat</span>
   <span class="o">***|</span><span class="n">ae</span>                          <span class="n">rgt</span><span class="o">|**</span>
   <span class="n">B1</span> <span class="o">=</span> <span class="n">F</span>                          <span class="n">B2</span> <span class="o">=</span> <span class="n">F</span>

<span class="err">显然</span> <span class="n">C</span> <span class="o">=</span> <span class="n">A</span> <span class="o">||</span> <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="n">T</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">F</span> <span class="o">&amp;&amp;</span> <span class="n">F</span><span class="p">)</span> <span class="o">=</span> <span class="n">T</span>
</code></pre></div>
<ol>
<li><p><strong>当(A1 &amp;&amp; A2) = T时， s1-left和s2-left互为Scramble， s1-right和s2-right互为Scramble；</strong> </p></li>
<li><p><strong>当(B1 &amp;&amp; B2) = T时， s1-left和s2-right互为Scramble， s1-right和s2-left互为Scramble。</strong></p></li>
</ol>

<p>状态转移方程有了，还差个初始化状态:</p>

<p><strong>n = 0时，s1、s2退化成s1[i]和s2[j]，那么res[0][i][j] 等于 s1[i] == s2[j]</strong></p>

<p>代码如下:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">bool</span> <span class="nf">isScramble</span><span class="p">(</span><span class="n">string</span> <span class="n">s1</span><span class="p">,</span> <span class="n">string</span> <span class="n">s2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">()){</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="c1">//tricky</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">){</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">){</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">){</span>
                    <span class="kt">bool</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">){</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">])</span> 
                            <span class="o">||</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
                    <span class="p">}</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
</code></pre></div>
<p>rumtime 196ms...别人最快有4ms的。应该是4重循环的自底而上的DP计算导致这么慢的，必须全部状态都算出来才可以返回最终结果。</p>

      </div>

      <a href="/leetcode-problem-87/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-213/">leetcode题解 problem213 House Robber II</a></h1>
      <div class="date">
        Written on July 24, 2015
      </div>
      <div class="entry">
        <blockquote>
<p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>

<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
</blockquote>

<h3>题意：</h3>

<p><a href="http://www.qiujiawei.com/leetcode-problem-198/">&quot;House Robber&quot;</a>的变种（尼玛又改需求了摔)。改动的地方是，房子分布从一条线变成了一个环，首尾相接了。依然是求最大值。</p>

<h3>题解：</h3>

<p>变成环后，其实还是可以用动态规划来解。</p>

<p>f(n) : 代表窃贼在前n个房子最多能拿到多少钱</p>

<p>在变成环后，f(n)不能容许同时盗窃第1和第n个房子的情况。那么就分情况解决。</p>

<ol>
<li>绝对不偷第1个房子，只在其余房子中偷。也就是排除掉第1个房子，在剩余的第2-&gt;n个房子里偷；</li>
<li>绝对不偷第n个房子，那么其实就是求f(n - 1)</li>
</ol>

<p>按照这2种情况计算出的f1、f2，求出max(f1，f2)，就是要得到的解。</p>

<p>代码如下：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">rob</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">cur1</span><span class="p">;</span>
            <span class="n">cur1</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">,</span> <span class="n">cur1</span><span class="p">);</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">cur2</span><span class="p">;</span>
            <span class="n">cur2</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">,</span> <span class="n">cur2</span><span class="p">);</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">cur1</span><span class="p">,</span> <span class="n">cur2</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-213/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/beauty-of-math/">《数学之美》读后小结</a></h1>
      <div class="date">
        Written on July 24, 2015
      </div>
      <div class="entry">
        <p>大学时候读过吴军博士的《浪潮之巅》，从中了解到了IT行业的近代史，形形色色的传奇人物和大事件，非常震撼，读完的同时也对作者的才华感到佩服，不仅是一名一流的计算机科学家，更是一位难得的历史研究者。</p>

<p>最近又拜读了吴博士的《数学之美》。入手前以为是一本和《编程之美》类似的书，无非讲讲算法、数学之类的。但等到开始读的时候才发现，这本书的特别之处，他将IT发展史和数学、算法一起介绍，却一点也不显乱，甚至是让枯燥的数学变得生动，读完的感觉就像读了一本小说。</p>

<p>大概记录下读书笔记吧。</p>

<p>第一个重要点是，自然语言处理。之前完全没了解这方面的技术，一直以为自然语言处理应该也是雷同编程语言的处理，文法分析语义分析什么的。但实际上，这是个大坑。前期研究自然语言处理的科学家，包括各种工程师和语言学家，都花了大量精力地研究怎么用“精确的语言解码器&quot;来让计算机理解自然语言。</p>

<p>这条路是行不通的。一是因为自然语言很难建模，或者说很难建立一个完备的模型，使得任何自然语句计算机都能正确解析和翻译，想想上编译原理课的时候，（一个语法简单的tinyc编译器都折腾死人了）；二是世界上有太多的语言了，不同的语言，语法不一样，无法用同一个数学模型，所有语言都要去分析研究、建模、开发程序，成本太高了。虽然到了21世纪，有人确实用“规则”的方法，实现了翻译精确度50%以上的翻译程序，但这个程度是不够的。特别是遇到强大的对手—基于统计的自然语言处理——的时候。</p>

<p>用了统计语言模型后，语音识别的准确度可以高达90%。这其中仅仅是用到了一些概率论和数论的定理，太神奇了。自然语言处理包括了各种各样小问题，但差不多都是用概率的方法来解决的，包括中文分词等。</p>

<p>第二个重要点是，信息的度量。怎么量化信息？一本《水浒传》有多少信息量？这个问题的答案是，信息熵。<strong>一条信息的信息量与其不确定性有着直接的关系。</strong> 信息量可以用比特数来表示，香农的公式这里就不贴了~</p>

<p>信息的作用呢，就是用来消除不确定性的。比如现在你想追隔壁班的一位女生，你对她一点都不了解，除了知道她长什么样。你不确定你能不能追到这个女生，或者说，你希望提高成功率。于是你需要消除这种不确定性，那就需要去获取关于这个女生的一些信息。</p>

<p>第三个重要点是，搜索和布尔代数。一直对搜索引擎的原理不了解，而吴军这位在google工作过的大牛，解答了我的疑问。原来搜索的核心技术，只是布尔代数。当前还有很多工程问题、优化问题、大数据、分布式问题，也不是开玩笑的。不过总的来说就是，用横向扩张物理服务器的方式来处理大访问量和存放处理大数据，而搜索的核心技术是布尔运算。数学ORZ。</p>

<p>其他的内容，和搜索、反作弊，关联比较多，因为我不是打算做这2个方向的，所以这里也不说太多了。入手这本书的原因是据说这本书讲了一些人工智能的技术。虽然和期待不太一样，不过也是收获颇丰了。</p>

<p>说到人工智能，其实自然语言处理就是现代人工智能技术的一个基础。因为它要解决的是自然语言-&gt;机器，这个输入问题。假设现在我们开发出了一个非常智能的程序，但是它不能直接理解自然语言（输入数据），那它也无法产生我们需要的输出了。以视觉为基础的机器人也是一样，如果不研究计算机视觉技术，那这个机器人就只能是个盲人，即时他大脑再聪明。</p>

      </div>

      <a href="/beauty-of-math/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-45/">leetcode题解 problem 45 Jump Game II</a></h1>
      <div class="date">
        Written on July 20, 2015
      </div>
      <div class="entry">
        <blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>

<p>Each element in the array represents your maximum jump length at that position.</p>

<p>Your goal is to reach the last index in the minimum number of jumps.</p>

<p>For example:
Given array A = [2,3,1,1,4]</p>

<p>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p>
</blockquote>

<h3>题意：</h3>

<p>Jump Game I 的升级版，问到达最后一个位置时，至少要跳跃多少步。</p>

<h3>题解：</h3>

<p>贪心算法：</p>

<p>因为要求的是到达最后一个位置的最小步数，那么先假设最终的跳跃路径S存在，可以知道这个路径必然是从0位置开始跳（设起点为S1=0），S2必然是在A[0]能到达的范围内。S2的取值范围是[S1 + 1, S1 + A[S1]]。</p>

<p>若S2不能直接到达last，则S3存在，且S3的取值范围是[S2 + 1, S2 + A[S2]]。 </p>

<p>观察S2和S3的式子可以发现，这个问题是可以用贪心法或者DP处理的。因为每一个阶段的最优解只和上一个阶段有关。</p>

<p>那么对于S(i)，究竟是选D = [S(i - 1) + 1, S(i - 1) + A[S(i - 1)]]这个区间的哪个值呢？ 可以让S(i)逐个取D范围的值， 并计算出 y = MAX( S(i) + A[S(i)] )，那么使得y最大的S(i)，就是局部最优解了。</p>

<p>按照这个思路我实现了下面的代码(runtime 16ms)：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">jump</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">maxStep</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">maxStep</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="o">++</span><span class="n">depth</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">maxStep</span><span class="p">){</span><span class="c1">//在maxStep一样大的情况下，选择最靠右的</span>
                    <span class="n">maxStep</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                    <span class="n">next</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-45/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/jekyll-1/">我是这样用jekyll搭建个人博客的</a></h1>
      <div class="date">
        Written on July 18, 2015
      </div>
      <div class="entry">
        <p>好几年前就尝试用github pages服务来搭建github博客，当时也已经用了jekyll，不过由于那时候主要是在windows下工作学习（学图形学），手头也只有一台电脑，在win环境弄jekyll实在是不方便，要装ruby啊gem啊，都感觉没有linux环境顺手，最后还是转去了csdn博客。不过csdn博客在我毕业后也是荒废了。</p>

<p>现在我的解决方案是，用我购买的阿里云vps（在阿里云叫ecs），并把我的博客git整个放到Dropbox，并在vps上面搭建了jekyll服务器，就搞定了测试用的博客服务器了。</p>

<p>写博客的流程就简单了，在win或mac下都可以写，md文件一保存，就会被dropbox同步到云端，然后vps的dropbox文件夹也会即时被更新，而jekyll serve是会自动检测文件状态的，一旦被修改就会重新generate静态网站。那么我就可以直接本地开个浏览器，进入 http://vps地址:jekyll服务器端口/，去预览了。</p>

<p>还有就是，在win和mac下有个叫sourcetree的git客户端，十分好用，完全不用打git指令，点几下按钮就可以把代码push到github，也就进一步简化了写博客的步骤。</p>

<p>另外，我发现jekyll-now是符合github pages规范的jekyll程序，但是功能太不完整了，连文章分类tag功能都没。于是我只能回归普通jekyll的模式，开2个git仓库，一个用来放jekyll代码，一个用来放jekyll生成的网站静态代码（也就是本博客的代码）。要更新博客，只需要提交博客的git即可，jekyll的git倒是随意，反正有dropbox在同步，不怕丢失。</p>

<p>最后的最后，吐槽下坚果云。坚果云的linux版只支持桌面版，没有terminal的版本，导致我在vps上无法用坚果云。Dropbox虽然被墙了，但是Dropbox支持linux terminal，而且安装超级简单，按照官方说明，一下子就搞定了。</p>

      </div>

      <a href="/jekyll-1/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-134/">leetcode题解 problem 134 Gas Station</a></h1>
      <div class="date">
        Written on July 15, 2015
      </div>
      <div class="entry">
        <blockquote>
<p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>

<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>

<p>Return the starting gas station&#39;s index if you can travel around the circuit once, otherwise return -1.</p>

<p>Note:
The solution is guaranteed to be unique.</p>
</blockquote>

<h3>题意：</h3>

<p>有N个加油站，连成环形，每个加油站有gas[i]的油，从第i个加油站到第i+1个加油站需要消耗cost[i]的油。现在有一辆车，它有无限大的油箱，但是是空的。求问这辆车应该从哪个加油站出发，才可以跑一遍所有的加油站，返回该加油站的序号，如果不存在这样的起点，返回-1。</p>

<h3>题解：</h3>

<p>设sum-gas是所有加油站的油的总和，sum-cost是汽车走一圈消耗的油的总和，容易知道，当sum-gas&lt;sum-cost时，汽车是不可能遍历所有加油站的，因为油不够。</p>

<p>反过来说，当sum-gas&gt;=sum-cost时，是不是一定有一个起点，可以让汽车顺序跑一圈加油站呢？</p>

<p>证明：
1）当N=1，g1 &gt;= c1，那么预言正确；</p>

<p>2）当N=2，g1 + g2 &gt;= c1 + c2，若g1 &gt; c1且g2 &gt; c2，则怎么走都可以，所以只要考虑 (g1 &lt; c1 &amp;&amp; g2 &gt; c2) 或者 (g1 &gt; c1 &amp;&amp; g2 &lt; c2) 的情况（实际上2个情况是等同的，只要证明其一即可）。设g1 &lt; c1，因为g1 + g2 &gt; c1 + c2，所以g2 &gt; c2。那么只要从g &gt; c的点出发，必然可以到另一个点。</p>

<p>3）当N=3，g1 + g2 + g3 &gt;= c1 + c2 + c3，若g1 &gt; c1且g2 &gt; c2且g3 &gt; c3，则怎么走都可以。所以只需要考虑g1 &lt; c1 &amp;&amp; g2 + g3 &gt; c2 + c3 的情况（g1可以换成g2或g3，因为是加油站是环形的)。设g1 &lt; c1，那么不能以1作为起点，分情况考虑：a)当g2 &gt; c2，那么可以从2出发，而因为g2 + g3 &gt; c2 + c3,所以2-&gt;3-&gt;1成立；b)当g2 &lt; c2时，g3 &gt; c3，又可得g3 + g1 &gt; c3 + c1，所以3-&gt;1-&gt;2成立。 所以3个加油站也必然存在一个可走的路径。</p>

<p>4）当N=4时，g1 + g2 + g3 + g4 &gt;= c1 + c2 + c3 + c4，因为在3)中已经证明3个加油站必然存在一条路径，那么对于4个加油站，可以设 g1 + g2 + g3 &gt;= c1 + c2 + c3（也可以是234、341、412)，那么对于这3个加油站，肯定是有一条路的，那么久可以把这3个加油站合并，变成 g0 &gt;= c0 且 g0 + g4 &gt;= c0 +c4，问题就转化为2)的情况，而2）已经证明是有解的，所以综上可得，N=4也必然有解。</p>

<p>5) 当N&gt;4时，通过上面的合并法，归纳得证。</p>

<p>所以，<strong>当sum-gas&gt;=sum-cost时，一定有一个起点，可以让汽车顺序跑一圈加油站。</strong></p>

<p>知道起点必然存在后，再利用上面的合并法，可以设起点为i，g(left)是从1到i-1所有加油站的油的总和，c(left)是从1到i-1所有加油站的开销的总和，同理g(right)是i+1到n所有加油站的油的总和，c(right)是从1+1到n所有加油站的开销的总和。那么问题就降级为3个加油站left、i、right的路径问题。因为i是起点，路径必然是i-&gt;right-&gt;left，i就可以合并到right区域里，那么路径进一步简化，变成right-&gt;left。即我们需要的i的值，同时也是right区间的起始点位置。</p>

<p>right和left的关系为：</p>

<ul>
<li><p>g(right) &gt;= c(right)</p></li>
<li><p><strong>g(left) + g(right) &gt;= c(left) + c(right)</strong></p></li>
<li><p>区间left = [1, i - 1]</p></li>
<li><p>区间right = [i, n]</p></li>
</ul>

<p>具体代码实现是，从1和n向中间扫，计算left和right的gas和cost，当2个指针相遇，且满足上面的关系式，则高位指针的位置就是我们的起点。</p>

<p>这里可以做一个优化，因为<strong>g(left) + g(right) &gt;= c(left) + c(right)</strong>，可得<strong>sum = g(left) + g(right) - ( c(left) + c(right) ) &gt;= 0</strong>那么即是说，在扫的过程中，可以把left和right视作一个合并中加油站集群，只要保证sum&gt;=0成立，left和right就可以不断向中间逼近，直到相遇。</p>

<p>&quot;伪&quot;代码如下：</p>

<ol>
<li><p>设start = n, end = 1，sum = gas(start-&gt;end) - cost(start-&gt;end)</p></li>
<li><p>初始sum = gas(start) - cost(start)</p></li>
<li><p>while(start &gt; end):</p>

<p>sum &gt;= 0:
    当sum &gt;= 0时，因为start的gas比cost大，必然可以走到end，所以可以把把gas(end)-cost(end)加到sum里，sum += gas(end)-cost(end)（也就是把start-&gt;end的所有加油站合并，变成一个start），合并后end加1；</p>

<p>sum &lt; 0:
    当sum &lt; 0时，说明start的gas已经少到不能走到end了，但又因为start必然是路径的起点，于是start还可以尝试往左挪，start减一，并执行 sum += gas(start) - cost(start)。（也就是把start的左边的加油站合并到start）</p></li>
</ol>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">canCompleteCircuit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">gas</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">gas</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">gas</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">gas</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
                <span class="o">++</span><span class="n">end</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="o">--</span><span class="n">start</span><span class="p">;</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">gas</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="n">cost</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-134/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/gamejam-tech/">Gamejam作品 《虐之太空》 技术分享</a></h1>
      <div class="date">
        Written on July 15, 2015
      </div>
      <div class="entry">
        <p>游戏试玩地址：<a href="http://wanga.me/45512" title="http://wanga.me/45512">http://wanga.me/45512</a></p>

<p>技术架构：</p>

<p>平台：web、mobile</p>

<p>引擎：cocos2d</p>

<p>语言：js</p>

<p>使用的插件：chipmunk(物理引擎) underscore(js增强函数库）</p>

<p>技术实现：</p>

<p>这游戏的技术难点是<strong>电网</strong>的实现。</p>

<p>电网的特点：</p>

<ul>
<li>电流在电网上移动（路径固定，会循环）</li>
<li>电流可能有多条，电流会转向，可以设置电流的长度、速度</li>
</ul>

<p>实际上这个游戏的核心创意是我提出的，提出之后，大家一起围绕这个核心玩法开了各种脑洞。可惜因时间关系，只来得及完成这个核心玩法。</p>

<p>技术永远是跟着需求走的。需求确定的情况下，只要选一个成本最低、最简单的实现方案即可。若改了需求，任何程序员都不能保证既有代码实现可以完全不改动。</p>

<p>对于这个电网来说，我主要处理几个难点：</p>

<ul>
<li>电流和导弹的碰撞的实现</li>
<li>电流移动问题</li>
<li>电流转弯问题</li>
<li>电流动画问题</li>
<li>电流和发电器整体移动的问题</li>
</ul>

<p>第一个问题是用物理引擎chipmunk解决的，为什么不是box2d？因为我在公司刚好也在做一款物理类游戏，而chipmunk是能跨android和ios的引擎（box2d暂时不支持ios）。But，引入chipmunk后，又引发新的问题，下面会说到。</p>

<p>第二和第三个问题，电流移动和转弯，都是用cocos的action功能实现的，移动是cc.moveTo，转弯是cc.callFunc（在回调函数里即时计算旋转角），那么一个电流sprite就是不断执行move-&gt;rotate-&gt;move-&gt;rotate即可。</p>

<p>但电流转弯又引发新的问题，因为电流是一个绑定了chipmunk&#39;s body的PhysicSprite，body是一个狭长的长方形，转弯的时候会出现这样子的bug：</p>

<p><img src="../images/2015.7/11.png" alt="11.png">
<img src="../images/2015.7/12.png" alt="12.png">
<img src="../images/2015.7/13.png" alt="13.png">
<img src="../images/2015.7/14.png" alt="14.png"></p>

<p>即电流的body会超出路径限定的范围。于是我做了一个细分的操作，把一条电流切成N截，每一截都是一个PhsicalSprite，那么只要让他们在路径上移动时有前后顺序，就会变成：</p>

<p><img src="../images/2015.7/15.png" alt="15.png"></p>

<p>这里有个实现技巧：要生成N个速度为v的小电流，且他们的总长度为s，可以做一个createCurrent()函数，然后用某种延时机制，在0、 1/N *(s/v)、2/N *(s/v)、···、N/N *(s/v)时刻，各执行一次createCurrent函数，每次执行函数都会在路径起点生成一截小电流。执行N次后，就得到了一条会拐弯的大电流。</p>

<p>第四个问题，电流动画，因为没做过类似的需求，在处理这个问题时总感觉不对，最后出来的效果也不太好。我的做法是，让每截小电流都播放同一个cc.animation帧动画。最后发现效果不是很理想，因为每截小电流太小了，导致动画的细节少了很多。但勉强可以作为demo演示用。</p>

<p>第五个问题，电流和发电器整体移动的问题。按照chipmunk的物理规则，一个PhysicSprite的移动应该是被动的，cp.body移动从而导致PhysicSprite移动。但我是用cc.moveTo来移动的，也就是反过来实现了。不过这个细节也没什么影响。对于这第五个问题，一开始想到的方案是，通过改变所有电流Sprite的父节点的位置，从而整体移动整个电网。</p>

<p>但实际上会出bug：电网是整体偏移了，但是Sprite的body没有偏移，这是因为chipmunk的实现和cocos的node树的实现是完全分开的。所以就还要让body也跟着偏移。</p>

<p>最后我的实现方法是：如果电网会移动，那么久解除PhysicSprite和body的连接，从而可以分别操作sprite和body的位置而又不会互相影响，这样只要2边的位置能对上，就OK了。具体实现这里不提。</p>

<p>其他问题：</p>

<ul>
<li>电流角度的计算</li>
<li>关卡配表问题</li>
</ul>

      </div>

      <a href="/gamejam-tech/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/gamejam/">IndieAce Gamejam 广州站</a></h1>
      <div class="date">
        Written on July 15, 2015
      </div>
      <div class="entry">
        <p><img src="../images/2015.7/5.jpg" alt="5.jpg"></p>

<p>比赛介绍：<a href="http://www.indieace.com/article-715-1.html" title="http://www.indieace.com/article-715-1.html">http://www.indieace.com/article-715-1.html</a></p>

<p>本次主题：</p>

<p><img src="../images/2015.7/3.png" alt="3.png"></p>

<p>我们组的作品《虐之太空》：
<a href="http://wanga.me/45512" title="http://wanga.me/45512">http://wanga.me/45512</a></p>

<p><img src="../images/2015.7/4.jpg" alt="4.jpg"></p>

      </div>

      <a href="/gamejam/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-142/">leetcode题解 problem 142 Linked List Cycle II</a></h1>
      <div class="date">
        Written on July  8, 2015
      </div>
      <div class="entry">
        <blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>

<p>Follow up:</p>

<p>Can you solve it without using extra space?</p>
</blockquote>

<h3>题意：</h3>

<p>判断一个链表是否有环，有环的话返回环的起始节点，无环的话返回NULL。</p>

<h3>题解：</h3>

<p>Linked List Cycle的升级，不仅要判断有无环，还要求入口。很显然可以在Linked List Cycle的基础上来做。</p>

<p>这里我直接翻译ngcl的<a href="https://leetcode.com/discuss/16567/concise-solution-using-with-detailed-alogrithm-description" title="answer">answer</a>，写得非常好：</p>

<ol>
<li>用slower和faster方法判断是否有环；</li>
<li>设链表的头节点是head，环的入口节点是entry，slower和faster2个指针相遇的节点是meeting;</li>
<li>设L1是head到entry的正向距离，<strong>L2是entry到meeting的正向距离</strong>，C是环的长度，n是faster指针在cycle里遍历的次数(不到一遍算0)；</li>
</ol>

<p>根据上面的定义，可知：</p>

<ol>
<li>当slower和faster相遇时，slower已经走了L1 + L2的距离，也即head和meeting的距离;</li>
<li>当slower和faster相遇时，faster已经走了L1 + L2 + n * C的距离;</li>
<li>因为slower步进1，而faster步进2，那么当slower和faster第一次相遇时，faster已经走的距离是slower已经走的距离的两倍，即 2* (L1 + L2) = L1 + L2 + n * C =&gt; L1 = (n - 1) * C + (C - L2)</li>
</ol>

<p><strong>L1 = (n - 1) * C + (C - L2)</strong> 这个等式表明， head和entry的距离(L1)，等于<strong>meeting到entry的正向距离</strong>（链表是有遍历方向的）。</p>

<p>这是因为式子中的 (n - 1) * C相当于走n-1个循环，对一个指向meeting的环内指针来说，走(n - 1) * C等于回到起点，所以式子可以简化成 <strong>L1 = C - L2</strong>。</p>

<p>画成图是这样子：</p>

<p><img src="../images/2015.7/2.png" alt="1.png"></p>

<p>ngcl的代码如下：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">ListNode</span> <span class="o">*</span><span class="nf">detectCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span>  <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">fast</span>  <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">)</span> <span class="p">{</span>                      <span class="c1">// there is a cycle</span>
                <span class="k">while</span><span class="p">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>               <span class="c1">// found the entry location</span>
                    <span class="n">slow</span>  <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>                                 <span class="c1">// there has no cycle</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-142/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-152/">leetcode题解 problem 152 Maximum Product Subarray</a></h1>
      <div class="date">
        Written on July  6, 2015
      </div>
      <div class="entry">
        <blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>

<p>For example, given the array [2,3,-2,4],</p>

<p>the contiguous subarray [2,3] has the largest product = 6.</p>
</blockquote>

<h3>题意：</h3>

<p>求数组里最大的连续子序列的乘积。</p>

<h3>题解：</h3>

<p>Maximum Subarray的变形，把求和改成求积了。且有负数。</p>

<p>设DP[i]是以i位置元素为终点的子序列的乘积，那么DP[i]的最大值就是我们要的解。</p>

<p>DP[i] = max( DP[i - 1] * nums[i], nums[i] )</p>

<p>上面的方程是错的，因为没有考虑到负数的情况，比如数组[-10,5,-10]，DP[0] = -10, DP[1] = 5, DP[2] =-10，最大乘积是5。 但实际上最大乘积是 -10 * 5　＊ (-10) = 500。</p>

<p>正确的方程是，记录2个DP数组，一个记乘积最大值，一个记乘积最小值，然后综合2个DP数组的结果，就可以得到真正的最大值。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">DP_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">DP_min</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DP_max</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">DP_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="n">DP_min</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DP_max</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</code></pre></div>
<p>按这个方程组来做的话，需要O(n)的空间，考虑到题目只要求输出最大值，那么可以优化到O(1)的空间消耗。</p>

<p>原理就是，DP_*[i]只和上一个状态以及当前的值有关，那么只需要保存上一个状态的结果，就足够求最大乘积了。</p>

<p>下面是我的代码：（runtime 8 ms）</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">maxProduct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">dp_pre_min</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">dp_pre_max</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">dp_max</span> <span class="o">=</span> <span class="n">dp_pre_max</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">dp_cur_max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp_pre_max</span><span class="o">*</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">dp_pre_min</span><span class="o">*</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="kt">int</span> <span class="n">dp_cur_min</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="n">min</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp_pre_max</span><span class="o">*</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">dp_pre_min</span><span class="o">*</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dp_max</span> <span class="o">&lt;</span> <span class="n">dp_cur_max</span><span class="p">)</span>
                <span class="n">dp_max</span> <span class="o">=</span> <span class="n">dp_cur_max</span><span class="p">;</span>
            <span class="n">dp_pre_max</span> <span class="o">=</span> <span class="n">dp_cur_max</span><span class="p">;</span>
            <span class="n">dp_pre_min</span> <span class="o">=</span> <span class="n">dp_cur_min</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dp_max</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-152/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-221/">leetcode题解 problem 221 Maximal Square</a></h1>
      <div class="date">
        Written on July  5, 2015
      </div>
      <div class="entry">
        <blockquote>
<p>Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest square containing all 1&#39;s and return its area.</p>

<p>For example, given the following matrix:</p>

<p>1 0 1 0 0</p>

<p>1 0 1 1 1</p>

<p>1 1 1 1 1</p>

<p>1 0 0 1 0</p>

<p>Return 4.</p>
</blockquote>

<h3>题意：</h3>

<p>给定一个01矩阵，求矩阵里最大的1字正方形的面积</p>

<h3>题解：</h3>

<p>考虑动态规划来解题。</p>

<p>设DP(i,j)是子矩阵p(0,0)-&gt;p(i,j)里，以p(i,j)为右下顶点的正方形的最大边长(i属于x轴，j属于y轴）。那么DP(i,j)的最大值的平方，就是所要求的解。</p>

<p>以题目的矩阵来说，可以很容易看出DP(i,j)值：</p>

<p>DP(0,0) = <strong>1</strong>  DP(1,0) = <strong>0</strong>  DP(2,0) = <strong>1</strong>  DP(3,0) = <strong>0</strong>  DP(4,0) = <strong>0</strong></p>

<p>DP(0,1) = <strong>1</strong>  DP(1,1) = <strong>0</strong>  DP(2,1) = <strong>1</strong>  DP(3,1) = <strong>1</strong>  DP(4,1) = <strong>1</strong></p>

<p>DP(0,2) = <strong>1</strong>  DP(1,2) = <strong>1</strong>  DP(2,2) = <strong>1</strong>  DP(3,2) = <strong>2</strong>  DP(4,2) = <strong>2</strong></p>

<p>DP(0,3) = <strong>1</strong>  DP(1,3) = <strong>0</strong>  DP(2,3) = <strong>0</strong>  DP(3,3) = <strong>1</strong>  DP(4,3) = <strong>0</strong></p>

<p>DP(i,j)的值很好算，有一些规律存在：（下面是python伪代码）</p>

<p>if j == 0: DP(i,0) = M(i,0)</p>

<p>elif i == 0: DP(0,j) = M(0,j)</p>

<p>elif M(i,j)==0: DP(i,j) = 0</p>

<p>else: DP(i,j) = min( DP(i - 1, j), DP(i, j - 1), DP(i - 1, j - 1)) + 1</p>

<p>前2个if处理了DP(i,j)的边界值问题，后2个if就是DP(i,j)的状态转移方程了。</p>

<p>我的实现代码如下（runtime 12 ms）：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">maximalSquare</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span><span class="c1">//row col</span>
        <span class="kt">char</span> <span class="n">result</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span><span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">result</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="kt">int</span><span class="p">(</span><span class="n">result</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-221/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-222/">leetcode题解 problem 222 Count Complete Tree Nodes</a></h1>
      <div class="date">
        Written on July  3, 2015
      </div>
      <div class="entry">
        <blockquote>
<p>Given a complete binary tree, count the number of nodes.</p>

<p>Definition of a complete binary tree from Wikipedia:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
</blockquote>

<h3>题意：</h3>

<p>求一颗完全二叉树得节点的数量。</p>

<h3>题解：</h3>

<p>看了这道题的discuss，发现一个挺有意思的解决方案（也可能是最快的方案了），这里分析一下。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">countNodes</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">hl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">hr</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">l</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="o">=</span><span class="n">root</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span><span class="n">hl</span><span class="o">++</span><span class="p">;</span><span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;}</span>

        <span class="k">while</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span><span class="n">hr</span><span class="o">++</span><span class="p">;</span><span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">hl</span><span class="o">==</span><span class="n">hr</span><span class="p">)</span> <span class="k">return</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">hl</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="n">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span><span class="o">+</span><span class="n">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p>函数内第4、5行，2个while循环，获得了root的最左节点和最右节点的深度，然后判断深度是否一样，一样的话，说明root是一棵满二叉树，于是可以用公式直接返回该子树的节点个数。</p>

<p>再利用分而治之的思想，就可以得到总的节点的个数了：</p>

<p>countNodes(root) = 一棵完全二叉树的节点个数 = 1（即根节点） + countNodes(左子树) + countNodes(右子树)</p>

<p>而因为完全二叉树的性质，可以知道root的左子树和右子树中肯定有一棵是满二叉树。所以这个算法是很快的，当countNodes遇到满二叉树时，一次lgn的迭代运算后，即可以返回该树的节点个数。因为只有满二叉树可以让递归中止，所以总的耗时就是计算各个满二叉树的总耗时。</p>

      </div>

      <a href="/leetcode-problem-222/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-11/">leetcode题解 problem 11 Container With Most Water</a></h1>
      <div class="date">
        Written on June 30, 2015
      </div>
      <div class="entry">
        <blockquote>
<p>Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>

<p>Note: You may not slant the container.</p>
</blockquote>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maxArea</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3>题意：</h3>

<p>有一排竖直放置的、长短不一的圆柱，圆柱之间间隔都是1，问哪2根圆柱（用ai，aj表示)可以组成一个体积（因为是二维空间，其实就是面积）最大的<strong>水容器</strong>。</p>

<p>注意：容器里面放着其他圆柱也是没影响的（奇葩的容器？），ai和aj不要求相邻；因为是水容器，所以最短边决定了容器的容量。</p>

<h3>题解：</h3>

<p>这道题并不是动态规划题， 原因是动态规划的一个条件——无后效性，无法满足。</p>

<blockquote>
<p>无后效性是这样一种性质：某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响，简单的说，就是“未来与过去无关”，当前的状态是此前历史的一个完整总结。</p>
</blockquote>

<p>设S(i)是从第0根柱子到第i根柱子这个范围里，所能得到的最大的面积。换一种说法就是说，S(i)是考虑只有前i根柱子存在的情况下的最优解。所以，S(4)就是我们的解。</p>

<p>考虑动态规划的最优化原理——最优策略的任何一部分子策略也必须是最优的。
S(i)是符合这个定义的，S(i)代表i阶段时的最优结果。</p>

<p>但S(i)并不满足无后效性规则。考虑下面这个情况：</p>

<p><img src="../images/2015.7/1.png" alt="1.png"></p>

<p>S(3)的值是以[1,3]为边界的面积:(3-1)<em>min(4,2) = 4。按照无后效性定义“未来与过去无关”，S(3)是对0,1,2,3这4根柱子的一个总结，那么S(4)呢？容易看出，S(4)的值是以[1,4]为边界的面积：(4-1)</em>min(4,4) = 12。S(4)的值(未来），不仅与3有关系，还与0、1、2有关系，即过去影响了未来。</p>

<p>这道题的真正解法是很简单的。假设T(i,j)代表我们能从整个区间里找的最大容器面积，T(i,j)=(j-i)*min(a[i],[j]) (i&lt;j)，可以证明，在j的右端肯定没有比j更高的柱子了（只可能小于或等于），不然T(i,j)就不成立。</p>

<p>那么可以反过来思考，我们假设0和n-1号柱子组成的面积是最大的，要使这个结论不成立，除非是在[0,n-1]区间里找到了比a[0]和a[n-1]高的柱子，且新的柱子对的面积比目前的最大值还大。</p>

<p>所以可以从两端向中间迭代，直接看代码：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">maxArea</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">area</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">curArea</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">curArea</span> <span class="o">&gt;</span> <span class="n">area</span><span class="p">)</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">curArea</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">]){</span>
                <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">height</span><span class="p">[</span><span class="n">l</span><span class="p">]){</span>
                    <span class="n">k</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">height</span><span class="p">[</span><span class="n">r</span><span class="p">]){</span>
                    <span class="n">k</span><span class="o">--</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">area</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-11/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-62-63/">leetcode题解 problem 62 63 Unique Paths I & II</a></h1>
      <div class="date">
        Written on June 27, 2015
      </div>
      <div class="entry">
        <p>A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).</p>

<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).</p>

<p>How many possible unique paths are there?</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">uniquePaths</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3>题意：</h3>

<p>求路径总数，每次只能往右或往下走</p>

<h3>题解：</h3>

<p>入门级别动态规划题目。</p>

<p>列下状态转移方程：</p>

<p>设sum(i，j)是从pos(0,0)到pos(i,j)的路径总数。</p>

<p>可得：</p>

<p><strong>S(i, j) = S(i - 1, j) + S(i, j - 1)</strong></p>

<p>方程的含义是：</p>

<p>每个格子的路径总数 等于 起点到它左边的格子的路径总数 + 起点到它上方的格子的路径总数。</p>

<h3>代码（0ms RunTime)：</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
                <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
</code></pre></div>
<p>对于Unique Paths II，改变点是，有些格子变成了障碍物。其实也很简单，上面的代码稍微改下就好了。</p>

<h3>代码（4ms RunTime)：</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">obstacleGrid</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-62-63/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-53/">leetcode题解 problem53 Maximum Subarray</a></h1>
      <div class="date">
        Written on June 26, 2015
      </div>
      <div class="entry">
        <p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>

<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">maxSubArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3>题意：</h3>

<p>求子串和最大值</p>

<h3>题解：</h3>

<p>经典动态规划题目。</p>

<p>列下状态转移方程：</p>

<p>设数组为T(i), 设S(i)是数组从0到i位置的子串和的最大值。明确一下，S(i)对应的子串的左右2个索引[start,end]，start的取值范围是[0,i],end必然是i，即[start,end]是数组[0,i]段的一个后缀。</p>

<p>可得：</p>

<p><strong>S(i) = T(i) + ( S(i - 1) &gt; 0 ? S(i - 1) : 0 )</strong></p>

<p>方程的含义是：
求S(i)时，S(i-1)如果大于0，那么说明i-1存在一个后缀（必然是连续的）使得S(i-1)大于0，此时把T[i]也加进去S(i-1)，当然就是S(i)的最长后缀了。（S(i)可能小于等于0）；</p>

<p>S(i-1)如果小于等于0，说明S(i-1)对增大S(i)没有意义了，也即说明S(i)的最长后缀等于[i,i]，S(i) = T(i)。</p>

<p>空间复杂度O(n)，时间复杂度O(n)。</p>

<h3>代码：</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">maxS</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxS</span><span class="p">){</span>
                <span class="n">maxS</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">maxS</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>考虑到S(i)数组对于这个题目是多余的，题目只是要求S(i)的max值，那么可以改下代码，把空间复杂度从O(n)降到O(1)。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxS</span><span class="o">=</span><span class="n">INT_MIN</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">maxS</span><span class="p">){</span>
                <span class="n">maxS</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">maxS</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-53/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-120/">leetcode题解 problem120 Triangle</a></h1>
      <div class="date">
        Written on June 25, 2015
      </div>
      <div class="entry">
        <p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>

<p>For example, given the following triangle</p>

<ul>
<li>[</li>
<li>........[<strong>2</strong>],</li>
<li>.......[<strong>3</strong>,4],</li>
<li>.....[6,<strong>5</strong>,7],</li>
<li>....[4,<strong>1</strong>,8,3]</li>
<li>]</li>
</ul>

<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>

<p>Note:</p>

<p>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">minimumTotal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">triangle</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3>题意：</h3>

<p>自顶向下寻找一条路径使得路径上每个节点的值的和，是所有路径中最小的。限制条件：每次只能选下一行的邻接节点。</p>

<h3>题解：</h3>

<p>很明显是动态规划方面的题（实际上我就是特地先做动态规划的题=。=）。</p>

<p>列下状态转移方程：</p>

<p>设总共有N层，T=triangle，每个节点的值表示为T(n,i)，从根节点到每个节点的最优路径的值总和为S(n,i)，
那么可以得到：</p>

<p><strong>S(n,i) = MAX( S(n-1, i-1), S(n-1, i) ) + T(n,i)</strong></p>

<p>初始状态：S(0,0) = T(0,0)</p>

<p>然后自顶向下地迭代一轮，即可求得最下面一层的S(n, i)，遍历这一层，找出S的最小值即可。</p>

<p>空间复杂度O(n)，时间复杂度O(n)</p>

<h3>代码：</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">minimumTotal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">triangle</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">triangle</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">triangle</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">triangle</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">triangle</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="kt">int</span> <span class="n">maxLayer</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxLayer</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">leftPathSum</span><span class="p">,</span> <span class="n">righPathSum</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">layer</span> <span class="o">&lt;</span> <span class="n">maxLayer</span><span class="p">;</span> <span class="o">++</span><span class="n">layer</span><span class="p">){</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">layer</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
                <span class="n">leftPathSum</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
                <span class="n">righPathSum</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">leftPathSum</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum</span><span class="p">[</span><span class="n">layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">)</span>
                    <span class="n">righPathSum</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sum</span><span class="p">[</span><span class="n">layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
                <span class="n">sum</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">leftPathSum</span><span class="p">,</span> <span class="n">righPathSum</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="p">[</span><span class="n">maxLayer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">maxLayer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-120/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/leetcode-problem-198/">leetcode题解 problem198 House Robber</a></h1>
      <div class="date">
        Written on June 24, 2015
      </div>
      <div class="entry">
        <blockquote>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>

<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
</blockquote>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">rob</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<h3>题意：</h3>

<p>一个坏蛋要去盗窃一排房子，每个房子都藏有一笔钱（函数参数nums记录了每个房子的钱的数量），盗窃的限制条件是，如果某两个相邻的房子同时被盗了，会触发安保系统，也就是说不能连续地盗窃房子。
求：这个坏蛋最多能盗取多少钱？</p>

<h3>题解：</h3>

<p>看得出题目是要求一个最优解，即安排这个窃贼的行动路线，让他拿到最多的钱。路线有很多种，目标是求最优解，似乎是动态规划题目？那么就试试分析状态转移方程：</p>

<p>f(n) : 代表窃贼在前n个房子最多能拿到多少钱，n==nums.size()时，即是我们要的解</p>

<p>f(0) : 窃贼在前0个房子最多能拿到多少钱（一家都不偷），显然 <strong>f(0) == 0</strong></p>

<p>f(1) : 窃贼在前1个房子最多能拿到多少钱（只偷一家），显然 <strong>f(1) == nums[0]</strong></p>

<p>f(2) : 窃贼在前2个房子最多能拿到多少钱，因为限制条件存在，窃贼只能选偷第1个房子或第2个房子，取决于哪个房子的钱多，那么 <strong>f(2) = max(nums[0], nums[1])</strong></p>

<p>f(3) : 总共有4种路线：[0,2]、[0]、[1]、[2]，而因为nums[i]&gt;=0（钱是非负数），那么可以剔除掉[0]、[2]这2个路线（偷了0后还可以偷2，不会亏，为什么不偷呢？），所以只剩[0,2]、[1]2种，于是 <strong>f(3) = max(nums[1], nums[0] + nums[2])</strong></p>

<p>从而得到方程：</p>

<p>f(n) = max( f(n-1), nums[n-1] + f(n-2) ) </p>

<p>对方程的解释：</p>

<p>偷前n个房子的最优解（即钱的总数），等于：偷前(n-1)个房子的最优解、偷前(n-2)个房子的最优解 + 第n个房子的钱，取这两者中较大的那个。</p>

<p>验证一下该方程是否合理：</p>

<p><strong>f(1)</strong> = nums[0] = max(0，nums[0]) = <strong>max(f(0), nums[0] + f(-1))</strong> =  max(f(0), nums[0] + f(0)) （ 因为n&lt;0时没有意义了，所以f(n&lt;0) = f(0) )</p>

<p><strong>f(2)</strong> = max(nums[0], nums[1]) = <strong>max( f(1), nums[1] + f(0) )</strong></p>

<p>f(3) = max(nums[1], nums[0] + nums[2]) = max( <strong>max(nums[0], nums[1])</strong>, nums[0] + nums[2]) = max( f(2), nums[2] + f(1) )</p>

<p>代码如下(leetcode RunTime 0ms)：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">rob</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="err">，</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>又因为，我们只需要求f[n]，并不需要输出整个F数组，那么可以改下代码，降低空间复杂度。</p>

<p>代码如下(leetcode RunTime 0ms)：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
    <span class="kt">int</span> <span class="n">rob</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pre</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
      </div>

      <a href="/leetcode-problem-198/" class="read-more">Read More</a>
    </article>
  
    <article class="post">

      <h1><a href="/nopoll-windows/">windows 7 下编译 nopoll</a></h1>
      <div class="date">
        Written on April  7, 2015
      </div>
      <div class="entry">
        <h3>编译环境</h3>

<ul>
<li><p>windows 7 64位</p></li>
<li><p>VS 2013 Ultimate</p></li>
<li><p>openssl-1.0.2a</p></li>
<li><p>nopoll-0.2.8.b184</p></li>
</ul>

<h3>编译步骤</h3>

<ol>
<li>nopoll官网提供了二进制安装包，不过不知为什么无法直接用（运行时错误，无法debug)，所以还是得手动编译&lt;</li>
<li><p>nopoll依赖openssl，所以先编译openssl：</p>

<ul>
<li>下载<a href="http://www.openssl.org/source/openssl-1.0.2a.tar.gz">http://www.openssl.org/source/openssl-1.0.2a.tar.gz</a></li>
<li>安装perl <a href="http://downloads.activestate.com/ActivePerl/releases/5.20.1.2000/ActivePerl-5.20.1.2000-MSWin32-x64-298557.msi">http://downloads.activestate.com/ActivePerl/releases/5.20.1.2000/ActivePerl-5.20.1.2000-MSWin32-x64-298557.msi</a></li>
<li>解压后，阅读INSTALL.W64安装说明
&gt; We loved with a love that was more than love
&gt; To build for Win64/x64: 
&gt; perl Configure VC-WIN64A
&gt; ms\do_win64a
&gt; nmake -f ms\ntdll.mak
&gt; cd out32dll
&gt; ..\ms\test</li>
<li><p>第三步的ms\do_win65a和nmake -f ms\ntdll.mak必须要用vs的控制台程序来执行，否则会出错</p>

<p><img src="/images/2015.4/1.png" alt="1.png"></p></li>
<li><p>编译完成通过后，执行nmake -f ms\ntdll.mak install来生成最终发布文件, 生成位置默认是在usr/local/里，但windows下没有这个目录，所以Perl把ssl生成到当前控制台所在分区的根目录了（如源码在d:/openssl/，则会生成到D:/usr/local/)</p></li>
</ul></li>
<li><p>用编译好的openssl库来编译Nopoll</p>

<p>nopoll虽然提供了Makefile.win，但我试了下，发现并不能一键编译，会提示缺少versions.mk和config.mk（这2个文件最后在nopoll的svn仓库里找到），补上这2个文件后再次执行nmake，会提示./prepare-nsh.sh permission denied（win平台执行sh文件？）</p>

<p>按官方的编译方法失败后，只能自行建工程编译了：</p>

<ul>
<li>新建一个vs工程，取名libnopoll</li>
<li>添加 nopoll-0.2.8.b184/src目录的源码文件到工程</li>
<li>这里要改下nopoll_config.h（此文件应该是自动生成的，我们要手动修改一个出来）</li>
</ul>
<div class="highlight"><pre><code class="language-c" data-lang="c">  <span class="cm">/*</span>
<span class="cm">  * Nopoll Library nopoll_config.h</span>
<span class="cm">  * Platform dependant definitions.</span>
<span class="cm">  *</span>
<span class="cm">  * This is a generated file.  Please modify &#39;configure.in&#39;</span>
<span class="cm">  */</span>
  <span class="cp">#ifndef __NOPOLL_CONFIG_H__</span>
  <span class="cp">#define __NOPOLL_CONFIG_H__</span>
  <span class="cm">/**</span>
<span class="cm">  * \addtogroup nopoll_decl_module</span>
<span class="cm">  * @{</span>
<span class="cm">  */</span>
  <span class="cm">/**</span>
<span class="cm">  * @brief Allows to convert integer value (including constant values)</span>
<span class="cm">  * into a pointer representation.</span>
<span class="cm">  *</span>
<span class="cm">  * Use the oposite function to restore the value from a pointer to a</span>
<span class="cm">  * integer: \ref PTR_TO_INT.</span>
<span class="cm">  *</span>
<span class="cm">  * @param integer The integer value to cast to pointer.</span>
<span class="cm">  *</span>
<span class="cm">  * @return A \ref noPollPtr reference.</span>
<span class="cm">  */</span>
  <span class="cp">#ifndef INT_TO_PTR</span>
  <span class="cp">#define INT_TO_PTR(integer)   ((noPollPtr) (long) ((int)integer))</span>
  <span class="cp">#endif</span>
  <span class="cm">/**</span>
<span class="cm">  * @brief Allows to convert a pointer reference (\ref noPollPtr),</span>
<span class="cm">  * which stores an integer that was stored using \ref INT_TO_PTR.</span>
<span class="cm">  *</span>
<span class="cm">  * Use the oposite function to restore the pointer value stored in the</span>
<span class="cm">  * integer value.</span>
<span class="cm">  *</span>
<span class="cm">  * @param ptr The pointer to cast to a integer value.</span>
<span class="cm">  *</span>
<span class="cm">  * @return A int value.</span>
<span class="cm">  */</span>
  <span class="cp">#ifndef PTR_TO_INT</span>
  <span class="cp">#define PTR_TO_INT(ptr) ((int) (long) (ptr))</span>
  <span class="cp">#endif</span>
  <span class="cm">/**</span>
<span class="cm">  * @brief Allows to get current platform configuration. This is used</span>
<span class="cm">  * by Nopoll library but could be used by applications built on top of</span>
<span class="cm">  * Nopoll to change its configuration based on the platform information.</span>
<span class="cm">  */</span>
  <span class="c1">//#define NOPOLL_OS_UNIX (1)</span>
  <span class="cp">#define NOPOLL_OS_WIN32 (1)</span>
  <span class="cp">#define R_OK 4</span>
  <span class="cp">#define W_OK 2</span>
  <span class="cm">/**</span>
<span class="cm">  * @internal Allows to now if the platform support vasprintf</span>
<span class="cm">  * function. Do not use this macro as it is supposed to be for</span>
<span class="cm">  * internal use.</span>
<span class="cm">  */</span>
  <span class="c1">//#define NOPOLL_HAVE_VASPRINTF (1)</span>
  <span class="cm">/**</span>
<span class="cm">  * @brief Indicates that this platform have support for 64bits.</span>
<span class="cm">  */</span>
  <span class="cp">#define NOPOLL_64BIT_PLATFORM (1)</span>
  <span class="cm">/* @} */</span>
  <span class="cp">#endif</span>
</code></pre></div>
<ul>
<li><p>配置编译环境</p>

<p><img src="/images/2015.4/2.png" alt="1.png"></p>

<p><img src="/images/2015.4/3.png" alt="1.png"></p>

<ul>
<li>添加openssl的include、nopoll的src到包含目录</li>
<li>添加上一步生成的ssl/lib目录 到 库目录</li>
<li>执行 生成项目，就得到了libnopoll.lib文件</li>
</ul></li>
</ul></li>
<li><p>测试libnopoll.lib是否可用：</p>

<ul>
<li>新建测试项目，一样是    <img src="/images/2015.4/4.png" alt="1.png"></li>
<li>添加nopoll官方的example代码，<a href="https://dolphin.aspl.es/svn/publico/nopoll/trunk/test/nopoll-regression-listener.c">https://dolphin.aspl.es/svn/publico/nopoll/trunk/test/nopoll-regression-listener.c</a></li>
<li><p>复制 /test的pem、crt、key文件到工程目录里:</p>

<p><img src="/images/2015.4/5.png" alt="1.png"></p></li>
<li><p>然后是附加依赖项：</p>

<p><img src="/images/2015.4/6.png" alt="1.png"></p></li>
<li><p>之后就可以编译 运行了：</p>

<p><img src="/images/2015.4/7.png" alt="1.png"></p>

<p>看样子是成功了。</p></li>
<li><p>最后客户端的例子也试着编译下，工程配置和server的一样，咦！！ 编译时出现各种error:</p>

<p><img src="/images/2015.4/8.png" alt="1.png"></p>

<p>照着反馈做即可，在文件头添加一个define </p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#define _CRT_SECURE_NO_WARNINGS</span>
</code></pre></div>
<p><img src="/images/2015.4/9.png" alt="1.png"></p>

<p>unlink改成_unlink呗；</p>

<p>VERSION可能是要自己定义，也定义一个，之后就顺利编译出来了。</p>

<p>不过运行的时候又出现报错：</p>

<p><img src="/images/2015.4/10.png" alt="1.png"></p>

<p>问题就是windows下没有linux的diff工具，先把相关的几行代码屏蔽掉先把，再次编译运行：</p>

<p><img src="/images/2015.4/11.png" alt="1.png"></p>

<p>Nice，客户端和服务端协同工作了。</p></li>
</ul></li>
</ol>

<h3>附</h3>

<ul>
<li>编译debug版的openssl :  <a href="http://blog.csdn.net/wangxvfeng101/article/details/7261264">http://blog.csdn.net/wangxvfeng101/article/details/7261264</a></li>
</ul>

      </div>

      <a href="/nopoll-windows/" class="read-more">Read More</a>
    </article>
  
</div>

  <script type="text/javascript"
          src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:voyagingmk@gmail.com"><i class="svg-icon email"></i></a>


<a href="http://github.com/barryclark/jekyll-now"><i class="svg-icon github"></i></a>




<a href="http://twitter.com/voyagingmk"><i class="svg-icon twitter"></i></a>


        </footer>
      </div>
    </div>

  </body>
</html>
