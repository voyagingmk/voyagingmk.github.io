<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>伪技术宅，兴趣点：服务器编程、游戏开发、人工智能</description>
    <link>http://www.qiujiawei.com</link>
    <atom:link href="http://www.qiujiawei.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>狄拉克δ函数(Dirac delta)和狄拉克梳状函数(Dirac comb)</title>
        <description>&lt;h2&gt;狄拉克δ函数(Dirac delta)&lt;/h2&gt;

&lt;p&gt;在卷积那篇文章中，已经提到了狄拉克δ函数的定义:&lt;/p&gt;

&lt;p&gt;\[ delta (t) =  \begin {cases} +\infty , t=0 \\  0, t\neq 0 \end {cases} \]&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }\delta (t)dt = 1 \]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;下面介绍它的一些性质:&lt;/p&gt;

&lt;h4&gt;对称性质&lt;/h4&gt;

&lt;p&gt;从δ函数的波形图(或者定义)可以简单看出，δ函数是偶函数，即:&lt;/p&gt;

&lt;p&gt;\[ \delta (t) = \delta (-t) \]&lt;/p&gt;

&lt;h4&gt;缩放性质&lt;/h4&gt;

&lt;p&gt;设有常数a，令u = at，再依据δ函数的积分特性，有:&lt;/p&gt;

&lt;p&gt;\[ dt = \frac {1}{a}du \]&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }\delta (at)dt = \int _{-\infty }^{\infty }\delta (u)\frac {1}{a}du = \frac {1}{a} \int _{-\infty }^{\infty }\delta (u)du = \frac {1}{a} \]&lt;/p&gt;

&lt;p&gt;也即:&lt;/p&gt;

&lt;p&gt;\[ \delta (at) = \frac {1}{a}\delta (t) \]&lt;/p&gt;

&lt;p&gt;又因为它的对称性质，有:&lt;/p&gt;

&lt;p&gt;\[ \delta (at) = \frac {1}{|a|}\delta (t) \]&lt;/p&gt;

&lt;h4&gt;代数性质&lt;/h4&gt;

&lt;p&gt;\[ t\delta (t) = 0 \]&lt;/p&gt;

&lt;p&gt;这个太简单了，从基本定义出发可以很快看出来这个式子的正确性。&lt;/p&gt;

&lt;h4&gt;平移性质&lt;/h4&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }f(t)\delta (t - T)dt = f(T) \]&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;http://www.qiujiawei.com/convolution/&quot;&gt;理解卷积 Convolution&lt;/a&gt;中有对这个式子的详细讨论。当然从δ函数的定义去理解这个式子也很简单。&lt;/p&gt;

&lt;h4&gt;δ函数的傅里叶变换&lt;/h4&gt;

&lt;p&gt;\[ \mathcal {F}[\delta (s)] = \int _{-\infty }^{\infty }e^{-2\pi ist}\delta (t) = 1 \]&lt;/p&gt;

&lt;p&gt;因为只有当x等于0时，δ函数才非0(等于1)，所以这个式子的计算结果等于1。&lt;/p&gt;

&lt;p&gt;傅里叶变换后是一个常数1，这个性质看起来就很特别。&lt;/p&gt;

&lt;h2&gt;狄拉克梳状函数(Dirac comb)&lt;/h2&gt;

&lt;p&gt;这个函数在电子工程&lt;a href=&quot;https://en.wikipedia.org/wiki/Electrical_engineering&quot;&gt;electrical engineering&lt;/a&gt;中称为脉冲序列(impulse train)或采样函数(sampling function)。注意，有些文章会把它叫做Shah function。&lt;/p&gt;

&lt;p&gt;它其实就是关于狄拉克δ函数的用周期T间隔的无穷级数(多个δ函数的合并)。(wiki原文是:&lt;strong&gt;A Dirac comb is an infinite series of Dirac delta functions spaced at intervals of T&lt;/strong&gt;）&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;用图表示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/9.png&quot; alt=&quot;9.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图片来自wiki）&lt;/p&gt;

&lt;p&gt;公式表示:&lt;/p&gt;

&lt;p&gt;\[ III_{T}(t) = \sum _{k=-\infty }^{\infty }\delta (t - kT)\]&lt;/p&gt;

&lt;p&gt;这个公式和图片完全对应。&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/shah-function/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/shah-function/</guid>
      </item>
    
      <item>
        <title>理解卷积 Convolution</title>
        <description>&lt;h2&gt;数学中的卷积&lt;/h2&gt;

&lt;p&gt;卷积的wiki：&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution#Derivations&quot;&gt;Convolution&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;卷积和(convolution sum)的公式是:&lt;/p&gt;

&lt;p&gt;\[ y(t) = x(t)*h(t) = \sum _{\tau =-\infty }^{\infty }x(\tau )h(t-\tau )\]&lt;/p&gt;

&lt;p&gt;写成积分形式是:&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;\[ x(t)*h(t) = \int _{-\infty }^{\infty }x(\tau )h(t-\tau )d\tau = \int _{-\infty }^{\infty }x(t-\tau )h(\tau )d\tau \]&lt;/p&gt;

&lt;p&gt;要理解这个东西，比较难，一种是公式推导，不过是从傅里叶变换得到的；一种是用狄拉克δ函数来辅助理解（我自认为的）；最后一种是通过线性时不变系统理论&lt;a href=&quot;https://en.wikipedia.org/wiki/LTI_system_theory#Overview&quot;&gt;LTI system theory&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;先讲第一种吧。&lt;/p&gt;

&lt;h2&gt;第一种思路：傅里叶变换与卷积&lt;/h2&gt;

&lt;p&gt;首先要搬出&lt;a href=&quot;http://www.qiujiawei.com/fourier-equation/&quot;&gt;傅里叶变换&lt;/a&gt;的一个推论：&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[\alpha f(t) + \beta g(t)] = \alpha F(s) + \beta G(s) \]&lt;/p&gt;

&lt;p&gt;这个公式意思是，一个时域下的复杂信号函数可以分解成多个简单信号函数的和，然后对各个子信号函数做傅里叶变换并再次求和，就求出了原信号的傅里叶变换。这个事实显然很有用处。&lt;/p&gt;

&lt;p&gt;但除了加法之外，还有乘法。这时候有一个问题：&lt;strong&gt;是否存在某种新的f(t)和g(t)的结合方式，使得f(t)和g(t)结合后的函数的傅里叶变换结果是F(s)G(s)？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要求这个问题的解，要用倒推法。&lt;/p&gt;

&lt;p&gt;首先，设有信号函数f(x)和g(t)（注意，x、t都是指横轴变量，只是用来区分开f和g），G(s)、F(s)分别是f(x)和g(t)的傅里叶变换，于是有:&lt;/p&gt;

&lt;p&gt;\[ G(s)F(s) = \int _{-\infty }^{\infty }e^{-2\pi ist}g(t)dt\int _{-\infty }^{\infty }e^{-2\pi isx}f(x)dx \]&lt;/p&gt;

&lt;p&gt;接着做一些变换:&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }e^{-2\pi ist}g(t)dt\int _{-\infty }^{\infty }e^{-2\pi isx}f(x)dx = \int _{-\infty }^{\infty }\int _{-\infty }^{\infty }e^{-2\pi ist}e^{-2\pi isx}g(t)f(x)dtdx \]
\[ = \int _{-\infty }^{\infty }\int _{-\infty }^{\infty }e^{-2\pi is(t+x)}g(t)f(x)dtdx \]
\[ = \int _{-\infty }^{\infty }\left (\int _{-\infty }^{\infty }e^{-2\pi is(t+x)}g(t)dt\right )f(x)dx \]&lt;/p&gt;

&lt;p&gt;现在设u = t + x，所以t = u - x，du = dt（这是把x看做常数项了）。则有：&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }\left (\int _{-\infty }^{\infty }e^{-2\pi is(t+x)}g(t)dt\right )f(x)dx =  \int _{-\infty }^{\infty }\left (\int _{-\infty }^{\infty }e^{-2\pi isu}g(u - x)du\right )f(x)dx \]&lt;/p&gt;

&lt;p&gt;接着调整下积分顺序：
\[ \int _{-\infty }^{\infty }\left (\int _{-\infty }^{\infty }e^{-2\pi isu}g(u - x)du\right )f(x)dx = \int _{-\infty }^{\infty }\int _{-\infty }^{\infty }e^{-2\pi isu}g(u - x)f(x)dudx \]
\[ = \int _{-\infty }^{\infty }\int _{-\infty }^{\infty }e^{-2\pi isu}g(u - x)f(x)dxdu \]
\[ = \int _{-\infty }^{\infty }e^{-2\pi isu}\left (\int _{-\infty }^{\infty }g(u - x)f(x)dx\right )du \]&lt;/p&gt;

&lt;p&gt;括号内那个积分是一个关于u的函数，所以可以设成h(u)：&lt;/p&gt;

&lt;p&gt;\[ h(u) = \int _{-\infty }^{\infty }g(u - x)f(x)dx \]&lt;/p&gt;

&lt;p&gt;于是上面的式子就变成:&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }e^{-2\pi isu}\left (\int _{-\infty }^{\infty }g(u - x)f(x)dx\right )du = \int _{-\infty }^{\infty }e^{-2\pi isu}h(u)du =  \mathcal {F}[h(s)] = H(s)  \]&lt;/p&gt;

&lt;p&gt;这个结论，可以简化成：&lt;/p&gt;

&lt;p&gt;\[  H(s) = G(s)F(s) \]&lt;/p&gt;

&lt;p&gt;再来看下h(u)。如果把h(u)的u换成t（这是可以的，只是一个符号而已），就有:&lt;/p&gt;

&lt;p&gt;\[ h(t) = \int _{-\infty }^{\infty }g(t - x)f(x)dx \]&lt;/p&gt;

&lt;p&gt;2个终极公式都出来了。&lt;/p&gt;

&lt;p&gt;最后，我们还要定义一个特殊的二元运算符号*****来替代h(t)（也叫卷积运算符，注意，这个不是乘法的乘号哦）：&lt;/p&gt;

&lt;p&gt;\[ h(t) = (g*f)(t) = \int _{-\infty }^{\infty }g(t - x)f(x)dx \]&lt;/p&gt;

&lt;p&gt;于是有：&lt;/p&gt;

&lt;p&gt;\[ H(s) = G(s)F(s) \]
\[ \mathcal {F}[h(t)] = \mathcal {F}[g(s)] \mathcal {F}[f(s)] \]
\[ \mathcal {F}[(g*f)(s)] = \mathcal {F}[g(s)] \mathcal {F}[f(s)] \]&lt;/p&gt;

&lt;p&gt;最后的公式，也被叫做&lt;strong&gt;卷积定理&lt;/strong&gt;(Convolution Theorem)。&lt;/p&gt;

&lt;p&gt;这个定理说明，信号f和信号g的卷积的傅里叶变换，等于f、g各自的傅里叶变换的积。&lt;/p&gt;

&lt;h2&gt;第二种思路：狄拉克δ函数与卷积&lt;/h2&gt;

&lt;p&gt;第二种思路的关键在于&lt;strong&gt;狄拉克δ函数&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;狄拉克δ函数 dirac delta function&lt;/h3&gt;

&lt;p&gt;狄拉克δ函数的wiki：&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_delta_function&quot;&gt;dirac delta function&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;狄拉克δ函数在坐标系上的长相:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/Dirac_function_approximation.gif&quot; alt=&quot;Dirac_function_approximation.gif&quot;&gt;&lt;/p&gt;

&lt;p&gt;（图片来自wiki）&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;信号处理科学&lt;/strong&gt;中狄拉克δ函数被称为单位脉冲信号(unit impulse symbol）。上面这个图也很形象地说明了这一点。&lt;/p&gt;

&lt;p&gt;狄拉克δ函数有这样的性质:&lt;/p&gt;

&lt;p&gt;\[ delta (t) =  \begin {cases} +\infty , t=0 \\  0, t\neq 0 \end {cases} \]&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }\delta (t)dt = 1 \]&lt;/p&gt;

&lt;p&gt;狄拉克δ函数在t等于0时值为正无穷，t不等于0时则为0，且在整个定义域的积分等于1。&lt;/p&gt;

&lt;h3&gt;狄拉克δ函数与卷积&lt;/h3&gt;

&lt;p&gt;考虑卷积公式的一个特殊情况：&lt;strong&gt;当h(t)是狄拉克δ函数时&lt;/strong&gt;。现在试一下把h(t)代入卷积公式，得到:&lt;/p&gt;

&lt;p&gt;\[ x(t) * h(t) = x(t) * \delta (t) = \int _{-\infty }^{\infty }x(\tau )\delta (t-\tau )d\tau = x(t) \]&lt;/p&gt;

&lt;p&gt;(最后一步跳跃得比较厉害，后文会有说明）&lt;/p&gt;

&lt;p&gt;这个结果说明，x(t)和狄拉克δ函数卷积的结果还是x(t)，为什么会这样呢？&lt;/p&gt;

&lt;p&gt;再看下前面给出的卷积和标准公式：&lt;/p&gt;

&lt;p&gt;\[ y(t) = x(t)*h(t) = \sum _{\tau =-\infty }^{\infty }x(\tau )h(t-\tau )\]&lt;/p&gt;

&lt;p&gt;把其中的\( h(t - \tau ) \)换成\( \delta (t - \tau ) \)，那么里面的\( t - \tau \)，其实就是让那个脉冲信号在横轴上移动(偏移)\( \tau \)距离。根据狄拉克δ函数的定义，可以知道，当\( t = \tau \)时，\( x(\tau )h(t-\tau ) \)才非0，且等于\( x(\tau ) \)。所以卷积和也就等于\( x(\tau ) \)。（这也算是上面的公式的证明吧）&lt;/p&gt;

&lt;p&gt;将这个特殊情况一般化，即不限制h = δ时，就是所谓的卷积公式了。&lt;/p&gt;

&lt;h2&gt;第三种思路：线性时不变系统·理论 LTI system theory&lt;/h2&gt;

&lt;p&gt;这个还没搞懂，搞懂了再来填坑&lt;/p&gt;

&lt;h2&gt;找到的相关资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.eecg.toronto.edu/%7Eahouse/mirror/engi7824/course_notes_7824_part6.pdf&quot;&gt;The Convolution Sum for Discrete-Time LTI Systems. Andrew W. H. House&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/convolution/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/convolution/</guid>
      </item>
    
      <item>
        <title>gcc-4.9.3 编译过程笔记</title>
        <description>&lt;p&gt;官方的编译指南：&lt;a href=&quot;https://gcc.gnu.org/install/&quot;&gt;https://gcc.gnu.org/install/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;唠叨几句&lt;/h2&gt;

&lt;p&gt;之前升级了我的阿里云的gcc，记得是费了些功夫的，有些坑。可惜忘了记笔记。今天编译node.js时发现我编译的gcc有些问题，要重新编译下，悲催的是gcc的编译目录都删掉了。全部得重来过。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;准备&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;https://gcc.gnu.org/mirrors.html&quot;&gt;https://gcc.gnu.org/mirrors.html&lt;/a&gt;下载源码包到机器上并解压：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;wget http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-4.9.3/gcc-4.9.3.tar.gz&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tar -xzvf gcc-4.9.3.tar.gz&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;配置&lt;/h2&gt;

&lt;p&gt;To configure GCC:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; % mkdir objdir
 % cd objdir
 % srcdir/configure [options] [target]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即，在gcc-4.9.3目录里建立objdir子目录，并在这个子目录里执行configure。&lt;/p&gt;

&lt;p&gt;configure要填什么参数，这个因人而异了。就不说了。官方文档是&lt;a href=&quot;https://gcc.gnu.org/install/configure.html&quot;&gt;https://gcc.gnu.org/install/configure.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我只需要用c++，所以我执行了:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/download/gcc-4.9.3/configure --enable-languages=c,c++&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后就遇到第一个坑：&lt;/p&gt;

&lt;h3&gt;坑1&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;configure: error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+. Try the --with-gmp, --with-mpfr and/or --with-mpc options to specify their locations.  Source code for these libraries can be found at their respective hosting sites as well as at ftp://gcc.gnu.org/pub/gcc/infrastructure/.  See also http://gcc.gnu.org/install/prerequisites.html for additional info.  If you obtained GMP, MPFR and/or MPC from a vendor distribution package, make sure that you have installed both the libraries and the header files.  They may be located in separate packages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说是需要GMP 4.2+、MPFR 2.4.0+、MPC 0.8.0+。不知道是什么鬼。上次编译好像也有见到这个提示。&lt;/p&gt;

&lt;p&gt;它叫我去翻看&lt;a href=&quot;https://gcc.gnu.org/install/prerequisites.html&quot;&gt;https://gcc.gnu.org/install/prerequisites.html&lt;/a&gt;，好咯。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Several support libraries are necessary to build GCC, some are required, others optional. While any sufficiently new version of required tools usually work, library requirements are generally stricter. Newer versions may work in some cases, but it&amp;#39;s safer to use the exact versions documented. We appreciate bug reports about problems with newer versions, though. If your OS vendor provides packages for the support libraries then using those packages may be the simplest way to install the libraries.&lt;/p&gt;

&lt;p&gt;GNU Multiple Precision Library (GMP) version 4.3.2 (or later)&lt;/p&gt;

&lt;p&gt;MPFR Library version 2.4.2 (or later)&lt;/p&gt;

&lt;p&gt;MPC Library version 0.8.1 (or later)&lt;/p&gt;

&lt;p&gt;ISL Library version 0.15, 0.14, 0.13, or 0.12.2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看起来很复杂的样子，其实gcc自己给出了简单的解决办法，但是又不在这个页面写出来，这是傲娇吗=。=&lt;/p&gt;

&lt;p&gt;方法就是，在gcc-4.9.3目录执行:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sh ./contrib/download_prerequisites&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;哗啦啦的就把各个依赖库下载好了。好棒。&lt;/p&gt;

&lt;h3&gt;坑2&lt;/h3&gt;

&lt;p&gt;回到objdir目录，再次执行:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/download/gcc-4.9.3/configure --enable-languages=c,c++&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;出现一些warning：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;configure: WARNING: using in-tree ISL, disabling version check&lt;/p&gt;

&lt;p&gt;configure: WARNING: using in-tree CLooG, disabling version check&lt;/p&gt;

&lt;p&gt;*** This configuration is not supported in the following subdirectories:
gnattools target-libada target-libgfortran target-libgo target-libffi target-libbacktrace target-zlib target-libjava target-libobjc target-boehm-gc
(Any other directories should still work fine.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这些目录是什么东西，懒得了解了，只是warning的话先不管了。重点是还出现以下的error提示：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;/usr/bin/ld: cannot find crt1.o: No such file or directory&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find crti.o: No such file or directory&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: skipping incompatible /usr/local/lib/gcc/x86_64-unknown-linux-gnu/4.9.3/libgcc.a when searching for -lgcc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lgcc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lgcc_s&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: skipping incompatible /usr/local/lib/gcc/x86_64-unknown-linux-gnu/4.9.3/libgcc.a when searching for -lgcc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lgcc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lgcc_s&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find crtn.o: No such file or directory&lt;/p&gt;

&lt;p&gt;collect2: error: ld returned 1 exit status&lt;/p&gt;

&lt;p&gt;configure: error: I suspect your system does not have 32-bit developement libraries (libc and headers). If you have them, rerun configure with --enable-multilib. If you do not have them, and want to build a 64-bit-only compiler, rerun configure with --disable-multilib.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个意思应该是，我编译配置是默认支持32位和64位，但是32位的dev lib不齐全，建议我关掉32位。好咯。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/download/gcc-4.9.3/configure --disable-multilib --enable-languages=c,c++&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后就天晴了，那些cannot find和error不见了（除了那个warning），没有其他异常提示：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;configure: creating ./config.status&lt;/p&gt;

&lt;p&gt;config.status: creating Makefile&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;开始编译&lt;/h2&gt;

&lt;p&gt;还是在objdir，执行:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;make&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过漫长的等待，终于，出现了坑3。&lt;/p&gt;

&lt;h3&gt;坑3&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;make[3]: *** [s-attrtab] Killed&lt;/p&gt;

&lt;p&gt;make[3]: Leaving directory `/root/download/gcc-4.9.3/objdir/gcc&amp;#39;&lt;/p&gt;

&lt;p&gt;make[2]: *** [all-stage1-gcc] Error 2&lt;/p&gt;

&lt;p&gt;make[2]: Leaving directory `/root/download/gcc-4.9.3/objdir&amp;#39;&lt;/p&gt;

&lt;p&gt;make[1]: *** [stage1-bubble] Error 2&lt;/p&gt;

&lt;p&gt;make[1]: Leaving directory `/root/download/gcc-4.9.3/objdir&amp;#39;&lt;/p&gt;

&lt;p&gt;make: *** [all] Error 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查了下，这个是因为我的vps内存不足导致的，看官们的机器应该不会出现这个错误T_T。&lt;/p&gt;

&lt;p&gt;重启下vps再编译，看看能不能解决。&lt;/p&gt;

&lt;p&gt;Oh，编译成功了。接着执行make install就完成了。&lt;/p&gt;

&lt;p&gt;End。&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/cpp-2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/cpp-2/</guid>
      </item>
    
      <item>
        <title>学习傅里叶变换</title>
        <description>&lt;p&gt;本文主要写的是公式层面的推导，关于傅里叶变换的应用，请到知乎搜索&amp;#39;傅里叶&amp;#39;，能找到很多不错的文章。&lt;/p&gt;

&lt;p&gt;本文主要参考了斯坦福大学Brad Osgood的公开课:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://open.163.com/special/opencourse/fouriertransforms.html&quot;&gt;http://open.163.com/special/opencourse/fouriertransforms.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;youtube的比较高清:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=gZNm7L96pfY&quot;&gt;https://www.youtube.com/watch?v=gZNm7L96pfY&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;傅里叶级数 fourier series&lt;/h2&gt;

&lt;h3&gt;基础&lt;/h3&gt;

&lt;p&gt;翻译一下wiki的fourier series：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在数学中，傅里叶级数是一个&lt;strong&gt;可以把(有波形的)函数表示成多个简单的sin函数的叠加&lt;/strong&gt;的方法。更形式地说，傅里叶级数能够把任意周期函数(信号)分解成&lt;strong&gt;有限(或无限)个简单的震荡函数的叠加&lt;/strong&gt;，这些震荡函数可以是正弦函数、余弦函数或复指数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;傅里叶级数的公式定义（不要问为什么长这样，这只是一个定义，不是推出来的公式)：&lt;/p&gt;

&lt;p&gt;\[ S = \sum_{k=1}^{n}A_{k}\sin (2\pi kt+\phi _{k}) \]&lt;/p&gt;

&lt;p&gt;(如果不清楚什么是级数，请戳 &lt;a href=&quot;https://en.wikipedia.org/wiki/Series_(mathematics)&quot;&gt;https://en.wikipedia.org/wiki/Series_(mathematics)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用三角函数的一道公式:&lt;/p&gt;

&lt;p&gt;\[ \sin (\alpha + \beta ) = \sin \alpha \cos \beta + \cos \alpha \sin \beta \]&lt;/p&gt;

&lt;p&gt;代入到傅里叶级数，得：&lt;/p&gt;

&lt;p&gt;\[ \sin (2\pi kt + \phi _{k}) =\sin 2\pi kt \cos \phi _{k} + \cos 2\pi kt \sin \phi _{k} \]&lt;/p&gt;

&lt;p&gt;\[ S = \sum_{k=1}^{n}A_{k}\sin 2\pi kt \cos \phi _{k} + \sum_{k=1}^{n}A_{k}\cos 2\pi kt \sin \phi _{k} \]&lt;/p&gt;

&lt;p&gt;再设:&lt;/p&gt;

&lt;p&gt;\[ a_{k} = A_{k}\cos \phi _{k} \]&lt;/p&gt;

&lt;p&gt;\[ b_{k} = A_{k}\sin \phi _{k} \]&lt;/p&gt;

&lt;p&gt;则上面的傅里叶级数被简化成:&lt;/p&gt;

&lt;p&gt;\[ S = \sum_{k=1}^{n}a_{k}\sin 2\pi kt + \sum_{k=1}^{n}b_{k}\cos 2\pi kt \]
\[  S(x) = \sum_{k=1}^{n}(a_{k}\sin 2\pi kt + b_{k}\cos 2\pi kt) \]&lt;/p&gt;

&lt;p&gt;这是傅里叶级数的&lt;strong&gt;常用形式1&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用形式2&lt;/strong&gt;是这样的：&lt;/p&gt;

&lt;p&gt;\[  S = \frac {A_{0}}{2} + \sum_{k=1}^{n}(a_{k}\sin 2\pi kt + b_{k}\cos 2\pi kt) \]&lt;/p&gt;

&lt;p&gt;前面多出来的那个东西，先不管它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用形式3&lt;/strong&gt;，是最重要的：用复指数来表示傅里叶级数。&lt;/p&gt;

&lt;p&gt;推导过程，要用到&lt;strong&gt;欧拉公式&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;\[ e^{ix} = \cos x + i\sin x\]&lt;/p&gt;

&lt;p&gt;（关于欧拉公式的推导，可以看我的另一篇文章:&lt;a href=&quot;http://www.qiujiawei.com/complex-1&quot;&gt;复数和三角函数&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;把 \( x = 2\pi kt \)代入到欧拉公式，得到:&lt;/p&gt;

&lt;p&gt;\[   e^{i2\pi kt} = \cos 2\pi kt + i\sin 2\pi kt\]&lt;/p&gt;

&lt;p&gt;再搬出另外两条欧拉公式的推论:&lt;/p&gt;

&lt;p&gt;\[ \cos x = \frac {e^{ix} + e^{-ix}}{2} \]&lt;/p&gt;

&lt;p&gt;\[ \sin x = \frac {e^{ix} - e^{-ix}}{2i} \]&lt;/p&gt;

&lt;p&gt;也把 \( x = 2\pi kt \)代入，得到:&lt;/p&gt;

&lt;p&gt;\[ \cos 2\pi kt = \frac {e^{i2\pi kt} + e^{-i2\pi kt}}{2} \]&lt;/p&gt;

&lt;p&gt;\[ \sin 2\pi kt = \frac {e^{i2\pi kt} - e^{-i2\pi kt}}{2i} \]&lt;/p&gt;

&lt;p&gt;这时候，教授突然说，傅里叶级数可以写成:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;这个式子确实是常用形式3——复指数表示的傅里叶级数。
但是，这究竟是怎么得到的呢。&lt;/p&gt;

&lt;p&gt;请耐心看下文。&lt;/p&gt;

&lt;h3&gt;复指数形式的傅里叶级数的\(c_{k}\)的性质&lt;/h3&gt;

&lt;p&gt;对于傅里叶级数f(t)，假设它是一个&amp;quot;实信号(real signal)&amp;quot;（一般来说，傅里叶变换处理的目标都是实信号)，
那么就有等式:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \overline {f(t)} \]&lt;/p&gt;

&lt;p&gt;即是说，f(t)没有虚部。而又因为：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;\[ \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} = \overline {\sum_{k=-n}^{n}c_{k}e^{2\pi ikt}} = \sum_{k=-n}^{n}\overline {c_{k}}\overline {e^{2\pi ikt}} = \sum_{k=-n}^{n}\overline {c_{k}}e^{-2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;然后，要注意一个事实是：这个级数是从-n到n的累加，根据加法交换律，这个级数也可以变成从n到-n的累加，也即:&lt;/p&gt;

&lt;p&gt;\[ \sum_{k=-n}^{n} = \sum_{k=n}^{-n}  \]&lt;/p&gt;

&lt;p&gt;于是，把傅里叶级数的k变成-k，就有:&lt;/p&gt;

&lt;p&gt;\[ \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} = \sum_{-k=-n}^{n}c_{-k}e^{-2\pi ikt} = \sum_{k=n}^{-n}c_{-k}e^{-2\pi ikt} = \sum_{k=-n}^{n}c_{-k}e^{-2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;再对比上面的推导，就会发现：&lt;/p&gt;

&lt;p&gt;\[ c_{-k} = \overline {c_{k}} \]&lt;/p&gt;

&lt;p&gt;先记住这个性质，然后继续往下看。&lt;/p&gt;

&lt;p&gt;设有复数z，它必然会满足一个性质：&lt;/p&gt;

&lt;p&gt;\[ z + \overline {z} = 2Re\{ z \} \]&lt;/p&gt;

&lt;p&gt;Re{···}代表取出花括号的复数表达式的实部。&lt;/p&gt;

&lt;p&gt;对于傅里叶级数，也可以把它当成一个复数，再利用刚刚推导出来的\(c_{-k} = \overline {c_{k}} \)，就有：&lt;/p&gt;

&lt;p&gt;\[ c_{k}e^{2\pi ikt} + c_{-k}e^{2\pi i(-k)t} = c_{k}e^{2\pi ikt} + c_{-k}e^{-2\pi ikt}\]
\[ = c_{k}e^{2\pi ikt} + \overline {c_{k}}e^{\overline {2\pi ikt}} \]
\[ = c_{k}e^{2\pi ikt} + \overline {c_{k}e^{2\pi ikt}} \]
\[ = 2Re\{ c_{k}e^{2\pi ikt} \} \]&lt;/p&gt;

&lt;p&gt;这个结果表明，\(c_{k}e^{2\pi ikt} + c_{-k}e^{2\pi i(-k)t} \)是一个实数。把这个结论代入到傅里叶级数，就可以得到：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]
\[ = \sum_{k=0}^{n}2Re\{ c_{k}e^{2\pi ikt} \} \]
\[ = 2Re\{ \sum_{k=0}^{n}c_{k}e^{2\pi ikt} \} \]&lt;/p&gt;

&lt;p&gt;注意，这个式子是把0和-0都算进去的。如果不允许signed zero，就要对k=0的情况特殊处理。&lt;/p&gt;

&lt;h3&gt;求解\(c_{k}\)的积分形式&lt;/h3&gt;

&lt;p&gt;回到前面的那个傅里叶级数f(t)：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;其实是这样子搞出来的：
先假设傅里叶的&lt;strong&gt;常用形式2&lt;/strong&gt;可以变换成这个等式，然后求\(c_{k}\)，求得出来的话，式子不就成立了嘛。&lt;/p&gt;

&lt;p&gt;为了搞定这个事情，要使用新的招数：积分。&lt;/p&gt;

&lt;p&gt;( 在教授的notes(&lt;a href=&quot;https://see.stanford.edu/materials/lsoftaee261/book-fall-07.pdf&quot;&gt;https://see.stanford.edu/materials/lsoftaee261/book-fall-07.pdf&lt;/a&gt;]的第10-12页第1.5小节Lost at c，清楚地推导了一遍\(c_{k}\)。 )&lt;/p&gt;

&lt;p&gt;这里我按自己对原文的理解，翻译下。&lt;/p&gt;

&lt;p&gt;我们先随便取了一个k(k在-n到n之间)，然后，对上面的傅里叶级数等式两边同时乘以\( e^{-2\pi ikt } \)：&lt;/p&gt;

&lt;p&gt;\[ e^{-2\pi ikt }f(t) = e^{-2\pi ikt }\sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;把右边的式子展开，得到:&lt;/p&gt;

&lt;p&gt;\[ e^{-2\pi ikt }f(t) = \cdots + e^{-2\pi ikt }c_{k}e^{2\pi ikt} + \cdots \]
\[ = \cdots + c_{k}e^{-2\pi ikt}e^{2\pi ikt } + \cdots \]
\[ = \cdots + c_{k}e^{-2\pi ikt + 2\pi ikt } + \cdots \]
\[ = \cdots + c_{k} + \cdots \]&lt;/p&gt;

&lt;p&gt;这时候，可以把\(c_{k}\)移到等式左边，左边的那个东东移到右边，就得到了一个\(c_{k}\)的表达式:&lt;/p&gt;

&lt;p&gt;\[ c_{k}  = e^{-2\pi ikt }f(t) - \sum_{k&amp;#39;=-n\,k&amp;#39;\neq k}^{n}c_{k&amp;#39;}e^{2\pi ik&amp;#39;t}e^{-2\pi ikt } \]
\[ e^{-2\pi ikt }f(t) - \sum_{k&amp;#39;=-n\,k&amp;#39;\neq k}^{n}c_{k&amp;#39;}e^{2\pi i(k&amp;#39;-k)t} \]&lt;/p&gt;

&lt;p&gt;然后再放大招：对等式两边同时积分，范围是0到1（f(t)的t的周期为1）。&lt;/p&gt;

&lt;p&gt;积分的时候，会发现有这么个神奇的等式:&lt;/p&gt;

&lt;p&gt;\[ \int _{0}^{1}e^{2\pi i(k&amp;#39;-k)t}dt = \left  [ \frac {2\pi i(k&amp;#39;-k)}{1}e^{2\pi i(k&amp;#39;-k)t}\right ]_{0}^{1} \]
\[ = \frac {2\pi i(k&amp;#39;-k)}{1}(e^{2\pi i(k&amp;#39;-k)} - e^{0})\]
\[ = \frac {2\pi i(k&amp;#39;-k)}{1}(1-1) = 0\]&lt;/p&gt;

&lt;p&gt;最后那个1-1=0的前面那个1，其实用上欧拉公式就懂了，&lt;strong&gt;\( 2\pi i(k&amp;#39;-k) \)&lt;/strong&gt;，代表\(\phi =2\pi (k&amp;#39;-k)\) ,又因为k&amp;#39;-k必然是整数，所以\(\phi \)代表了复数平面的坐标(1,0)，所以整个式子就等于1。&lt;/p&gt;

&lt;p&gt;于是，积分等式就只剩下：&lt;/p&gt;

&lt;p&gt;\[ \int _{0}^{1}c_{k}dt = \int _{0}^{1}e^{-2\pi ikt }f(t)dt \]&lt;/p&gt;

&lt;p&gt;\[ (1-0)c_{k} = c_{k} = \int _{0}^{1}e^{-2\pi ikt }f(t)dt \]&lt;/p&gt;

&lt;p&gt;这就是\(c_{k}\)的积分形式。&lt;/p&gt;

&lt;p&gt;做一个小结：&lt;/p&gt;

&lt;p&gt;如果对于一个已知的周期为1的周期函数f(t)，它可以写成这样的形式：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;那么其中的\(c_{k}\)必然满足：&lt;/p&gt;

&lt;p&gt;\[ c_{k} = \int _{0}^{1}e^{-2\pi ikt }f(t)dt \]&lt;/p&gt;

&lt;h3&gt;求解\(c_{k}\)的非积分形式&lt;/h3&gt;

&lt;p&gt;回到傅里叶级数的常用形式2:&lt;/p&gt;

&lt;p&gt;\[  f(t) = \frac {A_{0}}{2} + \sum_{k=1}^{n}(a_{k}\sin 2\pi kt + b_{k}\cos 2\pi kt) \]&lt;/p&gt;

&lt;p&gt;代入下面这2个式子:&lt;/p&gt;

&lt;p&gt;\[ \cos 2\pi kt = \frac {e^{i2\pi kt} + e^{-i2\pi kt}}{2} \]&lt;/p&gt;

&lt;p&gt;\[ \sin 2\pi kt = \frac {e^{i2\pi kt} - e^{-i2\pi kt}}{2i} \]&lt;/p&gt;

&lt;p&gt;得:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \frac {A_{0}}{2} + \sum_{k=1}^{n}(a_{k}\frac {e^{i2\pi kt} - e^{-i2\pi kt}}{2i} + b_{k}\frac {e^{i2\pi kt} + e^{-i2\pi kt}}{2}) \]
\[  = \frac {A_{0}}{2} + \sum_{k=1}^{n}(\frac {b_{k} - ia_{k}}{2}e^{i2\pi kt} + \frac {b_{k} + ia_{k}}{2}e^{-i2\pi  kt})  \]&lt;/p&gt;

&lt;p&gt;设:&lt;/p&gt;

&lt;p&gt;\[ c_{0} = \frac {1}{2}A_{0} \]
\[ c_{k} = \frac {1}{2}(b_{k} - ia_{k}) \]
\[ c_{-k} = \overline {c_{k}} = \frac {1}{2}(b_{k} + ia_{k}) \]&lt;/p&gt;

&lt;p&gt;（注意，第三个式子是利用了前面的结论 ）&lt;/p&gt;

&lt;p&gt;则:&lt;/p&gt;

&lt;p&gt;\[ f(t) = c_{0} + \sum_{k=1}^{n}(c_{k}e^{i2\pi kt} + c_{-k}e^{-i2\pi  kt}) \]
\[ = c_{0} + \sum_{k=1}^{n}c_{k}e^{i2\pi kt} + \sum_{k=1}^{n}c_{-k}e^{-i2\pi  kt} \]
\[ = c_{0} + \sum_{k=1}^{n}c_{k}e^{i2\pi kt} + \sum_{k=-1}^{-n}c_{k}e^{i2\pi  kt} \]
\[ = c_{0} +  \sum_{k=-n,k\neq 0}^{n}c_{k}e^{i2\pi kt}   \]&lt;/p&gt;

&lt;p&gt;和那个常用形式3非常接近了，只需要把\(c_{0}\)也合并到级数里即可。但，这需要有一个前提：\( c_{0} = \frac {1}{2}A_{0} \)和k=0时的f(t)的\( c_{0} \)相等，而这是不一定的。&lt;/p&gt;

&lt;p&gt;傅里叶级数是很不错的东西，但是实际应用时，要考虑很多细节，不是随便用就可以的。&lt;/p&gt;

&lt;h3&gt;大跃进，终极的傅里叶级数的复指数形式&lt;/h3&gt;

&lt;p&gt;终极的傅里叶级数的复指数形式是(fourier series exponential form  )：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-\infty }^{\infty }c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;前面的傅里叶级数是finite的，这个是infinite的。&lt;/p&gt;

&lt;p&gt;其中的\(c_{k}\)有一个专门的notation：\( \hat {f}(t) \)，代入后得到：&lt;/p&gt;

&lt;p&gt;\[ \hat {f}(t) = \int _{-\frac {1}{2} }^{\frac {1}{2} }f(t)e^{-2\pi ikt}dt \]&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-\infty }^{\infty }\hat {f}(t)e^{2\pi ikt} \]&lt;/p&gt;

&lt;h2&gt;傅里叶变换 fourier transform&lt;/h2&gt;

&lt;p&gt;(以下内容摘选自《复变函数与积分变换(华东理工大学出版社)》，有删改)&lt;/p&gt;

&lt;h3&gt;傅里叶积分定理 fourier integrate&lt;/h3&gt;

&lt;p&gt;若函数f(t)在\(-\infty ,+\infty \)上的任一有限区间内满足Dirichlet条件，并且在\( (-\infty ,+\infty) \)上绝对可积（即积分\( \int _{-\infty }^{+\infty }|f(t)|dt\)收敛)，则有：
\[ \frac {1}{2\pi }\int _{-\infty }^{+\infty }\left [ \int _{-\infty }^{+\infty }f(t)e^{-i\omega t}dt\right ]e^{i\omega t}d\omega =  \begin {cases} f(t), 当t为f(t)的连续点; \\  \frac {f(t+0)+f(t-0)}{2},当t为f(t)的间断点。 \end {cases} \]&lt;/p&gt;

&lt;p&gt;令:&lt;/p&gt;

&lt;p&gt;\[ F(\omega ) = \int _{-\infty }^{+\infty }f(t)e^{-i\omega t}dt \]&lt;/p&gt;

&lt;p&gt;则:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \frac {1}{2\pi }\int _{-\infty }^{+\infty }F(\omega )e^{i\omega t}d\omega \]&lt;/p&gt;

&lt;p&gt;上两式子表明\( F(\omega ) 和 f(t) \)通过指定的积分运算可以相互表示。&lt;/p&gt;

&lt;p&gt;第一个式子称为f(t)的&lt;strong&gt;傅里叶变换&lt;/strong&gt;，记为:&lt;/p&gt;

&lt;p&gt;\[ F(\omega ) = \mathcal {F}[f(t)] \]&lt;/p&gt;

&lt;p&gt;函数为\(F(\omega ) \)称为f(t)的&lt;strong&gt;像函数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;第二个式子称为\(F(\omega ) \)的&lt;strong&gt;逆傅里叶变换&lt;/strong&gt;，记为:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \mathcal {F}^{-1}[ F(\omega ) ] \]&lt;/p&gt;

&lt;p&gt;函数f(t)称为为\(F(\omega ) \)的&lt;strong&gt;像原函数&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;傅里叶变换的性质&lt;/h3&gt;

&lt;h4&gt;线性性质&lt;/h4&gt;

&lt;p&gt;设：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( \mathcal {F}[f_{1}(t)] = F_{1}(\omega )\)&lt;/li&gt;
&lt;li&gt;\( \mathcal {F}[f_{2}(t)] = F_{2}(\omega )\)&lt;/li&gt;
&lt;li&gt;\( \alpha \beta \)为常数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;则:&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[\alpha f_{1}(t) + \beta f_{2}(t)] = \alpha F_{1}(\omega ) + \beta F_{2}(\omega ) \]&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}^{-1}[\alpha F_{1}(\omega ) + \beta F_{2}(\omega )] = \alpha f_{1}(t) + \beta f_{2}(t) \]&lt;/p&gt;

&lt;h4&gt;位移性质&lt;/h4&gt;

&lt;p&gt;设\( \mathcal {F}[f(t)] = F(\omega )\)，\( f(t) = \mathcal {F}^{-1}[ F(\omega ) ] \)，则:&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[f(t\pm t_{0})] = e^{\pm i\omega t_{0}}F(\omega )\]&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}^{-1}[F(\omega )\mp F_{0}(\omega )] = e^{\pm i\omega _{0}t}f(t) \]&lt;/p&gt;

&lt;p&gt;其中\( t_{0},\omega _{0} \)为常数。&lt;/p&gt;

&lt;h4&gt;微分性质&lt;/h4&gt;

&lt;p&gt;若f(t)在\( (-\infty ,+\infty) \)内连续或只有有限个可去间断点，且：&lt;/p&gt;

&lt;p&gt;\[ \lim _{|t|\to +\infty }f(t) = 0 \]&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[f(t)] = F(\omega )\]&lt;/p&gt;

&lt;p&gt;则：&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[f&amp;#39;(t)] = i\omega F(\omega )\]&lt;/p&gt;

&lt;h4&gt;像函数的微分性质&lt;/h4&gt;

&lt;p&gt;设\( \mathcal {F}[f(t)] = F(\omega )\)，则:&lt;/p&gt;

&lt;p&gt;\[ \frac {d}{d\omega }F(\omega ) = -i\mathcal {F}[tf(t)] \]&lt;/p&gt;

&lt;h4&gt;积分性质&lt;/h4&gt;

&lt;p&gt;设\( g(t) = \int _{-\infty }^{t}f(t)dt\)，若：&lt;/p&gt;

&lt;p&gt;\[ \lim _{t\to +\infty }g(t) = 0 \]&lt;/p&gt;

&lt;p&gt;则:&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[g(t)]=\frac {1}{i\omega }\mathcal {F}[f(t)] \]&lt;/p&gt;

&lt;h4&gt;对称性质&lt;/h4&gt;

&lt;p&gt;若\( F(\omega ) = \mathcal {F}[f(t)] \)，则：&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[F(t)] = 2\pi f(-\omega ) \]&lt;/p&gt;

&lt;h4&gt;相似性质&lt;/h4&gt;

&lt;p&gt;设\( F(\omega ) = \mathcal {F}[f(t)] \)，a为非零常数，则：&lt;/p&gt;

&lt;p&gt;\[  \mathcal {F}[f(at)] = \frac {1}{|a|}F(\frac {\omega }{a}) \]&lt;/p&gt;

&lt;h3&gt;离散傅里叶变换 discrete fourier transform&lt;/h3&gt;

&lt;p&gt;wiki:&lt;a href=&quot;https://en.wikibooks.org/wiki/Digital_Signal_Processing/Discrete_Fourier_Transform&quot;&gt;Digital Signal Processing/Discrete Fourier Transform&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;设在时域上有离散的采样点\( f = (f[0],f[1],\cdots ,f[N-1]) \)，对f做离散傅里叶变换(DFT)，可以得到频域上的离散点\( F = (F[0],F[1],\cdots ,F[N-1]) \)，且：&lt;/p&gt;

&lt;p&gt;\[ F[m] =  \sum_{n=0}^{N-1}f[n]e^{-2\pi imn/N}, m = 0,1,\dots ,N-1 \]&lt;/p&gt;

&lt;p&gt;这个就是DFT的标准公式。&lt;/p&gt;

&lt;p&gt;解释一下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;f(t)是原信号(时域)，\( f(n_{0}) \) 到 \( f(n_{N - 1}) \)是所谓的采样点，也就是说f(t)被离散成了这些点；&lt;/li&gt;
&lt;li&gt;F(w)是转换后的频域信号，\( F(m_{0}) \) 到 \( F(m_{N - 1} )\)是频域里均匀分布的N个点；&lt;/li&gt;
&lt;li&gt;那么上面的公式就是指，对于每个m值，都求出这n个采样点f(n)的傅里叶级数，这个级数就是F(m)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要推导出这个这个公式并不容易，其中还要用到卷积的知识。&lt;/p&gt;

&lt;p&gt;先大概地讲一遍：&lt;/p&gt;

&lt;p&gt;给信号函数f(t)设定一个有限的时间范围L：\( 0\leq t\leq L \)；给f(t)的傅里叶转换F(w)设定一个有限的频率范围2B：\( 0\leq w\leq 2B \)。&lt;/p&gt;

&lt;p&gt;这里为什么是2B呢？这需要先认识一下&lt;strong&gt;采样定理&lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem#Introduction&quot;&gt;Nyquist–Shannon sampling theorem&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;香农指出，如果一个信号函数f(t)的频率不高于B赫兹，那么用时间间隔\( \frac {1}{2B} \)秒去采样f(t)而得到的f(t&amp;#39;)，相当于f(t)。&lt;/p&gt;

&lt;p&gt;简单来说，如果要完美地采样一个函数f(t)，采样间隔必须小于或等于\( \frac {1}{2B} \)秒（大于或等于2B赫兹），B是这个f(t)的频域的最大赫兹。&lt;/p&gt;

&lt;p&gt;继续推导。&lt;/p&gt;

&lt;p&gt;既然时域的范围是L，完美的采样频率是2B，那么理论上要采样的点共有这么多个：&lt;/p&gt;

&lt;p&gt;\[ N = \frac {L}{1/2B} = 2BL \]&lt;/p&gt;

&lt;p&gt;时域的采样点横坐标列表如下：&lt;/p&gt;

&lt;p&gt;\[ t_{0} = 0, t_{1} = \frac {1}{2B}, t_{2} = \frac {2}{2B}, \cdots , t_{N-1} = \frac {N-1}{2B} \]&lt;/p&gt;

&lt;p&gt;所以，f(t)的离散版本\( f_{discrete}(t) \)就是这个采样点列表\( f(t_{0}), f(t_{1}),\cdots , f(t_{N-1}) \)。&lt;/p&gt;

&lt;p&gt;接下来轮到&lt;strong&gt;卷积&lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;Convolution&lt;/a&gt;和&lt;strong&gt;狄拉克梳状函数&lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_comb&quot;&gt;Dirac comb&lt;/a&gt;登场。&lt;/p&gt;

&lt;p&gt;(关于卷积和狄拉克梳状函数，请阅读我的其他文章&lt;a href=&quot;http://www.qiujiawei.com/convolution&quot;&gt;理解卷积&lt;/a&gt;，&lt;a href=&quot;http://www.qiujiawei.com/shah-function&quot;&gt;狄拉克梳状函数&lt;/a&gt; )。&lt;/p&gt;

&lt;p&gt;继续讨论。因为上面得到的\( f_{discrete}(t) \)是不连续的，所以不能直接用傅里叶变换把它转换用到频域（标准傅里叶变换是处理连续函数的）。要把不连续信号转成连续信号，就是用卷积，即把离散信号和连续信号‘合并’。&lt;/p&gt;

&lt;p&gt;狄拉克梳状函数：&lt;/p&gt;

&lt;p&gt;\[ III_{T}(t) = \sum _{k=-\infty }^{\infty }\delta (t - kT)\]&lt;/p&gt;

&lt;p&gt;代入我们的离散横坐标\( (t_{0}, t_{1}, \cdots , t_{N-1} \)，则有：&lt;/p&gt;

&lt;p&gt;\[ III_{T=\frac {1}{2B}}(t) = \sum _{n=0 }^{N-1 }\delta (t - t_{n})\]&lt;/p&gt;

&lt;p&gt;定义一个\( f_{discrete}(t) \)，代表f(t)离散化后和shah函数合并:&lt;/p&gt;

&lt;p&gt;\[ f_{discrete}(t)  = \sum _{n=0 }^{N-1 }f(t_{n})\delta (t - t_{n}) \]&lt;/p&gt;

&lt;p&gt;这个式子是连续的(因为t的取值是连续的)。这个式子也叫做&lt;strong&gt;f(t)的采样形式&lt;/strong&gt;(the sampled form of f(t))。它的傅里叶变换是:&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[f_{discrete}(s)] =  \sum _{n=0 }^{N-1 }f(t_{n})\mathcal {F}[\delta (t - t_{n})] = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi ist_{n} } \]&lt;/p&gt;

&lt;p&gt;注意，这个傅里叶变换也是连续的。&lt;/p&gt;

&lt;p&gt;上面是时域到频域的讨论，接下来换个角度：想一下如何在频域中对连续的频域信号做采样，并转换到时域。也即&lt;strong&gt;离散的逆傅里叶变换&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在频域中做采样，那么就是做离散化，&lt;strong&gt;频率间隔&lt;/strong&gt;应该是多少(赫兹)？频率公式是\(f =  \frac {1}{T} \)，f的单位是赫兹，赫兹是指&lt;strong&gt;1秒内震动次数&lt;/strong&gt;，震动次数要看信号的周期T。如果把t的范围L当做周期的话，1除以L就是指\( \frac {1}{L} \)赫兹，注意，&lt;strong&gt;这是频率的下限&lt;/strong&gt;，频率的上限是前面已经给出的2B，而我们要做的是在频率这条横轴上做采样，即从频率=0(赫兹)开始，间隔=1/L(赫兹)，到频率=2B(赫兹)结束，对F(s)进行采样。&lt;/p&gt;

&lt;p&gt;总共的频域采样点有这么多个:&lt;/p&gt;

&lt;p&gt;\[ \frac {2B}{\frac {1}{L}} = 2BL = N \]&lt;/p&gt;

&lt;p&gt;对比上面的时域采样，频域采样也有同样数目的采样点**。&lt;/p&gt;

&lt;p&gt;频域的采样点横坐标列表如下：&lt;/p&gt;

&lt;p&gt;\[ s_{0} = 0, s_{1} = \frac {1}{L}, s_{2} = \frac {2}{L}, \cdots , s_{N-1} = \frac {N-1}{L} \]&lt;/p&gt;

&lt;p&gt;有了采样点，就可以做采样了。但是是对什么东西做采样？结果有点反直觉，我们是对刚才推导出来的\( \mathcal {F}[f_{discrete}(s)] \)做采样，而不是\( \mathcal {F}[f(s)] \)。&lt;/p&gt;

&lt;p&gt;设\( F(s) \mathcal {F}[f_{discrete}(s)] \)，则F(s)的离散版本是:&lt;/p&gt;

&lt;p&gt;\[ F(s_{0}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{0}t_{n} }, F(s_{1}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{1}t_{n} }, \cdots ,F(s_{N-1}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{N-1}t_{n} } \]&lt;/p&gt;

&lt;p&gt;将这串东西再简化下:&lt;/p&gt;

&lt;p&gt;\[ F(s_{m}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{m}t_{n} } \]&lt;/p&gt;

&lt;p&gt;于是我们有了一道从离散f(t)到离散F(s)的公式！&lt;/p&gt;

&lt;p&gt;好像和前面给出的标准形式不一样？没事，还可以再变一变。&lt;/p&gt;

&lt;p&gt;由:&lt;/p&gt;

&lt;p&gt;\[ t_{n} = \frac {n}{2B} \]
\[ s_{m} = \frac {m}{L} \]&lt;/p&gt;

&lt;p&gt;有:&lt;/p&gt;

&lt;p&gt;\[ F(s_{m}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{m}t_{n} } \]
\[ = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi i\frac {m}{L}\frac {n}{2B} } \]
\[ = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi imn/2BL } \]
\[ = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi imn/N } \]&lt;/p&gt;

&lt;h3&gt;傅里叶变换的应用&lt;/h3&gt;

&lt;p&gt;(如果理解了上面的DFT，基本不需要看这一节)&lt;/p&gt;

&lt;h4&gt;采样和重建 Sampling and Reconstruction&lt;/h4&gt;

&lt;p&gt;采样和重建这两个字花了我不少功夫去理解。其实并不复杂，举一个例子吧。&lt;/p&gt;

&lt;p&gt;假设现在有一个你不太喜欢的信号函数f(t)，可以想象成一个充满毛刺的、扭曲的正弦波形曲线(理论上不必须是波形)。你觉得它太丑了，想给它整容，变成你喜欢的模样。那么，就可以这样子做：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;采样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在横轴上挑选一些你觉得不错的坐标t，代入f(t)，这样就得到了一个坐标集合\( (t_{i},f(t_{i}))(i=[0,n]) \)。
这个过程叫做采样，这些坐标对样本，对应的t坐标叫做采样点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重建&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过采样后，原来的连续的f(t)变成了离散的\( f(t_{i})(i=[0,n]) \)(continuous to descrete)。对于这个\(f(t_{i})\)，我们可以根据这些坐标，重新构建一条新的曲线，也就是说，整出一条新的曲线，使得这条新曲线会通过所有的采样坐标点。这个过程叫做重建。&lt;/p&gt;

&lt;p&gt;重点来了:&lt;strong&gt;采样和重建是通过傅里叶变换完成的&lt;/strong&gt;。这意味着什么？首先要记住，傅里叶变换，可以把时域的函数变成一个等价的频域的函数。我们还是按前面的做法，在时域上完成‘采样’工作，但是采样点要足够多，并且均匀。采样后，用傅里叶变换把\(f(t_{i})\)变成\(F(w_{i})\)，然后就可以&lt;strong&gt;在频域上完成真正的采样(或叫过滤)&lt;/strong&gt;。
在频域上采样，往往比在时域上采样要简单得多，比如说，你只对中高频信号感兴趣，那么就可以只采样那些频率高的点。对F(w_{i})采样后，得到F&amp;#39;(w_{i})，再通过&lt;strong&gt;逆傅里叶变换&lt;/strong&gt;，就可以得到一个新的f&amp;#39;(t)。整容完毕。&lt;/p&gt;

&lt;p&gt;哦，还有一个细节要注意，这个采样和重建用的傅里叶变换是&lt;strong&gt;离散傅里叶变换&lt;/strong&gt;。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/fourier-equation/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/fourier-equation/</guid>
      </item>
    
      <item>
        <title>复数和三角函数</title>
        <description>&lt;h2&gt;欧拉公式&lt;/h2&gt;

&lt;p&gt;复数和三角函数有密切的联系，因为大神欧拉发现了这样的公式：&lt;/p&gt;

&lt;p&gt;\[ e^{ix} = \cos x + i\sin x\]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图片来自
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler%27s_formula&quot;&gt;wikipedia-Euler-formula&lt;/a&gt;)&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;怎么推导出欧拉公式?&lt;/h2&gt;

&lt;p&gt;设z是复数平面的一个复数，且用三角函数来表示它的实数和虚数：&lt;/p&gt;

&lt;p&gt;\[ z = \cos \theta + i\sin \theta \]&lt;/p&gt;

&lt;p&gt;两边算微分:&lt;/p&gt;

&lt;p&gt;\[ dz = (-\sin \theta + i\cos \theta)d\theta \]&lt;/p&gt;

&lt;p&gt;提取i:&lt;/p&gt;

&lt;p&gt;\[ dz = i( \cos \theta + i\sin \theta )d\theta \]&lt;/p&gt;

&lt;p&gt;注意看，括号内的东西，不就是z嘛，所以有:&lt;/p&gt;

&lt;p&gt;\[ dz = izd\theta \]&lt;/p&gt;

&lt;p&gt;换个写法:&lt;/p&gt;

&lt;p&gt;\[ \frac {1}{z}dz = id\theta \]&lt;/p&gt;

&lt;p&gt;两边求积分:&lt;/p&gt;

&lt;p&gt;\[ \int_{}^{} \frac {1}{z}dz = \int_{}^{} id\theta \]&lt;/p&gt;

&lt;p&gt;\[ \ln z = i\theta \]&lt;/p&gt;

&lt;p&gt;注意，右边的积分，是把i当做常数看待的，所以i直接被提取出来。&lt;/p&gt;

&lt;p&gt;再写出这个式子的指数形式:&lt;/p&gt;

&lt;p&gt;\[ e^{\ln z} = e^{i\theta } \]&lt;/p&gt;

&lt;p&gt;\[ z = e^{i\theta } = \cos \theta + i\sin \theta \]&lt;/p&gt;

&lt;p&gt;推导完毕。&lt;/p&gt;

&lt;h2&gt;欧拉公式的延伸特性&lt;/h2&gt;

&lt;p&gt;由:&lt;/p&gt;

&lt;p&gt;\[ e^{ix} = \cos x + i\sin x\]&lt;/p&gt;

&lt;p&gt;得到:&lt;/p&gt;

&lt;p&gt;\[ e^{-ix} = \cos (-x) + i\sin (-x) = \cos x - i\sin x \]&lt;/p&gt;

&lt;p&gt;上面两个等式相加:&lt;/p&gt;

&lt;p&gt;\[ e^{ix} + e^{-ix} = (\cos x + i\sin x) + (\cos x - i\sin x) \]&lt;/p&gt;

&lt;p&gt;\[ = 2\cos x \]&lt;/p&gt;

&lt;p&gt;所以有:&lt;/p&gt;

&lt;p&gt;\[ \cos x = \frac {e^{ix} + e^{-ix}}{2} \]&lt;/p&gt;

&lt;p&gt;同样的，把上面2个等式相减:&lt;/p&gt;

&lt;p&gt;\[ e^{ix} - e^{-ix} = (\cos x + i\sin x) - (\cos x - i\sin x) \]&lt;/p&gt;

&lt;p&gt;\[ = 2i\sin x \]&lt;/p&gt;

&lt;p&gt;所以有:&lt;/p&gt;

&lt;p&gt;\[ \sin x = \frac {e^{ix} - e^{-ix}}{2i} \]&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/complex-1/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/complex-1/</guid>
      </item>
    
      <item>
        <title>PBRT《章3》阅读笔记</title>
        <description>&lt;p&gt;第三章介绍各种特殊几何体。&lt;/p&gt;

&lt;h3&gt;Ray与Sphere的相交判断&lt;/h3&gt;
</description>
        <pubDate>Mon, 05 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/pbrt-chapter3/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/pbrt-chapter3/</guid>
      </item>
    
      <item>
        <title>线性代数之TRS分解</title>
        <description>&lt;h3&gt;pbrt的TRS分解&lt;/h3&gt;

&lt;p&gt;设矩阵A，假设A可以分解成T、R、S，则有A=TRS，设A:&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} A_{11}&amp;amp;A_{12}&amp;amp;A_{13}&amp;amp;A_{14}\\ A_{21}&amp;amp;A_{22}&amp;amp;A_{23}&amp;amp;A_{24}\\ A_{31}&amp;amp;A_{32}&amp;amp;A_{33}&amp;amp;A_{34}\\ A_{41}&amp;amp;A_{42}&amp;amp;A_{43}&amp;amp;A_{44}\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;再设T、R、S分别为：&lt;/p&gt;

&lt;p&gt;\[ T =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;t_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;t_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;t_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;\[ R =  \left[ \begin{matrix} r_{11}&amp;amp;r_{12}&amp;amp;r_{13}&amp;amp;0\\ r_{21}&amp;amp;r_{22}&amp;amp;r_{23}&amp;amp;0\\ r_{31}&amp;amp;r_{32}&amp;amp;r_{33}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;\[ S =  \left[ \begin{matrix} s_{x}&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;s_{y}&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;t_{y}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;所以TRS等于：&lt;/p&gt;

&lt;p&gt;\[ A = TRS =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;t_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;t_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;t_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} r_{11}&amp;amp;r_{12}&amp;amp;r_{13}&amp;amp;0\\ r_{21}&amp;amp;r_{22}&amp;amp;r_{23}&amp;amp;0\\ r_{31}&amp;amp;r_{32}&amp;amp;r_{33}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} s_{x}&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;s_{y}&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;t_{y}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]\]
\[ =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;t_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;t_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;t_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} r_{11}s_{x}&amp;amp;r_{12}s_{y}&amp;amp;r_{13}s_{z}&amp;amp;0\\ r_{21}s_{x}&amp;amp;r_{22}s_{y}&amp;amp;r_{23}s_{z}&amp;amp;0\\ r_{31}s_{x}&amp;amp;r_{32}s_{y}&amp;amp;r_{33}s_{z}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]\]
\[  =  \left[ \begin{matrix} r_{11}s_{x}&amp;amp;r_{12}s_{y}&amp;amp;r_{13}s_{z}&amp;amp;t_{x}\\ r_{21}s_{x}&amp;amp;r_{22}s_{y}&amp;amp;r_{23}s_{z}&amp;amp;t_{y}\\ r_{31}s_{x}&amp;amp;r_{32}s_{y}&amp;amp;r_{33}s_{z}&amp;amp;t_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;从TRS矩阵可以看出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A矩阵的最后一行为[0,0,0,1]&lt;/li&gt;
&lt;li&gt;A的最后一列是T的最后一列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以T是最好求的：&lt;/p&gt;

&lt;p&gt;\[ T =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;A_{14}\\ 0&amp;amp;1&amp;amp;0&amp;amp;A_{24}\\ 0&amp;amp;0&amp;amp;1&amp;amp;A_{34}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;同时，我们也可以快速知道RS矩阵：&lt;/p&gt;

&lt;p&gt;\[ RS =  \left[ \begin{matrix} A_{11}&amp;amp;A_{12}&amp;amp;A_{13}&amp;amp;0\\ A_{21}&amp;amp;A_{22}&amp;amp;A_{23}&amp;amp;0\\ A_{31}&amp;amp;A_{32}&amp;amp;A_{33}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;问题就简化成：如果让RS分解成R和S。&lt;/p&gt;

&lt;p&gt;pbrt的解法比较神奇，称为polar decomposition(极分解?)。&lt;/p&gt;

&lt;p&gt;(这算法似乎是用来求矩阵的平方根的，但是为什么可以用在这里，我没搞明白，也没找到证明过程。有知道的朋友麻烦告知一下哈)&lt;/p&gt;

&lt;p&gt;pbrt给了一个公式是：&lt;/p&gt;

&lt;p&gt;\[ M_{i+1} = \frac {1}{2}(M_{i} + (M_{i}^{T})^{-1}) \]&lt;/p&gt;

&lt;p&gt;把M = RS代入这个公式，迭代多次后，M的值会收敛，得到的最终的M就是R。&lt;/p&gt;

&lt;p&gt;然后S就等于\(S = (RS)R^{-1} \)。&lt;/p&gt;

&lt;p&gt;因为R是一个转换矩阵，意味着经过S转换后的点，还是处于原来的空间，只是坐标变换了。那么R必然是一个正交矩阵(列向量之间线性无关)，所以有\(R^{T}=R^{-1}\)。
将这个式子代入上面的公式，可以发现:&lt;/p&gt;

&lt;p&gt;\[ R_{i+1} = \frac {1}{2}(R_{i} + (R_{i}^{T})^{-1}) \]
\[ = \frac {1}{2}(R_{i} + (R_{i}^{-1})^{-1}) \]
\[ = \frac {1}{2}(R_{i} + R_{i}) \]
\[ = \frac {1}{2}2R_{i}  = R_{i} \]&lt;/p&gt;

&lt;p&gt;即是说，对于一个纯粹的旋转矩阵R，将R和R的转置的逆矩阵求平均，依然还是R。&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-8/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-8/</guid>
      </item>
    
      <item>
        <title>线性代数之各种各样的矩阵</title>
        <description>&lt;p&gt;矩阵家族成员非常多，本文主要记录了我遇到过的矩阵(前面的文章所提到的矩阵，在这里就不重复列举了)。以后见识了新的矩阵时，会继续扩充本文。&lt;/p&gt;

&lt;p&gt;(以下知识均查阅了wikipedia。单词的中文翻译查的是有道词典。)&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;共轭(转置)矩阵 Conjugate Transpose Matrix&lt;/h2&gt;

&lt;p&gt;公式上的定义：&lt;/p&gt;

&lt;p&gt;\[ A^{*} = (\overline {A})^{T} \]&lt;/p&gt;

&lt;p&gt;A上面的横线表示对矩阵中的元素的复数部分取反(类似复数的上横线)。&lt;/p&gt;

&lt;p&gt;回想下共轭复数的定义，可以发现，矩阵的共轭，还需要再转置一下，很很大的一个不同点。&lt;/p&gt;

&lt;p&gt;共轭矩阵还有其他表达形式：&lt;/p&gt;

&lt;p&gt;\[ A^{\dagger } = A^{*} = A^{H} \]&lt;/p&gt;

&lt;h2&gt;厄米特矩阵 Hermitian matrix&lt;/h2&gt;

&lt;p&gt;厄米特矩阵也称为self-adjoint matrix，中文是：自伴矩阵、自共轭矩阵、自伴随矩阵。&lt;/p&gt;

&lt;p&gt;厄米特矩阵必须满足下面的性质:&lt;/p&gt;

&lt;p&gt;\[ A = A^{*} \]&lt;/p&gt;

&lt;p&gt;即，A等于A的共轭矩阵时，A是一个厄米特矩阵。&lt;/p&gt;

&lt;h2&gt;单式矩阵 Unitary matrix&lt;/h2&gt;

&lt;p&gt;看名字有点像单位矩阵(Unit matrix)，但是公式上的定义是这样子的：&lt;/p&gt;

&lt;p&gt;\[ U^{*}U = I \]&lt;/p&gt;

&lt;p&gt;即：如果矩阵的共轭乘以矩阵自身等于单位矩阵，那么它是一个单式矩阵。&lt;/p&gt;

&lt;h2&gt;正定矩阵 Positive Definite Matrix&lt;/h2&gt;

&lt;p&gt;定义比较复杂，我翻译下wikipedia的定义吧：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个对称的n阶实数矩阵M，设元素不全为0的列向量为z，当所有这样的z满足\( z^{T}Mz &amp;gt; 0\)时，M是正定矩阵。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据定义，可以知道单位矩阵I是正定的；&lt;/p&gt;

&lt;p&gt;贴上wiki的例子来帮助理解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;设M的z为(a,b,c)，则有：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个式子的结果显然是非负的，且当a=b=c=0时，这个式子才等于0，所以满足正定矩阵的条件。&lt;/p&gt;

&lt;h2&gt;半正定矩阵 Positive Semi-Definite&lt;/h2&gt;

&lt;p&gt;参考正定矩阵，半正定矩阵的定义公式是:\( z^{T}Mz &amp;gt;= 0\)。&lt;/p&gt;

&lt;h2&gt;负定矩阵 Negative Definite Matrix&lt;/h2&gt;

&lt;p&gt;参考正定矩阵，负定矩阵的定义公式是:\( z^{T}Mz &amp;lt; 0\)。&lt;/p&gt;

&lt;h2&gt;半负定矩阵 Negative Semi-Definite Matrix&lt;/h2&gt;

&lt;p&gt;参考正定矩阵，负定矩阵的定义公式是:\( z^{T}Mz &amp;lt;= 0\)。&lt;/p&gt;

&lt;h2&gt;厄米特矩阵的正定矩阵&lt;/h2&gt;

&lt;p&gt;参考正定矩阵，厄米特矩阵的正定矩阵的定义公式是:\( z^{*}Mz &amp;gt; 0\)，注意，算出来的值必须是实数，不能是复数。&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-7/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-7/</guid>
      </item>
    
      <item>
        <title>Understanding Quaternions 中文翻译《理解四元数》</title>
        <description>&lt;p&gt;原文地址:&lt;a href=&quot;http://www.3dgep.com/understanding-quaternions/&quot;&gt;http://www.3dgep.com/understanding-quaternions/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;在这篇文章中我会尝试用简单的方式去解释四元数的概念，即用可视化的方式解释四元数以及几种对四元数的操作。我将把矩阵、欧拉角和四元数放在一起比较，并解释什么时候该用四元数、什么时候该用欧拉角或矩阵。&lt;/p&gt;

&lt;h3&gt;内容结构&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;复数

&lt;ul&gt;
&lt;li&gt;复数的加减&lt;/li&gt;
&lt;li&gt;复数的系数缩放&lt;/li&gt;
&lt;li&gt;复数的积&lt;/li&gt;
&lt;li&gt;复数的平方&lt;/li&gt;
&lt;li&gt;共轭复数&lt;/li&gt;
&lt;li&gt;复数的绝对值&lt;/li&gt;
&lt;li&gt;两复数的商&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;i的幂&lt;/li&gt;
&lt;li&gt;复数平面

&lt;ul&gt;
&lt;li&gt;旋转数（Rotors)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;四元数

&lt;ul&gt;
&lt;li&gt;作为有序数的四元数&lt;/li&gt;
&lt;li&gt;四元数的加减&lt;/li&gt;
&lt;li&gt;四元数的积&lt;/li&gt;
&lt;li&gt;实四元数&lt;/li&gt;
&lt;li&gt;四元数的系数缩放&lt;/li&gt;
&lt;li&gt;纯四元数&lt;/li&gt;
&lt;li&gt;四元数的加法形式&lt;/li&gt;
&lt;li&gt;单位四元数&lt;/li&gt;
&lt;li&gt;四元数的二元形式&lt;/li&gt;
&lt;li&gt;共轭四元数&lt;/li&gt;
&lt;li&gt;四元数范数&lt;/li&gt;
&lt;li&gt;四元数规范化&lt;/li&gt;
&lt;li&gt;四元数的逆&lt;/li&gt;
&lt;li&gt;四元数的点乘&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;旋转&lt;/li&gt;
&lt;li&gt;四元数的插值

&lt;ul&gt;
&lt;li&gt;SLERP

&lt;ul&gt;
&lt;li&gt;四元数的差&lt;/li&gt;
&lt;li&gt;四元数的指数运算&lt;/li&gt;
&lt;li&gt;2个四元数的分数差&lt;/li&gt;
&lt;li&gt;注意事项&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SQUARD&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;结论&lt;/li&gt;
&lt;li&gt;下载Demo&lt;/li&gt;
&lt;li&gt;引用&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;在计算机图形学中，我们使用转换矩阵来表示空间中的一个位置以及朝向。一个转换矩阵还可以表示对一个目标的缩放(scale)或错切(shear)等。   我们可以把转换矩阵想象成一个空间，当你用这个矩阵乘以向量、点（甚至矩阵）后， 你就把向量、点、矩阵转换进这个空间了。&lt;/p&gt;

&lt;p&gt;在这篇文章中，我不会讨论转换矩阵的细节。你可以查看我前面的文章，文章中描述了转换矩阵的细节。&lt;/p&gt;

&lt;p&gt;在这篇文章中，我想要讨论一个可替代的方案，即用四元数来描述空间里的物体的朝向。&lt;/p&gt;

&lt;p&gt;四元数的概念是由爱尔兰数学家Sir William Rowan Hamilton发明的（1843年，都柏林）。Hamilton当时正和他的妻子前往爱尔兰皇家研究院，当他从Brougham桥通过皇家运河时，他领悟到了一个激动人心的东西，并立刻把它刻在桥的一个石头上：&lt;/p&gt;

&lt;p&gt;\[ i^{2} = j^{2} = k^{2} = ijk = -1 \]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/2.jpg&quot; alt=&quot;2.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;William Rowan Hamilton Plaque on Broome Bridge on the Royal Canal commemorating his discovery of the fundamental formula for quaternion multiplication.&lt;/p&gt;

&lt;h3&gt;复数&lt;/h3&gt;

&lt;p&gt;在我们能够完全理解四元数之前，我们必须先知道四元数是怎么来的。四元数的根源其实是&lt;strong&gt;复数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;除了知名的数集（自然数、整数、实数、分数）之外，复数系统引入了一个新的数集——虚数。虚数的发明是为了解决一些特定的无解的方程，例如：
\[ x^{2} + 1 = 0 \]
要解决这个等式，必须让\(x^{2} = -1 \)，这当然是不行的，因为任意实数的平方都是非负数。&lt;/p&gt;

&lt;p&gt;一般而言，数学家是不能忍受一个等式是无解的。于是，一个新的术语被发明了，它就是虚数，一个可以解决上面这个等式的数。&lt;/p&gt;

&lt;p&gt;虚数有这样的形式：&lt;/p&gt;

&lt;p&gt;\[ i^{2} = -1 \]&lt;/p&gt;

&lt;p&gt;不要为这个术语较真，因为逻辑上这个数是不存在的。只要知道i是一个平方等于-1的东西即可。&lt;/p&gt;

&lt;p&gt;虚数的集合可以用\( \mathbb{I} \)来表示。&lt;/p&gt;

&lt;p&gt;复数的集合\( \mathbb{C} \)是一个实数和一个虚数的和，形式如下：&lt;/p&gt;

&lt;p&gt;\[ z = a + bi \ a,b\in R,\ i^{2} = -1 \]&lt;/p&gt;

&lt;p&gt;可以认为所有实数都是b=0的复数、所有虚数都是a=0的复数。&lt;/p&gt;

&lt;h3&gt;复数的加减&lt;/h3&gt;

&lt;p&gt;加法：&lt;/p&gt;

&lt;p&gt;\[ (a_{1} + b_{1}i) + (a_{2} + b_{2}i) = (a_{1} + a_{2}) + (b_{1} + b_{2})i \]&lt;/p&gt;

&lt;p&gt;减法：&lt;/p&gt;

&lt;p&gt;\[ (a_{1} + b_{1}i) - (a_{2} + b_{2}i) = (a_{1} - a_{2}) + (b_{1} - b_{2})i \]&lt;/p&gt;

&lt;h3&gt;复数的系数缩放&lt;/h3&gt;

&lt;p&gt;\[ \lambda (a_{1} + b_{1}i) = \lambda  a_{1} + \lambda b_{1}i \]&lt;/p&gt;

&lt;h3&gt;复数的积&lt;/h3&gt;

&lt;p&gt;\[  z_{1} = (a_{1} + b_{1}i) \]
\[  z_{2} = (a_{2} + b_{2}i) \]
\[  z_{1}z_{2} = (a_{1} + b_{1}i)(a_{2} + b_{2}i) = a_{1}a_{2} + a_{1}b_{2}i + b_{1}a_{2}i+b_{1}b_{2}i^{2} \]
\[ z_{1}z_{2} = (a_{1}a_{2} - b_{1}b_{2}) + (a_{1}b_{2} + b_{1}a_{2})i \]&lt;/p&gt;

&lt;h3&gt;复数的平方&lt;/h3&gt;

&lt;p&gt;\[ z = (a + bi) \]
\[ z^{2} = (a + bi)(a + bi) \]
\[ z^{2} = (a^{2} - b^{2}) + 2abi \]&lt;/p&gt;

&lt;h3&gt;共轭复数&lt;/h3&gt;

&lt;p&gt;复数的共轭就是指把复数的虚数部分变成负的。共轭复数的符号是\(\bar z\)或\(z^{*}\)。&lt;/p&gt;

&lt;p&gt;\[ z = (a + bi) \]&lt;/p&gt;

&lt;p&gt;\[ z^{*} = (a - bi) \]&lt;/p&gt;

&lt;p&gt;复数和它的共轭复数的乘积是：&lt;/p&gt;

&lt;p&gt;\[ zz^{*} = (a + bi)(a - bi) = a^{2}-abi+abi+b^{2} = a^{2}+b^{2} \]&lt;/p&gt;

&lt;h3&gt;复数的绝对值&lt;/h3&gt;

&lt;p&gt;我们使用共轭复数来计算复数的绝对值：&lt;/p&gt;

&lt;p&gt;\[ z = (a + bi) \]&lt;/p&gt;

&lt;p&gt;\[ |z| = \sqrt {zz^{*}} = \sqrt {(a + bi)(a - bi)} = \sqrt {a^{2} + b^{2} } \]&lt;/p&gt;

&lt;h3&gt;两复数的商&lt;/h3&gt;

&lt;p&gt;\[  z_{1} = (a_{1} + b_{1}i) \]
\[  z_{2} = (a_{2} + b_{2}i) \]
\[ \frac {z_{1}}{z_{2}} = \frac {a_{1} + b_{1}i}{a_{2} + b_{2}i} = \frac {(a_{1} + b_{1}i)(a_{2} - b_{2}i)}{(a_{2} + b_{2}i)(a_{2} - b_{2}i)} \]
\[  = \frac {a_{1}a_{2}-a_{1}b_{2}i+b_{1}a_{2}i-b_{1}b_{2}i^{2} }{a_{2}^{2} + b_{2}^{2}} \]&lt;/p&gt;

&lt;p&gt;\[ = \frac {a_{1}a_{2} + b_{1}b_{2} }{a_{2}^{2} + b_{2}^{2}}   + \frac {b_{1}a_{2} - a_{1}b_{2} }{a_{2}^{2} + b_{2}^{2}}i \]&lt;/p&gt;

&lt;h2&gt;i的幂&lt;/h2&gt;

&lt;p&gt;如果i的平方等于-1，那么i的n次幂也应该存在：&lt;/p&gt;

&lt;p&gt;\[ i^{0} = 1 \]
\[ i^{1} = i \]
\[ i^{2} = -1 \]
\[ i^{3} = ii^{2} = -i \]
\[ i^{4} = i^{2}i^{2} = 1 \]
\[ i^{5} = ii^{4} = i \]
\[ i^{6} = ii^{5} = i^{2} = -1 \]&lt;/p&gt;

&lt;p&gt;如果按照这个顺序写下去，会出现这样一个模式：
(1,i,-1,-i,1,...)&lt;/p&gt;

&lt;p&gt;一个类似的模式也出现在递增的负数幂：&lt;/p&gt;

&lt;p&gt;\[ i^{0} = 1 \]
\[ i^{-1} = -i \]
\[ i^{-2} = -1 \]
\[ i^{-3} = i \]
\[ i^{-4} = 1 \]
\[ i^{-5} = -i \]
\[ i^{-6} = -1 \]&lt;/p&gt;

&lt;p&gt;你可能已经在数学里头见过类似的模式，但是是以（x,y,-x,-y,x,...)的形式，这是在2D笛卡尔平面对一个点逆时针旋转90度时生成的；（x,-y,-x,y,x,...)则是在2D笛卡尔平面对一个点顺时针旋转90度时生成的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;复数平面&lt;/h2&gt;

&lt;p&gt;我们也能够把复数映射到一个2D网格平面——复数平面，只需要把实数映射到横轴、虚数映射到纵轴。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;如前面的序列所示，我们可以认为，对一个复数乘以i，这个复数就在复数平面上旋转了90度。&lt;/p&gt;

&lt;p&gt;让我们看看这是不是真的。我们随机地在复数平面上取一个点：&lt;/p&gt;

&lt;p&gt;\[ p = 2 + i \]&lt;/p&gt;

&lt;p&gt;p乘以i后得到q：
\[ q = pi = (2+i)i = 2i+i^{2} = -1+2i \]&lt;/p&gt;

&lt;p&gt;q乘以i后得到r：
\[ r = qi = (-1+2i)i = -i+2i^{2} = -2-i \]&lt;/p&gt;

&lt;p&gt;r乘以i后得到s：
\[ s = ri = (-2-i)i = -2i-i^{2} = 1-2i \]&lt;/p&gt;

&lt;p&gt;s乘以i后得到t：
\[ t = si = (1-2i)i = i-2i^{2} = 2+i \]&lt;/p&gt;

&lt;p&gt;t刚好是开始的p。如果我们把这些复数放到复数平面上，就得到下面的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们也可以按顺时针方向旋转，只需要把上面的乘数i改成-i。&lt;/p&gt;

&lt;h3&gt;旋转数（Rotors)&lt;/h3&gt;

&lt;p&gt;我们也可以在复数平面上进行任意角度的旋转，只需要定义下面这个复数：
\[q = cos\theta +isin\theta \]&lt;/p&gt;

&lt;p&gt;任意的复数乘以q：&lt;/p&gt;

&lt;p&gt;\[ p = a + bi \]
\[ q = cos\theta + isin\theta \]
\[ pq = (a + bi)(cos\theta + isin\theta ) \]
\[ a&amp;#39; + b&amp;#39;i = acos\theta -bsin\theta + (asin\theta +bcos\theta )i \] &lt;/p&gt;

&lt;p&gt;也可以写成矩阵的形式：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} a&amp;#39;&amp;amp;-b&amp;#39;\\ b&amp;#39;&amp;amp;a&amp;#39;\\ \end{matrix} \right] =  \left[ \begin{matrix} cos\theta &amp;amp;-sin\theta \\ sin\theta &amp;amp;cos\theta \\ \end{matrix} \right] \left[ \begin{matrix} a&amp;amp;-b\\ b&amp;amp;a\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;这也是一个在复数平面绕原点逆时针旋转任意点的方法。（译注：这句话应该是在说旋转矩阵）&lt;/p&gt;

&lt;h2&gt;四元数&lt;/h2&gt;

&lt;p&gt;了解了复数系统和复数平面后，我们可以额外增加2个虚数到我们的复数系统，从而把这些概念拓展到3维空间。&lt;/p&gt;

&lt;p&gt;四元数的一般形式：&lt;/p&gt;

&lt;p&gt;\[ q = s + xi + yj + zk \ \ \ s,x,y,z \in \mathbb{R} \]&lt;/p&gt;

&lt;p&gt;上面的公式是根据Hamilton的著名的表达式得到的：&lt;/p&gt;

&lt;p&gt;\[ i^{2} = j^{2} = k^{2} = ijk = -1 \]&lt;/p&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;p&gt;\[ ij = k \ \ \ jk = i \ \ \ ki = j \]
\[ ji = -k \ \ \ kj = -i \ \ \ ik = -j \]&lt;/p&gt;

&lt;p&gt;你可能已经注意到了，i、j、k之间的关系非常像笛卡尔坐标系下单位向量的叉积规则：&lt;/p&gt;

&lt;p&gt;\[ x\times y = z \ \ \ y\times z = x \ \ \ z\times x = y \]
\[ y\times x = -z \ \ \ z\times y = -x \ \ \ x\times z = -y \]&lt;/p&gt;

&lt;p&gt;Hamilton自己也发现i、j、k虚数可以被用来表达3个笛卡尔坐标系单位向量i、j、k，并且仍然保持有虚数的性质，也即\( i^{2} = j^{2} = k^{2} = -1 \)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/6.png&quot; alt=&quot;6.png&quot;&gt;
（ij, jk, ki这几个性质的可视化）&lt;/p&gt;

&lt;p&gt;上图展示了如何用i、j、k作为笛卡尔坐标系的单位向量。&lt;/p&gt;

&lt;h3&gt;作为有序数的四元数&lt;/h3&gt;

&lt;p&gt;我们可以用有序对的形式，来表示四元数：
\[ [s,v] \ \ \ s\in \mathbb{R},v\in \mathbb{R^{3}} \]&lt;/p&gt;

&lt;p&gt;其中的v，也可以用它各自独立的3个分量表示：&lt;/p&gt;

&lt;p&gt;\[ q = [s,xi + yj + zk] \ \ \ s,x,y,z\in \mathbb{R} \]&lt;/p&gt;

&lt;p&gt;使用这种表示法，我们可以更容易地展示四元数和复数之间的相似性。&lt;/p&gt;

&lt;h3&gt;四元数的加减&lt;/h3&gt;

&lt;p&gt;和复数类似，四元数也可以被加减：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [s_{a},a] \]
\[ q_{b} = [s_{b},b] \]
\[ q_{a} + q_{b} = [s_{a} + s_{b},a + b] \]
\[ q_{a} - q_{b} = [s_{a} - s_{b},a - b] \]&lt;/p&gt;

&lt;h3&gt;四元数的积&lt;/h3&gt;

&lt;p&gt;我们也可以表示四元数的乘积：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [s_{a},a][s_{b},b] \]
\[ = (s_{a} + x_{a}i + y_{a}j +z_{a}k)(s_{b} + x_{b}i + y_{b}j +z_{b}k) \]
\[ = (s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}) \]
\[ + (s_{a}x_{b} + s_{b}x_{a} + y_{a}z_{b} - y_{b}z_{a})i \]
\[ + (s_{a}y_{b}+s_{b}y_{a}+z_{a}x_{b}-z_{b}x_{a})j \]
\[ + (s_{a}z_{b}+s_{b}z_{a}+x_{a}y_{b}-x_{b}y_{a})k \]&lt;/p&gt;

&lt;p&gt;可以看到，四元数的乘积依然还是一个四元数。如果我们把虚数i、j、k替换成有序对：&lt;/p&gt;

&lt;p&gt;\[ i = [0,i]\ \ \  j = [0,j]\ \ \  k = [0,k] \]&lt;/p&gt;

&lt;p&gt;以及还有[1,0] = 1，将它们代入前面的表达式，就得到了：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = (s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b})[1,0] \]
\[ + (s_{a}x_{b} + s_{b}x_{a} + y_{a}z_{b} - y_{b}z_{a})[0,i] \]
\[ + (s_{a}y_{b}+s_{b}y_{a}+z_{a}x_{b}-z_{b}x_{a})[0,j] \]
\[ + (s_{a}z_{b}+s_{b}z_{a}+x_{a}y_{b}-x_{b}y_{a})[0,k] \]&lt;/p&gt;

&lt;p&gt;再把这个表达式扩展成多个有序对的和：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [(s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}),0] \]
\[ + [0,(s_{a}x_{b} + s_{b}x_{a} + y_{a}z_{b} - y_{b}z_{a})i] \]
\[ + [0,(s_{a}y_{b}+s_{b}y_{a}+z_{a}x_{b}-z_{b}x_{a})j] \]
\[ + [0,(s_{a}z_{b}+s_{b}z_{a}+x_{a}y_{b}-x_{b}y_{a})k] \]&lt;/p&gt;

&lt;p&gt;如果把后3个四元数相加，并提取公共部分，就可以把等式改写成：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [(s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}),0] \]
\[ + [0,s_{a}(x_{b}i + y_{b}j+z_{b}k) + s_{b}(x_{a}i+y_{a}j+z_{a}k)\]
\[+(y_{a}z_{b}-y_{b}z_{a})i+(z_{a}x_{b}-z_{b}x_{a})j+(x_{a}y_{b}-x_{b}y_{a})k] \]&lt;/p&gt;

&lt;p&gt;这个等式是2个有序对的和。第1个有序对是一个&lt;strong&gt;实&lt;/strong&gt;四元数，第2个是一个&lt;strong&gt;纯&lt;/strong&gt;四元数。这两个四元数也可以合并成一个：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [(s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}), \]
\[ s_{a}(x_{b}i + y_{b}j+z_{b}k) + s_{b}(x_{a}i+y_{a}j+z_{a}k)\]
\[+(y_{a}z_{b}-y_{b}z_{a})i+(z_{a}x_{b}-z_{b}x_{a})j+(x_{a}y_{b}-x_{b}y_{a})k] \]&lt;/p&gt;

&lt;p&gt;如果把下面的表达式代入上面的等式：&lt;/p&gt;

&lt;p&gt;\[ a = x_{a}i + y_{a}j + z_{a}k\]
\[ b = x_{b}i + y_{b}j + z_{b}k\]
\[ a\cdot b = x_{a}x_{b}i^{2}+y_{a}y_{b}j^{2}+z_{a}z_{b}k^{2} \]
\[ a\times b = (y_{a}z_{b}-y_{b}z_{a})i + (z_{a}x_{b} - z_{b}x_{a})j + (x_{a}y_{b} - x_{b}y_{a})k  \]&lt;/p&gt;

&lt;p&gt;（译注：注意，第三条和第四条并不是四元数的点积和叉积，而是向量的点积和叉积）&lt;/p&gt;

&lt;p&gt;我们就得到了：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [s_{a}s_{b} - a\cdot b, s_{a}b+s_{b}a+a\times b] \]&lt;/p&gt;

&lt;p&gt;这就是四元数乘积的一般式。&lt;/p&gt;

&lt;h3&gt;实四元数&lt;/h3&gt;

&lt;p&gt;一个实四元数是一个虚部向量为零向量的四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [s,0] \]&lt;/p&gt;

&lt;p&gt;两个实四元数的乘积是另一个实四元数：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [s_{a},0] \]
\[ q_{b} = [s_{b},0] \]
\[ q_{a}q_{b} = [s_{a},0] [s_{b},0] = [s_{a}s_{b},0]  \]&lt;/p&gt;

&lt;p&gt;这和2个虚部为0的复数的乘积几乎一样：&lt;/p&gt;

&lt;p&gt;\[ z_{1} = a_{1} + 0i \]
\[ z_{2} = a_{2} + 0i \]
\[ z_{1}z_{2} = (a_{1} + 0i)(a_{2} + 0i) = a_{1}a_{2} \] &lt;/p&gt;

&lt;h3&gt;四元数的系数缩放&lt;/h3&gt;

&lt;p&gt;我们也可以用一个系数（实数）去乘四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ \lambda q = \lambda [s,v] = [\lambda s,\lambda v] \]&lt;/p&gt;

&lt;p&gt;我们可以用实四元数与普通四元数的乘积，来确认这个等式是否正确：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ \lambda = [\lambda ,0] \]
\[ \lambda q = [\lambda ,0][s,v] = [\lambda s,\lambda v] \]&lt;/p&gt;

&lt;h3&gt;纯四元数&lt;/h3&gt;

&lt;p&gt;和实四元数相似，Hamilton也定义了纯四元数。纯四元数是s=0的四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [0,v] \]&lt;/p&gt;

&lt;p&gt;也可以写成下面的形式：&lt;/p&gt;

&lt;p&gt;\[ q = xi + yj + zk \]&lt;/p&gt;

&lt;p&gt;然后是2个纯四元数的乘积：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [0,a] \]
\[ q_{b} = [0,b] \]
\[ q_{a}q_{b} = [0,a] [0,b] = [-a\cdot b, a\times b]  \]&lt;/p&gt;

&lt;h3&gt;四元数的加法形式&lt;/h3&gt;

&lt;p&gt;我们可以把四元数写成实四元数和纯四元数的和：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ = [s,0] + [0,v] \]&lt;/p&gt;

&lt;h3&gt;单位四元数&lt;/h3&gt;

&lt;p&gt;给定任意的向量v，我们可以把这个向量写成一个系数和一个单位方向向量的乘积：&lt;/p&gt;

&lt;p&gt;\[ v = \mathbf {v}\hat {v}\ \ \mathbf {v}=|v|,|\hat {v}|=1\]&lt;/p&gt;

&lt;p&gt;将这个定义和纯四元数的定义结合，就得到了：&lt;/p&gt;

&lt;p&gt;\[ q = [0,v] \]
\[ = [0,\mathbf {v} \hat {v}] \]
\[ = \mathbf {v} [0,\hat {v}] \]&lt;/p&gt;

&lt;p&gt;然后，我们可以定义单位四元数了，它是一个s=0、v为单位向量的四元数：&lt;/p&gt;

&lt;p&gt;\[ \hat {q} = [0, \hat {v}] \]&lt;/p&gt;

&lt;h3&gt;四元数的二元形式&lt;/h3&gt;

&lt;p&gt;我们现在可以把单位四元数的定义和四元数的加法形式结合到一起，就创造了一种新的四元数的表示法，这种表示法和复数的表示法形似：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ = [s,0] + [0,v] \]
\[ = [s,0] + \mathbf {v} [0,\hat {v}] \]
\[ = s + \mathbf {v} \hat {q} \]&lt;/p&gt;

&lt;p&gt;这就给了我们一种和复数非常相似的四元数表示法：&lt;/p&gt;

&lt;p&gt;\[ z = a + bi \]
\[ q = s + \mathbf {v} \hat {q} \]&lt;/p&gt;

&lt;h3&gt;共轭四元数&lt;/h3&gt;

&lt;p&gt;共轭四元数的计算，就是将四元数的虚向量取反：&lt;/p&gt;

&lt;p&gt;\[  q = [s,v] \]
\[  q^{*} = [s,-v] \]&lt;/p&gt;

&lt;p&gt;四元数和它的共轭四元数的乘积：&lt;/p&gt;

&lt;p&gt;\[  qq^{*} = [s,v][s,-v] \]
\[ = [s^{2} - v\cdot -v,-sv+sv+v\times -v] \]
\[ = [s^{2} + v\cdot v,0] \]
\[ = [s^{2} + v^{2},0] \]&lt;/p&gt;

&lt;h3&gt;四元数范数&lt;/h3&gt;

&lt;p&gt;回忆下复数范数的定义：&lt;/p&gt;

&lt;p&gt;\[ |z| = \sqrt {a^{2}+b^{2}} \]
\[ zz^{*} = |z|^{2} \]&lt;/p&gt;

&lt;p&gt;类似的，四元数的范数可以这样定义：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ |q| = \sqrt {s^{2} + v^{2}} \]&lt;/p&gt;

&lt;p&gt;这也让我们可以这样表达四元数范数：&lt;/p&gt;

&lt;p&gt;\[ qq^{*} = |q|^{2} \]&lt;/p&gt;

&lt;h3&gt;四元数规范化&lt;/h3&gt;

&lt;p&gt;利用四元数范数的定义，就可以对四元数进行规范化。要让一个四元数规范化，只需要让这个四元数去除以它的范数：&lt;/p&gt;

&lt;p&gt;\[ q&amp;#39; = \frac {q}{\sqrt {s^{2}+v^{2}}} \]&lt;/p&gt;

&lt;p&gt;举一个例子，让我们规范化下面这个四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [1, 4i + 4j - 4k] \]&lt;/p&gt;

&lt;p&gt;第一步，先计算q的范数：&lt;/p&gt;

&lt;p&gt;\[ |q| = \sqrt {1^{2}+4^{2}+4^{2}+(-4)^{2}} \]
\[ = \sqrt {49} = 7 \]&lt;/p&gt;

&lt;p&gt;然后，q除以|q|:&lt;/p&gt;

&lt;p&gt;\[ q&amp;#39; = \frac {q}{|q|} \]
\[ = \frac {(1+4i+4j-4k)}{7} \]
\[ = \frac {1}{7}+\frac {4}{7}i+\frac {4}{7}j-\frac {4}{7}k \]&lt;/p&gt;

&lt;h3&gt;四元数的逆&lt;/h3&gt;

&lt;p&gt;四元数的逆用\(q^{-1} \)表示。要计算四元数的逆，需要用四元数的共轭四元数去除以四元数的范数的平方：&lt;/p&gt;

&lt;p&gt;\[ q^{-1} = \frac {q^{*}}{|q|^{2} } \]&lt;/p&gt;

&lt;p&gt;为了证明这个式子，我们先根据&lt;strong&gt;逆&lt;/strong&gt;的定义，有：&lt;/p&gt;

&lt;p&gt;\[ qq^{-1} = [1,0] = 1 \]&lt;/p&gt;

&lt;p&gt;两边都左乘共轭四元数\(q^{&lt;em&gt;} \)：
\[ q^{&lt;/em&gt;}qq^{-1} = q^{*} \]&lt;/p&gt;

&lt;p&gt;将上文中的\( qq^{*} = |q|^{2} \)代入这个式子，得到：&lt;/p&gt;

&lt;p&gt;\[ |q|^{2}q^{-1} = q^{*} \] &lt;/p&gt;

&lt;p&gt;\[ q^{-1} = \frac {q^{*}}{|q|^{2}} \] &lt;/p&gt;

&lt;p&gt;对于单位四元数，它的范数是1，所以可以写成：&lt;/p&gt;

&lt;p&gt;\[ q^{-1} = q^{*} \]&lt;/p&gt;

&lt;h3&gt;四元数的点积&lt;/h3&gt;

&lt;p&gt;和向量的点积相似，我们也可以计算2个四元数的点积，只需要将各个对应的系数相乘，然后相加:&lt;/p&gt;

&lt;p&gt;\[ q_{1} = [s_{1},x_{1}i+y_{1}j+z_{1}k] \]
\[ q_{2} = [s_{2},x_{2}i+y_{2}j+z_{2}k] \]
\[ q_{1}\cdot q_{2} = s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2} \]&lt;/p&gt;

&lt;p&gt;我们也可以利用四元数点积，来计算四元数之间的角度差：&lt;/p&gt;

&lt;p&gt;\[ cos\theta = \frac {s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}}{|q_{1}||q_{2}|} \]&lt;/p&gt;

&lt;p&gt;对于单位四元数，我们可以简化上面的等式：
\[ cos\theta = s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2} \]&lt;/p&gt;

&lt;h2&gt;旋转&lt;/h2&gt;

&lt;p&gt;前面我们定义了一个特殊的复数：旋转数。它是用来旋转2D复数平面的点的：
\[ q = cos\theta + isin\theta \]&lt;/p&gt;

&lt;p&gt;根据四元数和复数的相似性，应该有可能设计一个可以旋转3D空间的点的四元数：
\[ q = [cos\theta, sin\theta v] \]&lt;/p&gt;

&lt;p&gt;让我们测试一下这个理论是否可靠，方法就是计算四元数q和向量p的积。第一步，我们把p写成纯四元数的形式：&lt;/p&gt;

&lt;p&gt;\[ p = [0,\textbf {p}] \]&lt;/p&gt;

&lt;p&gt;以及单位四元数q：&lt;/p&gt;

&lt;p&gt;\[ q = [s,\lambda \hat {v}] \]&lt;/p&gt;

&lt;p&gt;从而：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; = qp = [s,\lambda \hat {v}] [0,\textbf {p}] \]
\[ =  [-\lambda \hat {v}\cdot \textbf {p}, s\textbf {p} + \lambda \hat {v}\times \textbf {p} ] \]&lt;/p&gt;

&lt;p&gt;我们可以看到结果是一个同时有系数、有虚向量的四元数。&lt;/p&gt;

&lt;p&gt;让我们先考虑特殊的情形：\( \textbf {p} \)与\( \hat {v} \)正交。这种情况下，点乘部分等于0：\(-\lambda \hat {v}\cdot \textbf {p} = 0\)。所以上面的四元数就变成了纯四元数：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; =  [0, s\textbf {p} + \lambda \hat {v}\times \textbf {p}] \]&lt;/p&gt;

&lt;p&gt;这时候，要使\( \textbf {p} \)绕\( \hat {v} \)旋转，我们只需要代入\(s=cos\theta \)和\( \lambda =sin\theta \)：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; =  [0, cos\theta \textbf {p} + sin\theta \hat {v}\times \textbf {p}] \]&lt;/p&gt;

&lt;p&gt;现在，让我们找一个例子来测试上面的公式。譬如绕z轴(就是k轴)旋转45度，那么我们的四元数q就变成：&lt;/p&gt;

&lt;p&gt;\[ q = [cos\theta ,sin\theta k] \]
\[ = [\frac {\sqrt {2}}{2},\frac {\sqrt {2}}{2}k] \]&lt;/p&gt;

&lt;p&gt;然后，选一个特殊的p，并且p要和k轴正交，譬如把p放到i轴上，也就是：
\[ p = [0, 2i] \]&lt;/p&gt;

&lt;p&gt;好了，现在计算下qp：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; = qp \]
\[ = [\frac {\sqrt {2}}{2},\frac {\sqrt {2}}{2}k] [0,2i] \]
\[ = [0,2\frac {\sqrt {2}}{2}i + 2\frac {\sqrt {2}}{2}k\times i]  \]
\[  = [0, \sqrt {2}i + \sqrt {2}j] \]&lt;/p&gt;

&lt;p&gt;结果是一个绕了k轴转了45度的纯四元数。
我们可以确认这个四元数的向量部分的长度是：&lt;/p&gt;

&lt;p&gt;\[  p&amp;#39; = \sqrt { \sqrt {2}^{2} + \sqrt {2}^{2} }  =  2 \]&lt;/p&gt;

&lt;p&gt;这正是我们所期望的！&lt;/p&gt;

&lt;p&gt;我们可以用图像展示旋转过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/7.png&quot; alt=&quot;7.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;现在，让我们考虑更一般化的四元数，即和p不正交的四元数。现在让我们把p的向量部分偏移45度：&lt;/p&gt;

&lt;p&gt;\[ \hat {v} = \frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k \]&lt;/p&gt;

&lt;p&gt;\[ \textbf {p} = 2i \]&lt;/p&gt;

&lt;p&gt;\[ q = [cos\theta , sin\theta \hat {v}] \]&lt;/p&gt;

&lt;p&gt;\[ p = [0, \textbf {p}] \]&lt;/p&gt;

&lt;p&gt;然后算qp：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; = qp \]
\[ = [cos\theta ,sin\theta \hat {v}] [0, \mathbf {p} ]  \]
\[ [-sin\theta \hat {v}\cdot \mathbf {p}, cos\theta \mathbf {p}+sin\theta \hat {v}\times \mathbf {p}] \]&lt;/p&gt;

&lt;p&gt;代入我们设定的\(\hat {v}, \mathbf {p}\)，以及\(\theta = 45^{\circ } \)，得到：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; = [-\frac {\sqrt {2}}{2}(\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)\cdot (2i), \frac {\sqrt {2}}{2}2i+\frac {\sqrt {2}}{2}(\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)\times 2i] \]
\[ = [-1, \sqrt {2}i + j] \]
注意，算出来的结果已经不是纯四元数了，并且，它并没有旋转45度、范数也不再是2(反而变小了，变成\(\sqrt {3}\))&lt;/p&gt;

&lt;p&gt;我们可以用图像展示旋转过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;严格来说，这样子在3维空间中表示\(p&amp;#39;\)是不正确的。因为它其实是一个4维的向量！为了简单起见，我只将这个四元数的向量部分显示出来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而，还有一线生机。Hamilton发现（但没有正式宣布），如果对qp右乘q的逆，出来的结果是一个纯四元数，并且四元数向量部分的范数可以保持不变。让我们试试应用在我们的例子里。&lt;/p&gt;

&lt;p&gt;首先计算:&lt;/p&gt;

&lt;p&gt;\[ q =  [cos\theta ,  sin\theta (\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)] \]&lt;/p&gt;

&lt;p&gt;\[ q^{-1} =  [cos\theta ,  -sin\theta (\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)] \]&lt;/p&gt;

&lt;p&gt;(译注：这里\(q^{-1}=q^{*}\)是因为q是单位四元数)&lt;/p&gt;

&lt;p&gt;再代入\(\theta = 45^{\circ } \)，得到：&lt;/p&gt;

&lt;p&gt;\[ q^{-1} =  [\frac {\sqrt {2}}{2},  -\frac {\sqrt {2}}{2}(\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)] \]&lt;/p&gt;

&lt;p&gt;\[ \frac {1}{2}[\sqrt {2}, -i-k] \]&lt;/p&gt;

&lt;p&gt;现在，把前面算出来的qp再次拿出来：&lt;/p&gt;

&lt;p&gt;\[ qp = [-1, \sqrt {2}i + j] \]
\[ qpq^{-1}  = [-1, \sqrt {2}i + j]\frac {1}{2}[\sqrt {2}, -i-k] \]
\[ = \frac {1}{2}[-\sqrt {2}-(\sqrt {2}i+j)\cdot (-i-k), i+k+\sqrt {2}(\sqrt {2}i+j)-i+\sqrt {2}j+k] \]
\[ = \frac {1}{2}[-\sqrt {2}+\sqrt {2},i+k+2i+\sqrt {2}j-i+\sqrt {2}j+k] \]
\[ = [0,i+\sqrt {2}j+k] \]&lt;/p&gt;

&lt;p&gt;这下是纯四元数了，并且它的范数是：&lt;/p&gt;

&lt;p&gt;\[ |qpq^{-1}| = \sqrt {1^{2} + \sqrt {2}^{2} + 1^{2} } = \sqrt {4} = 2 \]&lt;/p&gt;

&lt;p&gt;这和原始的p的范数一致。&lt;/p&gt;

&lt;p&gt;下面的图像展示了旋转结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/9.png&quot; alt=&quot;9.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;所以我们可以看到，这个结果是一个纯四元数，并且原四元数的向量的范数也保持住了。但是还有一个问题：向量被旋转了90度而不是45度。这刚好是我们需要的度数的两倍！为了正确地让一个向量绕某个轴向量旋转某个角度，我们必须以目标角度的一半来计算。因此，我们构造了下面的四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [cos\frac {1}{2}\theta ,sin\frac {1}{2}\theta \hat {v}] \]&lt;/p&gt;

&lt;p&gt;这就是&lt;strong&gt;旋转四元数&lt;/strong&gt;的一般形式！&lt;/p&gt;

&lt;h2&gt;四元数插值&lt;/h2&gt;

&lt;p&gt;在计算机图形学中使用四元数，其中一个重要原因是四元数非常适合用来表示空间中的旋转。四元数解决了其他3维空间旋转算法会遇到的恼人的问题，比如使用欧拉角来表示旋转操作时会遇到的万向节锁问题(&lt;a href=&quot;https://en.wikipedia.org/wiki/Gimbal_lock&quot;&gt;Gimbal lock&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;使用四元数，我们可以定义好几种方案来表示3维空间的转动插值。第一种是SLERP，它被用来把一个点(物体)从一个朝向平滑地插值到另一个朝向。第二个是SLERP的扩展版本，被称为SQAD，它被用来处理用一系列朝向定义得到的一条路径的插值。&lt;/p&gt;

&lt;h2&gt;SLERP&lt;/h2&gt;

&lt;p&gt;SLERP代表&lt;strong&gt;S&lt;/strong&gt;pherical &lt;strong&gt;L&lt;/strong&gt;inear Int&lt;strong&gt;erp&lt;/strong&gt;olation。SLERP可以在2个朝向之间平滑地插值。&lt;/p&gt;

&lt;p&gt;第一个朝向设为\( q_{1}\)，第二个朝向设为\( q_{2}\)。被插值前的点设为\( \mathbf {p} \)，插值后的点设为\( \mathbf {p}&amp;#39; \)。而插值参数t，当t=0时会把\(\mathbf {p}\)转到\( q_{1}\)，当t=1时会转到\( q_{2}\)。&lt;/p&gt;

&lt;p&gt;标准的线性插值公式是(译注：这个公式是笛卡尔坐标系下的，不是指四元数)：&lt;/p&gt;

&lt;p&gt;\[ \mathbf {p}&amp;#39; = \mathbf {p}_{1} + t(\mathbf {p}_{2} - \mathbf {p}_{1} ) \]&lt;/p&gt;

&lt;p&gt;应用这个等式的一般步骤是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算\( \mathbf {p}_{1} 、\mathbf {p}_{2}\)之间的差。&lt;/li&gt;
&lt;li&gt;根据参数t，计算两个点的差的小数值(因为0&amp;lt;=t&amp;lt;=1)&lt;/li&gt;
&lt;li&gt;把第二步的值加上原始点的值，算出结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以把这个基础公式，套用到2个用四元数表示的朝向的插值上。&lt;/p&gt;

&lt;h3&gt;四元数的差&lt;/h3&gt;

&lt;p&gt;根据上面的公式的第一步，我们必须先计算\( q_{1}、 q_{2}\)的差。对于四元数来说，这等价于计算2个四元数的角度差：&lt;/p&gt;

&lt;p&gt;\[ diff =  q_{1}^{-1}q_{2} \]&lt;/p&gt;

&lt;p&gt;（译注：这个公式用到了上述的四元数点积公式）&lt;/p&gt;

&lt;h3&gt;四元数的指数&lt;/h3&gt;

&lt;p&gt;接下来是计算上面的角度差的分数值，方法是计算四元数的t次幂(就是上面的那个插值参数t)。&lt;/p&gt;

&lt;p&gt;四元数的指数的一般化公式是：&lt;/p&gt;

&lt;p&gt;\[ q^{t} = exp(t \log q) \]&lt;/p&gt;

&lt;p&gt;其中，(纯)四元数的exp函数的公式是：&lt;/p&gt;

&lt;p&gt;\[ e^{q} = exp(q) = exp([0,\theta \hat {v}]) \]
\[ = [cos\theta ,sin\theta \hat {v} ] \]&lt;/p&gt;

&lt;p&gt;(纯)四元数的对数公式是：&lt;/p&gt;

&lt;p&gt;\[ \log q = \log (cos\theta + sin \theta \hat {v}) \]
\[ = \log (exp(\theta \hat {v} )) \]
\[ = \theta \hat {v} \]
\[ = [0, \theta \hat {v}] \]&lt;/p&gt;

&lt;p&gt;(译注：上述的2次公式推导，其实省略了很多证明过程。具体可以参考：&lt;a href=&quot;http://bpeers.com/blog/?itemid=861&quot;&gt;http://bpeers.com/blog/?itemid=861&lt;/a&gt;,&lt;a href=&quot;http://bpeers.com/blog/?itemid=863&quot;&gt;http://bpeers.com/blog/?itemid=863&lt;/a&gt;,&lt;a href=&quot;http://bpeers.com/blog/?itemid=866&quot;&gt;http://bpeers.com/blog/?itemid=866&lt;/a&gt;, &lt;a href=&quot;http://bpeers.com/blog/?itemid=1001&quot;&gt;http://bpeers.com/blog/?itemid=1001&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;对于t = 0，我们有：&lt;/p&gt;

&lt;p&gt;\[ q^{0} = exp(0\log q) \]
\[ = exp([cos(0), sin(0)\hat {v}]) \]
\[ = exp([1,0]) \]
\[ = [1,0] \]&lt;/p&gt;

&lt;p&gt;而对于t = 1，有：&lt;/p&gt;

&lt;p&gt;\[ q^{1} = exp(1\log q) = q \]&lt;/p&gt;

&lt;h3&gt;2个四元数的分数差&lt;/h3&gt;

&lt;p&gt;对于角旋转的插值计算，我们利用q1和q2的角度分数差来调整原始朝向q1：&lt;/p&gt;

&lt;p&gt;\[ q&amp;#39; = q_{1}(q_{1}^{-1}q_{2})^{t} \]&lt;/p&gt;

&lt;p&gt;这也就是使用四元数的球面线性插值的一般形式。然而，这不是slerp函数的常用形式。&lt;/p&gt;

&lt;p&gt;我们可以应用类似的用于计算向量的球面插值公式，到四元数里。计算向量的球面插值的一般形式定义如下：&lt;/p&gt;

&lt;p&gt;\[ v_{t} = \frac {sin((1-t)\theta )}{sin\theta }v_{1} + \frac {sin(t\theta )}{sin\theta }v_{2} \]&lt;/p&gt;

&lt;p&gt;用图像表示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/10.png&quot; alt=&quot;10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个公式可以原封不动地应用到四元数：&lt;/p&gt;

&lt;p&gt;\[ q_{t} = \frac {sin((1-t)\theta )}{sin\theta }q_{1} + \frac {sin(t\theta )}{sin\theta }q_{2} \]&lt;/p&gt;

&lt;p&gt;但这个公式需要提供角度\(\theta \)，我们可以计算\(q_{1}\)和\(q_{2}\)的点积从而得出角度\(\theta \)：&lt;/p&gt;

&lt;p&gt;\[ cos\theta  = \frac {q_{1}\cdot q_{2}}{ |q_{1}||q_{2}| } \]&lt;/p&gt;

&lt;p&gt;\[ cos\theta = \frac {s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}}{|q_{1}||q_{2}|} \]&lt;/p&gt;

&lt;p&gt;\[ \theta = cos^{-1}(\frac {s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}}{|q_{1}||q_{2}|}) \]&lt;/p&gt;

&lt;h3&gt;注意事项&lt;/h3&gt;

&lt;p&gt;这个方案有2个问题，必须在实现过程中加以考虑。&lt;/p&gt;

&lt;p&gt;第一，如果四元数点积的结果是负值，那么后面的插值就会在4D球面上绕远路，这并不是我们想要的。为了解决这个问题，我们测试点积的结果，当结果是负值时，我们将2个四元数的其中一个取反，取反它的系数和向量部分，并不会改变它代表的朝向。而经过这一步操作，可以保证这个旋转走的是最短路径。&lt;/p&gt;

&lt;p&gt;当\(q_{1}\)和\(q_{2}\)的角度差非常小，小到导致\(sin\theta = 0\)时，会出现第二个问题。如果这个情况出现了，当我们除以\(sin\theta\)时就会得到一个未定义的结果。在这个情况下，我们可以回退去使用\(q_{1}\)和\(q_{2}\)的线性插值。&lt;/p&gt;

&lt;h2&gt;SQUAD&lt;/h2&gt;

&lt;p&gt;正如一个SLERP可以被用来计算四元数之间的插值，一个SQUAD (&lt;strong&gt;S&lt;/strong&gt;pherical and &lt;strong&gt;Quad&lt;/strong&gt;rangle)可以被用来对旋转路径进行平滑插值。&lt;/p&gt;

&lt;p&gt;如果我们有四元数序列：&lt;/p&gt;

&lt;p&gt;\[ q_{1},q_{2},q_{3},\cdots,q_{n-2},q_{n-1},q_{n}\]&lt;/p&gt;

&lt;p&gt;然后我们再定义一个&amp;quot;辅助&amp;quot;四元数(\(s_{i}\))，它是一个中间控制点：&lt;/p&gt;

&lt;p&gt;\[ s_{i} = exp( - \frac {\log(q_{i+1}q_{i}^{-1})+\log(q_{i-1}q_{i}^{-1})}{4})q_{i} \]&lt;/p&gt;

&lt;p&gt;所以，沿着子曲线的朝向可以定义为：&lt;/p&gt;

&lt;p&gt;\[ q_{i-1},q_{i},q_{i+1},q_{i+2} \]&lt;/p&gt;

&lt;p&gt;在t时刻的朝向就是：&lt;/p&gt;

&lt;p&gt;\[ squad(q_{i},q_{i+1},s_{i},s_{i+1},t ) = slerp(slerp(q_{i},q_{i+1},t),slerp(s_{i},s_{i+1},t),2t(1-t)) \]&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;除了特别难理解之外，相比矩阵或欧拉角，四元数在表示旋转这个事情上，拥有一些明显的优点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SLERP和SQUAD，提供了一种使得在朝向之间可以平滑过渡的方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用四元数来串联&amp;quot;旋转&amp;quot;，要比使用矩阵快得多。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于单位四元数，逆向旋转可以通过对向量部分取反来实现。而计算一个矩阵的逆矩阵是被认为比较慢的，如果这个矩阵未被标准正交化的话(标准正交矩阵的逆矩阵是它的转置矩阵)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从四元数转换到矩阵，要比从欧拉角转换到矩阵快一点。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四元数只需要4个数字(如果旋转四元数已经单位化了那么只需要3个，实数部分可以在运行时计算)来表示一个旋转，而矩阵需要至少9个数字。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尽管使用四元数有这么多优点，还是有缺点存在的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为浮点数的舍入运算错误，四元数可能会变无效。不过，这个错误可以通过重新单位化四元数来避免。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用四元数最具威慑性的地方，还是四元数的理解难度大。我希望这个问题可以通过阅读本文来解决。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;存在一些已经实现了四元数、并且是正确的的数学程序库。在我的个人经验里，我发现GLM(OpenGL Math Library)是一个优秀的数学库，它的四元数的实现极其不错。如果你对在你的程序中使用四元数感兴趣，那么我会推荐你使用这个数学库。&lt;/p&gt;

&lt;h2&gt;下载Demo&lt;/h2&gt;

&lt;p&gt;我实现了一个小demo来演示一个四元数如何被用来旋转一个3维物体。这个demo是用Unity3.5.2实现的，你可以免费下载它和阅读它的脚本。zip文件也包含了一个Windows版的Unity程序。当然你可以自己构建一个Mac的版本。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.google.com/open?id=0B0ND0J8HHfaXdzM0dmdGUzBLV1U&quot;&gt;Understanding Quaternions.zip&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/understanding-quaternions/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/understanding-quaternions/</guid>
      </item>
    
      <item>
        <title>PBRT《章2》阅读笔记</title>
        <description>&lt;p&gt;最近在看线代的公开课，顺便也把PBRT这个坑开了，合在一起学。&lt;/p&gt;

&lt;p&gt;本文的cpp代码均来自&lt;a href=&quot;https://github.com/mmp/pbrt-v2&quot;&gt;https://github.com/mmp/pbrt-v2&lt;/a&gt;，木有修改。只为方便读者阅读。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;一个基本的渲染器，需要实现2点：输入场景数据、输出渲染图像。&lt;/p&gt;

&lt;p&gt;输入场景数据这一步，就需要对3D世界各种东西进行抽象、并设计各种数据结构，比如比较fundamental的：3D空间向量、3D坐标系系统、光线，或者visible的：各种2D/3D几何体、纹理系统等。大概就是，这个渲染器要渲染的东西，程序上都会有一些对应的代码。渲染器不可能对未知的东西进行渲染。比如毛发、布这种高端的东西，一个基本的渲染器是无法渲染的，除非你写了一些代码来完成这个事情。&lt;/p&gt;

&lt;p&gt;《PBRT》第二章就讲了这些基础的东西。&lt;/p&gt;

&lt;p&gt;在前面的线代的文章中，提到了矩阵的基(basis)的概念。矩阵的基是一组线性无关的列向量，这个矩阵的列空间的任意一点，可以通过对矩阵的基的线性组合得到。&lt;/p&gt;

&lt;p&gt;那么n维的情况下，定义一个向量的公式是：&lt;/p&gt;

&lt;p&gt;\[ v = s_{1}v_{1} + \cdots + s_{n}v_{n} \]&lt;/p&gt;

&lt;p&gt;定义一个点的位置的公式是：&lt;/p&gt;

&lt;p&gt;\[ p = p_{0} + s_{1}v_{1} + \cdots + s_{n}v_{n} \]&lt;/p&gt;

&lt;p&gt;对于渲染器的3维空间，要简化成：&lt;/p&gt;

&lt;p&gt;\[ p_{0} = (0,0,0) \]
\[ basis = (1,0,0) (0,1,0) (0,0,1) \]&lt;/p&gt;

&lt;p&gt;这3个标准基向量对应的空间被称为世界空间(world space)。&lt;/p&gt;

&lt;h3&gt;向量(vector)、点(point)的区别&lt;/h3&gt;

&lt;p&gt;向量和点，区别在于点没有长度的概念，也就是说点是零维的，点代表空间里的一个&lt;strong&gt;位置&lt;/strong&gt;（pbrt的Point和Vector的差异是没有LengthSquared、Length函数)，而向量没有起点的概念，向量只是指明了一个&lt;strong&gt;方向&lt;/strong&gt;并且有长度。&lt;/p&gt;

&lt;h3&gt;3维空间下，如何从一个向量出发，构造出一组标准正交基&lt;/h3&gt;

&lt;p&gt;注意，这个问题是有重要意义的，因为一组标准正交基相当于一个坐标系。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设\( v_{1}=(x_{1},y_{1},z_{1}) \)，并且v1已经单位化&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随便选择v1的某一个分量，并将它变成0，再交换剩余的2个分量的位置，并对其中一个分量取反，就能得到和v1正交的v2。这是因为这样构造出来的v2，必然使得\(  v_{1}\cdot v_{2}=0 \)。比如当\( v_{2}=(-z_{1},0,x_{1}) \)时，有\( v_{1}\cdot v_{2}=(x_{1},y_{1},z_{1})\cdot (-z_{1},0,x_{1}) = 0\)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面的v2还有不足，因它不是单位化的。单位化的v2应该是\[v_{2}=\dfrac { (-z_{1},0,x_{1}) }{ \sqrt {z_{1}^{1}+x_{1}^{1}}} \]&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有了v1、v2后，v3就等于v1和v2的叉积(cross product): \( v_{3} =v_{1} \times v_{2} \)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;法向量Normal&lt;/h3&gt;

&lt;p&gt;(突然意识到，pbrt把向量、点、法向量写成3个没有继承关系的类，意义在于，防止程序员乱用并搞砸代码=。=)&lt;/p&gt;

&lt;p&gt;** A surface normal is a vector that is perpendicular to a surface at a particular position.It can be defined as the cross product of any two nonparallel vectors
that are tangent to the surface at a point. **&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;法向量是与某个平面垂直，并经过平面上某个特殊位置的向量。可以用平面上2个互不平行、与平面正切的向量的叉积来表示。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;法向量应该说是一种特殊的向量。pbrt也实现了一个以Vector为参数的Normal构造函数（但有explicit标志），允许通过向量构造出法向量。&lt;/p&gt;

&lt;h3&gt;光线Ray&lt;/h3&gt;

&lt;p&gt;光线是一条半无限长的线，用一个原点和一个方向向量来表示。&lt;/p&gt;

&lt;p&gt;参数形式的光线表示：&lt;/p&gt;

&lt;p&gt;\[ r(t) = o + td   \ \ \ 0\leq t\geq \infty \]&lt;/p&gt;

&lt;p&gt;光线还有其他成员变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mint maxt，用来限定t的范围&lt;/li&gt;
&lt;li&gt;time 用于构建动画，当构建静态场景时不需要&lt;/li&gt;
&lt;li&gt;depth 光线弹射深度。限制光线只能bounce多少次&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;微分光线Differential Ray&lt;/h3&gt;

&lt;p&gt;先跳过&lt;/p&gt;

&lt;h3&gt;包围盒&lt;/h3&gt;

&lt;p&gt;包围盒的主要作用，是用来优化程序性能的，更具体的说，就是让复杂场景物件简化成简单的球形、方盒，使得光线快速剔除不相交的对象，计算得更快。&lt;/p&gt;

&lt;p&gt;BBox&lt;/p&gt;

&lt;p&gt;这玩意神奇的地方，我觉得是它的构造函数。输入是2个Point，就能构造一个盒子，并且也仅仅是花了2个Point来存储。这2个新的Point和输入的Point不同，被称为pMin和pMax:&lt;/p&gt;

&lt;p&gt;\[ pMin = (min(p_{1}.x,p_{2}.x), min(p_{1}.y,p_{2}.y), min(p_{1}.z,p_{2}.z)) \]&lt;/p&gt;

&lt;p&gt;\[ pMax = (max(p_{1}.x,p_{2}.x), max(p_{1}.y,p_{2}.y), max(p_{1}.z,p_{2}.z)) \]&lt;/p&gt;

&lt;p&gt;需要注意的是，根据这个转换公式，要使得pMin和pMax足够定义一个BBox，那么他们必然是BBox的2个对角顶点。且因为BBox平行于x、y、z轴，那么pMin和pMax的任意一个分量都不能相等。（否则，pMin、pMax就只能是BBox的一对邻接顶点）&lt;/p&gt;

&lt;p&gt;p1、p2和pMin、pMax是什么关系呢？其实，p1、p2也是这个BBox的某一组对角顶点。计算出来的pMin、pMax也只是这4组对角顶点的特定的一组，只不过pMin必然是BBox8个顶点中最靠近坐标系原点的顶点、pMax必然是最远离坐标系原点的顶点。&lt;/p&gt;

&lt;h3&gt;转换Transformation&lt;/h3&gt;

&lt;p&gt;** In general, a transformation T is a mapping from points to points and from vectors to
vectors:**&lt;/p&gt;

&lt;p&gt;\[ p^{\prime } = T(p) \]
\[ v^{\prime } = T(v) \]&lt;/p&gt;

&lt;p&gt;回想下线代的知识，就可以知道，这个T必然是一个方阵，阶数等于p(或v)的维数，T对p(或v)的转换，其实只是一次矩阵乘法。&lt;/p&gt;

&lt;p&gt;T有很多种，大部分是无特殊转换意义的，但有小部分是有特定意义且能用在图形学里的。譬如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Translation，我称之为位置转换&lt;/li&gt;
&lt;li&gt;Scaling，缩放转换&lt;/li&gt;
&lt;li&gt;Rotation，旋转转换&lt;/li&gt;
&lt;li&gt;LookAt，视角转换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Translation的一般形式：&lt;/p&gt;

&lt;p&gt;\[ T(\vartriangle x,\vartriangle y,\vartriangle z) =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;\vartriangle x\\ 0&amp;amp;1&amp;amp;0&amp;amp;\vartriangle y\\ 0&amp;amp;0&amp;amp;1&amp;amp;\vartriangle z\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;Scaling的一般形式：&lt;/p&gt;

&lt;p&gt;\[ T(\vartriangle x,\vartriangle y,\vartriangle z) =  \left[ \begin{matrix} x&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;y&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;z&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;Rotation的一般形式，比较复杂，先分成3种情况考虑。所谓的旋转，都要有一个轴线，对任意一个3维坐标系来说，有3条轴，所以就有以3条轴为轴线的3个Rotation：&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta ) =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;cos\theta &amp;amp;-sin\theta &amp;amp;0\\ 0&amp;amp;sin\theta &amp;amp;cos\theta &amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ R_{y}(\theta ) =  \left[ \begin{matrix} cos\theta &amp;amp;0&amp;amp;sin\theta &amp;amp;0\\ 0&amp;amp;1&amp;amp;0&amp;amp;0\\ -sin\theta &amp;amp;0&amp;amp;cos\theta &amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ R_{z}(\theta ) =  \left[ \begin{matrix} cos\theta &amp;amp;-sin\theta &amp;amp;0&amp;amp;0\\ sin\theta &amp;amp;cos\theta &amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;以x轴的旋转分析一下：&lt;/p&gt;

&lt;p&gt;因为：&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta )[x,y,z,w]^{T} = [x,cos\theta \cdot y - sin\theta \cdot z,sin\theta \cdot y + cos\theta \cdot z, w]^{T} \]&lt;/p&gt;

&lt;p&gt;所以有：&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta )[1,0,0,0]^{T} = [1,0,0,0]^{T} \]&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta )[0,1,0,0]^{T} = [0,cos\theta ,sin\theta ,0]^{T} \]&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta )[0,0,1,0]^{T} = [0,-sin\theta ,cos\theta ,0]^{T} \]&lt;/p&gt;

&lt;p&gt;可以看出，用Rx旋转x轴,x轴不变,旋转y、z轴，y、z轴会被顺时针旋转\(\theta \)度（左手坐标系时）。&lt;/p&gt;

&lt;p&gt;Rotation有一些特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( R_{\alpha }(0) = I \) 这个0是指\(\theta=0\)，不是向量0&lt;/li&gt;
&lt;li&gt;\( R_{\alpha }(\theta _{1})R_{\alpha }(\theta _{2}) = R_{\alpha }(\theta _{1} + \theta _{2}) \)&lt;/li&gt;
&lt;li&gt;\( R_{\alpha }(\theta _{1})R_{\alpha }(\theta _{2}) = R_{\alpha }(\theta _{2})R_{\alpha }(\theta _{1}) \)&lt;/li&gt;
&lt;li&gt;\( R_{\alpha }^{-1}(\theta ) = R_{\alpha }(-\theta ) = R_{\alpha }^{T}(\theta ) \)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回想下正交矩阵的定义：&lt;strong&gt;如果实数域上的方阵A满足 \( A^{T}A = I \)，则称A为正交矩阵&lt;/strong&gt;，根据上面的第四条性质，R显然也是一个正交矩阵。正交矩阵的好处是，它的逆矩阵很简单，等于它的转置矩阵。&lt;/p&gt;

&lt;p&gt;当需要围绕任意一个向量做旋转时，可以这样想：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设轴向量为a，要被旋转的向量为v&lt;/li&gt;
&lt;li&gt;把a向量当做一个x轴（y or z轴也行）；把v到a的error向量（如果不知道什么是error向量，请看我之前的文章）当做y轴&lt;/li&gt;
&lt;li&gt;以x、y轴向量去计算正交的z轴向量（用叉积即可）&lt;/li&gt;
&lt;li&gt;就得到了一个以a向量为x轴的xyz坐标系了&lt;/li&gt;
&lt;li&gt;所以原问题就变成了，绕这个虚拟坐标系的x轴旋转&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( v_{c} = a\parallel v\parallel cos\alpha = a(v\cdot a) \)&lt;/li&gt;
&lt;li&gt;\( v_{1} = v - v_{c} \)&lt;/li&gt;
&lt;li&gt;\( v_{2} = v_{1}\times a \)&lt;/li&gt;
&lt;li&gt;\( v_{1}^{\prime } =  v_{1}cos\theta + v_{2}sin\theta \) &lt;/li&gt;
&lt;li&gt;\( v^{\prime } = v_{c} + v_{1}^{\prime } \) &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(书里没有标出来\( v_{c} \) ,红色的那段就是)&lt;/p&gt;

&lt;p&gt;书里也没有解释上面第三个式子是怎么得到的。我的理解是，因为\( v_{1}^{\prime } \)和\( v_{1} \)等长，所以\( v_{1}^{\prime } \)在\( v_{1} \)上的投影(向量)等于\(v_{1}cos\theta \)，又因为\( v_{1} \)是一个坐标系的轴，所以这个投影就是\( v_{1}^{\prime } \)对应这个轴的分量；同理，\(v_{2}sin\theta \)，是\( v_{1}^{\prime } \)在\( v_{2} \)上的投影。这两个投影向量的和，就是\( v_{1}^{\prime } \)。&lt;/p&gt;

&lt;p&gt;不过这个任意轴旋转的矩阵就不那么简单了，先设：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( c = cos\theta  \)&lt;/li&gt;
&lt;li&gt;\( s = sin\theta  \)&lt;/li&gt;
&lt;li&gt;\( x,y,z = normalize(x,y,z) \)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ R_{(x,y,z)}(\theta ) =  \left[ \begin{matrix} x^{2}+(1-x^{2})c&amp;amp;xy(1-c) -zs&amp;amp;xz(1-c)+ys&amp;amp;0\\ xy(1-c)+zs&amp;amp;y^{2}+(1-y^{2})c&amp;amp;yz(1-c)-xs&amp;amp;0\\ xz(1-c)-ys&amp;amp;yz(1-c)+xs&amp;amp;z^{2}+(1-z^{2})c&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;(好可怕的矩阵=。=，不过这世界上还有个东西叫四元数旋转。有空再写一篇四元数的文章）&lt;/p&gt;

&lt;p&gt;LookAt转换&lt;/p&gt;

&lt;p&gt;LookAt矩阵的第4列是摄像机在世界坐标系的坐标；第3列是单位化的视点朝向向量（摄像机的前方），即视点坐标减去第4列的坐标;第2列是单位化的up向量（摄像机的上方），以世界坐标系表示；第1列是摄像机坐标系的x向量在世界坐标系对应的向量。&lt;/p&gt;

&lt;p&gt;第1列的x向量，是用第2列的up向量和第3列的朝向向量进行叉积得到。&lt;/p&gt;

&lt;p&gt;设：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pos是摄像机坐标（世界坐标）&lt;/li&gt;
&lt;li&gt;up是用户提供的摄像机朝向上方的向量（世界坐标）&lt;/li&gt;
&lt;li&gt;look是用户提供的摄像机视点的向量（世界坐标）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dir = Normalize(look - pos)，摄像机的朝向向量（世界坐标）&lt;/li&gt;
&lt;li&gt;xaxis = Normalize(Cross(Normalize(up), dir))，摄像机的x轴单位向量（世界坐标）&lt;/li&gt;
&lt;li&gt;newUp = Cross(Normalize(dir), xaxis)，新的单位化的up向量（世界坐标）。这里不太明白为什么不直接newUp = Normalize(up)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[  \left[ \begin{matrix} xaxis.x&amp;amp;newUp.x&amp;amp;dir.x&amp;amp;pos.x\\ xaxis.y&amp;amp;newUp.y&amp;amp;dir.y&amp;amp;pos.y\\ xaxis.z&amp;amp;newUp.z&amp;amp;dir.z&amp;amp;pos.z\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h3&gt;Tranform的应用原理&lt;/h3&gt;

&lt;p&gt;Tranform对Vector和Point的作用过程，上面已经提到了，就是简单的矩阵相乘。&lt;/p&gt;

&lt;p&gt;对Ray和BBox的转换，也不难，就是对Ray的o和d分量分别左乘T、对BBox的8个顶点分别左乘T。&lt;/p&gt;

&lt;p&gt;这里要提一下法向量的Tranform。法向量是不能直接T(n)的，这是错误的。&lt;/p&gt;

&lt;p&gt;直接贴公式：&lt;/p&gt;

&lt;p&gt;\[ n\cdot t = n^{T}t = 0 \]
\[ (n^{\prime })^{T}t^{\prime }= 0 \]
\[ (Sn)^{T}Mt = 0 \]
\[ n^{T}S^{T}Mt = 0 \]
\[ S^{T}M = I \]
\[ n^{\prime } = Sn = (M^{-1})^{T}n \]&lt;/p&gt;

&lt;p&gt;M是某种转换，当M对一个面作用时，这个面的法向量要用上面最后那条公式转换。注意到公式里面有一个逆矩阵，所以这就是为什么Transform要存一个逆矩阵。&lt;/p&gt;

&lt;h3&gt;旋转四元数-&amp;gt;旋转矩阵&lt;/h3&gt;

&lt;p&gt;虽然可以用四元数来实现旋转变换，但是如果能变回矩阵的形式，也是有用的。实际上却是办得到。&lt;/p&gt;

&lt;p&gt;设四元数的旋转轴为:
\[ q = [cos\frac {\theta }{2}, sin\frac {\theta }{2}\hat {v}] = [q_{w}, q_{x}i + q_{y}j + q_{z}k] = (q_{x}, q_{y}, q_{z}, q_{w}) \]&lt;/p&gt;

&lt;p&gt;被旋转的点的原坐标为p，旋转后的坐标为\(p&amp;#39;\)：&lt;/p&gt;

&lt;p&gt;\[ p = [w, xi + yj + zk] = (x,y,z,0)  \]&lt;/p&gt;

&lt;p&gt;四元数表示的旋转公式：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; = qpq^{-1} \]&lt;/p&gt;

&lt;p&gt;而矩阵表示的旋转公式是：
\[ p&amp;#39; = Mp \]&lt;/p&gt;

&lt;p&gt;M是未知的，目标就是算出M。把上面的p和q代入四元数旋转公式，就能得到一个新的四元数\(p&amp;#39;\),这个\(p&amp;#39;\)会有i、j、k分量，只要把i、j、k3个分量再按3个未知数x、y、z去分开，就得到一个9x9的矩阵，也就是M了。&lt;/p&gt;

&lt;p&gt;我在纸上写了下推导公式，非常繁琐，不好弄成latex。直接贴上最终的公式吧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/pbrt-chapter2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/pbrt-chapter2/</guid>
      </item>
    
  </channel>
</rss>