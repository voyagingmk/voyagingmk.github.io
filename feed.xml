<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>博主主要学习方向：图形学、机器学习，以及各种有趣的数学。联系QQ：234707482。</description>
    <link>http://www.qiujiawei.com</link>
    <atom:link href="http://www.qiujiawei.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>mini引擎开发备忘</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;跨平台问题汇总&lt;/h2&gt;

&lt;h3&gt;XCode 8 + iOS + SDL2 + OpenGL ES&lt;/h3&gt;

&lt;p&gt;首先是记录xcode项目的创建问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个iOS平台的game或Single View Application项目。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Main和Lauch Screen这2个storyboard可以去掉，去掉后还要把info.plist里2个storyboard的选项也去掉，并设置用默认的Lauch Screen storyboard： 【Launch screen interface file base name：iOS Launch Screen】。相应的ViewController的h和m文件也去掉，只留下AppDelegate和main.m。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AppDelegate的h和m文件可以不修改，但main.m里面的代码需要全部删除（因为SDL自身会定义main入口）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载SDL2源码，解压后找到里面的xcode-iOS目录，用xcode打开其中的SDL子目录里的工程，然后直接build，就获得里libsdl2.a静态库。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把libsdl2.a放到刚才创建的xcode项目根目录里。并在Build Phases的Link项里把libsdl2.a加上。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后继续添加iOS项目需要的官方frameworks: GLKit、OpenGLES、CoreMotion、AVFoundation、GameController、AudioToolbox&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把SDL2的include目录复制到项目目录，并把目录拖进xcode左边的目录树里，然后设置后search path，这样等下编译就能找到SDL2库了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后就可以新建一个main.cpp文件，开始写SDL程序了&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;renderer的代码在xcode中编译遇到的报错&lt;/h3&gt;

&lt;p&gt;一大堆报错，处理了一两个小时，主要产生原理是vc和gcc的不一致性，以及一些平台相关代码问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Point模板类，Vector模板继承Point，会出现一个偏特化的问题，症状就是Vector的代码里调用父类成员x y z，gcc会找不到（vc没问题），原因暂时没完全搞懂，关键词是偏特化，gcc要求明确指出x y z是哪来的对象，也就是说要么写成Point&lt;T&gt;::x, 要么写成this-&amp;gt;x。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当class的构造函数的参数没有加const限定符，但用右值作为参数去创建类实例时，vc不会报错，而gcc报错了，加上const后可以解决。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【Non-constant-expression cannot be narrowed from type &amp;#39;unsigned long&amp;#39; to &amp;#39;int&amp;#39; in initializer list】 initial list初始化列表不支持非常量表达式的long到int的narrow转换，需要自行加上static_cast&lt;int&gt;。（vc不会报这个错）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【Use of overloaded operator &amp;#39;/&amp;#39; is ambiguous (with operand types &amp;#39;value_type&amp;#39; (aka &amp;#39;nlohmann::basic_json&lt;std::map, std::vector, std::__1::basic_string&lt;char&gt;, bool, long long, double, std::allocator&amp;gt;&amp;#39;) and &amp;#39;float&amp;#39;) 】这个错和第三方json库有关，但vc没报错，大概就是编译器找到多个／操作符重载，不知道用哪个，需要把代码从 c[0] / 255.0f 改成 float(c[0]) / 255.0f&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【Non-const lvalue reference to type &amp;#39;renderer::Ray&amp;#39; cannot bind to a temporary of type &amp;#39;renderer::Ray&amp;#39;】 问题处在函数返回值类型和变量类型上。函数返回的是Ray，而变量是Ray&amp;amp;，如果是vc，那么不会报错。如果是gcc，有三个办法解决报错，一改成const Ray&amp;amp;（注意，改const的话，其他代码可能会有冲突），二改成Ray&amp;amp;&amp;amp;，三改成Ray。vc真是人性化到有点可怕，这种返回值没弄好，分分钟变成性能瓶颈的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【Control may reach end of non-void function】，这个在vc里没有报，在gcc里报了，gcc要严格得多呀。这个报错就是要求说，每个函数能到达的结束位置，都必须有返回值。我这里是不小心写漏了。小问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;头文件include报错，这种属于工程问题，通过配置xcode的include路径应该可以解决。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平台相关的编译报错，通过#if可以粗暴解决。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 17 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/game-engine-notes/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/game-engine-notes/</guid>
      </item>
    
      <item>
        <title>四元数公式的补充</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;继上一篇四元数的文章&lt;a href=&quot;http://www.qiujiawei.com/understanding-quaternions/&quot;&gt;Understanding Quaternions 中文翻译《理解四元数》&lt;/a&gt;，已经过去一两年了。我发现那篇文章有一些细节没有讲得特别清楚，遂现在写一篇关于四元数公式的文章补缺下。&lt;/p&gt;

&lt;h2&gt;四元数的指数函数&lt;/h2&gt;

&lt;p&gt;先给出最终公式。设有任意四元数q：&lt;/p&gt;

&lt;p&gt;\[q = s + x\mathbf i + y\mathbf j + z\mathbf k = s + \mathbf {v} = [s,\mathbf {v}] = [s,\mathbf 0] + [0,\mathbf {v}] \]&lt;/p&gt;

&lt;p&gt;则有：&lt;/p&gt;

&lt;p&gt;\[ e^{q} = e^{ s +\mathbf {v}} = e^{s}e^{\mathbf v} =e^{s}( cos|\mathbf v| + \mathbf v \frac {sin |\mathbf v| } { |\mathbf v| } ) \]&lt;/p&gt;

&lt;h3&gt;推导过程&lt;/h3&gt;

&lt;p&gt;首先搬出四元数的&lt;strong&gt;乘积&lt;/strong&gt;公式：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [s_{a},\mathbf {a}] \]&lt;/p&gt;

&lt;p&gt;\[ q_{b} = [s_{b},\mathbf {b}] \]&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [s_{a}s_{b} - a\cdot b, s_{a}b+s_{b}a+a\times b] \]&lt;/p&gt;

&lt;p&gt;代入上面的\( \mathbf v = 0 + x\mathbf i + y\mathbf j + z\mathbf k \)，得到：&lt;/p&gt;

&lt;p&gt;\[ \mathbf v ^{2} = [ 0 - \mathbf v\cdot \mathbf v, 0 * \mathbf v + 0 * \mathbf v + \mathbf v\times \mathbf v] \]&lt;/p&gt;

&lt;p&gt;\[ = [ - \mathbf v\cdot \mathbf v, 0 + 0 + 0] \]&lt;/p&gt;

&lt;p&gt;\[ = - \mathbf v\cdot \mathbf v \]&lt;/p&gt;

&lt;p&gt;\[ = - (x^{2} + y^{2} + z^{2}) \]&lt;/p&gt;

&lt;p&gt;\[ = -|\mathbf v|^{2} \]&lt;/p&gt;

&lt;p&gt;这时候设\( |\mathbf v| = θ  \) （注意，这个θ没有实际意义，只是一个临时符号），那么就有：&lt;/p&gt;

&lt;p&gt;\[ \mathbf v ^{2} =  -θ^{2} \ \ ，\ \ \mathbf v ^{3} =  -θ^{2}\mathbf v \ \ ，\ \ \mathbf v ^{4} = θ^{4}  \ \ ，\ \ \mathbf v ^{5} = θ^{4}\mathbf v \ \ ，\ \ \mathbf v ^{6} = -θ^{6} \ \ ，\cdots \]&lt;/p&gt;

&lt;p&gt;下一步，拿出指数函数使用极限形式的定义(证明见[2])：&lt;/p&gt;

&lt;p&gt;\[ e^{x} = \sum _{k=0}^{\infty } \frac {x^{k} }{k!} \ \ \ \ x是实数 \]&lt;/p&gt;

&lt;p&gt;把实数x替换成上面的四元数\(\mathbf v\)，并利用上面的数列，则得到：&lt;/p&gt;

&lt;p&gt;\[ e^{\mathbf v} = \sum _{k=0}^{\infty } \frac {\mathbf v^{k} }{k!} \]&lt;/p&gt;

&lt;p&gt;\[ = 1 + \frac {\mathbf v}{1!} - \frac {θ^{2}}{2!} - \frac {θ^{2}\mathbf v}{3!} + \frac {θ^{4}}{4!} + \frac {θ^{4}\mathbf v}{5!}  - \frac {θ^{6}}{6!} + \cdots = \]&lt;/p&gt;

&lt;p&gt;\[ = 1 + \frac {θ\mathbf v}{1!θ} - \frac {θ^{2}}{2!} - \frac {θ^{3}\mathbf v}{3!θ} + \frac {θ^{4}}{4!} + \frac {θ^{5}\mathbf v}{5!θ}  - \frac {θ^{6}}{6!} + \cdots = \]&lt;/p&gt;

&lt;p&gt;\[ = ( 1 - \frac {θ^{2}}{2!} + \frac {θ^{4}}{4!} - \frac {θ^{6}}{6!}  \cdots ) +  \frac { \mathbf v }{θ} ( \frac {θ}{1!} - \frac {θ^{3}}{3!} + \frac {θ^{5}}{5!} \cdots )  = \]&lt;/p&gt;

&lt;p&gt;\[ = cosθ + \frac { \mathbf v }{θ} sinθ  \]&lt;/p&gt;

&lt;p&gt;最后一步里，2个无穷数列变成三角函数，是用了泰勒公式[3]。&lt;/p&gt;

&lt;p&gt;然后，把假设出来的θ去掉，得到： &lt;/p&gt;

&lt;p&gt;\[ e^{\mathbf v}  = cos|\mathbf v| + \frac { \mathbf v }{|\mathbf v|} sin|\mathbf v|  \]&lt;/p&gt;

&lt;p&gt;所以有：&lt;/p&gt;

&lt;p&gt;\[ e^{q} = e^{ s +\mathbf {v}} = e^{s}e^{\mathbf v} =e^{s}( cos|\mathbf v| + \mathbf v \frac {sin |\mathbf v| } { |\mathbf v| } ) \]&lt;/p&gt;

&lt;p&gt;得证。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;[1] &lt;a href=&quot;http://math.stackexchange.com/questions/1030737/exponential-function-of-quaternion-derivation&quot;&gt;Exponential Function of Quaternion - Derivation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2]指数函数的泰勒展开公式的证明：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.songho.ca/math/taylor/taylor_exp.html&quot;&gt;MacLaurin series of Exponential function&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] cos sin三角函数的泰勒展开公式的证明：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.songho.ca/math/taylor/taylor_tri.html&quot;&gt;MacLaurin series of Trigonometric function&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://web.mit.edu/2.998/www/QuaternionReport1.pdf&quot;&gt;Quaternions, Interpolation and Animation&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 04 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/quaternion3/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/quaternion3/</guid>
      </item>
    
      <item>
        <title>四元数公式的补充</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;继上一篇四元数的文章&lt;a href=&quot;http://www.qiujiawei.com/understanding-quaternions/&quot;&gt;Understanding Quaternions 中文翻译《理解四元数》&lt;/a&gt;，已经过去一两年了。我发现那篇文章有一些细节没有讲得特别清楚，遂现在写一篇关于四元数公式的文章补缺下。&lt;/p&gt;

&lt;h2&gt;四元数的指数函数&lt;/h2&gt;

&lt;p&gt;先给出最终公式。设有任意四元数q：&lt;/p&gt;

&lt;p&gt;\[q = s + x\mathbf i + y\mathbf j + z\mathbf k = s + \mathbf {v} = [s,\mathbf {v}] = [s,\mathbf 0] + [0,\mathbf {v}] \]&lt;/p&gt;

&lt;p&gt;则有：&lt;/p&gt;

&lt;p&gt;\[ e^{q} = e^{ s +\mathbf {v}} = e^{s}e^{\mathbf v} =e^{s}( cos|\mathbf v| + \mathbf v \frac {sin |\mathbf v| } { |\mathbf v| } ) \]&lt;/p&gt;

&lt;h3&gt;推导过程&lt;/h3&gt;

&lt;p&gt;首先搬出四元数的&lt;strong&gt;乘积&lt;/strong&gt;公式：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [s_{a},\mathbf {a}] \]&lt;/p&gt;

&lt;p&gt;\[ q_{b} = [s_{b},\mathbf {b}] \]&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [s_{a}s_{b} - a\cdot b, s_{a}b+s_{b}a+a\times b] \]&lt;/p&gt;

&lt;p&gt;代入上面的\( \mathbf v = 0 + x\mathbf i + y\mathbf j + z\mathbf k \)，得到：&lt;/p&gt;

&lt;p&gt;\[ \mathbf v ^{2} = [ 0 - \mathbf v\cdot \mathbf v, 0 * \mathbf v + 0 * \mathbf v + \mathbf v\times \mathbf v] \]&lt;/p&gt;

&lt;p&gt;\[ = [ - \mathbf v\cdot \mathbf v, 0 + 0 + 0] \]&lt;/p&gt;

&lt;p&gt;\[ = - \mathbf v\cdot \mathbf v \]&lt;/p&gt;

&lt;p&gt;\[ = - (x^{2} + y^{2} + z^{2}) \]&lt;/p&gt;

&lt;p&gt;\[ = -|\mathbf v|^{2} \]&lt;/p&gt;

&lt;p&gt;这时候设\( |\mathbf v| = θ  \) （注意，这个θ没有实际意义，只是一个临时符号），那么就有：&lt;/p&gt;

&lt;p&gt;\[ \mathbf v ^{2} =  -θ^{2} \ \ ，\ \ \mathbf v ^{3} =  -θ^{2}\mathbf v \ \ ，\ \ \mathbf v ^{4} = θ^{4}  \ \ ，\ \ \mathbf v ^{5} = θ^{4}\mathbf v \ \ ，\ \ \mathbf v ^{6} = -θ^{6} \ \ ，\cdots \]&lt;/p&gt;

&lt;p&gt;下一步，拿出指数函数使用极限形式的定义(证明见[2])：&lt;/p&gt;

&lt;p&gt;\[ e^{x} = \sum _{k=0}^{\infty } \frac {x^{k} }{k!} \ \ \ \ x是实数 \]&lt;/p&gt;

&lt;p&gt;把实数x替换成上面的四元数\(\mathbf v\)，并利用上面的数列，则得到：&lt;/p&gt;

&lt;p&gt;\[ e^{\mathbf v} = \sum _{k=0}^{\infty } \frac {\mathbf v^{k} }{k!} \]&lt;/p&gt;

&lt;p&gt;\[ = 1 + \frac {\mathbf v}{1!} - \frac {θ^{2}}{2!} - \frac {θ^{2}\mathbf v}{3!} + \frac {θ^{4}}{4!} + \frac {θ^{4}\mathbf v}{5!}  - \frac {θ^{6}}{6!} + \cdots = \]&lt;/p&gt;

&lt;p&gt;\[ = 1 + \frac {θ\mathbf v}{1!θ} - \frac {θ^{2}}{2!} - \frac {θ^{3}\mathbf v}{3!θ} + \frac {θ^{4}}{4!} + \frac {θ^{5}\mathbf v}{5!θ}  - \frac {θ^{6}}{6!} + \cdots = \]&lt;/p&gt;

&lt;p&gt;\[ = ( 1 - \frac {θ^{2}}{2!} + \frac {θ^{4}}{4!} - \frac {θ^{6}}{6!}  \cdots ) +  \frac { \mathbf v }{θ} ( \frac {θ}{1!} - \frac {θ^{3}}{3!} + \frac {θ^{5}}{5!} \cdots )  = \]&lt;/p&gt;

&lt;p&gt;\[ = cosθ + \frac { \mathbf v }{θ} sinθ  \]&lt;/p&gt;

&lt;p&gt;最后一步里，2个无穷数列变成三角函数，是用了泰勒公式[3]。&lt;/p&gt;

&lt;p&gt;然后，把假设出来的θ去掉，得到： &lt;/p&gt;

&lt;p&gt;\[ e^{\mathbf v}  = cos|\mathbf v| + \frac { \mathbf v }{|\mathbf v|} sin|\mathbf v|  \]&lt;/p&gt;

&lt;p&gt;所以有：&lt;/p&gt;

&lt;p&gt;\[ e^{q} = e^{ s +\mathbf {v}} = e^{s}e^{\mathbf v} =e^{s}( cos|\mathbf v| + \mathbf v \frac {sin |\mathbf v| } { |\mathbf v| } ) \]&lt;/p&gt;

&lt;p&gt;得证。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;[1] &lt;a href=&quot;http://math.stackexchange.com/questions/1030737/exponential-function-of-quaternion-derivation&quot;&gt;Exponential Function of Quaternion - Derivation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2]指数函数的泰勒展开公式的证明：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.songho.ca/math/taylor/taylor_exp.html&quot;&gt;MacLaurin series of Exponential function&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] cos sin三角函数的泰勒展开公式的证明：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.songho.ca/math/taylor/taylor_tri.html&quot;&gt;MacLaurin series of Trigonometric function&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://web.mit.edu/2.998/www/QuaternionReport1.pdf&quot;&gt;Quaternions, Interpolation and Animation&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 04 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/quaternion2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/quaternion2/</guid>
      </item>
    
      <item>
        <title>forwarder的应用</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.4/2.jpg&quot; alt=&quot;2.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;这是我在开发的游戏的通信架构图。&lt;/p&gt;

&lt;p&gt;这里面除开GS和数据库后端的连接，其他连接都基于forwarder。&lt;/p&gt;

&lt;p&gt;下面的客户端C连接，涵盖了三大平台：web、ios、android客户端。都可以通过forwarder和服务器通讯。&lt;/p&gt;

&lt;p&gt;这套系统已经熬过了压力测试。之前写了robot程序，几千机器人并发登录和战斗。刚开始压力测试时，确实forwarder崩了，经过几轮测试、调试、修bug，现在已经能完美运行。有信心可以做到超长时间不停机。单个服务器节点(16核16G内存)可以同时处理上万场战斗。增加cpu核心数和内存，还可以继续增大负载。&lt;/p&gt;

&lt;p&gt;解决了通信问题后，这套架构剩下的问题就是用户规模问题。越高的用户规模，就越需要仔细思考架构的每个地方是否会出现负载瓶颈。&lt;/p&gt;

&lt;p&gt;其实，我们的架构目标是&lt;strong&gt;分布式&lt;/strong&gt;，分布式就是说，后端是一个服务器集群，服务器数量可随意增加减少，就像cpu的核心数，核心越多，并发性能越好。总之，我们的后端服务器可以横向扩展，用户增多-&amp;gt;增加服务器。这样子是比较省事的。但实际上要做到这点很难。预期的最高同时在线用户数、预期的总注册用户总数，是做架构设计的2个指标。&lt;/p&gt;

&lt;p&gt;另外，我们做的是&lt;strong&gt;世界服&lt;/strong&gt;。玩家不需要选择服务器登录。对于玩家来说，只有一个服。不过对于后端来说，当然还是要分服的。这也是使得我们可以做分布式架构的原因。世界服若要做分服，就是分服务器集群。例如可以ios用户一个集群，android用户一个集群，两个集群完全隔离。&lt;/p&gt;

&lt;p&gt;其实游戏服务器架构很看游戏设计，但不管怎么变，都是要做网络通信的，基于forwarder去做跨进程、跨机器、跨机房通信，非常简单。只需要设置host和port即可。&lt;/p&gt;

&lt;p&gt;因为是公司项目，这里就不过多描述细节了。架构图仅供参考。&lt;/p&gt;
</description>
        <pubDate>Sun, 02 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/forwarder-application/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/forwarder-application/</guid>
      </item>
    
      <item>
        <title>实时战斗游戏的同步——demo实战</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;在GGJ2017上，我做了一个&lt;strong&gt;局域网联机&lt;/strong&gt;对战小游戏：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.4/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;本文将记录这个游戏的技术演化过程。&lt;/p&gt;

&lt;h3&gt;技术阶段1——局域网暴力帧同步&lt;/h3&gt;

&lt;p&gt;因为开发时间只有不到48小时，为了实现强一致性的复杂战斗（复杂之处主要在攻击方块上），我因此开发了一个暴力的帧同步系统。为什么说暴力呢？这是因为数据传输上相当不计开销：我每一个关键帧都要把整场战斗的数据打包广播给客户端。&lt;/p&gt;

&lt;p&gt;实际上，要实现这么暴力的同步方案也是有前提的。前提就是要实现&lt;strong&gt;数据驱动&lt;/strong&gt;的战斗，即战斗的每一逻辑帧的状态信息，可以简单提取成json之类的数据格式。也就是说，战斗需要实现save和load函数，save()返回战斗当前的状态数据data，load(data)则可以把任意战斗状态数据载入，使得战斗立即变成data的状态。&lt;/p&gt;

&lt;p&gt;当时已经实现了这一技术点。使得这游戏的同步问题很简单：我只需要保证单个服务端、多个客户端的战斗的data都是一样的就行了。&lt;/p&gt;

&lt;p&gt;也正因为暴力，我后来试了下把服务端放在阿里云上运行，非局域网联机的话，卡到飞起。&lt;/p&gt;

&lt;h3&gt;技术阶段2——只同步玩家操作输入&lt;/h3&gt;

&lt;p&gt;最近把代码翻了一遍，并换成使用我开发的forwarder库（之前用了npm上的websocket库），虽然对游戏表现没有什么实质的影响。另外，我把上一阶段里面的暴力同步代码干掉了，现在只需要同步玩家操作输入数据就可以了。&lt;/p&gt;

&lt;p&gt;流程大概是：A客户端点击移动-&amp;gt;A客户端向服务端发向前移动的操作包-&amp;gt;服务端验证A的操作包-&amp;gt;将操作包放到下一关键帧的玩家输入列表-&amp;gt;服务端的帧逻辑系统更新到下一关键帧，处理该帧的玩家操作输入，并把操作输入广播到各个客户端-&amp;gt;各个客户端收到广播包时，先缓存起来，当客户端自己的帧逻辑系统更新到这一关键帧时，也同样处理该帧的玩家操作输入。&lt;/p&gt;

&lt;p&gt;这个流程其实和旧版区别不大。除了逻辑层，表现层没有改动，也就是所在画面表现上和旧版一致。唯一区别就是，现在这个版本在&lt;strong&gt;非局域网&lt;/strong&gt;也能勉强运行了。因为服务端发包减少了不少，客户端处理数据包压力也小了，性能大大改善。&lt;/p&gt;

&lt;p&gt;但仍然有2个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;关键帧卡顿。这是因为服务端、客户端在按同个频率(目前LogicFPS=50)更新战斗时，客户端在到达关键帧后就会暂停并等待服务端的关键帧包，而因为非局域网网络有20-50ms的延迟，即使服务端更新游戏逻辑没有cpu计算上的延迟，也要受到这个网络延迟的制约，所以就会有卡顿感。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作响应有延迟。这是因为客户端的操作包要先发送到服务端，然后服务端在下一个关键帧再发回来，客户端才能处理到这个操作包。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;技术阶段3——改善玩家体验的细节技术(开发ing)&lt;/h3&gt;

&lt;p&gt;技术阶段2的实现是正确的，当前阶段的目标是怎么优化那2个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;关键帧如何不卡顿？我想象中的解决方案是，画面更新和逻辑更新要做一些分离。例如，在客户端等待服务端关键帧包的时间内，游戏画面不能静止不动，而是要做&lt;strong&gt;预测&lt;/strong&gt;。所有具有速度矢量的游戏实体都可以按照速度方向在关键帧包到达前继续自行运动，当关键包收后时，逻辑层驱动表现层，校验并矫正下位置即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作响应必须无延迟！和解决卡顿感的方法类似，玩家点击前进键，表现层的player就开始按照&lt;strong&gt;预测的&lt;/strong&gt;运动速度开始移动，并且需要应用我在上一篇文章里提到的技术：服务端需要尽可能相信客户端的位置。不然，即使客户端能够在操作发出时立即开始移动，但最终还是要以逻辑层的位置为主，而逻辑层的位置必然是有延迟的，也就是说，player虽然提前移动了，但最后又拉扯回去。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 01 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/game-synchronize2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/game-synchronize2/</guid>
      </item>
    
      <item>
        <title>实时战斗游戏的同步——问题分析</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;做了几年游戏服务端编程，目前对战斗系统、网络通信这些东西也比较熟悉了，就差一些细节问题没打通。所以下文将记录我对战斗同步算法的思考。&lt;/p&gt;

&lt;h2&gt;两种同步技术的对比：状态同步和帧同步&lt;/h2&gt;

&lt;h3&gt;状态同步&lt;/h3&gt;

&lt;p&gt;状态同步算法，我自己的理解是，在联网游戏里面，通过同步所有游戏实体的&lt;strong&gt;状态&lt;/strong&gt;信息，来同步多个客户端。以球球大作战这个游戏为例，用状态同步算法去同步的过程应该是这样子的：每个玩家的每个球都是一个游戏实体(按了分裂键后会一变多)，每个实体有自己的坐标、速度、加速度、图标等&lt;strong&gt;状态信息&lt;/strong&gt;，每个客户端都需要有这些信息，当所有客户端再任意一个时刻，这些信息都是一致的话，那么就是完美同步。状态同步算法的目标就是通过各种手段，使得各个实体的状态信息在各个客户端一直保持&lt;strong&gt;一致&lt;/strong&gt;或者&lt;strong&gt;近似&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;具体去实现这种状态同步技术，会遇到三大问题：&lt;strong&gt;网络延迟对状态信息同步的干扰问题、玩家操作体验问题、同步对象过多问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;假设网络环境是完美，例如延迟小于1ms（局域网游戏就做得到），玩家的任意操作对游戏实体的影响，都可以瞬时同步到其他客户端，那么对于游戏过程就没什么影响。反之，如果网络环境差(延迟大于1000ms)，那么所有客户端的同步9成9不会一致，如果是服务器本身的问题导致延迟高，那么所有客户端都会卡，如果是单个客户端的延迟高，那么这个客户端会卡，而其他客户端一般不受影响。&lt;/p&gt;

&lt;p&gt;玩家操作体验问题，是一个可以巧妙解决的问题。这个问题要处理好，关键点在于操作响应速度。譬如，玩家点了前进键，过了0.5秒后才开始动，和瞬间就开始动，感受完全不同的。（就像打开一个网站主页，花了0.5秒还是1秒、2秒、5秒，有很大的用户体验差距）。这个问题可以细分成各种各样的小问题，对于MMORPG，最主要的问题是位置同步，必须让玩家点了前进键，就立即开始移动，同时又要保证其他客户端的‘我’和自己客户端的‘我’是一致的位置。这个问题的解决方案就是著名的位置预测和位置拉扯技术。这里就不详述了。除了控制移动之外，玩家一般还会有很多操作，但这些操作一般对延迟的忍受都比较高，例如换装、购物，1秒左右的延迟都是可以忍受住的。&lt;/p&gt;

&lt;p&gt;状态同步还有一大问题是同步对象数量过多的问题。这个问题的产生是因为，状态同步为了同步各个客户端里各个游戏对象的状态，需要不断发送游戏对象的状态信息。先不考虑发送频率的问题，单单考虑游戏对象数量，问题就很可怕了。假设现在游戏关卡里面有10个玩家，但是每个玩家有100只宠物辅助战斗，每个宠物根据自己的AI作战，那么就是说1000个游戏实体需要同步。假设每个实体平均1秒就会发一个状态包，1000个实体的话，平均每毫秒就得发一个包。简直不可能做到。&lt;/p&gt;

&lt;p&gt;对象数量问题，比前两个问题更难搞，一般解决方法就是在游戏设计上设限制，保持同屏的同步对象不会过多。而在技术上只能是尽量降低单个对象的同步开销，使得数量上限高一点。&lt;/p&gt;

&lt;h2&gt;帧同步&lt;/h2&gt;

&lt;p&gt;帧同步技术的第一个要点就是，游戏的战斗必须变成一个确定性函数系统。确定性函数系统的特征是，给定固定的输入参数，这个系统就会有固定的输出（类似hash表结构）。为了做到这一点，就必须剔除掉战斗系统的&lt;strong&gt;各种不确定性因素&lt;/strong&gt;，例如随机数生成器必须可控，浮点数计算在不同机器上计算结果需要一致等。&lt;/p&gt;

&lt;p&gt;除此之外，一个战斗系统，必然是支持&lt;strong&gt;逐帧更新&lt;/strong&gt;的，这个机制就好比实时渲染系统，每秒渲染60个画面（离散），当FPS足够高时，画面看起来就是&lt;strong&gt;连续&lt;/strong&gt;的。在支持了逐帧更新后，这个战斗系统就是我所认为的&lt;strong&gt;帧逻辑系统&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为什么大费周章地把战斗系统变成这样子呢？这是因为帧同步可以解决状态同步所不能解决的那第三个问题：游戏实体过多问题。这是因为，基于帧同步的游戏战斗系统，需要做多客户端同步的东西并不是各个实体的状态信息，而是&lt;strong&gt;玩家的操作输入&lt;/strong&gt;。因为一个确定性函数系统，给定固定输入后，就必然会有固定的输出，那么只要保证各个客户端的战斗系统是同一个确定性函数系统，并且保证各个客户端的玩家操作（函数输入）都是一致的，那么所得到的每一逻辑帧的战斗状态就是一致的。&lt;/p&gt;

&lt;p&gt;但可惜的是，帧同步技术依然要面临网络延迟问题和玩家操作体验问题。&lt;/p&gt;

&lt;p&gt;基于帧逻辑系统的游戏战斗系统的设计要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端-服务端都需要有战斗代码&lt;/li&gt;
&lt;li&gt;以服务端的帧逻辑系统为准，客户端依据服务端保持同步&lt;/li&gt;
&lt;li&gt;客户端之间不互相等待，避免1个客户端卡，导致所有其他客户端也卡&lt;/li&gt;
&lt;li&gt;因为第3点的存在，服务端帧逻辑系统是不等待客户端的，不管客户端状态如何，服务端一直按照固定的时间间隔迭代更新&lt;/li&gt;
&lt;li&gt;玩家的操作包不能本地立即处理，而是需要先发给服务端，服务端汇集所有客户端操作包并等待下一个关键帧，服务端到达下一个关键帧时，把汇集的操作包广播给所有客户端，客户端收到关键帧操作包后，才能继续更新帧逻辑系统，没有收到前，客户端到达关键帧时需要暂停逻辑更新&lt;/li&gt;
&lt;li&gt;因为第5点，玩家的各种操作会有延迟，延迟间隔为( 收到服务端关键帧信息包t1 - 发送操作包时刻t0)，因此理论上最大延迟值为关键帧间隔时间，这个时间越小，操作延迟越低，但关键帧发包频率就越高，网络负担就越重，反过来说，这个时间越大，操作延迟越高，而关键帧发包频率变低。一般实时战斗游戏，延迟超过200ms就会造成对游戏体验的不良影响了，那么上关键帧最大间隔必须小于200ms&lt;/li&gt;
&lt;li&gt;非玩家控制角色，根据帧逻辑系统迭代更新，例如怪物的生成、移动、攻击、死亡等&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从玩家体验角度看，帧逻辑系统需要做到：
1. 玩家对自己的角色的操作，必须实时响应
2. 其他玩家的角色的操作包，需要尽可能快地发给自己，并播放出来
4. 玩家角色的关键判定，必须以帧逻辑系统为主，比如玩家的扣血、死亡、技能施放等&lt;/p&gt;

&lt;h3&gt;两种同步方案的综合总结&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;两种同步方案在实现位置同步的问题中，技术原理是大致的，都得用位置预测。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两者都需要尽可能相信客户端的移动操作。这是因为，假设A在t0时刻向前移动，服务端在t1时刻收到A的移动操作包时，A实际上已经以速度v移动了v*(t1 -t0)的距离，服务端可以根据A的速度v和时间差t1-t0，直接把A挪到新位置，这样就同步了客户端A和服务端A；剩下的问题就是同步服务端和其他客户端，仍然使用这个同步方法，服务端把A的移动包广播到其他客户端，其他客户端根据时间差，判定A的新位置，并使用仔细设计过的缓动逻辑，把A快速移动新位置，然后按照A当前的速度、加速度继续更新。当然，如果相信了客户端发来的信息，就存在作弊问题，就需要在反作弊上花一点心思。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;帧同步方案，对于负杂的游戏逻辑都可以轻松应对，反之，状态同步的游戏逻辑一般不能太复杂，因为需要时不时地做一次全局的游戏实体信息同步校对，毕竟每个客户端的状态没有强一致性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在帧同步中，除了移动操作之外的玩家操作，因为需要以帧系统为主，所以必须忍受一定时间的延迟，最大延迟时间一般在一个关键帧周期(200ms)；而在状态同步中，玩家操作只要服务端确认OK，就可以直接执行了，而不需要等到下个关键帧才执行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;帧同步方案可以为游戏带来一个额外加分，即&lt;strong&gt;回放系统&lt;/strong&gt;。一个高效的游戏回放系统必然是基于帧同步的，例如war3的replay文件，一场一个小时的多人游戏，replay文件仅仅只有不到1MB，这里面必然只是存储了战斗初始化数据以及最重要的&lt;strong&gt;所有玩家的操作输入数据&lt;/strong&gt;。除了war3，moba游戏如dota、王者荣耀、lol，非moba游戏如守望先锋、coc、东方project系列游戏（注意，coc和东方project比较特殊，战斗是单机战斗，不需要多端同步），都有这种帧回放系统。假如没有帧回放系统，游戏战斗过程的记录可能就只有录屏这个方案了，随便就是几百MB大小。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要应用帧同步技术，前提是这个游戏的战斗是&lt;strong&gt;有始有终&lt;/strong&gt;的。就是说，游戏要有&lt;strong&gt;场次&lt;/strong&gt;的概念，不能像MMORPG大地图模式、minecraft那样，游戏战斗没有明确的开始和结束时间点。这样的游戏模式，也就不需要回放系统了。同时也很难看到这类游戏同屏出现大量的游戏实体————不只是人物怪物，子弹这些小实体也要算进去。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了应用帧同步方案，需要客户端和服务端都有战斗的代码，那么也就是说，这份代码一般都得是同种语言缩写，脚本语言js、python，或者native语言c++都行，就是要保持一致。基本不可能用不同的语言写出同样的战斗系统，即使你能做到，也很难保证以后维护过程不出bug，而且开发成本急剧升高。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 31 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/game-synchronize/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/game-synchronize/</guid>
      </item>
    
      <item>
        <title>微分几何与渲染(1)</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;参数坐标——uv坐标系&lt;/h2&gt;

&lt;p&gt;在ComputerGraphics(CG)中，一般称纹理坐标是uv坐标，但其实uv坐标还有别的用处，例如下文将介绍的微分几何方程。&lt;/p&gt;

&lt;p&gt;既然被叫做uv坐标，那么它只有2个变量，但要注意，uv坐标和初中课本里面的xy坐标是不一样的，uv坐标可以用在&lt;strong&gt;曲面和平面&lt;/strong&gt;，而xy坐标只能处理平面。&lt;/p&gt;

&lt;p&gt;举个好理解的例子：一个完整的Sphere的uv坐标是什么呢？首先，定义一个球需要2个信息：球心坐标\( \vec o \)和半径r。&lt;/p&gt;

&lt;p&gt;接着，对于球面上某个点，要怎么表示呢？中学几何课本里会这样子写：&lt;/p&gt;

&lt;p&gt;\[ x^ 2 + y^ 2 + z^ 2 = r^ 2  \]&lt;/p&gt;

&lt;p&gt;则有：&lt;/p&gt;

&lt;p&gt;\[ p = (\vec o, r, x, y, z) \]&lt;/p&gt;

&lt;p&gt;参数可以进一步，第一个方法是应用球坐标系（Spherical coordinate），即用2个角\(\theta \)、\(\phi \)定位球面上的一个点：&lt;/p&gt;

&lt;p&gt;\[ p = (\vec o, r, \theta, \phi ) ， 0 \leq \theta \leq π， 0 \leq \phi \leq 2π  \]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017.3/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这些球面点当然也有uv坐标表示法：&lt;/p&gt;

&lt;p&gt;\[ p = (\vec o, r, u, v ) \]&lt;/p&gt;

&lt;p&gt;可以看到， θφ坐标和uv坐标都是可以表示曲面上的点的，而且都是2个变量，所以它们之间存在某种转换关系：&lt;/p&gt;

&lt;p&gt;\[ u=sinθcosϕ \]
\[ v=sinθsinϕ \]&lt;/p&gt;

&lt;p&gt;因为θ、φ是线性无关的，那么uv的取值范围为：&lt;/p&gt;

&lt;p&gt;\[ -1 \leq u \leq 1， -1 \leq v \leq 1 \]&lt;/p&gt;

&lt;p&gt;这个取值范围可以做一下转换，去掉负数：&lt;/p&gt;

&lt;p&gt;\[ u&amp;#39; = \frac {1}{2}(u + 1),   0 \leq u&amp;#39; \leq 1 \]&lt;/p&gt;

&lt;p&gt;\[ v&amp;#39; = \frac {1}{2}(v + 1),   0 \leq v&amp;#39; \leq 1 \]&lt;/p&gt;

&lt;p&gt;另外，当uv坐标作为纹理坐标时，uv坐标的取值范围是 \( 0 \leq u \leq 1 \)，\( 0 \leq v \leq 1 \)。&lt;/p&gt;

&lt;h2&gt;三角面片中的偏微分方程&lt;/h2&gt;

&lt;p&gt;每个mesh都是由有限数量的三角面片(下文简称Tri)组成，在渲染过程中，处理一个Tri和处理一堆Tri是一样的算法，所以只要解决单个Tri的渲染问题，就能渲染复杂的mesh。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017.3/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;假设上面这个图里的三角形表示mesh中的一个三角面片，三个顶点分别为：&lt;/p&gt;

&lt;p&gt;\[ \vec p_{0} = (x_{0}, y_{0}, z_{0}) \]&lt;/p&gt;

&lt;p&gt;\[ \vec p_{1} = (x_{1}, y_{1}, z_{1}) \]&lt;/p&gt;

&lt;p&gt;\[ \vec p_{2} = (x_{2}, y_{2}, z_{2}) \]&lt;/p&gt;

&lt;p&gt;虽然是三维的面片(顶点坐标有3个分量)，但我们可以把这个Tri想象成在一个二维空间里，并且设想这个二维平面上有一个原点\( \vec p_{o} \)(o代表origin), \( \vec p_{o} \)和Tri的相对位置取决于Tri三个顶点的uv坐标值。&lt;/p&gt;

&lt;p&gt;既然有了 \( \vec p_{o} \)，就可以用方程表示三个顶点了：&lt;/p&gt;

&lt;p&gt;\[ \vec p_{0} = \vec p_{o} + u_{0}\frac { \partial \vec p }{ \partial u } + v_{0}\frac { \partial \vec p }{ \partial v } \]&lt;/p&gt;

&lt;p&gt;\[ \vec p_{1} = \vec p_{o} + u_{1}\frac { \partial \vec p }{ \partial u } + v_{1}\frac { \partial \vec p }{ \partial v } \]&lt;/p&gt;

&lt;p&gt;\[ \vec p_{2} = \vec p_{o} + u_{2}\frac { \partial \vec p }{ \partial u } + v_{2}\frac { \partial \vec p }{ \partial v } \]&lt;/p&gt;

&lt;p&gt;这3个方程里总共有3个未知量：\( \vec p_{o}、\frac { \partial \vec p }{ \partial u }、\frac { \partial \vec p }{ \partial v } \)。\( \vec p_{o} \)是可以消去的，后面的2个偏微分才是我们要求出来的。&lt;/p&gt;

&lt;p&gt;要求这2个偏微分，需要先列出2个方程以便消去\( \vec p_{o} \)：\( \vec p_{0} - \vec p_{2} 、 \vec p_{1} - \vec p_{2} \)：&lt;/p&gt;

&lt;p&gt;\[ \vec p_{0} - \vec p_{2} = (u_{0} - u_{2})\frac { \partial \vec p }{ \partial u } +  (v_{0} - v_{2})\frac { \partial \vec p }{ \partial v } \]&lt;/p&gt;

&lt;p&gt;\[ \vec p_{1} - \vec p_{2} = (u_{1} - u_{2})\frac { \partial \vec p }{ \partial u } +  (v_{1} - v_{2})\frac { \partial \vec p }{ \partial v } \]&lt;/p&gt;

&lt;p&gt;然后把这2个方程写成矩阵乘法的形式：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} u_{0} - u_{2}&amp;amp;  v_{0} - v_{2}\\   u_{1} - u_{2}&amp;amp;  v_{1} - v_{2}\\ \end{matrix} \right]  \left[ \begin{matrix} \frac { \partial \vec p }{ \partial u }\\   \frac { \partial \vec p }{ \partial v }\\ \end{matrix} \right] =  \left[ \begin{matrix}  \vec p_{0} - \vec p_{2} \\   \vec p_{1} - \vec p_{2}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;再根据矩阵初级变换，有：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} \frac { \partial \vec p }{ \partial u }\\   \frac { \partial \vec p }{ \partial v }\\ \end{matrix} \right] =  \left[ \begin{matrix} u_{0} - u_{2}&amp;amp;  v_{0} - v_{2}\\   u_{1} - u_{2}&amp;amp;  v_{1} - v_{2}\\ \end{matrix} \right] ^{-1}  \left[ \begin{matrix}  \vec p_{0} - \vec p_{2} \\   \vec p_{1} - \vec p_{2}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;再根据二阶矩阵的逆矩阵公式：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} a&amp;amp; b\\  c&amp;amp; d\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ A^{-1} = \frac {1}{ad - bc}  \left[ \begin{matrix} d&amp;amp; -b\\  -c&amp;amp; a\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;上式的逆矩阵可以变成：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} u_{0} - u_{2}&amp;amp;  v_{0} - v_{2}\\   u_{1} - u_{2}&amp;amp;  v_{1} - v_{2}\\ \end{matrix} \right] ^{-1} = \frac {1}{(u_{0} - u_{2})(v_{1} - v_{2}) - (v_{0} - v_{2})(u_{1} - u_{2})}   \left[ \begin{matrix} v_{1} - v_{2}&amp;amp; -(v_{0} - v_{2})\\  -(u_{1} - u_{2})&amp;amp; u_{0} - u_{2}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;总结一下：3维空间中，某3个不同顶点组成的三角平面上的任意点\( \vec p \)关于u、v的偏微分的值完全一致，且可以通过三个顶点的xyz坐标和uv坐标求得。&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/partial-derivatives/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/partial-derivatives/</guid>
      </item>
    
      <item>
        <title>forwarder概况</title>
        <description>&lt;p&gt;5个月没更新博客，是因为这段时间主要用在开发&lt;a href=&quot;https://github.com/voyagingmk/forwarder&quot;&gt;forwarder&lt;/a&gt;。forwarder是因为工作需要而开发的一个工具，它统一了游戏前后端之间、后端各个服务之间的通信，目前forwarder不仅已经通过了初步的压力和稳定性测试，并且已经在项目中发挥了实际作用。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;目前成果&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;已经实现两种通信模式：enet(udp)和websocket(http based tcp)的一键切换&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们一开始用了websocket来实现服务端和客户端之间的通信。服务端架构做深入后，涌现了复杂的多服务器间通信的需求，为求快速开发，我们用上了npm上的一个websocket库，这样前后端、后端之间的通信模式就统一了：js + websocket。但是这个websocket库偶而会出现一个莫名其妙的error，第三方库的原因，修复无望，也不想死磕这个websocket，于是发现了新的方案：enet。&lt;/p&gt;

&lt;p&gt;enet是一个神奇的库，它把udp通信做了一层封装，使得通过enet通信，不仅可以发不可靠的udp，也可以发可靠的udp，使得通过udp也可以做网游（作者似乎也是某个游戏公司的）。&lt;/p&gt;

&lt;p&gt;更重要的是，tcp相比udp，有一个缺点，在网络状况不好时，tcp表现得很差，原因是RTO（Retransmission TimeOut)重传定时器跟不上RTT（Round Trip Time）的变化（这也是tcp的故意设计）。具体细节推荐这篇文章：&lt;a href=&quot;http://blog.csdn.net/heiyeshuwu/article/details/46402517&quot;&gt;TCP超时重传机制探索&lt;/a&gt;。RTO过高时，延迟就会变大，对有实时联网战斗的游戏是致命的。&lt;/p&gt;

&lt;p&gt;除了可靠性，enet还有很多features：有序、连接管理、带宽控制、跨平台等，都是无缝地从tcp通信切换到enet通信的有利条件。&lt;/p&gt;

&lt;p&gt;但我们项目如果要切换到enet还有很多问题，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们的web版客户端无法嵌入enet库（因为浏览器不支持），即使服务端支持了enet，web客户端也无法与之建立通信&lt;/li&gt;
&lt;li&gt;websocket在浏览器的js、spidermonkey的js、node.js（npm有现成的库），都算是内置的功能，但enet就需要我们自行解决这些平台问题了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，forwarder就应运而生了。forwarder对通信方式做了一层简单的抽象，把enet亦或者websocket都隐藏了，使得通过forwarder做通信时，不需要太关心通信方式细节。&lt;/p&gt;

&lt;p&gt;对于上面第一个问题就有了解决方案，服务端只需要开放2个访问端口，一个tcp(websocket)、一个udp(enet)，前者给web客户端连接，后者给支持enet的客户端连接，例如手机端、PC端。forwarder收到websocket线路来的包时，也交给enet线路的packer_handler处理就可以了，发包接口也类似。&lt;/p&gt;

&lt;p&gt;第二个问题的处理就是写driver，forwarder对收发的packet包一层scheme，用于做加密等功能，而web端既然无法使用forwarder的代码，那么就只能写一个scheme parser和一套简易的forwarder-js接口，实现解包、压包；node.js的话也实现了一个&lt;a href=&quot;https://www.npmjs.com/package/forwarder-node&quot;&gt;forwarder-node&lt;/a&gt;了；而spidermonkey或者说cocos2d-x中的spidermonkey，我也写了一套driver用于项目中。&lt;/p&gt;

&lt;p&gt;汇总下目前已经实现的driver：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;node.js&lt;/li&gt;
&lt;li&gt;spidermonkey(cocos2d-x)&lt;/li&gt;
&lt;li&gt;unity

&lt;ul&gt;
&lt;li&gt;windows&lt;/li&gt;
&lt;li&gt;ios&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有一个driver是web-js。因为浏览器不支持native代码，所以我实现了一个纯js版本的forwarder协议解析器，并封装了和其他driver一样的forwarder接口。但这个解析器暂时不支持上述的加密、压缩等功能。要实现这些功能需要接入web版的AES加密插件等，暂时还不必要。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;动态长度header，支持加密、压缩、base64、ip查询&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;加密使用了AES算法，密钥要求128位；压缩使用了zlib库；动态长度header是指，在不开启任何功能时，单个packet的header最少需要8个字节，根据开启的flag，header会动态增长。（初期写了固定长度的header，发现很不好使，中间重构了一遍）&lt;/p&gt;

&lt;h3&gt;以后计划&lt;/h3&gt;

&lt;p&gt;目前forwarder代码比较稳定，可以实际使用了，开发速度将放缓。&lt;/p&gt;

&lt;p&gt;forwarder目前待做的事项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;完善log代码&lt;/li&gt;
&lt;li&gt;完善API&lt;/li&gt;
&lt;li&gt;规范文档&lt;/li&gt;
&lt;li&gt;做新的通信模式：基于epoll&lt;/li&gt;
&lt;li&gt;针对各种需求，实现更多的driver层&lt;/li&gt;
&lt;li&gt;写测试代码&lt;/li&gt;
&lt;li&gt;protobuf插件？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;log这个东西必须得弄好，一是因为forwarder本身开发调试很需要看log情况，二是对于用户来说，让用户更好地中控forwarder的运行情况也是很有利的。API的设计，需要结合实际需求，最近因为项目需要，强行扩展了几个接口，之后还需要想办法弄好点。&lt;/p&gt;

&lt;p&gt;开发新通信模式，必要性在于，forwarder需要有属于自己的底层通信代码，就可以减少对第三方库的依赖了，例如可以把websocket、enet都变成插件代码，用户可以设置编译选项，决定要不要把websocket、enet编译进来。这样就可以减少forwarder代码体积了。&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/forwarder-progress/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/forwarder-progress/</guid>
      </item>
    
      <item>
        <title>forwarder开发备忘</title>
        <description>&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/voyagingmk/forwarder&quot;&gt;https://github.com/voyagingmk/forwarder&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;cmake&lt;/h1&gt;

&lt;h3&gt;1.windows下安装cmake&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://cmake.org/files/v3.7/cmake-3.7.0-rc1-win64-x64.msi&quot;&gt;https://cmake.org/files/v3.7/cmake-3.7.0-rc1-win64-x64.msi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;顺便可以下载cmake源码，源码里面有一个tests目录，有很多cmake工程可以参考，譬如官网的tutorials教程的代码都在tests里面了。&lt;/p&gt;

&lt;h3&gt;2.手写CMakeLists.txt&lt;/h3&gt;

&lt;p&gt;本文不谈cmake-gui的使用，原因是这东西界面有点怪，其次是cmake作为跨平台的构建系统，理应学习使用cmake的命令行模式，命令都是一致的，而cmake-gui是windows独有的。&lt;/p&gt;

&lt;p&gt;那么，在执行cmake构建指令前，需要在forwarder项目根目录下手写一个CMakeLists.txt文件。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;# 注：这个个CMakeLists.txt在将来的版本中会发生改动。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cmake_minimum_required&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VERSION&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# The version number.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FORWARDER_VERSION_MAJOR&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FORWARDER_VERSION_MINOR&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;include_directories&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;${PROJECT_SOURCE_DIR}/include&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;include_directories&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;${PROJECT_SOURCE_DIR}/enet&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_subdirectory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXTRA_LIBS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXTRA_LIBS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libenet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# add the executable&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_executable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target_link_libraries&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarder&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXTRA_LIBS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（这里推荐用vscode来编辑CMakeLists.txt，vscode有编辑CMakeLists.txt文件的插件，支持语法高亮和智能提示，很爽）&lt;/p&gt;

&lt;h3&gt;3.构建&lt;/h3&gt;

&lt;p&gt;forwarder项目目前用到了3个第三方库：enet、spdlog、rapidjson。&lt;/p&gt;

&lt;p&gt;spdlog和rapidjson是头文件形式的第三方库，直接把头文件放到include就可以了。&lt;/p&gt;

&lt;p&gt;enet则打算用静态链接的方式引入。需要建一个子目录&lt;strong&gt;enet&lt;/strong&gt;，然后添加enet的所有c文件、CMakeLists.txt。&lt;/p&gt;

&lt;p&gt;（其实可以把enet整个源码文件夹搬进来，不过我为了forwarder的东西更少些，所以只添加了enet的c文件和CMakeLists.txt）&lt;/p&gt;

&lt;p&gt;enet的CMakeLists.txt是作为根目录CMakeLists.txt的孩子存在的，由根目录的CMakeLists.txt来调用。&lt;/p&gt;

&lt;p&gt;有了这2个个CMakeLists.txt后，在根目录新建一个文件夹叫build，然后cmd进入这个目录，并执行：&lt;/p&gt;

&lt;p&gt;cmake ..&lt;/p&gt;

&lt;p&gt;就会自动在build目录生成visual studio项目，启动forwarder.sln，点生成解决方案，如果没报错，就说明构建成功了。&lt;/p&gt;

&lt;h1&gt;docker&lt;/h1&gt;

&lt;p&gt;用docker来测试forwarder在linux系统下的运行情况，非常方便。&lt;/p&gt;

&lt;h3&gt;1.首先windows安装docker：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.docker.com/products/overview&quot;&gt;https://www.docker.com/products/overview&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;2.然后设置share目录：&lt;/h3&gt;

&lt;p&gt;docker安装完毕后在任务栏会有一个图标，右键然后点setting：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/11.png&quot; alt=&quot;11.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/10.png&quot; alt=&quot;10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;注意红圈的内容，提示了我们开启share目录后，怎么在docker中用（其实就是-v指令）。&lt;/p&gt;

&lt;h3&gt;3.然后在cmd中执行：&lt;/h3&gt;

&lt;p&gt;docker run --rm -it -v D:\workplace\project\forwarder:/data ubuntu:latest&lt;/p&gt;

&lt;p&gt;run代表启动一个container；&lt;/p&gt;

&lt;p&gt;最后的参数ubuntu:latest代表使用ubuntu的最新版本镜像(image)&lt;/p&gt;

&lt;p&gt;其中的-rm作用是exit时会自动删除这个container；&lt;/p&gt;

&lt;p&gt;-it作用是设置成交互模式(interactive)；&lt;/p&gt;

&lt;p&gt;-v D:\workplace\project\forwarder:/data，是把windows的共享目录D:\workplace\project\forwarder 映射到container中的/data目录。&lt;/p&gt;

&lt;p&gt;第一次执行时，会从docker官方服务器下载ubuntu:latest镜像到本地，所以会比较慢。&lt;/p&gt;

&lt;p&gt;执行成功后，就进入这个临时生成的ubuntu的控制台啦！&lt;/p&gt;

&lt;h3&gt;4.在ubuntu中构建forward&lt;/h3&gt;

&lt;p&gt;第三步建立的ubuntu镜像不是持久化的，需要永久保存的镜像的话，需要自行写Dockerfile。&lt;/p&gt;

&lt;p&gt;在forwarder根目录下的docker目录我已经写了一个。cmd进入这个目录并执行：&lt;/p&gt;

&lt;p&gt;docker build -t myubuntu  .&lt;/p&gt;

&lt;p&gt;就开始在本地创建一个自定义的image镜像了。&lt;/p&gt;

&lt;p&gt;如果update太慢，可考虑更换国内的soureces，访问：&lt;a href=&quot;http://wiki.ubuntu.org.cn/%E6%A8%A1%E6%9D%BF:16.04source&quot;&gt;http://wiki.ubuntu.org.cn/%E6%A8%A1%E6%9D%BF:16.04source&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;把Dockerfile中的那些sources链接的地址替换成国内的镜像站点即可，例如我替换成阿里云的镜像站点。&lt;/p&gt;

&lt;p&gt;镜像生成完毕后，在任意目录执行命令：&lt;/p&gt;

&lt;p&gt;docker run --rm -it -v D:\workplace\project\forwarder:/data myubuntu&lt;/p&gt;

&lt;p&gt;此时，进入的ubuntu只是一个临时的无持久化的系统，若你修改了这个系统下的东西，exit退出后再执行上面的命令进入ubuntu，是不会看到之前的修改的。&lt;/p&gt;

&lt;p&gt;这个特性很适合用来做开发测试，保证了测试环境不会被轻易破坏掉。&lt;/p&gt;

&lt;h3&gt;5.apt-get的一些技巧&lt;/h3&gt;

&lt;p&gt;查询一个包的版本列表：&lt;/p&gt;

&lt;p&gt;apt-cache policy &lt;package name&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/forwarder-buildsystem/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/forwarder-buildsystem/</guid>
      </item>
    
      <item>
        <title>细说红黑树(2)-基本操作之Insert</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;本文争取用精简的文字描述清楚红黑树的各种基本操作：&lt;strong&gt;插入&lt;/strong&gt;、删除、查询。&lt;/p&gt;

&lt;p&gt;在开始下文之前，再次祭出红黑树的四大性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;根节点是黑色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;叶子节点（NULL）视为黑色节点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个节点是红色，那么它的2个孩子节点都是黑色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每条从根节点出发、并到达叶子节点的路径，路径上黑色节点的数量一致（叶子节点也计算在内）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;Insert&lt;/h1&gt;

&lt;p&gt;插入操作的第一个准则是，&lt;strong&gt;插入的节点先设置为红色&lt;/strong&gt;，插入后根据插入的节点在树中的&lt;strong&gt;位置&lt;/strong&gt;以及树的&lt;strong&gt;着色状态&lt;/strong&gt;，可以划分出多种情况，这些情况总结如下：&lt;/p&gt;

&lt;p&gt;（注意，在以下所有情况中，在节点插入前红黑树是平衡的，即使从图片上看并不能看出平衡性）&lt;/p&gt;

&lt;p&gt;1.插入的节点是根节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;显然无需调整红黑树。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2.插入的节点的父节点是&lt;strong&gt;黑&lt;/strong&gt;色&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;插入红节点，并不影响性质4。无需调整红黑树。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3.插入的节点的父节点是&lt;strong&gt;红&lt;/strong&gt;色&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3a.叔节点（即父节点的兄弟节点）也是&lt;strong&gt;红&lt;/strong&gt;色&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种情况下，需要把&lt;strong&gt;父、叔节点变为黑色，并把祖父节点变为红色&lt;/strong&gt;，这样就保证了当前局部范围内红黑树性质能够被满足，但因为祖父节点被改变了颜色，所以事情还没完，需要&lt;strong&gt;递归&lt;/strong&gt;本步骤（即把祖父节点当做是插入的节点），直到到达根节点。&lt;/p&gt;

&lt;p&gt;这个步骤被称为&lt;strong&gt;Recoloring&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3b.叔节点是&lt;strong&gt;黑&lt;/strong&gt;色&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当处于这个情况下，根据&lt;strong&gt;父节点相对祖父节点的位置（Left or Right）和  插入节点相对父节点的位置（Left or Right）&lt;/strong&gt;，总共有四种细分状态：&lt;/p&gt;

&lt;p&gt;i) Left-Left&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;右&lt;/strong&gt;旋转g&lt;/p&gt;

&lt;p&gt;2）交换g和p的颜色&lt;/p&gt;

&lt;p&gt;ii) Right-Right&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/6.png&quot; alt=&quot;6.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;左&lt;/strong&gt;旋转g&lt;/p&gt;

&lt;p&gt;2）交换g和p的颜色&lt;/p&gt;

&lt;p&gt;可以注意到，整个步骤和Left-Left非常相似，其实就是Left-Left的水平镜像。&lt;/p&gt;

&lt;p&gt;iii) Left-Right&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/7.png&quot; alt=&quot;7.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以用一个旋转操作把这个case转换成Left-Left的case，步骤如下：&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;左&lt;/strong&gt;旋转p&lt;/p&gt;

&lt;p&gt;iiii) Right-Left&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以用一个旋转操作把这个case转换成Right-Right的case，步骤如下：&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;右&lt;/strong&gt;旋转p&lt;/p&gt;

&lt;h2&gt;资料&lt;/h2&gt;

&lt;p&gt;本文配图使用yEd编辑：&lt;a href=&quot;http://www.yworks.com/products/yed/download&quot;&gt;http://www.yworks.com/products/yed/download&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/red-black-tree-set-2-insert/&quot;&gt;http://www.geeksforgeeks.org/red-black-tree-set-2-insert/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;红黑树测试程序：&lt;a href=&quot;https://www.cs.usfca.edu/%7Egalles/visualization/RedBlack.html&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/RedBlack.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/redblacktree-2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/redblacktree-2/</guid>
      </item>
    
  </channel>
</rss>