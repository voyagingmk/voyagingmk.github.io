<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>伪技术宅，兴趣点：服务器编程、游戏开发、人工智能</description>
    <link>http://www.qiujiawei.com</link>
    <atom:link href="http://www.qiujiawei.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>线性代数之奇异值分解 SVD Decomposition</title>
        <description>&lt;p&gt;在线性代数中，SVD是对实数矩阵(甚至复数矩阵)的一种因式分解。在信号、统计、图像图形学中都有应用。&lt;/p&gt;

&lt;p&gt;SVD非常强大且实用，因为数学界前辈已经证明任意的一个矩阵都可以做SVD分解。这一点特别重要，因为相比SVD分解，和SVD相近的特征值分解只能应用于方阵。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;SVD的定义&lt;/h2&gt;

&lt;p&gt;先给出公式的全貌：&lt;/p&gt;

&lt;p&gt;设有一个m X n的矩阵M，它的SVD分解是：&lt;/p&gt;

&lt;p&gt;\[ M = UΣV^{*} \]&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;U是一个m X m的单式矩阵(&lt;a href=&quot;https://en.wikipedia.org/wiki/Unitary_matrix&quot;&gt;Unitary Matrix&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Σ是m X n的矩形对角矩阵(&lt;a href=&quot;https://en.wikipedia.org/wiki/Diagonal_matrix&quot;&gt;Rectangular Diagonal Matrix&lt;/a&gt;)，并且在对角线上的元素都是非负实数\(\sigma _{i}\)，称为M的奇异值&lt;/li&gt;
&lt;li&gt;V*是一个n X n的单式矩阵，也是V的共轭转置矩阵(&lt;a href=&quot;https://en.wikipedia.org/wiki/Conjugate_transpose&quot;&gt;Conjugate Transpose Matrix&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些补充:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;U矩阵的m个列向量、V的n个列向量分别被称为M的左奇异向量，和M的右奇异向量&lt;/li&gt;
&lt;li&gt;约定Σ矩阵的对角线上的奇异值\(\sigma _{i}\)用降序排列&lt;/li&gt;
&lt;li&gt;由第2点可以看出，Σ矩阵完全由M决定，和U、V无关&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;SVD和特征值分解的联系&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;M的左奇异向量 是 \(MM^{*}\)的特征向量&lt;/li&gt;
&lt;li&gt;M的右奇异向量 是 \(M^{*}M\)的特征向量&lt;/li&gt;
&lt;li&gt;M的非零奇异值（即Σ的对角线上的元素）分别是\(M^{*}M\)以及\(MM^{*}\)的所有非零特征值的开平方&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由单式矩阵的定义，知：&lt;/p&gt;

&lt;p&gt;\[ U^{*}U = I = U^{-1}U \]&lt;/p&gt;

&lt;p&gt;\[ V^{*}V = I = V^{-1}V \]&lt;/p&gt;

&lt;p&gt;\[ U^{*} = U^{-1} \]&lt;/p&gt;

&lt;p&gt;\[ V^{*} = V^{-1} \]&lt;/p&gt;

&lt;p&gt;由矩形对角矩阵的定义，知：&lt;/p&gt;

&lt;p&gt;\[ Σ_{m,n}Σ_{m,n}^{*} = Σ_{m,n}Σ&amp;#39;_{n,m} = D_{m,m} \]&lt;/p&gt;

&lt;p&gt;\[ Σ_{m,n}^{*}Σ_{m,n} = Σ&amp;#39;_{n,m}Σ_{m,n} = D_{n,n} \]&lt;/p&gt;

&lt;p&gt;(D = Diagonal Square Matrix)&lt;/p&gt;

&lt;p&gt;即，Σ和Σ的转置相乘，等于一个新的方阵D，D的阶数等于左边的Σ矩阵的行数；D还是一个对角方阵，且对角线上的元素分别是Σ的对角线上的元素的平方。&lt;/p&gt;

&lt;p&gt;再根据SVD公式：&lt;/p&gt;

&lt;p&gt;\[ M = UΣV^{*} \]&lt;/p&gt;

&lt;p&gt;有：&lt;/p&gt;

&lt;p&gt;\[ M^{*}M = V\Sigma ^{*}U^{*}U\Sigma V^{*} = V\Sigma ^{*}(U^{*}U)\Sigma V^{*} = V\Sigma ^{*}\Sigma V^{*} = V(\Sigma  ^{*}\Sigma )V^{-1}  \]&lt;/p&gt;

&lt;p&gt;\[ MM^{*} = U\Sigma V^{*}V\Sigma ^{*}U^{*} = U\Sigma (V^{*}V)\Sigma ^{*}U^{*} = U\Sigma \Sigma ^{*}U^{*} = U(\Sigma \Sigma ^{*})U^{-1} \]&lt;/p&gt;

&lt;p&gt;右边的东西符合特征分解的定义，所以上述两式子都是特征分解。&lt;/p&gt;

&lt;h2&gt;SVD的求法&lt;/h2&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;https://en.wikipedia.org/wiki/Singular&lt;em&gt;value&lt;/em&gt;decomposition&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-9/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-9/</guid>
      </item>
    
      <item>
        <title>狄拉克δ函数(Dirac delta)和狄拉克梳状函数(Dirac comb)</title>
        <description>&lt;h2&gt;狄拉克δ函数(Dirac delta)&lt;/h2&gt;

&lt;p&gt;在卷积那篇文章中，已经提到了狄拉克δ函数的定义:&lt;/p&gt;

&lt;p&gt;\[ delta (t) =  \begin {cases} +\infty , t=0 \\  0, t\neq 0 \end {cases} \]&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }\delta (t)dt = 1 \]&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;下面介绍它的一些性质:&lt;/p&gt;

&lt;h4&gt;对称性质&lt;/h4&gt;

&lt;p&gt;从δ函数的波形图(或者定义)可以简单看出，δ函数是偶函数，即:&lt;/p&gt;

&lt;p&gt;\[ \delta (t) = \delta (-t) \]&lt;/p&gt;

&lt;h4&gt;缩放性质&lt;/h4&gt;

&lt;p&gt;设有常数a，令u = at，再依据δ函数的积分特性，有:&lt;/p&gt;

&lt;p&gt;\[ dt = \frac {1}{a}du \]&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }\delta (at)dt = \int _{-\infty }^{\infty }\delta (u)\frac {1}{a}du = \frac {1}{a} \int _{-\infty }^{\infty }\delta (u)du = \frac {1}{a} \]&lt;/p&gt;

&lt;p&gt;也即:&lt;/p&gt;

&lt;p&gt;\[ \delta (at) = \frac {1}{a}\delta (t) \]&lt;/p&gt;

&lt;p&gt;又因为它的对称性质，有:&lt;/p&gt;

&lt;p&gt;\[ \delta (at) = \frac {1}{|a|}\delta (t) \]&lt;/p&gt;

&lt;h4&gt;代数性质&lt;/h4&gt;

&lt;p&gt;\[ t\delta (t) = 0 \]&lt;/p&gt;

&lt;p&gt;这个太简单了，从基本定义出发可以很快看出来这个式子的正确性。&lt;/p&gt;

&lt;h4&gt;平移性质&lt;/h4&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }f(t)\delta (t - T)dt = f(T) \]&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;http://www.qiujiawei.com/convolution/&quot;&gt;理解卷积 Convolution&lt;/a&gt;中有对这个式子的详细讨论。当然从δ函数的定义去理解这个式子也很简单。&lt;/p&gt;

&lt;h4&gt;δ函数的傅里叶变换&lt;/h4&gt;

&lt;p&gt;\[ \mathcal {F}[\delta (s)] = \int _{-\infty }^{\infty }e^{-2\pi ist}\delta (t) = 1 \]&lt;/p&gt;

&lt;p&gt;因为只有当x等于0时，δ函数才非0(等于1)，所以这个式子的计算结果等于1。&lt;/p&gt;

&lt;p&gt;傅里叶变换后是一个常数1，这个性质看起来就很特别。&lt;/p&gt;

&lt;h2&gt;狄拉克梳状函数(Dirac comb)&lt;/h2&gt;

&lt;p&gt;这个函数在电子工程&lt;a href=&quot;https://en.wikipedia.org/wiki/Electrical_engineering&quot;&gt;electrical engineering&lt;/a&gt;中称为脉冲序列(impulse train)或采样函数(sampling function)。注意，有些文章会把它叫做Shah function。&lt;/p&gt;

&lt;p&gt;它其实就是关于狄拉克δ函数的用周期T间隔的无穷级数(多个δ函数的合并)。(wiki原文是:&lt;strong&gt;A Dirac comb is an infinite series of Dirac delta functions spaced at intervals of T&lt;/strong&gt;）&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;用图表示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/9.png&quot; alt=&quot;9.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图片来自wiki）&lt;/p&gt;

&lt;p&gt;公式表示:&lt;/p&gt;

&lt;p&gt;\[ III_{T}(t) = \sum _{k=-\infty }^{\infty }\delta (t - kT)\]&lt;/p&gt;

&lt;p&gt;这个公式和图片完全对应。&lt;/p&gt;

&lt;p&gt;下面介绍它的一些性质:&lt;/p&gt;

&lt;h4&gt;缩放性质&lt;/h4&gt;

&lt;p&gt;当T = 1（单位周期）时：&lt;/p&gt;

&lt;p&gt;\[ III(t) = \sum _{k=-\infty }^{\infty }\delta (t - k)\]&lt;/p&gt;

&lt;p&gt;这时再对t缩放a倍:&lt;/p&gt;

&lt;p&gt;\[ III(at) = \sum _{k=-\infty }^{\infty }\delta (at - k)\]&lt;/p&gt;

&lt;p&gt;现在搬出δ函数的对称性质公式:&lt;/p&gt;

&lt;p&gt;\[ \delta (at) = \frac {1}{a}\delta (t) \]&lt;/p&gt;

&lt;p&gt;\[ III(at) = \sum _{k=-\infty }^{\infty }\delta (at - k) \]
\[ = \sum _{k=-\infty }^{\infty }\delta (a(t - \frac {k}{a})) \]
\[ = \sum _{k=-\infty }^{\infty }\frac {1}{a}\delta (t - \frac {k}{a}) \]&lt;/p&gt;

&lt;p&gt;\[ = \frac {1}{a}III_{\frac {1}{a}}(t)\]&lt;/p&gt;

&lt;p&gt;也就是:&lt;/p&gt;

&lt;p&gt;\[  III(at)  = \frac {1}{a}III_{\frac {1}{a}}(t) \]&lt;/p&gt;

&lt;p&gt;\[  III_{a}(t)  = \frac {1}{a}III_{}(\frac {t}{a}) \]&lt;/p&gt;

&lt;h4&gt;傅里叶变换&lt;/h4&gt;

&lt;p&gt;\[  III_{a}(t) = \frac {1}{T}\sum _{k=-\infty }^{\infty }e^{2\pi is\frac {t}{T}} \]&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/shah-function/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/shah-function/</guid>
      </item>
    
      <item>
        <title>理解卷积 Convolution</title>
        <description>&lt;h2&gt;数学中的卷积&lt;/h2&gt;

&lt;p&gt;卷积的wiki：&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution#Derivations&quot;&gt;Convolution&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;卷积和(convolution sum)的公式是:&lt;/p&gt;

&lt;p&gt;\[ y(t) = x(t)*h(t) = \sum _{\tau =-\infty }^{\infty }x(\tau )h(t-\tau )\]&lt;/p&gt;

&lt;p&gt;写成积分形式是:&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;\[ x(t)*h(t) = \int _{-\infty }^{\infty }x(\tau )h(t-\tau )d\tau = \int _{-\infty }^{\infty }x(t-\tau )h(\tau )d\tau \]&lt;/p&gt;

&lt;p&gt;要理解这个东西，比较难，一种是公式推导，不过是从傅里叶变换得到的；一种是用狄拉克δ函数来辅助理解（我自认为的）；最后一种是通过线性时不变系统理论&lt;a href=&quot;https://en.wikipedia.org/wiki/LTI_system_theory#Overview&quot;&gt;LTI system theory&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;先讲第一种吧。&lt;/p&gt;

&lt;h2&gt;第一种思路：傅里叶变换与卷积&lt;/h2&gt;

&lt;p&gt;首先要搬出&lt;a href=&quot;http://www.qiujiawei.com/fourier-equation/&quot;&gt;傅里叶变换&lt;/a&gt;的一个推论：&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[\alpha f(t) + \beta g(t)] = \alpha F(s) + \beta G(s) \]&lt;/p&gt;

&lt;p&gt;这个公式意思是，一个时域下的复杂信号函数可以分解成多个简单信号函数的和，然后对各个子信号函数做傅里叶变换并再次求和，就求出了原信号的傅里叶变换。这个事实显然很有用处。&lt;/p&gt;

&lt;p&gt;但除了加法之外，还有乘法。这时候有一个问题：&lt;strong&gt;是否存在某种新的f(t)和g(t)的结合方式，使得f(t)和g(t)结合后的函数的傅里叶变换结果是F(s)G(s)？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要求这个问题的解，要用倒推法。&lt;/p&gt;

&lt;p&gt;首先，设有信号函数f(x)和g(t)（注意，x、t都是指横轴变量，只是用来区分开f和g），G(s)、F(s)分别是f(x)和g(t)的傅里叶变换，于是有:&lt;/p&gt;

&lt;p&gt;\[ G(s)F(s) = \int _{-\infty }^{\infty }e^{-2\pi ist}g(t)dt\int _{-\infty }^{\infty }e^{-2\pi isx}f(x)dx \]&lt;/p&gt;

&lt;p&gt;接着做一些变换:&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }e^{-2\pi ist}g(t)dt\int _{-\infty }^{\infty }e^{-2\pi isx}f(x)dx = \int _{-\infty }^{\infty }\int _{-\infty }^{\infty }e^{-2\pi ist}e^{-2\pi isx}g(t)f(x)dtdx \]
\[ = \int _{-\infty }^{\infty }\int _{-\infty }^{\infty }e^{-2\pi is(t+x)}g(t)f(x)dtdx \]
\[ = \int _{-\infty }^{\infty }\left (\int _{-\infty }^{\infty }e^{-2\pi is(t+x)}g(t)dt\right )f(x)dx \]&lt;/p&gt;

&lt;p&gt;现在设u = t + x，所以t = u - x，du = dt（这是把x看做常数项了）。则有：&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }\left (\int _{-\infty }^{\infty }e^{-2\pi is(t+x)}g(t)dt\right )f(x)dx =  \int _{-\infty }^{\infty }\left (\int _{-\infty }^{\infty }e^{-2\pi isu}g(u - x)du\right )f(x)dx \]&lt;/p&gt;

&lt;p&gt;接着调整下积分顺序：
\[ \int _{-\infty }^{\infty }\left (\int _{-\infty }^{\infty }e^{-2\pi isu}g(u - x)du\right )f(x)dx = \int _{-\infty }^{\infty }\int _{-\infty }^{\infty }e^{-2\pi isu}g(u - x)f(x)dudx \]
\[ = \int _{-\infty }^{\infty }\int _{-\infty }^{\infty }e^{-2\pi isu}g(u - x)f(x)dxdu \]
\[ = \int _{-\infty }^{\infty }e^{-2\pi isu}\left (\int _{-\infty }^{\infty }g(u - x)f(x)dx\right )du \]&lt;/p&gt;

&lt;p&gt;括号内那个积分是一个关于u的函数，所以可以设成h(u)：&lt;/p&gt;

&lt;p&gt;\[ h(u) = \int _{-\infty }^{\infty }g(u - x)f(x)dx \]&lt;/p&gt;

&lt;p&gt;于是上面的式子就变成:&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }e^{-2\pi isu}\left (\int _{-\infty }^{\infty }g(u - x)f(x)dx\right )du = \int _{-\infty }^{\infty }e^{-2\pi isu}h(u)du =  \mathcal {F}[h(s)] = H(s)  \]&lt;/p&gt;

&lt;p&gt;这个结论，可以简化成：&lt;/p&gt;

&lt;p&gt;\[  H(s) = G(s)F(s) \]&lt;/p&gt;

&lt;p&gt;再来看下h(u)。如果把h(u)的u换成t（这是可以的，只是一个符号而已），就有:&lt;/p&gt;

&lt;p&gt;\[ h(t) = \int _{-\infty }^{\infty }g(t - x)f(x)dx \]&lt;/p&gt;

&lt;p&gt;2个终极公式都出来了。&lt;/p&gt;

&lt;p&gt;最后，我们还要定义一个特殊的二元运算符号\(*\)来替代h(t)（也叫卷积运算符，注意，这个不是乘法的乘号哦）：&lt;/p&gt;

&lt;p&gt;\[ h(t) = (g*f)(t) = \int _{-\infty }^{\infty }g(t - x)f(x)dx \]&lt;/p&gt;

&lt;p&gt;于是有：&lt;/p&gt;

&lt;p&gt;\[ H(s) = G(s)F(s) \]
\[ \mathcal {F}[h(t)] = \mathcal {F}[g(s)] \mathcal {F}[f(s)] \]
\[ \mathcal {F}[(g*f)(s)] = \mathcal {F}[g(s)] \mathcal {F}[f(s)] \]&lt;/p&gt;

&lt;p&gt;最后的公式，也被叫做&lt;strong&gt;卷积定理&lt;/strong&gt;(Convolution Theorem)。&lt;/p&gt;

&lt;p&gt;这个定理说明，信号f和信号g的卷积的傅里叶变换，等于f、g各自的傅里叶变换的积。&lt;/p&gt;

&lt;h2&gt;第二种思路：狄拉克δ函数与卷积&lt;/h2&gt;

&lt;p&gt;第二种思路的关键在于&lt;strong&gt;狄拉克δ函数&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;狄拉克δ函数 dirac delta function&lt;/h3&gt;

&lt;p&gt;狄拉克δ函数的wiki：&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_delta_function&quot;&gt;dirac delta function&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;狄拉克δ函数在坐标系上的长相:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/Dirac_function_approximation.gif&quot; alt=&quot;Dirac_function_approximation.gif&quot;&gt;&lt;/p&gt;

&lt;p&gt;（图片来自wiki）&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;信号处理科学&lt;/strong&gt;中狄拉克δ函数被称为单位脉冲信号(unit impulse symbol）。上面这个图也很形象地说明了这一点。&lt;/p&gt;

&lt;p&gt;狄拉克δ函数有这样的性质:&lt;/p&gt;

&lt;p&gt;\[ delta (t) =  \begin {cases} +\infty , t=0 \\  0, t\neq 0 \end {cases} \]&lt;/p&gt;

&lt;p&gt;\[ \int _{-\infty }^{\infty }\delta (t)dt = 1 \]&lt;/p&gt;

&lt;p&gt;狄拉克δ函数在t等于0时值为正无穷，t不等于0时则为0，且在整个定义域的积分等于1。&lt;/p&gt;

&lt;h3&gt;狄拉克δ函数与卷积&lt;/h3&gt;

&lt;p&gt;考虑卷积公式的一个特殊情况：&lt;strong&gt;当h(t)是狄拉克δ函数时&lt;/strong&gt;。现在试一下把h(t)代入卷积公式，得到:&lt;/p&gt;

&lt;p&gt;\[ x(t) * h(t) = x(t) * \delta (t) = \int _{-\infty }^{\infty }x(\tau )\delta (t-\tau )d\tau = x(t) \]&lt;/p&gt;

&lt;p&gt;(最后一步跳跃得比较厉害，后文会有说明）&lt;/p&gt;

&lt;p&gt;这个结果说明，x(t)和狄拉克δ函数卷积的结果还是x(t)，为什么会这样呢？&lt;/p&gt;

&lt;p&gt;再看下前面给出的卷积和标准公式：&lt;/p&gt;

&lt;p&gt;\[ y(t) = x(t)*h(t) = \sum _{\tau =-\infty }^{\infty }x(\tau )h(t-\tau )\]&lt;/p&gt;

&lt;p&gt;把其中的\( h(t - \tau ) \)换成\( \delta (t - \tau ) \)，那么里面的\( t - \tau \)，其实就是让那个脉冲信号在横轴上移动(偏移)\( \tau \)距离。根据狄拉克δ函数的定义，可以知道，当\( t = \tau \)时，\( x(\tau )h(t-\tau ) \)才非0，且等于\( x(\tau ) \)。所以卷积和也就等于\( x(\tau ) \)。（这也算是上面的公式的证明吧）&lt;/p&gt;

&lt;p&gt;将这个特殊情况一般化，即不限制h = δ时，就是所谓的卷积公式了。&lt;/p&gt;

&lt;h2&gt;第三种思路：线性时不变系统·理论 LTI system theory&lt;/h2&gt;

&lt;p&gt;这个还没搞懂，搞懂了再来填坑&lt;/p&gt;

&lt;h2&gt;二维卷积以及图像中的卷积&lt;/h2&gt;

&lt;p&gt;上面讨论的仅仅是一维的卷积。幸运的是，高维卷积可以简单地根据一维卷积得到，比如说二维的卷积：&lt;/p&gt;

&lt;p&gt;\[ f(x,y)*g(x,y) = \sum _{x&amp;#39; }^{}\sum _{y&amp;#39; }^{}f(x&amp;#39;,y&amp;#39;)g(x - x&amp;#39;, y - y&amp;#39;)  \]&lt;/p&gt;

&lt;p&gt;积分形式是：&lt;/p&gt;

&lt;p&gt;\[ (f*g)(x,y) = \int \int f(x&amp;#39;,y&amp;#39;)g(x - x&amp;#39;, y - y&amp;#39;)dx&amp;#39;dy&amp;#39;  \]&lt;/p&gt;

&lt;p&gt;如果给定一个范围r，则有：&lt;/p&gt;

&lt;p&gt;\[ f(x,y)*g(x,y) = \sum _{x&amp;#39; = -r }^{x&amp;#39; = r}\sum _{y&amp;#39; = -r }^{y&amp;#39; = r }f(x&amp;#39;,y&amp;#39;)g(x - x&amp;#39;, y - y&amp;#39;)  \]&lt;/p&gt;

&lt;p&gt;现在想象一下，把一幅图片(位图)当做是一个函数：&lt;/p&gt;

&lt;p&gt;\[ f(x,y) = RGB\ value \]&lt;/p&gt;

&lt;p&gt;先让自己对这个式子有一个几何空间上的想象：带有2个变量的函数，它的几何表示是三维的，三个坐标轴分别是：x、y、f(x,y)，所以f(x,y)表示的是三维空间里的一个连续表面(surface)。&lt;/p&gt;

&lt;p&gt;然后，我们再来回顾下线性代数——矩阵。假设我们有一个128X128的bmp图像，可以用一个矩阵A(应该说是方阵)来表示它，A的每一个元素是一个rgb值。
有了这个图像-&amp;gt;矩阵的转换关系后，我们就可以用线性代数的知识对这个图像做处理。&lt;/p&gt;

&lt;p&gt;比如说，我们用矩阵乘法吧。假设有另一个和A同阶的方阵S，很显然，下面的等式成立：&lt;/p&gt;

&lt;p&gt;\[ AS = A&amp;#39; \]&lt;/p&gt;

&lt;p&gt;这个式子意味着，图像处理可以抽象成矩阵的线性运算。比如当S是单位矩阵I时，显然有\( AI = A \)，即A保持不变，什么都没做。&lt;/p&gt;

&lt;p&gt;好了，明确了图像可以用线性代数的方法来加工处理后，要理解图像卷积就简单了。&lt;/p&gt;

&lt;p&gt;上面说的‘转换’方阵S，是和A同阶的方阵。这个‘同阶’性质，是不是必要的？其实不是。只要你有办法使得A变成A&amp;#39;，就可以了。中间的S，代表的是一个转换过程。&lt;/p&gt;

&lt;p&gt;卷积转换，是一个特殊的转换，首先，它有一个叫做&lt;strong&gt;窗口&lt;/strong&gt;的东西（或者叫卷积子），一般情况下这个窗口是一个比A的阶数小得多的方阵。&lt;/p&gt;

&lt;p&gt;如果拿这个小方阵R去和A的&lt;strong&gt;局部区域&lt;/strong&gt;做线性变换(更具体地说，是&lt;strong&gt;点积运算&lt;/strong&gt;)，则有：&lt;/p&gt;

&lt;p&gt;\[ A_{x,y,w,h}\cdot R_{w,h} = \sum _{x&amp;#39; = x - w/2}^{x&amp;#39; = x + w/2}\sum _{y&amp;#39; = y - h/2}^{y&amp;#39; = y + h/2}A[x&amp;#39;,y&amp;#39;]R[x&amp;#39; - x, y&amp;#39; - y] = new\ RGB\ value \]&lt;/p&gt;

&lt;p&gt;把得到的这个RGB值赋给A[x,y]，就有：&lt;/p&gt;

&lt;p&gt;\[ A[x,y]R = A&amp;#39;[x,y]  \]&lt;/p&gt;

&lt;p&gt;简单地说就是，A[x,y]的值被R刷新了。如果对整幅图像的每一个像素都和R做一次点积运算，整幅图像就被刷新了。&lt;/p&gt;

&lt;p&gt;这就是图像的卷积变换的本质。&lt;/p&gt;

&lt;h2&gt;找到的相关资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.eecg.toronto.edu/%7Eahouse/mirror/engi7824/course_notes_7824_part6.pdf&quot;&gt;The Convolution Sum for Discrete-Time LTI Systems. Andrew W. H. House&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/convolution/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/convolution/</guid>
      </item>
    
      <item>
        <title>gcc-4.9.3 编译过程笔记</title>
        <description>&lt;p&gt;官方的编译指南：&lt;a href=&quot;https://gcc.gnu.org/install/&quot;&gt;https://gcc.gnu.org/install/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;唠叨几句&lt;/h2&gt;

&lt;p&gt;之前升级了我的阿里云的gcc，记得是费了些功夫的，有些坑。可惜忘了记笔记。今天编译node.js时发现我编译的gcc有些问题，要重新编译下，悲催的是gcc的编译目录都删掉了。全部得重来过。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;准备&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;https://gcc.gnu.org/mirrors.html&quot;&gt;https://gcc.gnu.org/mirrors.html&lt;/a&gt;下载源码包到机器上并解压：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;wget http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-4.9.3/gcc-4.9.3.tar.gz&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tar -xzvf gcc-4.9.3.tar.gz&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;配置&lt;/h2&gt;

&lt;p&gt;To configure GCC:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; % mkdir objdir
 % cd objdir
 % srcdir/configure [options] [target]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即，在gcc-4.9.3目录里建立objdir子目录，并在这个子目录里执行configure。&lt;/p&gt;

&lt;p&gt;configure要填什么参数，这个因人而异了。就不说了。官方文档是&lt;a href=&quot;https://gcc.gnu.org/install/configure.html&quot;&gt;https://gcc.gnu.org/install/configure.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我只需要用c++，所以我执行了:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/download/gcc-4.9.3/configure --enable-languages=c,c++&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后就遇到第一个坑：&lt;/p&gt;

&lt;h3&gt;坑1&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;configure: error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+. Try the --with-gmp, --with-mpfr and/or --with-mpc options to specify their locations.  Source code for these libraries can be found at their respective hosting sites as well as at ftp://gcc.gnu.org/pub/gcc/infrastructure/.  See also http://gcc.gnu.org/install/prerequisites.html for additional info.  If you obtained GMP, MPFR and/or MPC from a vendor distribution package, make sure that you have installed both the libraries and the header files.  They may be located in separate packages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说是需要GMP 4.2+、MPFR 2.4.0+、MPC 0.8.0+。不知道是什么鬼。上次编译好像也有见到这个提示。&lt;/p&gt;

&lt;p&gt;它叫我去翻看&lt;a href=&quot;https://gcc.gnu.org/install/prerequisites.html&quot;&gt;https://gcc.gnu.org/install/prerequisites.html&lt;/a&gt;，好咯。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Several support libraries are necessary to build GCC, some are required, others optional. While any sufficiently new version of required tools usually work, library requirements are generally stricter. Newer versions may work in some cases, but it&amp;#39;s safer to use the exact versions documented. We appreciate bug reports about problems with newer versions, though. If your OS vendor provides packages for the support libraries then using those packages may be the simplest way to install the libraries.&lt;/p&gt;

&lt;p&gt;GNU Multiple Precision Library (GMP) version 4.3.2 (or later)&lt;/p&gt;

&lt;p&gt;MPFR Library version 2.4.2 (or later)&lt;/p&gt;

&lt;p&gt;MPC Library version 0.8.1 (or later)&lt;/p&gt;

&lt;p&gt;ISL Library version 0.15, 0.14, 0.13, or 0.12.2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看起来很复杂的样子，其实gcc自己给出了简单的解决办法，但是又不在这个页面写出来，这是傲娇吗=。=&lt;/p&gt;

&lt;p&gt;方法就是，在gcc-4.9.3目录执行:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sh ./contrib/download_prerequisites&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;哗啦啦的就把各个依赖库下载好了。好棒。&lt;/p&gt;

&lt;h3&gt;坑2&lt;/h3&gt;

&lt;p&gt;回到objdir目录，再次执行:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/download/gcc-4.9.3/configure --enable-languages=c,c++&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;出现一些warning：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;configure: WARNING: using in-tree ISL, disabling version check&lt;/p&gt;

&lt;p&gt;configure: WARNING: using in-tree CLooG, disabling version check&lt;/p&gt;

&lt;p&gt;*** This configuration is not supported in the following subdirectories:
gnattools target-libada target-libgfortran target-libgo target-libffi target-libbacktrace target-zlib target-libjava target-libobjc target-boehm-gc
(Any other directories should still work fine.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这些目录是什么东西，懒得了解了，只是warning的话先不管了。重点是还出现以下的error提示：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;/usr/bin/ld: cannot find crt1.o: No such file or directory&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find crti.o: No such file or directory&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: skipping incompatible /usr/local/lib/gcc/x86_64-unknown-linux-gnu/4.9.3/libgcc.a when searching for -lgcc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lgcc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lgcc_s&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: skipping incompatible /usr/local/lib/gcc/x86_64-unknown-linux-gnu/4.9.3/libgcc.a when searching for -lgcc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lgcc&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find -lgcc_s&lt;/p&gt;

&lt;p&gt;/usr/bin/ld: cannot find crtn.o: No such file or directory&lt;/p&gt;

&lt;p&gt;collect2: error: ld returned 1 exit status&lt;/p&gt;

&lt;p&gt;configure: error: I suspect your system does not have 32-bit developement libraries (libc and headers). If you have them, rerun configure with --enable-multilib. If you do not have them, and want to build a 64-bit-only compiler, rerun configure with --disable-multilib.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个意思应该是，我编译配置是默认支持32位和64位，但是32位的dev lib不齐全，建议我关掉32位。好咯。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;~/download/gcc-4.9.3/configure --disable-multilib --enable-languages=c,c++&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后就天晴了，那些cannot find和error不见了（除了那个warning），没有其他异常提示：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;configure: creating ./config.status&lt;/p&gt;

&lt;p&gt;config.status: creating Makefile&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;开始编译&lt;/h2&gt;

&lt;p&gt;还是在objdir，执行:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;make&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过漫长的等待，终于，出现了坑3。&lt;/p&gt;

&lt;h3&gt;坑3&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;make[3]: *** [s-attrtab] Killed&lt;/p&gt;

&lt;p&gt;make[3]: Leaving directory `/root/download/gcc-4.9.3/objdir/gcc&amp;#39;&lt;/p&gt;

&lt;p&gt;make[2]: *** [all-stage1-gcc] Error 2&lt;/p&gt;

&lt;p&gt;make[2]: Leaving directory `/root/download/gcc-4.9.3/objdir&amp;#39;&lt;/p&gt;

&lt;p&gt;make[1]: *** [stage1-bubble] Error 2&lt;/p&gt;

&lt;p&gt;make[1]: Leaving directory `/root/download/gcc-4.9.3/objdir&amp;#39;&lt;/p&gt;

&lt;p&gt;make: *** [all] Error 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查了下，这个是因为我的vps内存不足导致的，看官们的机器应该不会出现这个错误T_T。&lt;/p&gt;

&lt;p&gt;重启下vps再编译，看看能不能解决。&lt;/p&gt;

&lt;p&gt;Oh，编译成功了。接着执行make install就完成了。&lt;/p&gt;

&lt;p&gt;End。&lt;/p&gt;
</description>
        <pubDate>Thu, 15 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/cpp-2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/cpp-2/</guid>
      </item>
    
      <item>
        <title>学习傅里叶变换</title>
        <description>&lt;p&gt;本文主要写的是公式层面的推导，关于傅里叶变换的应用，请到知乎搜索&amp;#39;傅里叶&amp;#39;，能找到很多不错的文章。&lt;/p&gt;

&lt;p&gt;本文主要参考了斯坦福大学Brad Osgood的公开课:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://open.163.com/special/opencourse/fouriertransforms.html&quot;&gt;http://open.163.com/special/opencourse/fouriertransforms.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;youtube的比较高清:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=gZNm7L96pfY&quot;&gt;https://www.youtube.com/watch?v=gZNm7L96pfY&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;傅里叶级数 fourier series&lt;/h2&gt;

&lt;h3&gt;基础&lt;/h3&gt;

&lt;p&gt;翻译一下wiki的fourier series：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在数学中，傅里叶级数是一个&lt;strong&gt;可以把(有波形的)函数表示成多个简单的sin函数的叠加&lt;/strong&gt;的方法。更形式地说，傅里叶级数能够把任意周期函数(信号)分解成&lt;strong&gt;有限(或无限)个简单的震荡函数的叠加&lt;/strong&gt;，这些震荡函数可以是正弦函数、余弦函数或复指数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;傅里叶级数的公式定义（不要问为什么长这样，这只是一个定义，不是推出来的公式)：&lt;/p&gt;

&lt;p&gt;\[ S = \sum_{k=1}^{n}A_{k}\sin (2\pi kt+\phi _{k}) \]&lt;/p&gt;

&lt;p&gt;(如果不清楚什么是级数，请戳 &lt;a href=&quot;https://en.wikipedia.org/wiki/Series_(mathematics)&quot;&gt;https://en.wikipedia.org/wiki/Series_(mathematics)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用三角函数的一道公式:&lt;/p&gt;

&lt;p&gt;\[ \sin (\alpha + \beta ) = \sin \alpha \cos \beta + \cos \alpha \sin \beta \]&lt;/p&gt;

&lt;p&gt;代入到傅里叶级数，得：&lt;/p&gt;

&lt;p&gt;\[ \sin (2\pi kt + \phi _{k}) =\sin 2\pi kt \cos \phi _{k} + \cos 2\pi kt \sin \phi _{k} \]&lt;/p&gt;

&lt;p&gt;\[ S = \sum_{k=1}^{n}A_{k}\sin 2\pi kt \cos \phi _{k} + \sum_{k=1}^{n}A_{k}\cos 2\pi kt \sin \phi _{k} \]&lt;/p&gt;

&lt;p&gt;再设:&lt;/p&gt;

&lt;p&gt;\[ a_{k} = A_{k}\cos \phi _{k} \]&lt;/p&gt;

&lt;p&gt;\[ b_{k} = A_{k}\sin \phi _{k} \]&lt;/p&gt;

&lt;p&gt;则上面的傅里叶级数被简化成:&lt;/p&gt;

&lt;p&gt;\[ S = \sum_{k=1}^{n}a_{k}\sin 2\pi kt + \sum_{k=1}^{n}b_{k}\cos 2\pi kt \]
\[  S(x) = \sum_{k=1}^{n}(a_{k}\sin 2\pi kt + b_{k}\cos 2\pi kt) \]&lt;/p&gt;

&lt;p&gt;这是傅里叶级数的&lt;strong&gt;常用形式1&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用形式2&lt;/strong&gt;是这样的：&lt;/p&gt;

&lt;p&gt;\[  S = \frac {A_{0}}{2} + \sum_{k=1}^{n}(a_{k}\sin 2\pi kt + b_{k}\cos 2\pi kt) \]&lt;/p&gt;

&lt;p&gt;前面多出来的那个东西，先不管它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用形式3&lt;/strong&gt;，是最重要的：用复指数来表示傅里叶级数。&lt;/p&gt;

&lt;p&gt;推导过程，要用到&lt;strong&gt;欧拉公式&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;\[ e^{ix} = \cos x + i\sin x\]&lt;/p&gt;

&lt;p&gt;（关于欧拉公式的推导，可以看我的另一篇文章:&lt;a href=&quot;http://www.qiujiawei.com/complex-1&quot;&gt;复数和三角函数&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;把 \( x = 2\pi kt \)代入到欧拉公式，得到:&lt;/p&gt;

&lt;p&gt;\[   e^{i2\pi kt} = \cos 2\pi kt + i\sin 2\pi kt\]&lt;/p&gt;

&lt;p&gt;再搬出另外两条欧拉公式的推论:&lt;/p&gt;

&lt;p&gt;\[ \cos x = \frac {e^{ix} + e^{-ix}}{2} \]&lt;/p&gt;

&lt;p&gt;\[ \sin x = \frac {e^{ix} - e^{-ix}}{2i} \]&lt;/p&gt;

&lt;p&gt;也把 \( x = 2\pi kt \)代入，得到:&lt;/p&gt;

&lt;p&gt;\[ \cos 2\pi kt = \frac {e^{i2\pi kt} + e^{-i2\pi kt}}{2} \]&lt;/p&gt;

&lt;p&gt;\[ \sin 2\pi kt = \frac {e^{i2\pi kt} - e^{-i2\pi kt}}{2i} \]&lt;/p&gt;

&lt;p&gt;这时候，教授突然说，傅里叶级数可以写成:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;这个式子确实是常用形式3——复指数表示的傅里叶级数。
但是，这究竟是怎么得到的呢。&lt;/p&gt;

&lt;p&gt;请耐心看下文。&lt;/p&gt;

&lt;h3&gt;复指数形式的傅里叶级数的\(c_{k}\)的性质&lt;/h3&gt;

&lt;p&gt;对于傅里叶级数f(t)，假设它是一个&amp;quot;实信号(real signal)&amp;quot;（一般来说，傅里叶变换处理的目标都是实信号)，
那么就有等式:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \overline {f(t)} \]&lt;/p&gt;

&lt;p&gt;即是说，f(t)没有虚部。而又因为：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;\[ \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} = \overline {\sum_{k=-n}^{n}c_{k}e^{2\pi ikt}} = \sum_{k=-n}^{n}\overline {c_{k}}\overline {e^{2\pi ikt}} = \sum_{k=-n}^{n}\overline {c_{k}}e^{-2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;然后，要注意一个事实是：这个级数是从-n到n的累加，根据加法交换律，这个级数也可以变成从n到-n的累加，也即:&lt;/p&gt;

&lt;p&gt;\[ \sum_{k=-n}^{n} = \sum_{k=n}^{-n}  \]&lt;/p&gt;

&lt;p&gt;于是，把傅里叶级数的k变成-k，就有:&lt;/p&gt;

&lt;p&gt;\[ \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} = \sum_{-k=-n}^{n}c_{-k}e^{-2\pi ikt} = \sum_{k=n}^{-n}c_{-k}e^{-2\pi ikt} = \sum_{k=-n}^{n}c_{-k}e^{-2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;再对比上面的推导，就会发现：&lt;/p&gt;

&lt;p&gt;\[ c_{-k} = \overline {c_{k}} \]&lt;/p&gt;

&lt;p&gt;先记住这个性质，然后继续往下看。&lt;/p&gt;

&lt;p&gt;设有复数z，它必然会满足一个性质：&lt;/p&gt;

&lt;p&gt;\[ z + \overline {z} = 2Re\{ z \} \]&lt;/p&gt;

&lt;p&gt;Re{···}代表取出花括号的复数表达式的实部。&lt;/p&gt;

&lt;p&gt;对于傅里叶级数，也可以把它当成一个复数，再利用刚刚推导出来的\(c_{-k} = \overline {c_{k}} \)，就有：&lt;/p&gt;

&lt;p&gt;\[ c_{k}e^{2\pi ikt} + c_{-k}e^{2\pi i(-k)t} = c_{k}e^{2\pi ikt} + c_{-k}e^{-2\pi ikt}\]
\[ = c_{k}e^{2\pi ikt} + \overline {c_{k}}e^{\overline {2\pi ikt}} \]
\[ = c_{k}e^{2\pi ikt} + \overline {c_{k}e^{2\pi ikt}} \]
\[ = 2Re\{ c_{k}e^{2\pi ikt} \} \]&lt;/p&gt;

&lt;p&gt;这个结果表明，\(c_{k}e^{2\pi ikt} + c_{-k}e^{2\pi i(-k)t} \)是一个实数。把这个结论代入到傅里叶级数，就可以得到：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]
\[ = \sum_{k=0}^{n}2Re\{ c_{k}e^{2\pi ikt} \} \]
\[ = 2Re\{ \sum_{k=0}^{n}c_{k}e^{2\pi ikt} \} \]&lt;/p&gt;

&lt;p&gt;注意，这个式子是把0和-0都算进去的。如果不允许signed zero，就要对k=0的情况特殊处理。&lt;/p&gt;

&lt;h3&gt;求解\(c_{k}\)的积分形式&lt;/h3&gt;

&lt;p&gt;回到前面的那个傅里叶级数f(t)：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;其实是这样子搞出来的：
先假设傅里叶的&lt;strong&gt;常用形式2&lt;/strong&gt;可以变换成这个等式，然后求\(c_{k}\)，求得出来的话，式子不就成立了嘛。&lt;/p&gt;

&lt;p&gt;为了搞定这个事情，要使用新的招数：积分。&lt;/p&gt;

&lt;p&gt;( 在教授的notes(&lt;a href=&quot;https://see.stanford.edu/materials/lsoftaee261/book-fall-07.pdf&quot;&gt;https://see.stanford.edu/materials/lsoftaee261/book-fall-07.pdf&lt;/a&gt;]的第10-12页第1.5小节Lost at c，清楚地推导了一遍\(c_{k}\)。 )&lt;/p&gt;

&lt;p&gt;这里我按自己对原文的理解，翻译下。&lt;/p&gt;

&lt;p&gt;我们先随便取了一个k(k在-n到n之间)，然后，对上面的傅里叶级数等式两边同时乘以\( e^{-2\pi ikt } \)：&lt;/p&gt;

&lt;p&gt;\[ e^{-2\pi ikt }f(t) = e^{-2\pi ikt }\sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;把右边的式子展开，得到:&lt;/p&gt;

&lt;p&gt;\[ e^{-2\pi ikt }f(t) = \cdots + e^{-2\pi ikt }c_{k}e^{2\pi ikt} + \cdots \]
\[ = \cdots + c_{k}e^{-2\pi ikt}e^{2\pi ikt } + \cdots \]
\[ = \cdots + c_{k}e^{-2\pi ikt + 2\pi ikt } + \cdots \]
\[ = \cdots + c_{k} + \cdots \]&lt;/p&gt;

&lt;p&gt;这时候，可以把\(c_{k}\)移到等式左边，左边的那个东东移到右边，就得到了一个\(c_{k}\)的表达式:&lt;/p&gt;

&lt;p&gt;\[ c_{k}  = e^{-2\pi ikt }f(t) - \sum_{k&amp;#39;=-n\,k&amp;#39;\neq k}^{n}c_{k&amp;#39;}e^{2\pi ik&amp;#39;t}e^{-2\pi ikt } \]
\[ e^{-2\pi ikt }f(t) - \sum_{k&amp;#39;=-n\,k&amp;#39;\neq k}^{n}c_{k&amp;#39;}e^{2\pi i(k&amp;#39;-k)t} \]&lt;/p&gt;

&lt;p&gt;然后再放大招：对等式两边同时积分，范围是0到1（f(t)的t的周期为1）。&lt;/p&gt;

&lt;p&gt;积分的时候，会发现有这么个神奇的等式:&lt;/p&gt;

&lt;p&gt;\[ \int _{0}^{1}e^{2\pi i(k&amp;#39;-k)t}dt = \left  [ \frac {2\pi i(k&amp;#39;-k)}{1}e^{2\pi i(k&amp;#39;-k)t}\right ]_{0}^{1} \]
\[ = \frac {2\pi i(k&amp;#39;-k)}{1}(e^{2\pi i(k&amp;#39;-k)} - e^{0})\]
\[ = \frac {2\pi i(k&amp;#39;-k)}{1}(1-1) = 0\]&lt;/p&gt;

&lt;p&gt;最后那个1-1=0的前面那个1，其实用上欧拉公式就懂了，&lt;strong&gt;\( 2\pi i(k&amp;#39;-k) \)&lt;/strong&gt;，代表\(\phi =2\pi (k&amp;#39;-k)\) ,又因为k&amp;#39;-k必然是整数，所以\(\phi \)代表了复数平面的坐标(1,0)，所以整个式子就等于1。&lt;/p&gt;

&lt;p&gt;于是，积分等式就只剩下：&lt;/p&gt;

&lt;p&gt;\[ \int _{0}^{1}c_{k}dt = \int _{0}^{1}e^{-2\pi ikt }f(t)dt \]&lt;/p&gt;

&lt;p&gt;\[ (1-0)c_{k} = c_{k} = \int _{0}^{1}e^{-2\pi ikt }f(t)dt \]&lt;/p&gt;

&lt;p&gt;这就是\(c_{k}\)的积分形式。&lt;/p&gt;

&lt;p&gt;做一个小结：&lt;/p&gt;

&lt;p&gt;如果对于一个已知的周期为1的周期函数f(t)，它可以写成这样的形式：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-n}^{n}c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;那么其中的\(c_{k}\)必然满足：&lt;/p&gt;

&lt;p&gt;\[ c_{k} = \int _{0}^{1}e^{-2\pi ikt }f(t)dt \]&lt;/p&gt;

&lt;h3&gt;求解\(c_{k}\)的非积分形式&lt;/h3&gt;

&lt;p&gt;回到傅里叶级数的常用形式2:&lt;/p&gt;

&lt;p&gt;\[  f(t) = \frac {A_{0}}{2} + \sum_{k=1}^{n}(a_{k}\sin 2\pi kt + b_{k}\cos 2\pi kt) \]&lt;/p&gt;

&lt;p&gt;代入下面这2个式子:&lt;/p&gt;

&lt;p&gt;\[ \cos 2\pi kt = \frac {e^{i2\pi kt} + e^{-i2\pi kt}}{2} \]&lt;/p&gt;

&lt;p&gt;\[ \sin 2\pi kt = \frac {e^{i2\pi kt} - e^{-i2\pi kt}}{2i} \]&lt;/p&gt;

&lt;p&gt;得:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \frac {A_{0}}{2} + \sum_{k=1}^{n}(a_{k}\frac {e^{i2\pi kt} - e^{-i2\pi kt}}{2i} + b_{k}\frac {e^{i2\pi kt} + e^{-i2\pi kt}}{2}) \]
\[  = \frac {A_{0}}{2} + \sum_{k=1}^{n}(\frac {b_{k} - ia_{k}}{2}e^{i2\pi kt} + \frac {b_{k} + ia_{k}}{2}e^{-i2\pi  kt})  \]&lt;/p&gt;

&lt;p&gt;设:&lt;/p&gt;

&lt;p&gt;\[ c_{0} = \frac {1}{2}A_{0} \]
\[ c_{k} = \frac {1}{2}(b_{k} - ia_{k}) \]
\[ c_{-k} = \overline {c_{k}} = \frac {1}{2}(b_{k} + ia_{k}) \]&lt;/p&gt;

&lt;p&gt;（注意，第三个式子是利用了前面的结论 ）&lt;/p&gt;

&lt;p&gt;则:&lt;/p&gt;

&lt;p&gt;\[ f(t) = c_{0} + \sum_{k=1}^{n}(c_{k}e^{i2\pi kt} + c_{-k}e^{-i2\pi  kt}) \]
\[ = c_{0} + \sum_{k=1}^{n}c_{k}e^{i2\pi kt} + \sum_{k=1}^{n}c_{-k}e^{-i2\pi  kt} \]
\[ = c_{0} + \sum_{k=1}^{n}c_{k}e^{i2\pi kt} + \sum_{k=-1}^{-n}c_{k}e^{i2\pi  kt} \]
\[ = c_{0} +  \sum_{k=-n,k\neq 0}^{n}c_{k}e^{i2\pi kt}   \]&lt;/p&gt;

&lt;p&gt;和那个常用形式3非常接近了，只需要把\(c_{0}\)也合并到级数里即可。但，这需要有一个前提：\( c_{0} = \frac {1}{2}A_{0} \)和k=0时的f(t)的\( c_{0} \)相等，而这是不一定的。&lt;/p&gt;

&lt;p&gt;傅里叶级数是很不错的东西，但是实际应用时，要考虑很多细节，不是随便用就可以的。&lt;/p&gt;

&lt;h3&gt;大跃进，终极的傅里叶级数的复指数形式&lt;/h3&gt;

&lt;p&gt;终极的傅里叶级数的复指数形式是(fourier series exponential form  )：&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-\infty }^{\infty }c_{k}e^{2\pi ikt} \]&lt;/p&gt;

&lt;p&gt;前面的傅里叶级数是finite的，这个是infinite的。&lt;/p&gt;

&lt;p&gt;其中的\(c_{k}\)有一个专门的notation：\( \hat {f}(t) \)，代入后得到：&lt;/p&gt;

&lt;p&gt;\[ \hat {f}(t) = \int _{-\frac {1}{2} }^{\frac {1}{2} }f(t)e^{-2\pi ikt}dt \]&lt;/p&gt;

&lt;p&gt;\[ f(t) = \sum_{k=-\infty }^{\infty }\hat {f}(t)e^{2\pi ikt} \]&lt;/p&gt;

&lt;h2&gt;傅里叶变换 fourier transform&lt;/h2&gt;

&lt;p&gt;(以下内容摘选自《复变函数与积分变换(华东理工大学出版社)》，有删改)&lt;/p&gt;

&lt;h3&gt;傅里叶积分定理 fourier integrate&lt;/h3&gt;

&lt;p&gt;若函数f(t)在\(-\infty ,+\infty \)上的任一有限区间内满足Dirichlet条件，并且在\( (-\infty ,+\infty) \)上绝对可积（即积分\( \int _{-\infty }^{+\infty }|f(t)|dt\)收敛)，则有：
\[ \frac {1}{2\pi }\int _{-\infty }^{+\infty }\left [ \int _{-\infty }^{+\infty }f(t)e^{-i\omega t}dt\right ]e^{i\omega t}d\omega =  \begin {cases} f(t), 当t为f(t)的连续点; \\  \frac {f(t+0)+f(t-0)}{2},当t为f(t)的间断点。 \end {cases} \]&lt;/p&gt;

&lt;p&gt;令:&lt;/p&gt;

&lt;p&gt;\[ F(\omega ) = \int _{-\infty }^{+\infty }f(t)e^{-i\omega t}dt \]&lt;/p&gt;

&lt;p&gt;则:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \frac {1}{2\pi }\int _{-\infty }^{+\infty }F(\omega )e^{i\omega t}d\omega \]&lt;/p&gt;

&lt;p&gt;上两式子表明\( F(\omega ) 和 f(t) \)通过指定的积分运算可以相互表示。&lt;/p&gt;

&lt;p&gt;第一个式子称为f(t)的&lt;strong&gt;傅里叶变换&lt;/strong&gt;，记为:&lt;/p&gt;

&lt;p&gt;\[ F(\omega ) = \mathcal {F}[f(t)] \]&lt;/p&gt;

&lt;p&gt;函数为\(F(\omega ) \)称为f(t)的&lt;strong&gt;像函数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;第二个式子称为\(F(\omega ) \)的&lt;strong&gt;逆傅里叶变换&lt;/strong&gt;，记为:&lt;/p&gt;

&lt;p&gt;\[ f(t) = \mathcal {F}^{-1}[ F(\omega ) ] \]&lt;/p&gt;

&lt;p&gt;函数f(t)称为为\(F(\omega ) \)的&lt;strong&gt;像原函数&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;傅里叶变换的性质&lt;/h3&gt;

&lt;h4&gt;线性性质&lt;/h4&gt;

&lt;p&gt;设：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( \mathcal {F}[f_{1}(t)] = F_{1}(\omega )\)&lt;/li&gt;
&lt;li&gt;\( \mathcal {F}[f_{2}(t)] = F_{2}(\omega )\)&lt;/li&gt;
&lt;li&gt;\( \alpha \beta \)为常数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;则:&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[\alpha f_{1}(t) + \beta f_{2}(t)] = \alpha F_{1}(\omega ) + \beta F_{2}(\omega ) \]&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}^{-1}[\alpha F_{1}(\omega ) + \beta F_{2}(\omega )] = \alpha f_{1}(t) + \beta f_{2}(t) \]&lt;/p&gt;

&lt;h4&gt;位移性质&lt;/h4&gt;

&lt;p&gt;设\( \mathcal {F}[f(t)] = F(\omega )\)，\( f(t) = \mathcal {F}^{-1}[ F(\omega ) ] \)，则:&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[f(t\pm t_{0})] = e^{\pm i\omega t_{0}}F(\omega )\]&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}^{-1}[F(\omega )\mp F_{0}(\omega )] = e^{\pm i\omega _{0}t}f(t) \]&lt;/p&gt;

&lt;p&gt;其中\( t_{0},\omega _{0} \)为常数。&lt;/p&gt;

&lt;h4&gt;微分性质&lt;/h4&gt;

&lt;p&gt;若f(t)在\( (-\infty ,+\infty) \)内连续或只有有限个可去间断点，且：&lt;/p&gt;

&lt;p&gt;\[ \lim _{|t|\to +\infty }f(t) = 0 \]&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[f(t)] = F(\omega )\]&lt;/p&gt;

&lt;p&gt;则：&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[f&amp;#39;(t)] = i\omega F(\omega )\]&lt;/p&gt;

&lt;h4&gt;像函数的微分性质&lt;/h4&gt;

&lt;p&gt;设\( \mathcal {F}[f(t)] = F(\omega )\)，则:&lt;/p&gt;

&lt;p&gt;\[ \frac {d}{d\omega }F(\omega ) = -i\mathcal {F}[tf(t)] \]&lt;/p&gt;

&lt;h4&gt;积分性质&lt;/h4&gt;

&lt;p&gt;设\( g(t) = \int _{-\infty }^{t}f(t)dt\)，若：&lt;/p&gt;

&lt;p&gt;\[ \lim _{t\to +\infty }g(t) = 0 \]&lt;/p&gt;

&lt;p&gt;则:&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[g(t)]=\frac {1}{i\omega }\mathcal {F}[f(t)] \]&lt;/p&gt;

&lt;h4&gt;对称性质&lt;/h4&gt;

&lt;p&gt;若\( F(\omega ) = \mathcal {F}[f(t)] \)，则：&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[F(t)] = 2\pi f(-\omega ) \]&lt;/p&gt;

&lt;h4&gt;相似性质&lt;/h4&gt;

&lt;p&gt;设\( F(\omega ) = \mathcal {F}[f(t)] \)，a为非零常数，则：&lt;/p&gt;

&lt;p&gt;\[  \mathcal {F}[f(at)] = \frac {1}{|a|}F(\frac {\omega }{a}) \]&lt;/p&gt;

&lt;h3&gt;离散傅里叶变换 discrete fourier transform&lt;/h3&gt;

&lt;p&gt;wiki:&lt;a href=&quot;https://en.wikibooks.org/wiki/Digital_Signal_Processing/Discrete_Fourier_Transform&quot;&gt;Digital Signal Processing/Discrete Fourier Transform&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;设在时域上有离散的采样点\( f = (f[0],f[1],\cdots ,f[N-1]) \)，对f做离散傅里叶变换(DFT)，可以得到频域上的离散点\( F = (F[0],F[1],\cdots ,F[N-1]) \)，且：&lt;/p&gt;

&lt;p&gt;\[ F[m] =  \sum_{n=0}^{N-1}f[n]e^{-2\pi imn/N}, m = 0,1,\dots ,N-1 \]&lt;/p&gt;

&lt;p&gt;这个就是DFT的标准公式。&lt;/p&gt;

&lt;p&gt;解释一下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;f(t)是原信号(时域)，\( f(n_{0}) \) 到 \( f(n_{N - 1}) \)是所谓的采样点，也就是说f(t)被离散成了这些点；&lt;/li&gt;
&lt;li&gt;F(w)是转换后的频域信号，\( F(m_{0}) \) 到 \( F(m_{N - 1} )\)是频域里均匀分布的N个点；&lt;/li&gt;
&lt;li&gt;那么上面的公式就是指，对于每个m值，都求出这n个采样点f(n)的傅里叶级数，这个级数就是F(m)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要推导出这个这个公式并不容易，其中还要用到卷积的知识。&lt;/p&gt;

&lt;p&gt;先大概地讲一遍：&lt;/p&gt;

&lt;p&gt;给信号函数f(t)设定一个有限的时间范围L：\( 0\leq t\leq L \)；给f(t)的傅里叶转换F(w)设定一个有限的频率范围2B：\( 0\leq w\leq 2B \)。&lt;/p&gt;

&lt;p&gt;这里为什么是2B呢？这需要先认识一下&lt;strong&gt;采样定理&lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem#Introduction&quot;&gt;Nyquist–Shannon sampling theorem&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;香农指出，如果一个信号函数f(t)的频率不高于B赫兹，那么用时间间隔\( \frac {1}{2B} \)秒去采样f(t)而得到的f(t&amp;#39;)，相当于f(t)。&lt;/p&gt;

&lt;p&gt;简单来说，如果要完美地采样一个函数f(t)，采样间隔必须小于或等于\( \frac {1}{2B} \)秒（大于或等于2B赫兹），B是这个f(t)的频域的最大赫兹。&lt;/p&gt;

&lt;p&gt;继续推导。&lt;/p&gt;

&lt;p&gt;既然时域的范围是L，完美的采样频率是2B，那么理论上要采样的点共有这么多个：&lt;/p&gt;

&lt;p&gt;\[ N = \frac {L}{1/2B} = 2BL \]&lt;/p&gt;

&lt;p&gt;时域的采样点横坐标列表如下：&lt;/p&gt;

&lt;p&gt;\[ t_{0} = 0, t_{1} = \frac {1}{2B}, t_{2} = \frac {2}{2B}, \cdots , t_{N-1} = \frac {N-1}{2B} \]&lt;/p&gt;

&lt;p&gt;所以，f(t)的离散版本\( f_{discrete}(t) \)就是这个采样点列表\( f(t_{0}), f(t_{1}),\cdots , f(t_{N-1}) \)。&lt;/p&gt;

&lt;p&gt;接下来轮到&lt;strong&gt;卷积&lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;Convolution&lt;/a&gt;和&lt;strong&gt;狄拉克梳状函数&lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_comb&quot;&gt;Dirac comb&lt;/a&gt;登场。&lt;/p&gt;

&lt;p&gt;(关于卷积和狄拉克梳状函数，请阅读我的其他文章&lt;a href=&quot;http://www.qiujiawei.com/convolution&quot;&gt;理解卷积&lt;/a&gt;，&lt;a href=&quot;http://www.qiujiawei.com/shah-function&quot;&gt;狄拉克梳状函数&lt;/a&gt; )。&lt;/p&gt;

&lt;p&gt;继续讨论。因为上面得到的\( f_{discrete}(t) \)是不连续的，所以不能直接用傅里叶变换把它转换用到频域（标准傅里叶变换是处理连续函数的）。要把不连续信号转成连续信号，就是用卷积，即把离散信号和连续信号‘合并’。&lt;/p&gt;

&lt;p&gt;狄拉克梳状函数：&lt;/p&gt;

&lt;p&gt;\[ III_{T}(t) = \sum _{k=-\infty }^{\infty }\delta (t - kT)\]&lt;/p&gt;

&lt;p&gt;代入我们的离散横坐标\( (t_{0}, t_{1}, \cdots , t_{N-1} \)，则有：&lt;/p&gt;

&lt;p&gt;\[ III_{T=\frac {1}{2B}}(t) = \sum _{n=0 }^{N-1 }\delta (t - t_{n})\]&lt;/p&gt;

&lt;p&gt;定义一个\( f_{discrete}(t) \)，代表f(t)离散化后和shah函数合并:&lt;/p&gt;

&lt;p&gt;\[ f_{discrete}(t)  = \sum _{n=0 }^{N-1 }f(t_{n})\delta (t - t_{n}) \]&lt;/p&gt;

&lt;p&gt;这个式子是连续的(因为t的取值是连续的)。这个式子也叫做&lt;strong&gt;f(t)的采样形式&lt;/strong&gt;(the sampled form of f(t))。它的傅里叶变换是:&lt;/p&gt;

&lt;p&gt;\[ \mathcal {F}[f_{discrete}(s)] =  \sum _{n=0 }^{N-1 }f(t_{n})\mathcal {F}[\delta (t - t_{n})] = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi ist_{n} } \]&lt;/p&gt;

&lt;p&gt;注意，这个傅里叶变换也是连续的。&lt;/p&gt;

&lt;p&gt;上面是时域到频域的讨论，接下来换个角度：想一下如何在频域中对连续的频域信号做采样，并转换到时域。也即&lt;strong&gt;离散的逆傅里叶变换&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在频域中做采样，那么就是做离散化，&lt;strong&gt;频率间隔&lt;/strong&gt;应该是多少(赫兹)？频率公式是\(f =  \frac {1}{T} \)，f的单位是赫兹，赫兹是指&lt;strong&gt;1秒内震动次数&lt;/strong&gt;，震动次数要看信号的周期T。如果把t的范围L当做周期的话，1除以L就是指\( \frac {1}{L} \)赫兹，注意，&lt;strong&gt;这是频率的下限&lt;/strong&gt;，频率的上限是前面已经给出的2B，而我们要做的是在频率这条横轴上做采样，即从频率=0(赫兹)开始，间隔=1/L(赫兹)，到频率=2B(赫兹)结束，对F(s)进行采样。&lt;/p&gt;

&lt;p&gt;总共的频域采样点有这么多个:&lt;/p&gt;

&lt;p&gt;\[ \frac {2B}{\frac {1}{L}} = 2BL = N \]&lt;/p&gt;

&lt;p&gt;对比上面的时域采样，频域采样也有同样数目的采样点**。&lt;/p&gt;

&lt;p&gt;频域的采样点横坐标列表如下：&lt;/p&gt;

&lt;p&gt;\[ s_{0} = 0, s_{1} = \frac {1}{L}, s_{2} = \frac {2}{L}, \cdots , s_{N-1} = \frac {N-1}{L} \]&lt;/p&gt;

&lt;p&gt;有了采样点，就可以做采样了。但是是对什么东西做采样？结果有点反直觉，我们是对刚才推导出来的\( \mathcal {F}[f_{discrete}(s)] \)做采样，而不是\( \mathcal {F}[f(s)] \)。&lt;/p&gt;

&lt;p&gt;设\( F(s) \mathcal {F}[f_{discrete}(s)] \)，则F(s)的离散版本是:&lt;/p&gt;

&lt;p&gt;\[ F(s_{0}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{0}t_{n} }, F(s_{1}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{1}t_{n} }, \cdots ,F(s_{N-1}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{N-1}t_{n} } \]&lt;/p&gt;

&lt;p&gt;将这串东西再简化下:&lt;/p&gt;

&lt;p&gt;\[ F(s_{m}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{m}t_{n} } \]&lt;/p&gt;

&lt;p&gt;于是我们有了一道从离散f(t)到离散F(s)的公式！&lt;/p&gt;

&lt;p&gt;好像和前面给出的标准形式不一样？没事，还可以再变一变。&lt;/p&gt;

&lt;p&gt;由:&lt;/p&gt;

&lt;p&gt;\[ t_{n} = \frac {n}{2B} \]
\[ s_{m} = \frac {m}{L} \]&lt;/p&gt;

&lt;p&gt;有:&lt;/p&gt;

&lt;p&gt;\[ F(s_{m}) = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi is_{m}t_{n} } \]
\[ = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi i\frac {m}{L}\frac {n}{2B} } \]
\[ = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi imn/2BL } \]
\[ = \sum _{n=0 }^{N-1 }f(t_{n})e^{-2\pi imn/N } \]&lt;/p&gt;

&lt;h3&gt;傅里叶变换的应用&lt;/h3&gt;

&lt;p&gt;(如果理解了上面的DFT，基本不需要看这一节)&lt;/p&gt;

&lt;h4&gt;采样和重建 Sampling and Reconstruction&lt;/h4&gt;

&lt;p&gt;采样和重建这两个字花了我不少功夫去理解。其实并不复杂，举一个例子吧。&lt;/p&gt;

&lt;p&gt;假设现在有一个你不太喜欢的信号函数f(t)，可以想象成一个充满毛刺的、扭曲的正弦波形曲线(理论上不必须是波形)。你觉得它太丑了，想给它整容，变成你喜欢的模样。那么，就可以这样子做：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;采样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在横轴上挑选一些你觉得不错的坐标t，代入f(t)，这样就得到了一个坐标集合\( (t_{i},f(t_{i}))(i=[0,n]) \)。
这个过程叫做采样，这些坐标对样本，对应的t坐标叫做采样点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重建&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过采样后，原来的连续的f(t)变成了离散的\( f(t_{i})(i=[0,n]) \)(continuous to descrete)。对于这个\(f(t_{i})\)，我们可以根据这些坐标，重新构建一条新的曲线，也就是说，整出一条新的曲线，使得这条新曲线会通过所有的采样坐标点。这个过程叫做重建。&lt;/p&gt;

&lt;p&gt;重点来了:&lt;strong&gt;采样和重建是通过傅里叶变换完成的&lt;/strong&gt;。这意味着什么？首先要记住，傅里叶变换，可以把时域的函数变成一个等价的频域的函数。我们还是按前面的做法，在时域上完成‘采样’工作，但是采样点要足够多，并且均匀。采样后，用傅里叶变换把\(f(t_{i})\)变成\(F(w_{i})\)，然后就可以&lt;strong&gt;在频域上完成真正的采样(或叫过滤)&lt;/strong&gt;。
在频域上采样，往往比在时域上采样要简单得多，比如说，你只对中高频信号感兴趣，那么就可以只采样那些频率高的点。对F(w_{i})采样后，得到F&amp;#39;(w_{i})，再通过&lt;strong&gt;逆傅里叶变换&lt;/strong&gt;，就可以得到一个新的f&amp;#39;(t)。整容完毕。&lt;/p&gt;

&lt;p&gt;哦，还有一个细节要注意，这个采样和重建用的傅里叶变换是&lt;strong&gt;离散傅里叶变换&lt;/strong&gt;。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/fourier-equation/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/fourier-equation/</guid>
      </item>
    
      <item>
        <title>复数和三角函数</title>
        <description>&lt;h2&gt;欧拉公式&lt;/h2&gt;

&lt;p&gt;复数和三角函数有密切的联系，因为大神欧拉发现了这样的公式：&lt;/p&gt;

&lt;p&gt;\[ e^{ix} = \cos x + i\sin x\]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图片来自
&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler%27s_formula&quot;&gt;wikipedia-Euler-formula&lt;/a&gt;)&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;怎么推导出欧拉公式?&lt;/h2&gt;

&lt;p&gt;设z是复数平面的一个复数，且用三角函数来表示它的实数和虚数：&lt;/p&gt;

&lt;p&gt;\[ z = \cos \theta + i\sin \theta \]&lt;/p&gt;

&lt;p&gt;两边算微分:&lt;/p&gt;

&lt;p&gt;\[ dz = (-\sin \theta + i\cos \theta)d\theta \]&lt;/p&gt;

&lt;p&gt;提取i:&lt;/p&gt;

&lt;p&gt;\[ dz = i( \cos \theta + i\sin \theta )d\theta \]&lt;/p&gt;

&lt;p&gt;注意看，括号内的东西，不就是z嘛，所以有:&lt;/p&gt;

&lt;p&gt;\[ dz = izd\theta \]&lt;/p&gt;

&lt;p&gt;换个写法:&lt;/p&gt;

&lt;p&gt;\[ \frac {1}{z}dz = id\theta \]&lt;/p&gt;

&lt;p&gt;两边求积分:&lt;/p&gt;

&lt;p&gt;\[ \int_{}^{} \frac {1}{z}dz = \int_{}^{} id\theta \]&lt;/p&gt;

&lt;p&gt;\[ \ln z = i\theta \]&lt;/p&gt;

&lt;p&gt;注意，右边的积分，是把i当做常数看待的，所以i直接被提取出来。&lt;/p&gt;

&lt;p&gt;再写出这个式子的指数形式:&lt;/p&gt;

&lt;p&gt;\[ e^{\ln z} = e^{i\theta } \]&lt;/p&gt;

&lt;p&gt;\[ z = e^{i\theta } = \cos \theta + i\sin \theta \]&lt;/p&gt;

&lt;p&gt;推导完毕。&lt;/p&gt;

&lt;h2&gt;欧拉公式的延伸特性&lt;/h2&gt;

&lt;p&gt;由:&lt;/p&gt;

&lt;p&gt;\[ e^{ix} = \cos x + i\sin x\]&lt;/p&gt;

&lt;p&gt;得到:&lt;/p&gt;

&lt;p&gt;\[ e^{-ix} = \cos (-x) + i\sin (-x) = \cos x - i\sin x \]&lt;/p&gt;

&lt;p&gt;上面两个等式相加:&lt;/p&gt;

&lt;p&gt;\[ e^{ix} + e^{-ix} = (\cos x + i\sin x) + (\cos x - i\sin x) \]&lt;/p&gt;

&lt;p&gt;\[ = 2\cos x \]&lt;/p&gt;

&lt;p&gt;所以有:&lt;/p&gt;

&lt;p&gt;\[ \cos x = \frac {e^{ix} + e^{-ix}}{2} \]&lt;/p&gt;

&lt;p&gt;同样的，把上面2个等式相减:&lt;/p&gt;

&lt;p&gt;\[ e^{ix} - e^{-ix} = (\cos x + i\sin x) - (\cos x - i\sin x) \]&lt;/p&gt;

&lt;p&gt;\[ = 2i\sin x \]&lt;/p&gt;

&lt;p&gt;所以有:&lt;/p&gt;

&lt;p&gt;\[ \sin x = \frac {e^{ix} - e^{-ix}}{2i} \]&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/complex-1/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/complex-1/</guid>
      </item>
    
      <item>
        <title>PBRT《章3》阅读笔记</title>
        <description>&lt;p&gt;第三章介绍各种特殊几何体。&lt;/p&gt;

&lt;h3&gt;Ray与Sphere的相交判断&lt;/h3&gt;
</description>
        <pubDate>Mon, 05 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/pbrt-chapter3/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/pbrt-chapter3/</guid>
      </item>
    
      <item>
        <title>线性代数之TRS分解</title>
        <description>&lt;h3&gt;pbrt的TRS分解&lt;/h3&gt;

&lt;p&gt;设矩阵A，假设A可以分解成T、R、S，则有A=TRS，设A:&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} A_{11}&amp;amp;A_{12}&amp;amp;A_{13}&amp;amp;A_{14}\\ A_{21}&amp;amp;A_{22}&amp;amp;A_{23}&amp;amp;A_{24}\\ A_{31}&amp;amp;A_{32}&amp;amp;A_{33}&amp;amp;A_{34}\\ A_{41}&amp;amp;A_{42}&amp;amp;A_{43}&amp;amp;A_{44}\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;再设T、R、S分别为：&lt;/p&gt;

&lt;p&gt;\[ T =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;t_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;t_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;t_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;\[ R =  \left[ \begin{matrix} r_{11}&amp;amp;r_{12}&amp;amp;r_{13}&amp;amp;0\\ r_{21}&amp;amp;r_{22}&amp;amp;r_{23}&amp;amp;0\\ r_{31}&amp;amp;r_{32}&amp;amp;r_{33}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;\[ S =  \left[ \begin{matrix} s_{x}&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;s_{y}&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;t_{y}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;所以TRS等于：&lt;/p&gt;

&lt;p&gt;\[ A = TRS =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;t_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;t_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;t_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} r_{11}&amp;amp;r_{12}&amp;amp;r_{13}&amp;amp;0\\ r_{21}&amp;amp;r_{22}&amp;amp;r_{23}&amp;amp;0\\ r_{31}&amp;amp;r_{32}&amp;amp;r_{33}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} s_{x}&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;s_{y}&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;t_{y}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]\]
\[ =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;t_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;t_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;t_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} r_{11}s_{x}&amp;amp;r_{12}s_{y}&amp;amp;r_{13}s_{z}&amp;amp;0\\ r_{21}s_{x}&amp;amp;r_{22}s_{y}&amp;amp;r_{23}s_{z}&amp;amp;0\\ r_{31}s_{x}&amp;amp;r_{32}s_{y}&amp;amp;r_{33}s_{z}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]\]
\[  =  \left[ \begin{matrix} r_{11}s_{x}&amp;amp;r_{12}s_{y}&amp;amp;r_{13}s_{z}&amp;amp;t_{x}\\ r_{21}s_{x}&amp;amp;r_{22}s_{y}&amp;amp;r_{23}s_{z}&amp;amp;t_{y}\\ r_{31}s_{x}&amp;amp;r_{32}s_{y}&amp;amp;r_{33}s_{z}&amp;amp;t_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;从TRS矩阵可以看出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A矩阵的最后一行为[0,0,0,1]&lt;/li&gt;
&lt;li&gt;A的最后一列是T的最后一列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以T是最好求的：&lt;/p&gt;

&lt;p&gt;\[ T =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;A_{14}\\ 0&amp;amp;1&amp;amp;0&amp;amp;A_{24}\\ 0&amp;amp;0&amp;amp;1&amp;amp;A_{34}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;同时，我们也可以快速知道RS矩阵：&lt;/p&gt;

&lt;p&gt;\[ RS =  \left[ \begin{matrix} A_{11}&amp;amp;A_{12}&amp;amp;A_{13}&amp;amp;0\\ A_{21}&amp;amp;A_{22}&amp;amp;A_{23}&amp;amp;0\\ A_{31}&amp;amp;A_{32}&amp;amp;A_{33}&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;问题就简化成：如果让RS分解成R和S。&lt;/p&gt;

&lt;p&gt;pbrt的解法比较神奇，称为polar decomposition(极分解?)。&lt;/p&gt;

&lt;p&gt;(这算法似乎是用来求矩阵的平方根的，但是为什么可以用在这里，我没搞明白，也没找到证明过程。有知道的朋友麻烦告知一下哈)&lt;/p&gt;

&lt;p&gt;pbrt给了一个公式是：&lt;/p&gt;

&lt;p&gt;\[ M_{i+1} = \frac {1}{2}(M_{i} + (M_{i}^{T})^{-1}) \]&lt;/p&gt;

&lt;p&gt;把M = RS代入这个公式，迭代多次后，M的值会收敛，得到的最终的M就是R。&lt;/p&gt;

&lt;p&gt;然后S就等于\(S = (RS)R^{-1} \)。&lt;/p&gt;

&lt;p&gt;因为R是一个转换矩阵，意味着经过S转换后的点，还是处于原来的空间，只是坐标变换了。那么R必然是一个正交矩阵(列向量之间线性无关)，所以有\(R^{T}=R^{-1}\)。
将这个式子代入上面的公式，可以发现:&lt;/p&gt;

&lt;p&gt;\[ R_{i+1} = \frac {1}{2}(R_{i} + (R_{i}^{T})^{-1}) \]
\[ = \frac {1}{2}(R_{i} + (R_{i}^{-1})^{-1}) \]
\[ = \frac {1}{2}(R_{i} + R_{i}) \]
\[ = \frac {1}{2}2R_{i}  = R_{i} \]&lt;/p&gt;

&lt;p&gt;即是说，对于一个纯粹的旋转矩阵R，将R和R的转置的逆矩阵求平均，依然还是R。&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-8/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-8/</guid>
      </item>
    
      <item>
        <title>线性代数之各种各样的矩阵</title>
        <description>&lt;p&gt;矩阵家族成员非常多，本文主要记录了我遇到过的矩阵(前面的文章所提到的矩阵，在这里就不重复列举了)。以后见识了新的矩阵时，会继续扩充本文。&lt;/p&gt;

&lt;p&gt;(以下知识均查阅了wikipedia。单词的中文翻译查的是有道词典。)&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;共轭(转置)矩阵 Conjugate Transpose Matrix&lt;/h2&gt;

&lt;p&gt;公式上的定义：&lt;/p&gt;

&lt;p&gt;\[ A^{*} = (\overline {A})^{T} \]&lt;/p&gt;

&lt;p&gt;A上面的横线表示对矩阵中的元素的复数部分取反(类似复数的上横线)。&lt;/p&gt;

&lt;p&gt;回想下共轭复数的定义，可以发现，矩阵的共轭，还需要再转置一下，很很大的一个不同点。&lt;/p&gt;

&lt;p&gt;共轭矩阵还有其他表达形式：&lt;/p&gt;

&lt;p&gt;\[ A^{\dagger } = A^{*} = A^{H} \]&lt;/p&gt;

&lt;h2&gt;厄米特矩阵 Hermitian matrix&lt;/h2&gt;

&lt;p&gt;厄米特矩阵也称为self-adjoint matrix，中文是：自伴矩阵、自共轭矩阵、自伴随矩阵。&lt;/p&gt;

&lt;p&gt;厄米特矩阵必须满足下面的性质:&lt;/p&gt;

&lt;p&gt;\[ A = A^{*} \]&lt;/p&gt;

&lt;p&gt;即，A等于A的共轭矩阵时，A是一个厄米特矩阵。&lt;/p&gt;

&lt;h2&gt;单式矩阵 Unitary matrix&lt;/h2&gt;

&lt;p&gt;其他名称：酉矩阵/幺正矩阵。&lt;/p&gt;

&lt;p&gt;看名字有点像单位矩阵(Unit matrix)，但是公式上的定义是这样子的：&lt;/p&gt;

&lt;p&gt;\[ U^{*}U = I \]&lt;/p&gt;

&lt;p&gt;即：如果矩阵的共轭乘以矩阵自身等于单位矩阵，那么它是一个单式矩阵。&lt;/p&gt;

&lt;h2&gt;正定矩阵 Positive Definite Matrix&lt;/h2&gt;

&lt;p&gt;定义比较复杂，我翻译下wikipedia的定义吧：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个对称的n阶实数矩阵M，设元素不全为0的列向量为z，当所有这样的z满足\( z^{T}Mz &amp;gt; 0\)时，M是正定矩阵。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据定义，可以知道单位矩阵I是正定的；&lt;/p&gt;

&lt;p&gt;贴上wiki的例子来帮助理解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;设M的z为(a,b,c)，则有：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.10/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个式子的结果显然是非负的，且当a=b=c=0时，这个式子才等于0，所以满足正定矩阵的条件。&lt;/p&gt;

&lt;h2&gt;半正定矩阵 Positive Semi-Definite&lt;/h2&gt;

&lt;p&gt;参考正定矩阵，半正定矩阵的定义公式是:\( z^{T}Mz &amp;gt;= 0\)。&lt;/p&gt;

&lt;h2&gt;负定矩阵 Negative Definite Matrix&lt;/h2&gt;

&lt;p&gt;参考正定矩阵，负定矩阵的定义公式是:\( z^{T}Mz &amp;lt; 0\)。&lt;/p&gt;

&lt;h2&gt;半负定矩阵 Negative Semi-Definite Matrix&lt;/h2&gt;

&lt;p&gt;参考正定矩阵，负定矩阵的定义公式是:\( z^{T}Mz &amp;lt;= 0\)。&lt;/p&gt;

&lt;h2&gt;厄米特矩阵的正定矩阵&lt;/h2&gt;

&lt;p&gt;参考正定矩阵，厄米特矩阵的正定矩阵的定义公式是:\( z^{*}Mz &amp;gt; 0\)，注意，算出来的值必须是实数，不能是复数。&lt;/p&gt;

&lt;h2&gt;规范化矩阵 Normal Matrix&lt;/h2&gt;

&lt;p&gt;又名：正规矩阵、正规阵、规范矩阵。&lt;/p&gt;

&lt;p&gt;wiki:&lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_matrix&quot;&gt;https://en.wikipedia.org/wiki/Normal_matrix&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当矩阵A满足:&lt;/p&gt;

&lt;p&gt;\[ A^{*}A = AA^{*} \]&lt;/p&gt;

&lt;p&gt;A即为Normal Matrix。&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-7/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-7/</guid>
      </item>
    
      <item>
        <title>Understanding Quaternions 中文翻译《理解四元数》</title>
        <description>&lt;p&gt;原文地址:&lt;a href=&quot;http://www.3dgep.com/understanding-quaternions/&quot;&gt;http://www.3dgep.com/understanding-quaternions/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;在这篇文章中我会尝试用简单的方式去解释四元数的概念，即用可视化的方式解释四元数以及几种对四元数的操作。我将把矩阵、欧拉角和四元数放在一起比较，并解释什么时候该用四元数、什么时候该用欧拉角或矩阵。&lt;/p&gt;

&lt;h3&gt;内容结构&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;复数

&lt;ul&gt;
&lt;li&gt;复数的加减&lt;/li&gt;
&lt;li&gt;复数的系数缩放&lt;/li&gt;
&lt;li&gt;复数的积&lt;/li&gt;
&lt;li&gt;复数的平方&lt;/li&gt;
&lt;li&gt;共轭复数&lt;/li&gt;
&lt;li&gt;复数的绝对值&lt;/li&gt;
&lt;li&gt;两复数的商&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;i的幂&lt;/li&gt;
&lt;li&gt;复数平面

&lt;ul&gt;
&lt;li&gt;旋转数（Rotors)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;四元数

&lt;ul&gt;
&lt;li&gt;作为有序数的四元数&lt;/li&gt;
&lt;li&gt;四元数的加减&lt;/li&gt;
&lt;li&gt;四元数的积&lt;/li&gt;
&lt;li&gt;实四元数&lt;/li&gt;
&lt;li&gt;四元数的系数缩放&lt;/li&gt;
&lt;li&gt;纯四元数&lt;/li&gt;
&lt;li&gt;四元数的加法形式&lt;/li&gt;
&lt;li&gt;单位四元数&lt;/li&gt;
&lt;li&gt;四元数的二元形式&lt;/li&gt;
&lt;li&gt;共轭四元数&lt;/li&gt;
&lt;li&gt;四元数范数&lt;/li&gt;
&lt;li&gt;四元数规范化&lt;/li&gt;
&lt;li&gt;四元数的逆&lt;/li&gt;
&lt;li&gt;四元数的点乘&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;旋转&lt;/li&gt;
&lt;li&gt;四元数的插值

&lt;ul&gt;
&lt;li&gt;SLERP

&lt;ul&gt;
&lt;li&gt;四元数的差&lt;/li&gt;
&lt;li&gt;四元数的指数运算&lt;/li&gt;
&lt;li&gt;2个四元数的分数差&lt;/li&gt;
&lt;li&gt;注意事项&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SQUARD&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;结论&lt;/li&gt;
&lt;li&gt;下载Demo&lt;/li&gt;
&lt;li&gt;引用&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;在计算机图形学中，我们使用转换矩阵来表示空间中的一个位置以及朝向。一个转换矩阵还可以表示对一个目标的缩放(scale)或错切(shear)等。   我们可以把转换矩阵想象成一个空间，当你用这个矩阵乘以向量、点（甚至矩阵）后， 你就把向量、点、矩阵转换进这个空间了。&lt;/p&gt;

&lt;p&gt;在这篇文章中，我不会讨论转换矩阵的细节。你可以查看我前面的文章，文章中描述了转换矩阵的细节。&lt;/p&gt;

&lt;p&gt;在这篇文章中，我想要讨论一个可替代的方案，即用四元数来描述空间里的物体的朝向。&lt;/p&gt;

&lt;p&gt;四元数的概念是由爱尔兰数学家Sir William Rowan Hamilton发明的（1843年，都柏林）。Hamilton当时正和他的妻子前往爱尔兰皇家研究院，当他从Brougham桥通过皇家运河时，他领悟到了一个激动人心的东西，并立刻把它刻在桥的一个石头上：&lt;/p&gt;

&lt;p&gt;\[ i^{2} = j^{2} = k^{2} = ijk = -1 \]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/2.jpg&quot; alt=&quot;2.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;William Rowan Hamilton Plaque on Broome Bridge on the Royal Canal commemorating his discovery of the fundamental formula for quaternion multiplication.&lt;/p&gt;

&lt;h3&gt;复数&lt;/h3&gt;

&lt;p&gt;在我们能够完全理解四元数之前，我们必须先知道四元数是怎么来的。四元数的根源其实是&lt;strong&gt;复数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;除了知名的数集（自然数、整数、实数、分数）之外，复数系统引入了一个新的数集——虚数。虚数的发明是为了解决一些特定的无解的方程，例如：
\[ x^{2} + 1 = 0 \]
要解决这个等式，必须让\(x^{2} = -1 \)，这当然是不行的，因为任意实数的平方都是非负数。&lt;/p&gt;

&lt;p&gt;一般而言，数学家是不能忍受一个等式是无解的。于是，一个新的术语被发明了，它就是虚数，一个可以解决上面这个等式的数。&lt;/p&gt;

&lt;p&gt;虚数有这样的形式：&lt;/p&gt;

&lt;p&gt;\[ i^{2} = -1 \]&lt;/p&gt;

&lt;p&gt;不要为这个术语较真，因为逻辑上这个数是不存在的。只要知道i是一个平方等于-1的东西即可。&lt;/p&gt;

&lt;p&gt;虚数的集合可以用\( \mathbb{I} \)来表示。&lt;/p&gt;

&lt;p&gt;复数的集合\( \mathbb{C} \)是一个实数和一个虚数的和，形式如下：&lt;/p&gt;

&lt;p&gt;\[ z = a + bi \ a,b\in R,\ i^{2} = -1 \]&lt;/p&gt;

&lt;p&gt;可以认为所有实数都是b=0的复数、所有虚数都是a=0的复数。&lt;/p&gt;

&lt;h3&gt;复数的加减&lt;/h3&gt;

&lt;p&gt;加法：&lt;/p&gt;

&lt;p&gt;\[ (a_{1} + b_{1}i) + (a_{2} + b_{2}i) = (a_{1} + a_{2}) + (b_{1} + b_{2})i \]&lt;/p&gt;

&lt;p&gt;减法：&lt;/p&gt;

&lt;p&gt;\[ (a_{1} + b_{1}i) - (a_{2} + b_{2}i) = (a_{1} - a_{2}) + (b_{1} - b_{2})i \]&lt;/p&gt;

&lt;h3&gt;复数的系数缩放&lt;/h3&gt;

&lt;p&gt;\[ \lambda (a_{1} + b_{1}i) = \lambda  a_{1} + \lambda b_{1}i \]&lt;/p&gt;

&lt;h3&gt;复数的积&lt;/h3&gt;

&lt;p&gt;\[  z_{1} = (a_{1} + b_{1}i) \]
\[  z_{2} = (a_{2} + b_{2}i) \]
\[  z_{1}z_{2} = (a_{1} + b_{1}i)(a_{2} + b_{2}i) = a_{1}a_{2} + a_{1}b_{2}i + b_{1}a_{2}i+b_{1}b_{2}i^{2} \]
\[ z_{1}z_{2} = (a_{1}a_{2} - b_{1}b_{2}) + (a_{1}b_{2} + b_{1}a_{2})i \]&lt;/p&gt;

&lt;h3&gt;复数的平方&lt;/h3&gt;

&lt;p&gt;\[ z = (a + bi) \]
\[ z^{2} = (a + bi)(a + bi) \]
\[ z^{2} = (a^{2} - b^{2}) + 2abi \]&lt;/p&gt;

&lt;h3&gt;共轭复数&lt;/h3&gt;

&lt;p&gt;复数的共轭就是指把复数的虚数部分变成负的。共轭复数的符号是\(\bar z\)或\(z^{*}\)。&lt;/p&gt;

&lt;p&gt;\[ z = (a + bi) \]&lt;/p&gt;

&lt;p&gt;\[ z^{*} = (a - bi) \]&lt;/p&gt;

&lt;p&gt;复数和它的共轭复数的乘积是：&lt;/p&gt;

&lt;p&gt;\[ zz^{*} = (a + bi)(a - bi) = a^{2}-abi+abi+b^{2} = a^{2}+b^{2} \]&lt;/p&gt;

&lt;h3&gt;复数的绝对值&lt;/h3&gt;

&lt;p&gt;我们使用共轭复数来计算复数的绝对值：&lt;/p&gt;

&lt;p&gt;\[ z = (a + bi) \]&lt;/p&gt;

&lt;p&gt;\[ |z| = \sqrt {zz^{*}} = \sqrt {(a + bi)(a - bi)} = \sqrt {a^{2} + b^{2} } \]&lt;/p&gt;

&lt;h3&gt;两复数的商&lt;/h3&gt;

&lt;p&gt;\[  z_{1} = (a_{1} + b_{1}i) \]
\[  z_{2} = (a_{2} + b_{2}i) \]
\[ \frac {z_{1}}{z_{2}} = \frac {a_{1} + b_{1}i}{a_{2} + b_{2}i} = \frac {(a_{1} + b_{1}i)(a_{2} - b_{2}i)}{(a_{2} + b_{2}i)(a_{2} - b_{2}i)} \]
\[  = \frac {a_{1}a_{2}-a_{1}b_{2}i+b_{1}a_{2}i-b_{1}b_{2}i^{2} }{a_{2}^{2} + b_{2}^{2}} \]&lt;/p&gt;

&lt;p&gt;\[ = \frac {a_{1}a_{2} + b_{1}b_{2} }{a_{2}^{2} + b_{2}^{2}}   + \frac {b_{1}a_{2} - a_{1}b_{2} }{a_{2}^{2} + b_{2}^{2}}i \]&lt;/p&gt;

&lt;h2&gt;i的幂&lt;/h2&gt;

&lt;p&gt;如果i的平方等于-1，那么i的n次幂也应该存在：&lt;/p&gt;

&lt;p&gt;\[ i^{0} = 1 \]
\[ i^{1} = i \]
\[ i^{2} = -1 \]
\[ i^{3} = ii^{2} = -i \]
\[ i^{4} = i^{2}i^{2} = 1 \]
\[ i^{5} = ii^{4} = i \]
\[ i^{6} = ii^{5} = i^{2} = -1 \]&lt;/p&gt;

&lt;p&gt;如果按照这个顺序写下去，会出现这样一个模式：
(1,i,-1,-i,1,...)&lt;/p&gt;

&lt;p&gt;一个类似的模式也出现在递增的负数幂：&lt;/p&gt;

&lt;p&gt;\[ i^{0} = 1 \]
\[ i^{-1} = -i \]
\[ i^{-2} = -1 \]
\[ i^{-3} = i \]
\[ i^{-4} = 1 \]
\[ i^{-5} = -i \]
\[ i^{-6} = -1 \]&lt;/p&gt;

&lt;p&gt;你可能已经在数学里头见过类似的模式，但是是以（x,y,-x,-y,x,...)的形式，这是在2D笛卡尔平面对一个点逆时针旋转90度时生成的；（x,-y,-x,y,x,...)则是在2D笛卡尔平面对一个点顺时针旋转90度时生成的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;复数平面&lt;/h2&gt;

&lt;p&gt;我们也能够把复数映射到一个2D网格平面——复数平面，只需要把实数映射到横轴、虚数映射到纵轴。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;如前面的序列所示，我们可以认为，对一个复数乘以i，这个复数就在复数平面上旋转了90度。&lt;/p&gt;

&lt;p&gt;让我们看看这是不是真的。我们随机地在复数平面上取一个点：&lt;/p&gt;

&lt;p&gt;\[ p = 2 + i \]&lt;/p&gt;

&lt;p&gt;p乘以i后得到q：
\[ q = pi = (2+i)i = 2i+i^{2} = -1+2i \]&lt;/p&gt;

&lt;p&gt;q乘以i后得到r：
\[ r = qi = (-1+2i)i = -i+2i^{2} = -2-i \]&lt;/p&gt;

&lt;p&gt;r乘以i后得到s：
\[ s = ri = (-2-i)i = -2i-i^{2} = 1-2i \]&lt;/p&gt;

&lt;p&gt;s乘以i后得到t：
\[ t = si = (1-2i)i = i-2i^{2} = 2+i \]&lt;/p&gt;

&lt;p&gt;t刚好是开始的p。如果我们把这些复数放到复数平面上，就得到下面的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们也可以按顺时针方向旋转，只需要把上面的乘数i改成-i。&lt;/p&gt;

&lt;h3&gt;旋转数（Rotors)&lt;/h3&gt;

&lt;p&gt;我们也可以在复数平面上进行任意角度的旋转，只需要定义下面这个复数：
\[q = cos\theta +isin\theta \]&lt;/p&gt;

&lt;p&gt;任意的复数乘以q：&lt;/p&gt;

&lt;p&gt;\[ p = a + bi \]
\[ q = cos\theta + isin\theta \]
\[ pq = (a + bi)(cos\theta + isin\theta ) \]
\[ a&amp;#39; + b&amp;#39;i = acos\theta -bsin\theta + (asin\theta +bcos\theta )i \] &lt;/p&gt;

&lt;p&gt;也可以写成矩阵的形式：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} a&amp;#39;&amp;amp;-b&amp;#39;\\ b&amp;#39;&amp;amp;a&amp;#39;\\ \end{matrix} \right] =  \left[ \begin{matrix} cos\theta &amp;amp;-sin\theta \\ sin\theta &amp;amp;cos\theta \\ \end{matrix} \right] \left[ \begin{matrix} a&amp;amp;-b\\ b&amp;amp;a\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;这也是一个在复数平面绕原点逆时针旋转任意点的方法。（译注：这句话应该是在说旋转矩阵）&lt;/p&gt;

&lt;h2&gt;四元数&lt;/h2&gt;

&lt;p&gt;了解了复数系统和复数平面后，我们可以额外增加2个虚数到我们的复数系统，从而把这些概念拓展到3维空间。&lt;/p&gt;

&lt;p&gt;四元数的一般形式：&lt;/p&gt;

&lt;p&gt;\[ q = s + xi + yj + zk \ \ \ s,x,y,z \in \mathbb{R} \]&lt;/p&gt;

&lt;p&gt;上面的公式是根据Hamilton的著名的表达式得到的：&lt;/p&gt;

&lt;p&gt;\[ i^{2} = j^{2} = k^{2} = ijk = -1 \]&lt;/p&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;p&gt;\[ ij = k \ \ \ jk = i \ \ \ ki = j \]
\[ ji = -k \ \ \ kj = -i \ \ \ ik = -j \]&lt;/p&gt;

&lt;p&gt;你可能已经注意到了，i、j、k之间的关系非常像笛卡尔坐标系下单位向量的叉积规则：&lt;/p&gt;

&lt;p&gt;\[ x\times y = z \ \ \ y\times z = x \ \ \ z\times x = y \]
\[ y\times x = -z \ \ \ z\times y = -x \ \ \ x\times z = -y \]&lt;/p&gt;

&lt;p&gt;Hamilton自己也发现i、j、k虚数可以被用来表达3个笛卡尔坐标系单位向量i、j、k，并且仍然保持有虚数的性质，也即\( i^{2} = j^{2} = k^{2} = -1 \)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/6.png&quot; alt=&quot;6.png&quot;&gt;
（ij, jk, ki这几个性质的可视化）&lt;/p&gt;

&lt;p&gt;上图展示了如何用i、j、k作为笛卡尔坐标系的单位向量。&lt;/p&gt;

&lt;h3&gt;作为有序数的四元数&lt;/h3&gt;

&lt;p&gt;我们可以用有序对的形式，来表示四元数：
\[ [s,v] \ \ \ s\in \mathbb{R},v\in \mathbb{R^{3}} \]&lt;/p&gt;

&lt;p&gt;其中的v，也可以用它各自独立的3个分量表示：&lt;/p&gt;

&lt;p&gt;\[ q = [s,xi + yj + zk] \ \ \ s,x,y,z\in \mathbb{R} \]&lt;/p&gt;

&lt;p&gt;使用这种表示法，我们可以更容易地展示四元数和复数之间的相似性。&lt;/p&gt;

&lt;h3&gt;四元数的加减&lt;/h3&gt;

&lt;p&gt;和复数类似，四元数也可以被加减：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [s_{a},a] \]
\[ q_{b} = [s_{b},b] \]
\[ q_{a} + q_{b} = [s_{a} + s_{b},a + b] \]
\[ q_{a} - q_{b} = [s_{a} - s_{b},a - b] \]&lt;/p&gt;

&lt;h3&gt;四元数的积&lt;/h3&gt;

&lt;p&gt;我们也可以表示四元数的乘积：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [s_{a},a][s_{b},b] \]
\[ = (s_{a} + x_{a}i + y_{a}j +z_{a}k)(s_{b} + x_{b}i + y_{b}j +z_{b}k) \]
\[ = (s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}) \]
\[ + (s_{a}x_{b} + s_{b}x_{a} + y_{a}z_{b} - y_{b}z_{a})i \]
\[ + (s_{a}y_{b}+s_{b}y_{a}+z_{a}x_{b}-z_{b}x_{a})j \]
\[ + (s_{a}z_{b}+s_{b}z_{a}+x_{a}y_{b}-x_{b}y_{a})k \]&lt;/p&gt;

&lt;p&gt;可以看到，四元数的乘积依然还是一个四元数。如果我们把虚数i、j、k替换成有序对：&lt;/p&gt;

&lt;p&gt;\[ i = [0,i]\ \ \  j = [0,j]\ \ \  k = [0,k] \]&lt;/p&gt;

&lt;p&gt;以及还有[1,0] = 1，将它们代入前面的表达式，就得到了：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = (s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b})[1,0] \]
\[ + (s_{a}x_{b} + s_{b}x_{a} + y_{a}z_{b} - y_{b}z_{a})[0,i] \]
\[ + (s_{a}y_{b}+s_{b}y_{a}+z_{a}x_{b}-z_{b}x_{a})[0,j] \]
\[ + (s_{a}z_{b}+s_{b}z_{a}+x_{a}y_{b}-x_{b}y_{a})[0,k] \]&lt;/p&gt;

&lt;p&gt;再把这个表达式扩展成多个有序对的和：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [(s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}),0] \]
\[ + [0,(s_{a}x_{b} + s_{b}x_{a} + y_{a}z_{b} - y_{b}z_{a})i] \]
\[ + [0,(s_{a}y_{b}+s_{b}y_{a}+z_{a}x_{b}-z_{b}x_{a})j] \]
\[ + [0,(s_{a}z_{b}+s_{b}z_{a}+x_{a}y_{b}-x_{b}y_{a})k] \]&lt;/p&gt;

&lt;p&gt;如果把后3个四元数相加，并提取公共部分，就可以把等式改写成：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [(s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}),0] \]
\[ + [0,s_{a}(x_{b}i + y_{b}j+z_{b}k) + s_{b}(x_{a}i+y_{a}j+z_{a}k)\]
\[+(y_{a}z_{b}-y_{b}z_{a})i+(z_{a}x_{b}-z_{b}x_{a})j+(x_{a}y_{b}-x_{b}y_{a})k] \]&lt;/p&gt;

&lt;p&gt;这个等式是2个有序对的和。第1个有序对是一个&lt;strong&gt;实&lt;/strong&gt;四元数，第2个是一个&lt;strong&gt;纯&lt;/strong&gt;四元数。这两个四元数也可以合并成一个：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [(s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}), \]
\[ s_{a}(x_{b}i + y_{b}j+z_{b}k) + s_{b}(x_{a}i+y_{a}j+z_{a}k)\]
\[+(y_{a}z_{b}-y_{b}z_{a})i+(z_{a}x_{b}-z_{b}x_{a})j+(x_{a}y_{b}-x_{b}y_{a})k] \]&lt;/p&gt;

&lt;p&gt;如果把下面的表达式代入上面的等式：&lt;/p&gt;

&lt;p&gt;\[ a = x_{a}i + y_{a}j + z_{a}k\]
\[ b = x_{b}i + y_{b}j + z_{b}k\]
\[ a\cdot b = x_{a}x_{b}i^{2}+y_{a}y_{b}j^{2}+z_{a}z_{b}k^{2} \]
\[ a\times b = (y_{a}z_{b}-y_{b}z_{a})i + (z_{a}x_{b} - z_{b}x_{a})j + (x_{a}y_{b} - x_{b}y_{a})k  \]&lt;/p&gt;

&lt;p&gt;（译注：注意，第三条和第四条并不是四元数的点积和叉积，而是向量的点积和叉积）&lt;/p&gt;

&lt;p&gt;我们就得到了：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [s_{a}s_{b} - a\cdot b, s_{a}b+s_{b}a+a\times b] \]&lt;/p&gt;

&lt;p&gt;这就是四元数乘积的一般式。&lt;/p&gt;

&lt;h3&gt;实四元数&lt;/h3&gt;

&lt;p&gt;一个实四元数是一个虚部向量为零向量的四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [s,0] \]&lt;/p&gt;

&lt;p&gt;两个实四元数的乘积是另一个实四元数：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [s_{a},0] \]
\[ q_{b} = [s_{b},0] \]
\[ q_{a}q_{b} = [s_{a},0] [s_{b},0] = [s_{a}s_{b},0]  \]&lt;/p&gt;

&lt;p&gt;这和2个虚部为0的复数的乘积几乎一样：&lt;/p&gt;

&lt;p&gt;\[ z_{1} = a_{1} + 0i \]
\[ z_{2} = a_{2} + 0i \]
\[ z_{1}z_{2} = (a_{1} + 0i)(a_{2} + 0i) = a_{1}a_{2} \] &lt;/p&gt;

&lt;h3&gt;四元数的系数缩放&lt;/h3&gt;

&lt;p&gt;我们也可以用一个系数（实数）去乘四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ \lambda q = \lambda [s,v] = [\lambda s,\lambda v] \]&lt;/p&gt;

&lt;p&gt;我们可以用实四元数与普通四元数的乘积，来确认这个等式是否正确：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ \lambda = [\lambda ,0] \]
\[ \lambda q = [\lambda ,0][s,v] = [\lambda s,\lambda v] \]&lt;/p&gt;

&lt;h3&gt;纯四元数&lt;/h3&gt;

&lt;p&gt;和实四元数相似，Hamilton也定义了纯四元数。纯四元数是s=0的四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [0,v] \]&lt;/p&gt;

&lt;p&gt;也可以写成下面的形式：&lt;/p&gt;

&lt;p&gt;\[ q = xi + yj + zk \]&lt;/p&gt;

&lt;p&gt;然后是2个纯四元数的乘积：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [0,a] \]
\[ q_{b} = [0,b] \]
\[ q_{a}q_{b} = [0,a] [0,b] = [-a\cdot b, a\times b]  \]&lt;/p&gt;

&lt;h3&gt;四元数的加法形式&lt;/h3&gt;

&lt;p&gt;我们可以把四元数写成实四元数和纯四元数的和：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ = [s,0] + [0,v] \]&lt;/p&gt;

&lt;h3&gt;单位四元数&lt;/h3&gt;

&lt;p&gt;给定任意的向量v，我们可以把这个向量写成一个系数和一个单位方向向量的乘积：&lt;/p&gt;

&lt;p&gt;\[ v = \mathbf {v}\hat {v}\ \ \mathbf {v}=|v|,|\hat {v}|=1\]&lt;/p&gt;

&lt;p&gt;将这个定义和纯四元数的定义结合，就得到了：&lt;/p&gt;

&lt;p&gt;\[ q = [0,v] \]
\[ = [0,\mathbf {v} \hat {v}] \]
\[ = \mathbf {v} [0,\hat {v}] \]&lt;/p&gt;

&lt;p&gt;然后，我们可以定义单位四元数了，它是一个s=0、v为单位向量的四元数：&lt;/p&gt;

&lt;p&gt;\[ \hat {q} = [0, \hat {v}] \]&lt;/p&gt;

&lt;h3&gt;四元数的二元形式&lt;/h3&gt;

&lt;p&gt;我们现在可以把单位四元数的定义和四元数的加法形式结合到一起，就创造了一种新的四元数的表示法，这种表示法和复数的表示法形似：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ = [s,0] + [0,v] \]
\[ = [s,0] + \mathbf {v} [0,\hat {v}] \]
\[ = s + \mathbf {v} \hat {q} \]&lt;/p&gt;

&lt;p&gt;这就给了我们一种和复数非常相似的四元数表示法：&lt;/p&gt;

&lt;p&gt;\[ z = a + bi \]
\[ q = s + \mathbf {v} \hat {q} \]&lt;/p&gt;

&lt;h3&gt;共轭四元数&lt;/h3&gt;

&lt;p&gt;共轭四元数的计算，就是将四元数的虚向量取反：&lt;/p&gt;

&lt;p&gt;\[  q = [s,v] \]
\[  q^{*} = [s,-v] \]&lt;/p&gt;

&lt;p&gt;四元数和它的共轭四元数的乘积：&lt;/p&gt;

&lt;p&gt;\[  qq^{*} = [s,v][s,-v] \]
\[ = [s^{2} - v\cdot -v,-sv+sv+v\times -v] \]
\[ = [s^{2} + v\cdot v,0] \]
\[ = [s^{2} + v^{2},0] \]&lt;/p&gt;

&lt;h3&gt;四元数范数&lt;/h3&gt;

&lt;p&gt;回忆下复数范数的定义：&lt;/p&gt;

&lt;p&gt;\[ |z| = \sqrt {a^{2}+b^{2}} \]
\[ zz^{*} = |z|^{2} \]&lt;/p&gt;

&lt;p&gt;类似的，四元数的范数可以这样定义：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ |q| = \sqrt {s^{2} + v^{2}} \]&lt;/p&gt;

&lt;p&gt;这也让我们可以这样表达四元数范数：&lt;/p&gt;

&lt;p&gt;\[ qq^{*} = |q|^{2} \]&lt;/p&gt;

&lt;h3&gt;四元数规范化&lt;/h3&gt;

&lt;p&gt;利用四元数范数的定义，就可以对四元数进行规范化。要让一个四元数规范化，只需要让这个四元数去除以它的范数：&lt;/p&gt;

&lt;p&gt;\[ q&amp;#39; = \frac {q}{\sqrt {s^{2}+v^{2}}} \]&lt;/p&gt;

&lt;p&gt;举一个例子，让我们规范化下面这个四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [1, 4i + 4j - 4k] \]&lt;/p&gt;

&lt;p&gt;第一步，先计算q的范数：&lt;/p&gt;

&lt;p&gt;\[ |q| = \sqrt {1^{2}+4^{2}+4^{2}+(-4)^{2}} \]
\[ = \sqrt {49} = 7 \]&lt;/p&gt;

&lt;p&gt;然后，q除以|q|:&lt;/p&gt;

&lt;p&gt;\[ q&amp;#39; = \frac {q}{|q|} \]
\[ = \frac {(1+4i+4j-4k)}{7} \]
\[ = \frac {1}{7}+\frac {4}{7}i+\frac {4}{7}j-\frac {4}{7}k \]&lt;/p&gt;

&lt;h3&gt;四元数的逆&lt;/h3&gt;

&lt;p&gt;四元数的逆用\(q^{-1} \)表示。要计算四元数的逆，需要用四元数的共轭四元数去除以四元数的范数的平方：&lt;/p&gt;

&lt;p&gt;\[ q^{-1} = \frac {q^{*}}{|q|^{2} } \]&lt;/p&gt;

&lt;p&gt;为了证明这个式子，我们先根据&lt;strong&gt;逆&lt;/strong&gt;的定义，有：&lt;/p&gt;

&lt;p&gt;\[ qq^{-1} = [1,0] = 1 \]&lt;/p&gt;

&lt;p&gt;两边都左乘共轭四元数\(q^{&lt;em&gt;} \)：
\[ q^{&lt;/em&gt;}qq^{-1} = q^{*} \]&lt;/p&gt;

&lt;p&gt;将上文中的\( qq^{*} = |q|^{2} \)代入这个式子，得到：&lt;/p&gt;

&lt;p&gt;\[ |q|^{2}q^{-1} = q^{*} \] &lt;/p&gt;

&lt;p&gt;\[ q^{-1} = \frac {q^{*}}{|q|^{2}} \] &lt;/p&gt;

&lt;p&gt;对于单位四元数，它的范数是1，所以可以写成：&lt;/p&gt;

&lt;p&gt;\[ q^{-1} = q^{*} \]&lt;/p&gt;

&lt;h3&gt;四元数的点积&lt;/h3&gt;

&lt;p&gt;和向量的点积相似，我们也可以计算2个四元数的点积，只需要将各个对应的系数相乘，然后相加:&lt;/p&gt;

&lt;p&gt;\[ q_{1} = [s_{1},x_{1}i+y_{1}j+z_{1}k] \]
\[ q_{2} = [s_{2},x_{2}i+y_{2}j+z_{2}k] \]
\[ q_{1}\cdot q_{2} = s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2} \]&lt;/p&gt;

&lt;p&gt;我们也可以利用四元数点积，来计算四元数之间的角度差：&lt;/p&gt;

&lt;p&gt;\[ cos\theta = \frac {s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}}{|q_{1}||q_{2}|} \]&lt;/p&gt;

&lt;p&gt;对于单位四元数，我们可以简化上面的等式：
\[ cos\theta = s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2} \]&lt;/p&gt;

&lt;h2&gt;旋转&lt;/h2&gt;

&lt;p&gt;前面我们定义了一个特殊的复数：旋转数。它是用来旋转2D复数平面的点的：
\[ q = cos\theta + isin\theta \]&lt;/p&gt;

&lt;p&gt;根据四元数和复数的相似性，应该有可能设计一个可以旋转3D空间的点的四元数：
\[ q = [cos\theta, sin\theta v] \]&lt;/p&gt;

&lt;p&gt;让我们测试一下这个理论是否可靠，方法就是计算四元数q和向量p的积。第一步，我们把p写成纯四元数的形式：&lt;/p&gt;

&lt;p&gt;\[ p = [0,\textbf {p}] \]&lt;/p&gt;

&lt;p&gt;以及单位四元数q：&lt;/p&gt;

&lt;p&gt;\[ q = [s,\lambda \hat {v}] \]&lt;/p&gt;

&lt;p&gt;从而：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; = qp = [s,\lambda \hat {v}] [0,\textbf {p}] \]
\[ =  [-\lambda \hat {v}\cdot \textbf {p}, s\textbf {p} + \lambda \hat {v}\times \textbf {p} ] \]&lt;/p&gt;

&lt;p&gt;我们可以看到结果是一个同时有系数、有虚向量的四元数。&lt;/p&gt;

&lt;p&gt;让我们先考虑特殊的情形：\( \textbf {p} \)与\( \hat {v} \)正交。这种情况下，点乘部分等于0：\(-\lambda \hat {v}\cdot \textbf {p} = 0\)。所以上面的四元数就变成了纯四元数：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; =  [0, s\textbf {p} + \lambda \hat {v}\times \textbf {p}] \]&lt;/p&gt;

&lt;p&gt;这时候，要使\( \textbf {p} \)绕\( \hat {v} \)旋转，我们只需要代入\(s=cos\theta \)和\( \lambda =sin\theta \)：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; =  [0, cos\theta \textbf {p} + sin\theta \hat {v}\times \textbf {p}] \]&lt;/p&gt;

&lt;p&gt;现在，让我们找一个例子来测试上面的公式。譬如绕z轴(就是k轴)旋转45度，那么我们的四元数q就变成：&lt;/p&gt;

&lt;p&gt;\[ q = [cos\theta ,sin\theta k] \]
\[ = [\frac {\sqrt {2}}{2},\frac {\sqrt {2}}{2}k] \]&lt;/p&gt;

&lt;p&gt;然后，选一个特殊的p，并且p要和k轴正交，譬如把p放到i轴上，也就是：
\[ p = [0, 2i] \]&lt;/p&gt;

&lt;p&gt;好了，现在计算下qp：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; = qp \]
\[ = [\frac {\sqrt {2}}{2},\frac {\sqrt {2}}{2}k] [0,2i] \]
\[ = [0,2\frac {\sqrt {2}}{2}i + 2\frac {\sqrt {2}}{2}k\times i]  \]
\[  = [0, \sqrt {2}i + \sqrt {2}j] \]&lt;/p&gt;

&lt;p&gt;结果是一个绕了k轴转了45度的纯四元数。
我们可以确认这个四元数的向量部分的长度是：&lt;/p&gt;

&lt;p&gt;\[  p&amp;#39; = \sqrt { \sqrt {2}^{2} + \sqrt {2}^{2} }  =  2 \]&lt;/p&gt;

&lt;p&gt;这正是我们所期望的！&lt;/p&gt;

&lt;p&gt;我们可以用图像展示旋转过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/7.png&quot; alt=&quot;7.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;现在，让我们考虑更一般化的四元数，即和p不正交的四元数。现在让我们把p的向量部分偏移45度：&lt;/p&gt;

&lt;p&gt;\[ \hat {v} = \frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k \]&lt;/p&gt;

&lt;p&gt;\[ \textbf {p} = 2i \]&lt;/p&gt;

&lt;p&gt;\[ q = [cos\theta , sin\theta \hat {v}] \]&lt;/p&gt;

&lt;p&gt;\[ p = [0, \textbf {p}] \]&lt;/p&gt;

&lt;p&gt;然后算qp：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; = qp \]
\[ = [cos\theta ,sin\theta \hat {v}] [0, \mathbf {p} ]  \]
\[ [-sin\theta \hat {v}\cdot \mathbf {p}, cos\theta \mathbf {p}+sin\theta \hat {v}\times \mathbf {p}] \]&lt;/p&gt;

&lt;p&gt;代入我们设定的\(\hat {v}, \mathbf {p}\)，以及\(\theta = 45^{\circ } \)，得到：&lt;/p&gt;

&lt;p&gt;\[ p&amp;#39; = [-\frac {\sqrt {2}}{2}(\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)\cdot (2i), \frac {\sqrt {2}}{2}2i+\frac {\sqrt {2}}{2}(\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)\times 2i] \]
\[ = [-1, \sqrt {2}i + j] \]
注意，算出来的结果已经不是纯四元数了，并且，它并没有旋转45度、范数也不再是2(反而变小了，变成\(\sqrt {3}\))&lt;/p&gt;

&lt;p&gt;我们可以用图像展示旋转过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;严格来说，这样子在3维空间中表示\(p&amp;#39;\)是不正确的。因为它其实是一个4维的向量！为了简单起见，我只将这个四元数的向量部分显示出来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而，还有一线生机。Hamilton发现（但没有正式宣布），如果对qp右乘q的逆，出来的结果是一个纯四元数，并且四元数向量部分的范数可以保持不变。让我们试试应用在我们的例子里。&lt;/p&gt;

&lt;p&gt;首先计算:&lt;/p&gt;

&lt;p&gt;\[ q =  [cos\theta ,  sin\theta (\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)] \]&lt;/p&gt;

&lt;p&gt;\[ q^{-1} =  [cos\theta ,  -sin\theta (\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)] \]&lt;/p&gt;

&lt;p&gt;(译注：这里\(q^{-1}=q^{*}\)是因为q是单位四元数)&lt;/p&gt;

&lt;p&gt;再代入\(\theta = 45^{\circ } \)，得到：&lt;/p&gt;

&lt;p&gt;\[ q^{-1} =  [\frac {\sqrt {2}}{2},  -\frac {\sqrt {2}}{2}(\frac {\sqrt {2}}{2}i + \frac {\sqrt {2}}{2}k)] \]&lt;/p&gt;

&lt;p&gt;\[ \frac {1}{2}[\sqrt {2}, -i-k] \]&lt;/p&gt;

&lt;p&gt;现在，把前面算出来的qp再次拿出来：&lt;/p&gt;

&lt;p&gt;\[ qp = [-1, \sqrt {2}i + j] \]
\[ qpq^{-1}  = [-1, \sqrt {2}i + j]\frac {1}{2}[\sqrt {2}, -i-k] \]
\[ = \frac {1}{2}[-\sqrt {2}-(\sqrt {2}i+j)\cdot (-i-k), i+k+\sqrt {2}(\sqrt {2}i+j)-i+\sqrt {2}j+k] \]
\[ = \frac {1}{2}[-\sqrt {2}+\sqrt {2},i+k+2i+\sqrt {2}j-i+\sqrt {2}j+k] \]
\[ = [0,i+\sqrt {2}j+k] \]&lt;/p&gt;

&lt;p&gt;这下是纯四元数了，并且它的范数是：&lt;/p&gt;

&lt;p&gt;\[ |qpq^{-1}| = \sqrt {1^{2} + \sqrt {2}^{2} + 1^{2} } = \sqrt {4} = 2 \]&lt;/p&gt;

&lt;p&gt;这和原始的p的范数一致。&lt;/p&gt;

&lt;p&gt;下面的图像展示了旋转结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/9.png&quot; alt=&quot;9.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;所以我们可以看到，这个结果是一个纯四元数，并且原四元数的向量的范数也保持住了。但是还有一个问题：向量被旋转了90度而不是45度。这刚好是我们需要的度数的两倍！为了正确地让一个向量绕某个轴向量旋转某个角度，我们必须以目标角度的一半来计算。因此，我们构造了下面的四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [cos\frac {1}{2}\theta ,sin\frac {1}{2}\theta \hat {v}] \]&lt;/p&gt;

&lt;p&gt;这就是&lt;strong&gt;旋转四元数&lt;/strong&gt;的一般形式！&lt;/p&gt;

&lt;h2&gt;四元数插值&lt;/h2&gt;

&lt;p&gt;在计算机图形学中使用四元数，其中一个重要原因是四元数非常适合用来表示空间中的旋转。四元数解决了其他3维空间旋转算法会遇到的恼人的问题，比如使用欧拉角来表示旋转操作时会遇到的万向节锁问题(&lt;a href=&quot;https://en.wikipedia.org/wiki/Gimbal_lock&quot;&gt;Gimbal lock&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;使用四元数，我们可以定义好几种方案来表示3维空间的转动插值。第一种是SLERP，它被用来把一个点(物体)从一个朝向平滑地插值到另一个朝向。第二个是SLERP的扩展版本，被称为SQAD，它被用来处理用一系列朝向定义得到的一条路径的插值。&lt;/p&gt;

&lt;h2&gt;SLERP&lt;/h2&gt;

&lt;p&gt;SLERP代表&lt;strong&gt;S&lt;/strong&gt;pherical &lt;strong&gt;L&lt;/strong&gt;inear Int&lt;strong&gt;erp&lt;/strong&gt;olation。SLERP可以在2个朝向之间平滑地插值。&lt;/p&gt;

&lt;p&gt;第一个朝向设为\( q_{1}\)，第二个朝向设为\( q_{2}\)。被插值前的点设为\( \mathbf {p} \)，插值后的点设为\( \mathbf {p}&amp;#39; \)。而插值参数t，当t=0时会把\(\mathbf {p}\)转到\( q_{1}\)，当t=1时会转到\( q_{2}\)。&lt;/p&gt;

&lt;p&gt;标准的线性插值公式是(译注：这个公式是笛卡尔坐标系下的，不是指四元数)：&lt;/p&gt;

&lt;p&gt;\[ \mathbf {p}&amp;#39; = \mathbf {p}_{1} + t(\mathbf {p}_{2} - \mathbf {p}_{1} ) \]&lt;/p&gt;

&lt;p&gt;应用这个等式的一般步骤是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算\( \mathbf {p}_{1} 、\mathbf {p}_{2}\)之间的差。&lt;/li&gt;
&lt;li&gt;根据参数t，计算两个点的差的小数值(因为0&amp;lt;=t&amp;lt;=1)&lt;/li&gt;
&lt;li&gt;把第二步的值加上原始点的值，算出结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以把这个基础公式，套用到2个用四元数表示的朝向的插值上。&lt;/p&gt;

&lt;h3&gt;四元数的差&lt;/h3&gt;

&lt;p&gt;根据上面的公式的第一步，我们必须先计算\( q_{1}、 q_{2}\)的差。对于四元数来说，这等价于计算2个四元数的角度差：&lt;/p&gt;

&lt;p&gt;\[ diff =  q_{1}^{-1}q_{2} \]&lt;/p&gt;

&lt;p&gt;（译注：这个公式用到了上述的四元数点积公式）&lt;/p&gt;

&lt;h3&gt;四元数的指数&lt;/h3&gt;

&lt;p&gt;接下来是计算上面的角度差的分数值，方法是计算四元数的t次幂(就是上面的那个插值参数t)。&lt;/p&gt;

&lt;p&gt;四元数的指数的一般化公式是：&lt;/p&gt;

&lt;p&gt;\[ q^{t} = exp(t \log q) \]&lt;/p&gt;

&lt;p&gt;其中，(纯)四元数的exp函数的公式是：&lt;/p&gt;

&lt;p&gt;\[ e^{q} = exp(q) = exp([0,\theta \hat {v}]) \]
\[ = [cos\theta ,sin\theta \hat {v} ] \]&lt;/p&gt;

&lt;p&gt;(纯)四元数的对数公式是：&lt;/p&gt;

&lt;p&gt;\[ \log q = \log (cos\theta + sin \theta \hat {v}) \]
\[ = \log (exp(\theta \hat {v} )) \]
\[ = \theta \hat {v} \]
\[ = [0, \theta \hat {v}] \]&lt;/p&gt;

&lt;p&gt;(译注：上述的2次公式推导，其实省略了很多证明过程。具体可以参考：&lt;a href=&quot;http://bpeers.com/blog/?itemid=861&quot;&gt;http://bpeers.com/blog/?itemid=861&lt;/a&gt;,&lt;a href=&quot;http://bpeers.com/blog/?itemid=863&quot;&gt;http://bpeers.com/blog/?itemid=863&lt;/a&gt;,&lt;a href=&quot;http://bpeers.com/blog/?itemid=866&quot;&gt;http://bpeers.com/blog/?itemid=866&lt;/a&gt;, &lt;a href=&quot;http://bpeers.com/blog/?itemid=1001&quot;&gt;http://bpeers.com/blog/?itemid=1001&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;对于t = 0，我们有：&lt;/p&gt;

&lt;p&gt;\[ q^{0} = exp(0\log q) \]
\[ = exp([cos(0), sin(0)\hat {v}]) \]
\[ = exp([1,0]) \]
\[ = [1,0] \]&lt;/p&gt;

&lt;p&gt;而对于t = 1，有：&lt;/p&gt;

&lt;p&gt;\[ q^{1} = exp(1\log q) = q \]&lt;/p&gt;

&lt;h3&gt;2个四元数的分数差&lt;/h3&gt;

&lt;p&gt;对于角旋转的插值计算，我们利用q1和q2的角度分数差来调整原始朝向q1：&lt;/p&gt;

&lt;p&gt;\[ q&amp;#39; = q_{1}(q_{1}^{-1}q_{2})^{t} \]&lt;/p&gt;

&lt;p&gt;这也就是使用四元数的球面线性插值的一般形式。然而，这不是slerp函数的常用形式。&lt;/p&gt;

&lt;p&gt;我们可以应用类似的用于计算向量的球面插值公式，到四元数里。计算向量的球面插值的一般形式定义如下：&lt;/p&gt;

&lt;p&gt;\[ v_{t} = \frac {sin((1-t)\theta )}{sin\theta }v_{1} + \frac {sin(t\theta )}{sin\theta }v_{2} \]&lt;/p&gt;

&lt;p&gt;用图像表示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/10.png&quot; alt=&quot;10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个公式可以原封不动地应用到四元数：&lt;/p&gt;

&lt;p&gt;\[ q_{t} = \frac {sin((1-t)\theta )}{sin\theta }q_{1} + \frac {sin(t\theta )}{sin\theta }q_{2} \]&lt;/p&gt;

&lt;p&gt;但这个公式需要提供角度\(\theta \)，我们可以计算\(q_{1}\)和\(q_{2}\)的点积从而得出角度\(\theta \)：&lt;/p&gt;

&lt;p&gt;\[ cos\theta  = \frac {q_{1}\cdot q_{2}}{ |q_{1}||q_{2}| } \]&lt;/p&gt;

&lt;p&gt;\[ cos\theta = \frac {s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}}{|q_{1}||q_{2}|} \]&lt;/p&gt;

&lt;p&gt;\[ \theta = cos^{-1}(\frac {s_{1}s_{2}+x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2}}{|q_{1}||q_{2}|}) \]&lt;/p&gt;

&lt;h3&gt;注意事项&lt;/h3&gt;

&lt;p&gt;这个方案有2个问题，必须在实现过程中加以考虑。&lt;/p&gt;

&lt;p&gt;第一，如果四元数点积的结果是负值，那么后面的插值就会在4D球面上绕远路，这并不是我们想要的。为了解决这个问题，我们测试点积的结果，当结果是负值时，我们将2个四元数的其中一个取反，取反它的系数和向量部分，并不会改变它代表的朝向。而经过这一步操作，可以保证这个旋转走的是最短路径。&lt;/p&gt;

&lt;p&gt;当\(q_{1}\)和\(q_{2}\)的角度差非常小，小到导致\(sin\theta = 0\)时，会出现第二个问题。如果这个情况出现了，当我们除以\(sin\theta\)时就会得到一个未定义的结果。在这个情况下，我们可以回退去使用\(q_{1}\)和\(q_{2}\)的线性插值。&lt;/p&gt;

&lt;h2&gt;SQUAD&lt;/h2&gt;

&lt;p&gt;正如一个SLERP可以被用来计算四元数之间的插值，一个SQUAD (&lt;strong&gt;S&lt;/strong&gt;pherical and &lt;strong&gt;Quad&lt;/strong&gt;rangle)可以被用来对旋转路径进行平滑插值。&lt;/p&gt;

&lt;p&gt;如果我们有四元数序列：&lt;/p&gt;

&lt;p&gt;\[ q_{1},q_{2},q_{3},\cdots,q_{n-2},q_{n-1},q_{n}\]&lt;/p&gt;

&lt;p&gt;然后我们再定义一个&amp;quot;辅助&amp;quot;四元数(\(s_{i}\))，它是一个中间控制点：&lt;/p&gt;

&lt;p&gt;\[ s_{i} = exp( - \frac {\log(q_{i+1}q_{i}^{-1})+\log(q_{i-1}q_{i}^{-1})}{4})q_{i} \]&lt;/p&gt;

&lt;p&gt;所以，沿着子曲线的朝向可以定义为：&lt;/p&gt;

&lt;p&gt;\[ q_{i-1},q_{i},q_{i+1},q_{i+2} \]&lt;/p&gt;

&lt;p&gt;在t时刻的朝向就是：&lt;/p&gt;

&lt;p&gt;\[ squad(q_{i},q_{i+1},s_{i},s_{i+1},t ) = slerp(slerp(q_{i},q_{i+1},t),slerp(s_{i},s_{i+1},t),2t(1-t)) \]&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;除了特别难理解之外，相比矩阵或欧拉角，四元数在表示旋转这个事情上，拥有一些明显的优点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SLERP和SQUAD，提供了一种使得在朝向之间可以平滑过渡的方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用四元数来串联&amp;quot;旋转&amp;quot;，要比使用矩阵快得多。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于单位四元数，逆向旋转可以通过对向量部分取反来实现。而计算一个矩阵的逆矩阵是被认为比较慢的，如果这个矩阵未被标准正交化的话(标准正交矩阵的逆矩阵是它的转置矩阵)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从四元数转换到矩阵，要比从欧拉角转换到矩阵快一点。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四元数只需要4个数字(如果旋转四元数已经单位化了那么只需要3个，实数部分可以在运行时计算)来表示一个旋转，而矩阵需要至少9个数字。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尽管使用四元数有这么多优点，还是有缺点存在的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因为浮点数的舍入运算错误，四元数可能会变无效。不过，这个错误可以通过重新单位化四元数来避免。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用四元数最具威慑性的地方，还是四元数的理解难度大。我希望这个问题可以通过阅读本文来解决。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;存在一些已经实现了四元数、并且是正确的的数学程序库。在我的个人经验里，我发现GLM(OpenGL Math Library)是一个优秀的数学库，它的四元数的实现极其不错。如果你对在你的程序中使用四元数感兴趣，那么我会推荐你使用这个数学库。&lt;/p&gt;

&lt;h2&gt;下载Demo&lt;/h2&gt;

&lt;p&gt;我实现了一个小demo来演示一个四元数如何被用来旋转一个3维物体。这个demo是用Unity3.5.2实现的，你可以免费下载它和阅读它的脚本。zip文件也包含了一个Windows版的Unity程序。当然你可以自己构建一个Mac的版本。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.google.com/open?id=0B0ND0J8HHfaXdzM0dmdGUzBLV1U&quot;&gt;Understanding Quaternions.zip&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/understanding-quaternions/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/understanding-quaternions/</guid>
      </item>
    
  </channel>
</rss>