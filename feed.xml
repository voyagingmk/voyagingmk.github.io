<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>写作主题覆盖：游戏开发技术、图形学、机器学习。QQ：234707482</description>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>漫谈网络通讯加密（2）流程设计</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;加密通讯的流程设计&lt;/h1&gt;

&lt;h2&gt;先介绍下&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonce&lt;/a&gt;这个东西&lt;/h2&gt;

&lt;p&gt;nonce本质就是一段随机码，因为不一定是数字，可能是字符，所以不能叫随机数。因此取了个名字叫nonce。&lt;/p&gt;

&lt;p&gt;nonce的存在是为了对付&lt;strong&gt;彩虹表(raintable)&lt;/strong&gt;、&lt;strong&gt;重放攻击(replay attack)&lt;/strong&gt;，或者说为了制造&lt;strong&gt;请求唯一性(request unique)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;nonce有server nonce、client nonce之分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要client nonce的原因：阻止邪恶的客户端做重放攻击。&lt;/li&gt;
&lt;li&gt;需要server nonce的原因：阻止中间人攻击。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nonce的生成策略有讲究：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以是时间相关变量&lt;/li&gt;
&lt;li&gt;可以是一个通过强随机算法生成的足够长的bits&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;例子：登录与登录密码&lt;/h3&gt;

&lt;h4&gt;方案1&lt;/h4&gt;

&lt;p&gt;直接经过无加密的tcp或者http，发password到服务器进行登录。&lt;/p&gt;

&lt;p&gt;问题：登录包一被截取，密码就泄露了，攻击者想怎么搞就怎么搞了。&lt;/p&gt;

&lt;h4&gt;方案2&lt;/h4&gt;

&lt;p&gt;对password做一个经典的hash：&lt;/p&gt;

&lt;p&gt;secret = Hash(password);&lt;/p&gt;

&lt;p&gt;客户端只发secret给服务器，服务器执行（这里假设存了密码原文）：&lt;/p&gt;

&lt;p&gt;secrect_server = Hash(password_server)；&lt;/p&gt;

&lt;p&gt;得到secret_server即可做校验。&lt;/p&gt;

&lt;p&gt;问题：攻击者还是截包，就获得了secret，因为每次登录都是发一样的secret，所使攻击者首先可以做&lt;strong&gt;重放攻击&lt;/strong&gt;，直接copy用户的登录包，发给服务器，就可以登录了；其次，因为Hash函数无非md5、SHA256这些，完全可以用raintable暴力查表，获得password。&lt;/p&gt;

&lt;h4&gt;方案3&lt;/h4&gt;

&lt;p&gt;改进：客户端每次登录前，服务器会生成一个nonce并发给客户端，客户端计算：&lt;/p&gt;

&lt;p&gt;secret = Hash(nonce_server, password);&lt;/p&gt;

&lt;p&gt;客户端只发secret给服务器，服务器执行：&lt;/p&gt;

&lt;p&gt;secrect_server = Hash(nonce_server, password_server)；&lt;/p&gt;

&lt;p&gt;然后比较secret和secret_server是否一致即可。&lt;/p&gt;

&lt;p&gt;优点：每次登录hash出来的secret都不一样，用户密码比较安全了，要破解密码，得根据secret、nonce_server、Hash，逆向出password，可行，但耗时。&lt;/p&gt;

&lt;p&gt;问题：服务端发送的nonce可以被攻击者篡改成固定的nonce，从而导致nonce特性还是被消去了，攻击者就还是可以弄raintable，暴力破解密码。不过因为篡改的nonce和服务器的nonce对不上，客户端发的错误的登录信息，是过不了服务器这一关的。总之，攻击者并不能完美而透明地实现中间人攻击，但可以破解密码。&lt;/p&gt;

&lt;h4&gt;基于方案3的方案4&lt;/h4&gt;

&lt;p&gt;既然方案3中，客户端接收了攻击者篡改出来的固定nonce，并发送了符合攻击者raintable预期的secret，导致密码容易被破解，那么客户端是否可以做一些保护措施，使得发到网络中的secret是随机的呢？&lt;/p&gt;

&lt;p&gt;方法是有的，就是客户端也生成nonce， 称之为nonce_client，secret的计算变成：&lt;/p&gt;

&lt;p&gt;secret = nonce_client || Hash(nonce_client, nonce_server, password)&lt;/p&gt;

&lt;p&gt;（Note：||表示concat操作）&lt;/p&gt;

&lt;p&gt;服务器收到secret后拆出nonce_client和hash值，本地也执行一遍这条公式，就能做登录校验。&lt;/p&gt;

&lt;p&gt;这样处理后，攻击者即使篡改了nonce_server，攻击者收到的客户端secret依然是随机的。并不能直接查raintable获得password，而必须根据客户端的nonce_client，即时算出一份新的raintable表（计算量巨大），才能破解密码。&lt;/p&gt;

&lt;p&gt;问题：在登录过程中，本质上还是发送了password，就依然有被猜出密码的可能。如果这个密码是用户的常用密码，例如生日，那后果还是很可怕的。&lt;/p&gt;

&lt;p&gt;进一步的思路：既然发送加密的密码不妥，那就是用DH密钥交换了，就不会有密钥在网络中传输的问题。当然对于用户输入密码登录的场景，DH应该是用不了了。&lt;/p&gt;

&lt;h2&gt;简单版本的加密通讯&lt;/h2&gt;

&lt;p&gt;首先以一个较为简单的例子来说明：某客户端想和某服务器建立tcp加密通讯。&lt;/p&gt;

&lt;p&gt;首先需要一个工具：公钥私钥对（非对称加密技术）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务器在本地或数据库中存放了用于和任意客户端建立通讯的公钥私钥对。&lt;/li&gt;
&lt;li&gt;客户端想和服务器通讯时，服务器发送公钥给客户端。客户端确信用这个公钥加密的数据只有这个服务器能解密。（暂时不考虑中间人攻击问题）&lt;/li&gt;
&lt;li&gt;客户端计算一个master key，这个key可能真的是本地算出来的，也可能用DH算法和服务器交换出来的。如果是本地算出来的，那就必须用刚刚的非对称加密通讯信道，发给服务器。总之，master key是客户端服务器都得持有。&lt;/li&gt;
&lt;li&gt;客户端服务器各自生成nonce，互发给对方。此时双方都持有master key、cnonce、snonce。&lt;/li&gt;
&lt;li&gt;客户端服务器各自本地计算Hash(master key，cnonce，snonce)获得真正用于通讯的对称密钥encrypt key。&lt;/li&gt;
&lt;li&gt;另外的，客户端服务器还可以计算Hash2(master key，cnonce，snonce)，获得用于别的用途的key，例如integrity protection key，验证消息用的key。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中，master key后的步骤其实不是必须的，因为master key是用安全的非对称加密信道协商了，没有泄露key的问题。&lt;/p&gt;

&lt;p&gt;然而，如果每次建立通讯都要走1-3步骤的话，开销会比较大，所以master key其实是要复用的。例如客户端可以缓存在本机，服务器就缓存到数据库，设个过期时间。&lt;/p&gt;

&lt;p&gt;之后如果客户端想再次发起通讯，那么就可以跳过1-3步，直接执行4-6步，算出用于本次通讯的加密密钥。&lt;/p&gt;

&lt;h2&gt;完整版本的加密通讯&lt;/h2&gt;

&lt;h3&gt;一，公钥证书&lt;/h3&gt;

&lt;p&gt;首先，上一篇文章说的CA那套公钥证书的东西，是必要的。因为在互联网中通讯，只有依靠公钥证书这个机制，才能确认正在握手的对端是不是你所预期的对端。简要地回顾下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务器向客户端出示由某CA签发的公钥证书，即CA用&lt;strong&gt;CA私钥&lt;/strong&gt;加密了服务器公钥，导出来的东西，称之为公钥证书&lt;/li&gt;
&lt;li&gt;在握手前，用户的浏览器已经安装了该CA的证书，该证书里面有CA的公钥&lt;/li&gt;
&lt;li&gt;客户端用本地CA公钥，&lt;strong&gt;解密&lt;/strong&gt;收到的公钥证书得到服务器公钥。解得出来，那就说明这个服务器公钥（证书）确实是这个CA曾经用私钥加密过的。&lt;/li&gt;
&lt;li&gt;当然，公钥证书是有过期问题的，例如服务器把私钥泄露了，那相应的公钥证书就得从CA里删掉，这就涉及到了&lt;strong&gt;证书撤销列表CRL&lt;/strong&gt;。CRL就是一个数据库，这个数据库显然得支持分布式，否则全世界的用户都涌到中心化的服务器去验证证书是否已被撤销，那是做不到的。而分布式数据库，显然就有个更新同步延迟问题，中心数据库更新了CRL，什么时候本地能更新CRL缓存，就决定了安全度有多高。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第4步骤先不说，前3步骤才是最关键的。这些流程，完全是为了&lt;strong&gt;确认正在握手的服务器是不是自己所信任的CA签名了的服务器&lt;/strong&gt;。信任的根基是CA，客户端只相信CA，CA说什么就是什么。&lt;/p&gt;

&lt;p&gt;值得思考的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端会不会装了不可靠的CA证书。如果是，那后面的所有流程都是白搭了。&lt;/li&gt;
&lt;li&gt;通讯双端没有CA基础设施怎么办？例如手机游戏，没有什么浏览器CA，只有tcp udp可用。答案是直接把服务器公钥硬编码到客户端安装包里，只要用户确保是从正规途径下载的安装包，那么就可以保证客户端里的公钥是真实服务器的公钥。例如从app store下载游戏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;二，都是为了加密性能&lt;/h3&gt;

&lt;p&gt;第一步中，客户端和服务器已经建立了可靠的&lt;strong&gt;非对称加密通讯&lt;/strong&gt;，客户端持有服务器的公钥，客户端用公钥加密自己数据，只有服务器才能解密，不就万事大吉了吗？&lt;/p&gt;

&lt;p&gt;然而很可惜的是，非对称加密算法，性能一般都差强人意，远不如&lt;strong&gt;对称加密算法&lt;/strong&gt;。所有用户要发送大量隐私数据给服务器，只用非对称加密的话，先不说客户端耗能，服务器的CPU首先就炸了。&lt;/p&gt;

&lt;p&gt;用指令openssl speed xxx，可以认识到各种算法的性能：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;                        sign        verify          sign/s    verify/s
rsa 2048 bits 0.000738s 0.000022s   1354.2  45918.7

因为rsa是按次的，这里得换算成k bytes才能和aes比较，即乘以256再除以1000：
rsa 2048 bits 0.000738s 0.000022s   346.7k 11755.2k


type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
aes-128 cbc      99115.02k   115128.04k   122790.06k   126412.46k   126915.93k

                              op      op/s
 256 bit ecdh (nistp256)   0.0001s  14937.4
 384 bit ecdh (nistp384)   0.0008s   1265.2
 521 bit ecdh (nistp521)   0.0009s   1148.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然可以看出rsa和aes根本不是同个数量级的，rsa私钥运算大约比aes慢1000倍。&lt;/p&gt;

&lt;p&gt;性能是关键，接下来的步骤，都得归咎于非对称加密算法的性能。&lt;/p&gt;

&lt;h3&gt;三，通讯密令：master key&lt;/h3&gt;

&lt;p&gt;因为性能问题，我们希望尽可能不使用非对称加密通讯信道，甚至不去建立非对称加密通讯。&lt;/p&gt;

&lt;p&gt;最终的，非对称加密通讯所要负责的事情，被精简成一件事：协商一个master key。&lt;/p&gt;

&lt;p&gt;master key前文也介绍过了，说白了就是一段password，master key只能是通讯的两端持有，不能告诉其他人，否则就不安全了。&lt;/p&gt;

&lt;p&gt;master key，用非对称加密信道协商，一般是用ECDH算法。&lt;/p&gt;

&lt;p&gt;master key难得，成本很高，所以需要有缓存机制。免得经常去生成新的master key。有2种套路，一个是session id，本质是服务器做缓存；另一个是session ticket，是客户端做缓存。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;session id：在之前的密钥协商后，服务器会分配一个session id，并在数据库中存入以session id为键的会话信息如master key。下次做密钥协商时，客户端发现已经缓存了一个session id，那么发id给服务器，如果服务器能在数据库找出这个id对应的master key，那么就不需要去协商master key了。不过缺点是很难维护一个这样子的数据库。&lt;/li&gt;
&lt;li&gt;session ticket：新的会话建立时，服务器用一个只有自己知道的密钥（ticket key）对master key做加密，把密文ticket发给客户端，客户端单纯地只把ticket缓存起来。下次要建立会话时，把缓存的ticket发给服务器，服务器解密，就拿到之前的master key。因为ticket key必须所有服务器一致，且不可变，也有一定安全风险，现在一般是采用轮转的方式，定时地渐进式地淘汰旧的ticket key（新的会话用旧的ticket key尝试解密，用新的ticket key加密）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两种方案中，共同点都是客户端依然得自己缓存好master key。&lt;/p&gt;

&lt;p&gt;然后是时效性问题，一般master key要设个过期时间，一天、一个星期、一个月，加了限时，就保证了要定期更换，一定程度降低了master key泄露的风险。一般是服务器设置过期时间，客户端只缓存，如果用了过期的master key，那服务器应有反馈，并重新协商新的master key。&lt;/p&gt;

&lt;h3&gt;四，基于master key，得到对称加密密钥，建立对称加密通讯&lt;/h3&gt;

&lt;p&gt;刚才的简化例子有一点没有说清楚的，就是nonce怎么发送。&lt;/p&gt;

&lt;p&gt;实际上，nonce_client, nonce_server，都可以不经过加密通讯信道直接发送，泄露了也没关系。&lt;/p&gt;

&lt;p&gt;因为需要的对称加密密钥基于三个参数：&lt;/p&gt;

&lt;p&gt;encrypt key = Hash(master key，nonce_client, nonce_server)&lt;/p&gt;

&lt;p&gt;我们不怕泄露后2个，因为第一个master key已经保证保密了。这样子hash出来的encrypt key也依然是保密的。&lt;/p&gt;

&lt;p&gt;有了双方一致的encrypt key，就可以拿出各种对称加密算法，来建立加密通讯了。&lt;/p&gt;

&lt;p&gt;要注意的点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nonce_client, nonce_server存在的意义前文也说过了，主要是防止重放攻击、中间人攻击，所以每次想要用master key建立加密通讯，都是即时地重新协商nonce。&lt;/li&gt;
&lt;li&gt;encrypt key实际上要2个，因为tcp是全双工连接，有2个数据流方向，2个方向的encrypt key如果一样，安全系数就降低了，详情不表。最好就是一个方向一个encrypt key。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;五，加密数据的完整性保证&lt;/h3&gt;

&lt;p&gt;前四步骤已经几乎建立了绝对可靠的性能不错的加密通讯，但还有一个问题：客户端发出去的包，依然还是有被截包篡改的可能。&lt;/p&gt;

&lt;p&gt;例如A用encrypt key加密了原文a得到密文b，用tcp把b发出去，b被攻击者截取，攻击者可能用各种奇奇怪怪的方法尝试篡改这个密文b变成密文c，亦或者替换了b变成密文d（很可能是通讯早期截获的包！），然后继续发向服务器，那么就还是不安全，因为客户端想要发给服务器的密文b并没有真正送到，服务器还处理了别的密文！&lt;/p&gt;

&lt;p&gt;还有一种情况是，客户端和服务器的对称密钥因为某种原因不同步了，这样会导致服务器用错误的对称密钥解密数据得到了“乱码”，但服务器是完全感知不到用了错误的密钥，服务器无法知道乱码是不是乱码。&lt;/p&gt;

&lt;p&gt;那怎么办呢？答案是再给密文b加一层&lt;strong&gt;认证&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;简单理解就是，客户端给密文b做个hash，得到消息验证码MAC（上一篇文章介绍过的)，把密文b和MAC一起发给服务器，服务器也对收到的密文做一样的hash，如果服务器得到的MAC值和客户端的MAC值不一致，那就说明数据不是客户端发来的。&lt;/p&gt;

&lt;p&gt;hash函数刚才也提到过了，需要一个integrity key，也是基于master key的。攻击者没有办法获得一样的hash函数。&lt;/p&gt;

&lt;p&gt;MAC的安全隐患上一篇文章也说到过了。最经典的是重放攻击，就是攻击者并不篡改密文和MAC，而只是原样地保存下来，并伺机重复发送给服务器。这个问题的解决办法就是对每条消息加一个递增的序号。同样的消息就不可能收到两次。&lt;/p&gt;

&lt;p&gt;P.S. 用一个额外的MAC（其实应该叫做MtE，EtM，E&amp;amp;M）来保证完整性已经是一种过时的思路，有安全缺陷。其中只有EtM(encrypt then MAC)是安全的，是一个大坑。让程序员搞懂这三者区别也是痛苦。所以现在并不提倡EtM之类的做法了。&lt;/p&gt;

&lt;p&gt;取而代之的是AEAD。所谓AEAD，含义是在对称加密算法里添加了完整性验证的功能，例如AES-128-GCM、ChaCha20-IETF-Poly1305。所以AEAD并不是一种算法，而只是方案的代名词。在即将到来的TLSv1.3中，已经彻底干掉MAC，而统一用AEAD了。&lt;/p&gt;

&lt;h3&gt;六，加密算法选取&lt;/h3&gt;

&lt;p&gt;上面的五大步骤，其实都没有谈到具体用什么算法。据我了解，如果不用openSSL之类的库，而是自己手动组合，那么可以这么弄：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非对称加密：RSA 或 ECC&lt;/li&gt;
&lt;li&gt;master key：ECDH&lt;/li&gt;
&lt;li&gt;对称加密：AES&lt;/li&gt;
&lt;li&gt;encrypt key：SHA256&lt;/li&gt;
&lt;li&gt;integrity key：SHA256 with salt&lt;/li&gt;
&lt;li&gt;消息验证码生成函数：HMAC with integrity key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这对程序员的要求比较高，需要了解各种算法的优缺点和如何组合，是否适合配对。&lt;/p&gt;

&lt;p&gt;所以算法选取这个事情，已经被建立起规范，关键词叫做cipherSuite，例如openSSL就支持，可以执行openssl ciphers -V | column -t，看到系统的openSSL支持的cipherSuites：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/4.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;（注意，SSLv3已经过时了，现在都是TLSv1.2，即将出现TLSv1.3）&lt;/p&gt;

&lt;p&gt;第一列2个十六进制值相当于ID。&lt;/p&gt;

&lt;p&gt;以其中最常见的0xC0,0x2F为例：&lt;/p&gt;

&lt;p&gt;0xC0,0x2F  -  ECDHE-RSA-AES128-GCM-SHA256    TLSv1.2  Kx=ECDH        Au=RSA    Enc=AESGCM(128)    Mac=AEAD&lt;/p&gt;

&lt;p&gt;含义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用于TLSv1.2版本&lt;/li&gt;
&lt;li&gt;kx = key exchange，使用ECDHE做秘钥交换。就是上一篇文章说的DH基于椭圆曲线EC算法的变种。最后的E代表ephemeral，表示转瞬即逝性。&lt;/li&gt;
&lt;li&gt;Au = authenticity，使用RSA做认证&lt;/li&gt;
&lt;li&gt;Enc = encryption，使用AES-128-GCM做对称加密。GCM意味着加密算法支持认证功能。&lt;/li&gt;
&lt;li&gt;MAC = AEAD（authenticated encryption with associated data），一种同时具备保密性(confidentiality)，完整性(integrity)和可认证性(authenticity assurances)的加密形式。 MAC=AEAD意思是说“把这些认证问题交给对称加密算法就行了，不需要MAC”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以撇除掉融合到加密算法里的MAC，那么CipherSuite其实只有3个东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1个authentication 认证算法&lt;/li&gt;
&lt;li&gt;1个encryption 加密算法&lt;/li&gt;
&lt;li&gt;1个key exchange 密钥交换算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;引入CipherSuite，说明算法的选取不是完全定死的，而是可以根据需要协商的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;协商过程会发生在tcp三次握手后的第一个包里&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这就要注意1个问题：&lt;strong&gt;算法选取过程是无加密的&lt;/strong&gt;，发生什么攻击都可能。&lt;/p&gt;

&lt;p&gt;例如中间人攻击，中间人篡改了算法协商的内容，使得通讯双方用了安全度较低的、符合中间人预期的加密算法，那么这次通讯就不那么安全了。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;h2&gt;概括加密通讯标准过程&lt;/h2&gt;

&lt;p&gt;从tcp握手到算法协商完成，步骤大致如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;tcp完成三次握手&lt;/li&gt;
&lt;li&gt;客户端发送它支持的CipherSuite列表和client nonce（所谓的ClientHello）&lt;/li&gt;
&lt;li&gt;服务器从该列表中，选择一套合适的算法，然后连同自己的公钥证书、server nonce 发给客户端（ServerHello）&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;0-rtt，1-rtt？&lt;/h2&gt;

&lt;p&gt;搞通讯偶尔会看到什么0-rtt，1-rtt，其实都指的是基于TLS连接，和tcp的三次握手没关系。&lt;/p&gt;

&lt;p&gt;TLS连接握手，是发生tcp三次握手后的事情，即三次握手后，还要经过多少个rtt回合，才能建立TLS连接？&lt;/p&gt;

&lt;p&gt;用1-rtt搞定TLS连接，那么这一个rtt必然是用来协商对称加密密钥的。比如说，你的程序可以强制客户端和服务端只用DH算法协商密钥，并且这个rtt里也发送各自的nonce，那么1-rtt后，通讯两端就都拥有了master key、cnonce、snonce。&lt;/p&gt;

&lt;p&gt;至于0-rtt，必然是有损安全性的。0-rtt意味着第一个数据包就得支持发送用户数据，那必然是用某种缓存的key来加密用户数据。这个key叫做半静态ECDH公钥。原理有点像前面说的，游戏客户端硬编码了服务器公钥。&lt;/p&gt;

&lt;p&gt;缺陷在于：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;0-RTT发送的应用数据没有前向安全性&lt;/li&gt;
&lt;li&gt;跨连接可以重放0-RTT里的应用数据（任何服务器端无共享状态的协议，都无法做到跨连接防重放）&lt;/li&gt;
&lt;li&gt;如果服务器端 半静态 ECDH公钥对应的私钥泄露了，攻击者就可以伪装成客户端随意篡改数据了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这简直就是性能和安全的博弈。google的QUIC就很好地实现了0-rtt。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;密码学算法难以被正确使用，究其原因是数学。要对密码学有一定了解，才能搞清楚那些加密套件各种参数和选项。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/&quot;&gt;https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.helong.info/blog/2015/01/23/ssl_tls_ciphersuite_intro/&quot;&gt;https://blog.helong.info/blog/2015/01/23/ssl_tls_ciphersuite_intro/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/crypto-2/</link>
        <guid isPermaLink="true">http://localhost:4000/crypto-2/</guid>
      </item>
    
      <item>
        <title>《计算机网络-自顶向下方法》笔记</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;网络层&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;是否对ip包分片，取决于输出链路的mtu，如果包大小大于mtu（可能500多到1500字节），那么就会自动分片&lt;/li&gt;
&lt;li&gt;分片有3个不可或缺字段：ip包的唯一标识（ID)、字节偏移offset、结束标志（0或1，1表示还没结束，0表示当前已是最后一个片）&lt;/li&gt;
&lt;li&gt;分片是ipv4的机制，且有安全问题，ipv6没有分片，杜绝了安全隐患&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分片重组是在目的地端主机上进行的，路由器只可能做分片，而不会做重组&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主机和物理链路之间的边界叫做接口&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个接口有自己的ip地址，所以ip地址技术是与接口关联，而不是和主机或路由器&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子网：直接互联并与其他网络岛隔离的主机接口+路由器接口组成子网&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子网掩码：例如223.1.1.0/24，/24就是子网掩码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络层有三个主要组件：IP协议、路由选择协议(RIP、OSPF、BGP）、因特网控制报文协议ICMP&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看和修改系统的mtu值：&lt;/p&gt;

&lt;p&gt;查看：&lt;/p&gt;

&lt;p&gt;ifconfig eth0&lt;/p&gt;

&lt;p&gt;修改：&lt;/p&gt;

&lt;p&gt;ifconfig eth0 mtu 1460&lt;/p&gt;

&lt;h2&gt;DHCP动态主机配置协议&lt;/h2&gt;

&lt;p&gt;四大步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DHCP发现报文，用UDP，端口67，src ip为0.0.0.0，dst ip为255.255.255.255，广播一个发现报文，报文里包含一个事物ID。&lt;/li&gt;
&lt;li&gt;DHCP提供报文，DHCP服务器收到广播而来的发现报文后，用一个提供报文做响应，src ip为自己的ip，dst ip为255.255.255.255，也是广播。因为DHCP服务器不一定唯一，所以客户机有选择权。提供报文包含，收到的发现报文的事物ID、向客户推荐的IP地址、IP地址的掩码、IP地址租用期（address lease time），租用期一般为几小时到几天。&lt;/li&gt;
&lt;li&gt;DHCP请求报文，客户机从1到多个提供报文中选择一个，并向该服务器发送DHCP请求报文。&lt;/li&gt;
&lt;li&gt;DHCP ACK报文，就是第三步的响应报文，告诉客户配置参数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第四步完成后，客户就可以在租用期里使用这个ip。另外，DHCP也有延长租用期的办法。&lt;/p&gt;

&lt;h2&gt;NAT网络地址转换&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;NAT是用来解决ipv4的ip地址不够用问题的&lt;/li&gt;
&lt;li&gt;NAT会使得外部主机不能直接访问内网主机（内网主机不可见），因为内网主机没有自己的全球唯一ip地址&lt;/li&gt;
&lt;li&gt;NAT用一张转换表来双向转发数据包&lt;/li&gt;
&lt;li&gt;内网主机可以主动访问外网，反过来就不行&lt;/li&gt;
&lt;li&gt;NAT的存在对实现p2p应用很不好&lt;/li&gt;
&lt;li&gt;应用NAT穿越技术，可以改善p2p应用的通讯问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NAT穿越：&lt;a href=&quot;https://www.jianshu.com/p/84e8c78ca61d&quot;&gt;https://www.jianshu.com/p/84e8c78ca61d&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;ICMP控制报文协议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;常用于差错报告，例如目的地不可达时，中间路由器就会返回类型3的ICMP报文&lt;/li&gt;
&lt;li&gt;ICMP协议是建立在IP协议上面的，因为是用IP分组承载的。类似TCP、UDP。但一般认为ICMP是属于网络层的协议。&lt;/li&gt;
&lt;li&gt;ICMP报文组成：类型、编码。编码可理解为大类型里的子类型。&lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol&quot;&gt;wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ping程序： 发一个ICMP[8,0]报文，目的主机发回一个ICMP[0,0]的报文。&lt;/p&gt;

&lt;p&gt;源抑制报文：从wiki可以看到已经deprecated了，最初是用来做拥塞控制的，不过tcp自己有拥塞控制，所以没卵用。&lt;/p&gt;

&lt;p&gt;traceroute：原理就是发送一系列IP数据报，每个数据报携带UDP报文，目的地ip为目标主机，端口号设置为不可达的端口号。关键的，第一个数据报的TTL设为1，第二个的TTL为2，以此类推。当第n个数据报到达第n台路由器时，第n台路由器发现这个数据报的TTL正好过期，然后就会发给源主机一个ICMP[11,0]，携带了该路由器的ip地址。然后每个数据报都设置了定时器，收到回复时就可以算出往返延迟RTT。&lt;/p&gt;

&lt;p&gt;traceroute还有个问题是何时停止发送udp报文，这是通过ICMP的类型和编码字段判断的，因为如果目的地主机在线，那么最终会返回一个ICMP[3,3]，表示目的主机端口不可达。&lt;/p&gt;

&lt;h2&gt;ipv6&lt;/h2&gt;

&lt;p&gt;改进：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;去掉了分片功能，因为分片功能是耗时操作，去掉后能提高路由器性能&lt;/li&gt;
&lt;li&gt;没有分片后，如果包太大，就无法发进链路层，只能丢弃，并返回ICMP差错报文，让发送方重新发一个小的&lt;/li&gt;
&lt;li&gt;去掉了首部校验和，因为传输层协议、链路层协议也会做校验和，所以多余了。另外，因为IP头部有个动态的跳数，会导致每次修改跳数都得重新计算校验和，影响性能。&lt;/li&gt;
&lt;li&gt;选项字段从IP首部去掉，但依然可以存在选项，方法是用“下一个头部”字段来实现，就是说选项信息是一个可选的头部。&lt;/li&gt;
&lt;li&gt;去掉了选项后，ipv6的头部就是定长的40字节，非常高效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2个ipv6主机之间通讯，可能会经过一段由仅支持ipv4的主机组成的路径，这时可以用隧道技术，把ipv6分组，放到ipv4分组的有效载荷里。&lt;/p&gt;

&lt;h2&gt;路由选择算法&lt;/h2&gt;

&lt;p&gt;全局式算法：路由器拥有网络拓扑信息、连通信息、链路费用信息，从而算出最优路径。也称为链路状态算法。链路费用一般取决于链路承载流量。&lt;/p&gt;

&lt;p&gt;分散式算法：路由器没有网络链路信息，而只需要拥有和路由器直接相连链路的费用信息就可开始工作。通过迭代、和邻居交换信息，就能逐渐计算出到达某目的地结点的最低费用路径。&lt;/p&gt;

&lt;p&gt;静态算法：依靠人工。&lt;/p&gt;

&lt;p&gt;动态算法：拓扑或负载变化时更新。不过容易受&lt;strong&gt;路由选择循环、路由震荡&lt;/strong&gt;影响。&lt;/p&gt;

&lt;p&gt;负载敏感算法：链路费用会动态地变化，以反映链路拥塞情况。&lt;/p&gt;

&lt;p&gt;负载迟钝算法：相反的，对拥塞不敏感，费用固定。更普遍可行的方法。&lt;/p&gt;

&lt;p&gt;路由震荡：用随机化的链路通告时间，可以改善震荡。&lt;/p&gt;

&lt;p&gt;LS链路状态算法：基于无向图最短路算法。最坏情况n平方。&lt;/p&gt;

&lt;p&gt;DV距离向量算法：是一种迭代、异步、分布式的算法。&lt;/p&gt;

&lt;h2&gt;互联网当前的路由算法&lt;/h2&gt;

&lt;h3&gt;RIP，&lt;strong&gt;路由选择信息协议&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;路由选择表（routing table），也叫RIP表，包含该路由器的距离向量、转发表。&lt;/li&gt;
&lt;li&gt;目的子网，就是把目的地路由器当成一个子网网络&lt;/li&gt;
&lt;li&gt;跳数，理解为到目的子网的链接边数即可&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;转发表的结构：目的子网，下一台路由器，到目的子网的跳数。每个子网占一行。&lt;/p&gt;

&lt;p&gt;转发表的状态是迭代的，不可能是实时获得整个网络的状态信息。&lt;/p&gt;

&lt;p&gt;邻居路由器之间会互相通告最新的转发表信息。大概30秒一次。&lt;/p&gt;

&lt;p&gt;如果邻居超过180秒没有发来报文，认为不可达，更新自己的路由表，并向其他存活的邻居发公告。&lt;/p&gt;

&lt;p&gt;每次收到转发表信息，都可能导致当前路由器的所知的到达某个子网的跳数、下一跳路由器信息，产生更新，因为新的路径（跳数）可能会更短。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/2.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/3.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/4.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;路由器可以主动询问邻居&lt;strong&gt;到指定目的地的费用&lt;/strong&gt;（RIP请求报文）。基于UDP 520端口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RIP是一个基于传输层UDP协议的应用层进程（叫routed），用UDP来控制IP路由。&lt;/strong&gt;这也是一个特殊进程，因为它可以操作系统内核的转发表。&lt;/p&gt;

&lt;p&gt;routed会和邻居路由器的routed进程相互联系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;OSPF&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;被设想为RIP的后继者，因为有许多先进特性&lt;/li&gt;
&lt;li&gt;洪泛链路状态信息的链路状态协议 + Dijkstra最低费用路径算法&lt;/li&gt;
&lt;li&gt;是基于完整信息状态的算法&lt;/li&gt;
&lt;li&gt;各条链路费用可用网络管理员配置，如果都设为1，则退化成&lt;strong&gt;最少跳数路由选择（RIP）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;管理员可以根据带宽大小来设置链路费用，反比，带宽越大，费用越低。&lt;/li&gt;
&lt;li&gt;路由选择信息是广播到整个网络的，而不仅仅是邻居&lt;/li&gt;
&lt;li&gt;当一跳链路状态（费用、连接/中断）变化时，更新并广播&lt;/li&gt;
&lt;li&gt;即使无变化，也要定期广播&lt;/li&gt;
&lt;li&gt;OSPF报文直接承载于IP层，所以OSPF要自行实现可靠传输，链路状态广播功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安全，对网络成员有身份鉴别功能，从而鉴别假冒的OSPF协议包。但这是可选的功能。鉴别方法是在每台路由器上配置一样的共享密钥，发包时，把密钥添加到分组里然后算一个MD5，再把MD5放到发包分组里，接收端收到分组后，对内容段添加自己的密钥并算一个MD5，并和收到的MD5进行比较鉴别。另外还有个序号，用来针对重放攻击。&lt;/li&gt;
&lt;li&gt;负载均衡，如果去某个目的地存在多条费用一样的路径，OSPF允许同时使用多条路径，而不是只用其中一条。&lt;/li&gt;
&lt;li&gt;层次结构&lt;/li&gt;
&lt;li&gt;对多播的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OSPF可按区域划分（大区分小区），区域和区域外的联系要经过&lt;strong&gt;区域边界路由器&lt;/strong&gt;，边界路由器都连到主干路由，从而实现区域之间的连通。&lt;/p&gt;

&lt;h3&gt;BGP 边界网关协议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;BGP确保了因特网中所有AS知道该子网以及如何到达那里。&lt;/li&gt;
&lt;li&gt;没有BGP，那么每个子网将是隔离的，不为互联网其他部分所知。&lt;/li&gt;
&lt;li&gt;是BGP这个协议将所有东西粘合在一起&lt;/li&gt;
&lt;li&gt;BGP基于TCP端口179，半永久TCP连接&lt;/li&gt;
&lt;li&gt;BGP作用：使得每个AS知道经过其相邻AS可达哪些目的地。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关键词定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BGP对等方，BGP peers，即一条BG TCP连接的两端&lt;/li&gt;
&lt;li&gt;沿着该连接发送所有BGP报文的TCP连接称为BGP会话&lt;/li&gt;
&lt;li&gt;跨越2个AS的BGP会话称为外部BGP，eBGP；同理，内部的叫iBGP。&lt;/li&gt;
&lt;li&gt;目的地：不是主机IP，而是CDIR化的前缀，表示一个子网或子网的集合，如：138.16.64/24。&lt;/li&gt;
&lt;li&gt;前缀聚合：如果AS连接了4个子网，138.16.64/24，138.16.65/24，138.16.66/24，138.16.67/24，可以聚合成138.16.64/22&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 24 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/network/</link>
        <guid isPermaLink="true">http://localhost:4000/network/</guid>
      </item>
    
      <item>
        <title>select和epoll多路复用用法总结</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;select&lt;/h2&gt;

&lt;p&gt;资料：&lt;a href=&quot;https://notes.shichao.io/unp/ch6/#select-function&quot;&gt;https://notes.shichao.io/unp/ch6/#select-function&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;struct fd_set，fd的集合&lt;/li&gt;
&lt;li&gt;FD_ZERO(fd_set *)， 清零一个fd_set，传fd_set的地址&lt;/li&gt;
&lt;li&gt;FD_SET(int fd, fdset *)，把fd添加到这个fd_set&lt;/li&gt;
&lt;li&gt;FD_CLR(int fd, fdset *)，把fd移出这个fd_set&lt;/li&gt;
&lt;li&gt;int FD_ISSET(int fd, fd_set *fdset); 查询fd是否在这个fd_set&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;核心函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;返回值：&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;&amp;lt;0：出错&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;0：select超时返回了，没有读、写事件&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;&amp;gt;0：有事件发生的fd数量&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;maxfdp：是最大的fd再加1！&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;readfds、writefds、errorfds是值-结果参数，调用的时候作为值语义参数，函数返回的时候作为结果，所以没有const修饰&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;readfds：   要监听读事件的fd集合   /    有读事件的fd集合&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;writefds：  要监听写事件的fd集合   /    有写事件的fd集合&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;errorfds：  错误事件，一般传null即可&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxfdp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writefds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errorfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用法要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按读、写声明2个fd_set：rfds、wfds&lt;/li&gt;
&lt;li&gt;需要再声明2个读、写fd_set，用于存放第一步的fd_set的拷贝，用于select：_rfds、_wfds&lt;/li&gt;
&lt;li&gt;用FD_SET和FD_CLR控制要监听哪个fd的读、写事件&lt;/li&gt;
&lt;li&gt;调用select前，要先复制一份fd_set，用memcpy即可&lt;/li&gt;
&lt;li&gt;调用select：retval = select(eventLoop-&amp;gt;getMaxFd() + 1, &amp;amp;_rfds, &amp;amp;_wfds, NULL, tvp);&lt;/li&gt;
&lt;li&gt;如果retval&amp;gt;0，就遍历所有fd（[0, maxfd]），用FD_ISSET(fd, _rfds)，判断这个fd是否可读，写事件同理&lt;/li&gt;
&lt;li&gt;到此就完成一次循环，做完其他逻辑后，回到第4步&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;select是基于位掩码的设计，所以fd_set有固定长度。长度由FD_SETSIZE确定，FD_SETSIZE可以用户自己定。默认只有1024。&lt;/p&gt;

&lt;h2&gt;epoll&lt;/h2&gt;

&lt;h3&gt;创建epfd&lt;/h3&gt;

&lt;p&gt;epoll_create1(0)，创建一个epfd，epoll所有接口都会用到它，它也是个文件描述符，持有资源&lt;/p&gt;

&lt;h3&gt;添加监听事件&lt;/h3&gt;

&lt;p&gt;需要区分是首次添加还是修改操作（用户自己要做记录），op = EPOLL_CTL_ADD或者EPOLL_CTL_MOD。&lt;/p&gt;

&lt;p&gt;然后创建一个epoll_event ee，如果需要监听读事件就执行ee.events |= EPOLLIN，写事件就 ee.events |= EPOLLOUT；然后要登记目标fd到ee里，ee.data.fd = fd。&lt;/p&gt;

&lt;p&gt;ee准备好后，就可以调用epoll_ctl(epfd, op, fd, &amp;amp;ee)。&lt;/p&gt;

&lt;p&gt;epoll_ctl返回值：0是成功；-1失败，errno记录错误类型。&lt;/p&gt;

&lt;h3&gt;删除监听事件&lt;/h3&gt;

&lt;p&gt;和添加监听事件类似，也是构造ee，也要设置ee.data.fd，最终调用epoll_ctl。&lt;/p&gt;

&lt;p&gt;op的就有点不一样，如果已经没有任何要监听的事件了，那么op是EPOLL_CTL_DEL；如果至少有监听某种事件，那么用EPOLL_CTL_MOD。&lt;/p&gt;

&lt;p&gt;需要注意的是，即使是删除监听事件，epoll_ctl一个参数都不能少。&lt;/p&gt;

&lt;h3&gt;轮询&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;epoll_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;timeout：-1，永久阻塞；0，立即返回，不阻塞； &amp;gt;0，阻塞多少毫秒后返回
events和maxevents：就是指定一块数组用来存epoll_wait的返回结果，maxevents就是这个数组的长度。&lt;/p&gt;

&lt;p&gt;如果返回值（numevents）大于0，那么就可以遍历events，遍历上限为numevents，逐个epoll_event访问它的events变量，看含有什么事件。也就是说，epoll_wait只返回了有事件的fd集合，比select要高效。&lt;/p&gt;

&lt;h3&gt;底层特点&lt;/h3&gt;

&lt;p&gt;epfd被创建时，会相应地创建一个eventpoll结构体：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;struct eventpoll {  
    /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/  
    struct rb_root  rbr;  
    /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/  
    struct list_head rdlist;    
};  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;eventpoll可理解为存了2个数据结构的头部指针，一个指向一个红黑树的根，一个指向双向链表的头。&lt;/p&gt;

&lt;p&gt;只要某个fd的某个事件被监听中，就会存在和这个fd关联的一个epitem:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epitem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rb_node&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;rbn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//红黑树节点  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;rdllink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//双向链表节点  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_filefd&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ffd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//事件句柄信息  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eventpoll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//指向其所属的eventpoll对象  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//期待发生的事件类型  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;红黑树中的每个节点都等同于某个epitem的rbn对象指针；双向链表的每个节点都等同于某个epitem的rdllink指针。&lt;/p&gt;

&lt;p&gt;所以epitem应该是一个内存连接的数组，而红黑树和双向链表用指针的方式和这个数组产生联系。&lt;/p&gt;

&lt;p&gt;为什么高效：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当监听的事件发生时，会回调ep_poll_callback，把事件信息添加到双向链表rdlist&lt;/li&gt;
&lt;li&gt;当调用epoll_wait检查是否有事件发生时，只需检查eventpoll的rdlist链表中是否有epitem元素即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1、2点已经凸显了epoll_wait的高效，这是一种基于驱动回调的技术，epoll_wait的成本只是获取这个rdlist而已。&lt;/p&gt;

&lt;p&gt;另外，为了保证不会重复添加同个fd的epitem，只能遍历内核的epitem数组，但这是个O(n)的操作，所以就需要红黑树，可以快速找出某个fd是否已被监听，并且也用于快速找到epitem从而修改fd的监听事件。这可是log(n)的复杂度，性能大大提高。&lt;/p&gt;

&lt;h3&gt;总结：&lt;/h3&gt;

&lt;p&gt;epoll是在内核维护复杂数据结构的设计，用户态的接口就相对复杂一些，但可控制性高一点；另外利用了回调技术，就不需要主动去查询每个fd是否有事件，效率自然就高了。&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/multiplexing/</link>
        <guid isPermaLink="true">http://localhost:4000/multiplexing/</guid>
      </item>
    
      <item>
        <title>C++ STL的一些笔记</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;set和multiset&lt;/h2&gt;

&lt;p&gt;set有去重；multiset无去重。&lt;/p&gt;

&lt;p&gt;multiset可以用来做计时器容器，因为计时器需要按时间排序，而时间戳可能会出现相同的，即同一时刻添加了2个定时任务。&lt;/p&gt;

&lt;p&gt;使用set和multiset的易错点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;存储的元素需要是const含义的，即添加到容器后，原则上是不能修改的。原因是排序需要。如果添加到容器后用户还能修改容器元素，那么应触发某种全排序，否则容器有序性就丢失了。&lt;/li&gt;
&lt;li&gt;然而容器没有办法保证用户不可修改元素，所以容易用错。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个易错点，只能好好记住了，不然迟早酿成bug。如果一定要在添加元素后，对这个元素做修改，那么需要先erase然后再insert回去。&lt;/p&gt;

&lt;p&gt;另外的问题是，容器和智能指针结合使用时的易错点。&lt;/p&gt;

&lt;p&gt;当元素为shared_ptr&lt;T&gt;包装的类实例时，直接放进(multi)set就有2个潜在问题，一是容器排序的依据是shared_ptr，而不是T，这是很容易误解的，解决这个问题的办法是声明容器时添加一个Comparator参数，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Compare&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;multiset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样子写才会真正地按照T的定义去排序。&lt;/p&gt;

&lt;p&gt;然而还有个细节问题：用于容器的Compare或者说operator&amp;lt;，必须满足&lt;strong&gt;strict weak ordering&lt;/strong&gt;。这个概念会贯穿整个STL。&lt;/p&gt;

&lt;p&gt;这个东西简单理解就是说，类T必须实现operator&amp;lt;，从而容器sort元素的时候，可以用这个operator&amp;lt;实现==、&amp;gt;比较。&lt;/p&gt;

&lt;p&gt;为什么一个&amp;lt;就能实现==呢？这是用了一个有趣的技巧： a==b 可认为等价于 !(a &amp;lt; b) &amp;amp;&amp;amp; !(b &amp;lt; a)。&lt;/p&gt;

&lt;p&gt;对于只有单个属性的T来说，实现strict weak ordering很简单，只要operator&amp;lt;里写一行a.x &amp;lt; a.x就行了。&lt;/p&gt;

&lt;p&gt;对于一个有复合属性的类T，operator&amp;lt;需要小心一点，但也是大同小异。例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;逆序排序的话，&amp;lt;的结果取反即可。所以总之遇到(multi)set排序，重载operator&amp;lt;就对了。&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/cpp-8/</link>
        <guid isPermaLink="true">http://localhost:4000/cpp-8/</guid>
      </item>
    
      <item>
        <title>漫谈网络通讯加密（1）基础</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;常见加密算法&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/RSA_(cryptosystem)&quot;&gt;RSA&lt;/a&gt; （Rivest–Shamir–Adleman)（1977年）&lt;/h2&gt;

&lt;p&gt;基于大数（1024bits以上)的质因数分解问题。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic-curve_cryptography&quot;&gt;ECC&lt;/a&gt;（Elliptic-curve cryptography） （1985年）&lt;/h2&gt;

&lt;p&gt;基于在椭圆曲线上的离散对数的求取问题。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES（Rijndael）&lt;/a&gt; （2001年）&lt;/h2&gt;

&lt;p&gt;AES的意思是高级加密标准（Advanced Encryption Standard），使用的算法是Rijndael，Rijndael是当时加密算法竞赛的top 1。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;DH&lt;/a&gt;（Diffie-Hellman key exchange）（1976年）&lt;/h2&gt;

&lt;p&gt;密钥交换算法。&lt;/p&gt;

&lt;p&gt;基于离散对数问题。&lt;/p&gt;

&lt;h1&gt;DH算法&lt;/h1&gt;

&lt;h2&gt;key exchange例子（ &lt;a href=&quot;https://scotthelme.co.uk/perfect-forward-secrecy/&quot;&gt;from here&lt;/a&gt; )：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Alice和Bob首先线下商量好，使用&lt;strong&gt;p (prime, 质数) = 23、g (generator, 生成器) = 5&lt;/strong&gt;作为通讯基础（p和g不需要绝对的保密，泄露了也没事）&lt;/li&gt;
&lt;li&gt;每次Alice和Bob想要建立通讯(连接)时，Alice自己随机生成一个在范围[1, p - 1]的数：a = 6&lt;/li&gt;
&lt;li&gt;同样，Bob自己也随机一个：b = 15&lt;/li&gt;
&lt;li&gt;Alice计算： \( A = ( g^{a} ) \% p = ( 5^{6} ) \% 23 =  15625 \% 23 = 8 \)，把A发给Bob&lt;/li&gt;
&lt;li&gt;Bob计算： \( B = ( g^{b} ) \% p = ( 5^{15} ) \% 23 =  30517578125 \% 23 = 19 \)，把B发给Alice&lt;/li&gt;
&lt;li&gt;Alice收到B后，可计算出&lt;strong&gt;对称密钥&lt;/strong&gt;：\( s_{Alice} = ( B^{a} ) \% p = ( 19^{6} ) \% 23 = 47045881 \% 23 = 2 \)&lt;/li&gt;
&lt;li&gt;Bob收到A后，可计算出&lt;strong&gt;对称密钥&lt;/strong&gt;：\( s_{Bob} = ( A^{b} ) \% p = ( 8^{15} ) \% 23 = 35184372088832 \% 23 = 2 \)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;数学原理&lt;/h2&gt;

&lt;p&gt;其中，用到了&lt;strong&gt;模幂运算&lt;/strong&gt;的基本定理，对于任意自然数a、b、n，有：&lt;/p&gt;

&lt;p&gt;\[ ab\  \%\  n =  ( ab\ \%\  n) \  \%\  n =  ( (a\ \%\  n)  (b\ \%\  n) ) \ \%\  n \]&lt;/p&gt;

&lt;p&gt;应用到幂运算：&lt;/p&gt;

&lt;p&gt;\[ a^{b}\  \%\  n =  ( a \cdots  a ) \  \%\  n =  ( (a\ \%\  n) \cdots  (a\ \%\  n) ) \  \%\  n =  ( \ (a\ \%\  n)  ^{b}\  ) \ \%\  n \]&lt;/p&gt;

&lt;p&gt;于是有：&lt;/p&gt;

&lt;p&gt;\[ s_{Alice} = ( B^{a} ) \% p =  (\  (\  g^{b} ) \% p\  ) ^{a}\   ) \% p =   (  \ g \% p\  ) ^{ab} \  ) \% p =  \ g ^{ab} \% p \]&lt;/p&gt;

&lt;p&gt;同理：&lt;/p&gt;

&lt;p&gt;\[ s_{Bob} = ( A^{b} ) \% p =  (\  (\  g^{a} ) \% p\  ) ^{b}\   ) \% p =   (  \ g \% p\  ) ^{ab} \  ) \% p =  \ g ^{ab} \% p \]&lt;/p&gt;

&lt;p&gt;显然：&lt;/p&gt;

&lt;p&gt;\[  s_{Alice} = s_{Bob}  \]&lt;/p&gt;

&lt;p&gt;这样就协商出了对称的密钥。&lt;/p&gt;

&lt;h2&gt;为什么可行&lt;/h2&gt;

&lt;p&gt;从攻击者角度看，攻击者最多只能获得以下信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;p：23&lt;/li&gt;
&lt;li&gt;g：5&lt;/li&gt;
&lt;li&gt;A：8&lt;/li&gt;
&lt;li&gt;B：19&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;攻击者目标是获得s（serect）。要计算s，就是算2条式子：&lt;/p&gt;

&lt;p&gt;\[ s = ( B^{a} ) \% p \]&lt;/p&gt;

&lt;p&gt;\[ s = ( A^{b} ) \% p \]&lt;/p&gt;

&lt;p&gt;显然，攻击者只需要破解出a或b，就能得到s。&lt;/p&gt;

&lt;p&gt;又因为有：&lt;/p&gt;

&lt;p&gt;\[ A = ( g^{a} ) \% p \]&lt;/p&gt;

&lt;p&gt;\[ B = ( g^{b} ) \% p \]&lt;/p&gt;

&lt;p&gt;所以破解a或b的方法是：&lt;/p&gt;

&lt;p&gt;\[ a = log_{g}^{A} \% p \]&lt;/p&gt;

&lt;p&gt;\[ b = log_{g}^{B} \% p \]&lt;/p&gt;

&lt;p&gt;这看似很简单的算术（对数运算和取模运算），其实是很难算的。目前为止没有找到一个快速计算对数的算法。&lt;/p&gt;

&lt;p&gt;关键在于&lt;strong&gt;p这个素数要足够大&lt;/strong&gt;，那么以现在的计算机计算速度，就很难通过A（或B）、g、p这3个参数算出a，这被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_logarithm&quot;&gt;离散对数难题&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这里需要注意，难的是&lt;strong&gt;离散对数&lt;/strong&gt;，即有log和mod运算并且参数是整数；若单单只有log运算，是不难的。&lt;/p&gt;

&lt;h2&gt;p、g的选取问题&lt;/h2&gt;

&lt;p&gt;涉及到了一些数论的概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Greatest_common_divisor&quot;&gt;最大公约数gcd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiplicative_order&quot;&gt;数论阶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Primitive_root_modulo_n&quot;&gt;原根&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先明确下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;p必须是素数，且必须是大数(1024-2048bits)，算法才安全&lt;/li&gt;
&lt;li&gt;g不需要是素数，且不需要很大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;p、g不需要自己挑选，可以直接用&lt;a href=&quot;https://tools.ietf.org/html/rfc5114&quot;&gt;rfc5114&lt;/a&gt;给定的值。&lt;/p&gt;

&lt;p&gt;例如&lt;a href=&quot;https://tools.ietf.org/html/rfc5114#section-2.1&quot;&gt;1024-bit MODP Group with 160-bit Prime Order Subgroup&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;再讲下去就是深入密码学、数论了，按住不表。&lt;/p&gt;

&lt;h1&gt;分组加密算法的模式&lt;/h1&gt;

&lt;p&gt;分组加密算法，都需要考虑wrap模式（【Block Cipher Modes（&lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation%EF%BC%89%EF%BC%89%E3%80%82&quot;&gt;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation））。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;模式多种多样，也很容易查到介绍资料。选择模式时主要考察几个点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;并发性：

&lt;ul&gt;
&lt;li&gt;如CTR、GCM计数器模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;安全性：

&lt;ul&gt;
&lt;li&gt;如ECB模式对重复出现的明文分组加密后结果是一样的，容易被猜出&lt;/li&gt;
&lt;li&gt;如CBC模式，会遇到&lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot;&gt;padding oracle attacks&lt;/a&gt;，这篇写得很详细：&lt;a href=&quot;https://blog.csdn.net/qq_35078631/article/details/78484980&quot;&gt;https://blog.csdn.net/qq_35078631/article/details/78484980&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;完整性(integrity)和可验证性(authenticity)：

&lt;ul&gt;
&lt;li&gt;其实就是指消息验证码MAC。加了MAC后，解密时，验证MAC，防止密文被篡改（tamper），保持完整。&lt;/li&gt;
&lt;li&gt;CCM模式，等于CTR加上CBC-MAC，不过做了2重加密，速度慢。&lt;/li&gt;
&lt;li&gt;OCB，有版权问题据说。&lt;/li&gt;
&lt;li&gt;GCM，等于CTR加上GHASH。这个是NIST官方标准了，绝对靠谱，性能据说很可以，openssl里面有一堆GASH的汇编代码，硬件级别上也有相应支持。&lt;/li&gt;
&lt;li&gt;这2个性质不一定要由分组加密完成。也可以外部套一个非对称加密，用数字签名来保证完整性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AES各种模式的选择问题，参考:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1220751/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb&quot;&gt;https://stackoverflow.com/questions/1220751/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此回答近300赞，在stackoverflow上算很多了。&lt;/p&gt;

&lt;p&gt;如果没耐心看，就看作者的最后总结：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果数据已经在外部做了非对称加密数字签名以支持验证，那么用CBC即可，否则用GCM&lt;/strong&gt;。&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;完全前向保密&lt;/strong&gt; PFS(Perfect Forward Secrecy)&lt;/h1&gt;

&lt;h2&gt;没有PFS之前：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果攻击者曾经窥探并保存了用户和服务器的加密数据流，且包括被公钥加密的对称密钥&lt;/li&gt;
&lt;li&gt;如果有一天攻击者通过某种办法获得了服务器私钥&lt;/li&gt;
&lt;li&gt;攻击者同时拥有了：“用公钥加密的对称密钥”、“私钥”&lt;/li&gt;
&lt;li&gt;攻击者用“私钥”对“用公钥加密的对称密钥”解密，获得了对称密钥&lt;/li&gt;
&lt;li&gt;攻击者此时就可以用破解出来的对称密钥对已存的历史加密数据做解密&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;基于DH的PFS：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不再使用公钥加密对称密钥的方案&lt;/li&gt;
&lt;li&gt;改为用DH密钥交换算法（key exchange），协商对称密钥，可以直接明文传输协商时需要的信息（并不怕这些信息被窃取）&lt;/li&gt;
&lt;li&gt;每次会话都协商新的对称密钥&lt;/li&gt;
&lt;li&gt;因为公钥私钥没有用来加密对称密钥了，所以即使服务器私钥被盗了也不会导致历史对称密钥被破解&lt;/li&gt;
&lt;li&gt;即使单次会话的对称密钥被破解了，也不会影响到别的会话&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;为什么可行&lt;/h2&gt;

&lt;p&gt;关键在于，用于生成会话密钥的“数据”，根本就没通过网络发送出去。而用公钥加密的密钥，本身就是通过网络传输的。&lt;/p&gt;

&lt;p&gt;后者显然更容易被攻击，主要获得私钥并记录了整个会话的数据流，就可以破解了。&lt;/p&gt;

&lt;p&gt;而前者，对称密钥的协商，根本没有用到公钥私钥，经过网络的也不是什么被加密后的密钥，而只是协商信息。攻击者要想破解某次会话的内容，只能从该次会话的加密数据流入手，没有他法。&lt;/p&gt;

&lt;h2&gt;问题&lt;/h2&gt;

&lt;p&gt;要做到perfect，意味着每次会话都要协商密钥，意味着增加了计算开销，不然不能保证密钥的转瞬即逝性质（ephemeral）。&lt;/p&gt;

&lt;h1&gt;通讯的认证&lt;/h1&gt;

&lt;p&gt;认证问题是指，如何确定和自己通讯的对方不是其他假冒者？&lt;/p&gt;

&lt;p&gt;目前有2个主要的解决方案：消息验证码（message authentication code，MAC）和数字签名（digital signature）。&lt;/p&gt;

&lt;h2&gt;消息验证码&lt;/h2&gt;

&lt;p&gt;前提：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通讯双方需要先约定好一个密钥，称为&lt;strong&gt;共享密钥&lt;/strong&gt;，双方都把它安全地存起来&lt;/li&gt;
&lt;li&gt;对任意长度的消息数据，用共享密钥可以计算出对应的固定长度的MAC&lt;/li&gt;
&lt;li&gt;计算MAC必须用到共享密钥，除非密钥泄露，否则第三者无法计算出MAC值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;协商密钥&lt;/li&gt;
&lt;li&gt;发送方对消息计算MAC值&lt;/li&gt;
&lt;li&gt;发送方把消息和MAC值都发给对方&lt;/li&gt;
&lt;li&gt;对方收到消息后，也用共享密钥计算MAC值，并与收到的MAC值比对&lt;/li&gt;
&lt;li&gt;如果2个MAC值一致，那么消息确实来自于发送方&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;各种问题：&lt;/h3&gt;

&lt;p&gt;一，密钥协商问题（上面已提过）。&lt;/p&gt;

&lt;p&gt;二，重放攻击(replay attack)：攻击者窃听通讯双方（例如2个银行）的数据，把汇款消息保存了下来（带有MAC值），然后重复发送这个汇款消息，接收方就会重复地向发送方发起汇款。其中，攻击者并不需要破解消息。&lt;/p&gt;

&lt;p&gt;解决方法：每条消息都加序号，序号必须保证递增，从而每条消息的序号唯一；消息加时间戳，但时钟同步和时钟精度又是新的问题；每个消息加nonce，一个只能用一次的随机数。&lt;/p&gt;

&lt;p&gt;三，密钥推测攻击：应确保攻击者不能通过MAC值逆向出共享密钥，否则攻击者就可以伪造发包了。&lt;/p&gt;

&lt;p&gt;四，对第三方证明问题：共享密钥只能保证2个人之间的通讯认证，但是如果多于2个人时，理论上共享密钥无法解决认证问题。&lt;/p&gt;

&lt;p&gt;例子：用户A向银行B用共享密钥传输了一个取款消息，如果B取款前需要告知C“A申请取款”，C是否可以相信A真的发出了取款消息，还是说消息是B杜撰的？答案是C没有办法知道。&lt;/p&gt;

&lt;p&gt;五，防止否认问题：就上面的取款例子，如果A真的发起了取款消息，但是事后又矢口否认，A认为是B杜撰了这个消息，此时事实就说不清了，A和B都有共享密钥，无法知道消息是A说的还是B说的。&lt;/p&gt;

&lt;h2&gt;数字签名&lt;/h2&gt;

&lt;p&gt;简单来说，数字签名是公钥加密的逆向过程。&lt;/p&gt;

&lt;p&gt;对比一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;公钥加密&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;公钥：发送者加密时使用&lt;/li&gt;
&lt;li&gt;私钥：接收者解密时使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数字签名&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;公钥：验证者验证签名时使用&lt;/li&gt;
&lt;li&gt;私钥：签名者生成签名时使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里面的公钥私钥是一样的东西，只是用法不一样。私钥依然需要保密地持有，而公钥依然可以任意地公开。&lt;/p&gt;

&lt;p&gt;为什么公钥加密反过来就是数字签名，而不是反方向的加密呢？用心琢磨下就知道了：用私钥去加密消息，而谁都能拿到公钥去解密，有什么保密意义可言？&lt;/p&gt;

&lt;p&gt;其中还有一个关键点是由公钥的数学原理保证的：用私钥加密的消息，只能用配套的公钥才能解密。&lt;/p&gt;

&lt;h3&gt;数字签名使用方法：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;发送方计算消息的摘要（MD5，SHA-1）&lt;/li&gt;
&lt;li&gt;发送方对摘要用自己的私钥加密，生成数字签名&lt;/li&gt;
&lt;li&gt;发送方把消息和数字签名同时发出&lt;/li&gt;
&lt;li&gt;任何人都可以用发送方公布的公钥对数字签名解密&lt;/li&gt;
&lt;li&gt;通过对比解出来的摘要和自己算出来的摘要，就可以知道消息是不是来自发送方（识别修改）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，上面说的消息，可以是明文也可以是密文，也就是说数字签名支持对明文做签名。&lt;/p&gt;

&lt;h3&gt;公钥证书：&lt;/h3&gt;

&lt;p&gt;对签名用到的公钥私钥对中的公钥也进行签名，就得到了公钥证书。（是不是有一种递归的感觉。）&lt;/p&gt;

&lt;p&gt;公钥证书可以用来判断收到的公钥是不是发送方的公钥。因为有可能收到假的公钥（中间人攻击）。&lt;/p&gt;

&lt;p&gt;签名公钥时，用到的公钥密钥对，本身又要认证。这就产生了CA的概念。&lt;/p&gt;

&lt;p&gt;一般公钥证书会简称证书。&lt;/p&gt;

&lt;h3&gt;数字签名的主要问题：&lt;/h3&gt;

&lt;p&gt;抛开一些攻击问题不讲，最主要的问题就是上面刚提到的中间人攻击。&lt;/p&gt;

&lt;p&gt;因为要正确地使用数字签名，有一个大前提：&lt;strong&gt;用于验证签名的公钥必须属于真正的发送者&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这就陷入了死循环：数字签名是用来&lt;strong&gt;防止伪冒&lt;/strong&gt;，但同时又必须从非伪冒的发送者拿到没有被篡改的公钥。&lt;/p&gt;

&lt;p&gt;所以就得用上刚刚提过的&lt;strong&gt;公钥证书&lt;/strong&gt;，给公钥附加一个第三方的签名，这样就把问题转移到了第三方。&lt;/p&gt;

&lt;p&gt;第三方的背后也可以存在别的第三方，于是需要构造一个&lt;strong&gt;数字签名链条&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;链条的末端，就是所谓的根证书了。&lt;/p&gt;

&lt;h3&gt;公钥基础设施：PKI（Public-Key Infrasture）&lt;/h3&gt;

&lt;p&gt;PKI的组成结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户，使用PKI的人&lt;/li&gt;
&lt;li&gt;认证机构（CA，Certification Authority），颁发证书的实体&lt;/li&gt;
&lt;li&gt;仓库（Repo），也叫证书目录，保存证书的数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PKI可以有无数个。&lt;/p&gt;

&lt;p&gt;重点要理解CA是怎么回事。&lt;/p&gt;

&lt;p&gt;CA主要做三件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成公钥密钥对。其实是可选的，如果由CA生成，那么需要安全地把私钥发给用户；如果是PKI用户生成，就简单多了。&lt;/li&gt;
&lt;li&gt;生成颁发证书。需要用到CA自己的私钥来对第一步的公钥进行数字签名，&lt;strong&gt;同时还需要对用户身份进行认证&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;作废（revoke）证书。作废比较复杂，因为用户会在本地缓存证书副本。于是就有了CRL，证书作废清单，（Certification Revocation List）。相当于是一个作废证书的公示榜单。其中每个证书有一个序列号可以作为id对应。用户通过查看CRL就可以知道证书有没作废。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CA可以形成层级关系，最顶层的叫根CA。验证某个公钥证书时，需要从根CA开始，一层层往下验证，确保整条链上的证书都是合法的。&lt;/p&gt;

&lt;h3&gt;对证书的攻击&lt;/h3&gt;

&lt;p&gt;有社会学的攻击也有非社会学的，具体建议看《图解密码技术》的第十章。&lt;/p&gt;

&lt;h3&gt;为什么要搞得这么复杂&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果用户有办法能够取得可信的公钥，则不需要CA&lt;/li&gt;
&lt;li&gt;当持有可信的CA公钥，并相信这个CA，则可以相信该CA颁发的证书，从而获得可信的公钥。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我的理解是，目前的技术瓶颈导致只能如此，没有更靠谱的方法。&lt;/p&gt;

&lt;p&gt;不过存在替代CA模式的其他解决方案：信任网络（web of trust），这个概念来源于PGP。&lt;/p&gt;

&lt;p&gt;信任网络就好像人与人之间的关系网（六度分隔理论），通过&lt;strong&gt;熟人推荐&lt;/strong&gt;，就可以建立起信任链，从而解决公钥认证问题。&lt;/p&gt;

&lt;p&gt;PGP就是建立在信任网络的协议和软件。鉴于PGP的设计，PGP特别适合用于电子邮件传输，当然电子邮件又不仅限用PGP，还可以用基于CA的S/MIME。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://scotthelme.co.uk/perfect-forward-secrecy/&quot;&gt;https://scotthelme.co.uk/perfect-forward-secrecy/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/crypto-1/</link>
        <guid isPermaLink="true">http://localhost:4000/crypto-1/</guid>
      </item>
    
      <item>
        <title>无损压缩算法：deflate</title>
        <description>&lt;p&gt;本文目标是搞清楚zlib库的deflate算法实现。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;名词解释&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/DEFLATE&quot;&gt;deflate&lt;/a&gt;：最常见的无损压缩算法，非常关键。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;.zip&lt;/a&gt;：archive format，使用了deflate压缩算法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Gzip&quot;&gt;.gz&lt;/a&gt;(或gzip格式）: single file compress format，也是使用了deflate压缩算法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Tar_(computing)&quot;&gt;.tar.gz&lt;/a&gt;或.tgz：archive format，可认为.gz文件的集合，但又不止是多个.gz的集合，因为tgz利用了文件之间的关联信息，提升了压缩率。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zlib.net/&quot;&gt;zlib&lt;/a&gt;：一个通用库，只有源代码，不提供可执行文件，支持gzip。linux内核、libpng、git等等都用了它。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/gzip/manual/gzip.html&quot;&gt;gzip&lt;/a&gt;：GNU Gzip，开源，提供了gzip和gunzip可执行文件，直接可以用来压缩、解压缩。内部也是实现了deflate算法。&lt;/p&gt;

&lt;p&gt;7-Zip：类似gzip，也是工具。&lt;/p&gt;

&lt;p&gt;经过了解，gzip的源码相对&lt;/p&gt;

&lt;h2&gt;Huffman Coding 和 LZ77&lt;/h2&gt;

&lt;h3&gt;LZ77（Lempel–Ziv Coding）&lt;/h3&gt;

&lt;p&gt;LZ77是基于&lt;strong&gt;字典&lt;/strong&gt;的算法。思路是，把数据中的重复（冗余）部分，用更短的metadata元信息代替。&lt;/p&gt;

&lt;p&gt;wiki：&lt;a href=&quot;https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;LZ77 and LZ78&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根据wiki所说，作者是发明了2个算法LZ77和LZ78。这2个算法是其他LZ算法变种的基础（LZW、LZSS、LZMA）。&lt;/p&gt;

&lt;p&gt;下面重点介绍LZ77。&lt;/p&gt;

&lt;h4&gt;LZ77关键词：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;input stream：待压缩的字节序列串&lt;/li&gt;
&lt;li&gt;byte：字节，是input stream的基本元素&lt;/li&gt;
&lt;li&gt;coding position：相当于一个指针，指向当前编码位置；也是lookahead buffer的起始位置&lt;/li&gt;
&lt;li&gt;lookahead buffer：就是指coding position为起点，input stream末端为终点的这段字节序列&lt;/li&gt;
&lt;li&gt;window：最大长度为W的滑动窗口，也是以coding position为起点，但是窗口方向是&lt;strong&gt;反向往左&lt;/strong&gt;；窗口初始长度为0，随着编码的进行，长度会增长到W，然后就开始往右滑动&lt;/li&gt;
&lt;li&gt;match：当前匹配串&lt;/li&gt;
&lt;li&gt;pointer：当前匹配串的信息，一般用（B，L）表示，B表示Go &lt;strong&gt;B&lt;/strong&gt;ack多少个字节（从coding position往左），因为也叫starting offset；L指匹配串从starting offset往右延伸的长度。 pointer为（0，0）时，表示匹配失败。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;LZ77要注意的点：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;pointer的L是可能比B还大的，即匹配串从window区域，延伸进了lookahead buffer区域，又因为匹配串的起点就是lookahead buffer的起点，所以此时出现了&lt;strong&gt;repeat&lt;/strong&gt;现象。这个repeat是没问题的，甚至是有用的，可以对不断重复的数据大大压缩。&lt;/li&gt;
&lt;li&gt;pointer有匹配成功和匹配失败2种情况，所以把pointer信息输出时，还得在pointer前用一个bit表示是哪种pointer。&lt;/li&gt;
&lt;li&gt;pointer里2个信息：B和L，它们的位数一般是固定的。位数大小可以是任意的N bits，但显然，位数太少的话，说明最大匹配长度就受限，即对于超长串是无法高度压缩的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重点&lt;/strong&gt;：有的文章会把pointer表示成（B，L，C）。C就是一个byte数据，这是因为任意一个byte第一次出现时，肯定是找不到匹配串的，所以会输出（0，0，byte）；并且，为了输出缓冲区的结构一致性，当匹配成功时，也得输出（B，L，C），C相当于一个空的占位符，有点浪费，所以有的LZ77算法会再成功匹配后，把下一个byte存到占位符里，因此encoding position要移动L+1。（注意下文讲解的实例占位符是留空的）&lt;/li&gt;
&lt;li&gt;B和L耗用的位数不需要一样。&lt;/li&gt;
&lt;li&gt;既然固定了B和L的位数大小，那么最大窗口大小W也是可以固定的，例如当W为32KB时，那么15 bits就可以表达32KB的任意一个值。&lt;/li&gt;
&lt;li&gt;window的最大长度W影响到压缩比率和压缩效率。显然W越大，匹配得越充分，但也越慢。&lt;/li&gt;
&lt;li&gt;需要定一个&lt;strong&gt;最小匹配长度&lt;/strong&gt;，只有当当前匹配串大于最小匹配长度时，这个匹配才成立。例如B用15位，L用8位，差不多就用了3个字节，如果当前匹配串不足3个字节，例如1个字节，那就导致encoding后长度反而更长了。&lt;/li&gt;
&lt;li&gt;显然LZ77的compress做的工作量要比decompress多得多，因为做了大量的匹配查找。所以LZ77特别适合于&lt;strong&gt;一次压缩，多次解压缩&lt;/strong&gt;的情景。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;实例：&lt;/h4&gt;

&lt;p&gt;这种算法用实例来理解是最快的。微软&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ee916854.aspx&quot;&gt;这篇文章&lt;/a&gt;就给出了一个例子，这里拿来用一下。&lt;/p&gt;

&lt;p&gt;（&lt;a href=&quot;https://www.cnblogs.com/junyuhuang/p/4138376.html&quot;&gt;另外这篇文章&lt;/a&gt;给出了这个例子的示意图，建议同时参照下，本文就不做图了）&lt;/p&gt;

&lt;p&gt;待压缩字节串（流）：AABCBBABC&lt;/p&gt;

&lt;p&gt;字节串中每个字节记一个位置标记position（上面的encoding position也是指这个），从1开始数，不是从0哦：&lt;/p&gt;

&lt;pre&gt;

Position    1    2    3    4    5    6    7    8    9

Byte        A    A    B    C    B    B    A    B    C

&lt;/pre&gt;

&lt;p&gt;开始LZ77编码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;LZ77编码后，就输出了最右边一列，注意，这里只是方便理解，实际上不会存成文本形式，没有（ ），这些字符。&lt;/p&gt;

&lt;p&gt;这里重点要搞懂output这一列是怎么来的，用人话来描述下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始时，滑动窗口window是空的：【】&lt;/li&gt;
&lt;li&gt;第1次遇到A，然后在window里match一下，必然找不到A，match失败，于是输出(0,0)A。window更新为【A】&lt;/li&gt;
&lt;li&gt;第2次遇到A，window里match一下，此时要注意，match的方向是右到左（反向）。在window右起第1个位置就找到了A，所以输出(1, 1)，window更新为【AA】&lt;/li&gt;
&lt;li&gt;第1次遇到B，同步骤1，输出(0,0)B，window更新为【AAB】&lt;/li&gt;
&lt;li&gt;同步骤3，输出(0,0)C，window更新为【AABC】&lt;/li&gt;
&lt;li&gt;第2次遇到B，在window第2个位置找到B，于是starting position为2，同时发现下一个字节不匹配（左C和右B），所以长度为1，输出（2，1），window更新为【AABCB】&lt;/li&gt;
&lt;li&gt;第3次遇到B，在window第1个位置就找到B，同时发现下一个字节不匹配（左B和右C），所以长度为1，输出（1，1），window更新为【AABCBB】&lt;/li&gt;
&lt;li&gt;第3次遇到A，在window第5个位置找到A，然后迭代匹配，发现后面的BC也匹配上，所以长度为3，输出（5，3），window更新为【AABCBBABC】&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来，看看如何把这一列output再解码回原文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;输入(0,0)A，表示直接往输出缓冲区push一个A字符。 【A】&lt;/li&gt;
&lt;li&gt;输入(1,1)，只有meta信息，(1,1)意思是它的位置等于1，长度为1，&lt;strong&gt;注意，位置是反向数，长度是正向数&lt;/strong&gt;。显然，(1,1)等于缓冲区的字符A，于是push了一个一样的A。【AA】&lt;/li&gt;
&lt;li&gt;(0,0)B，和步骤1一样，直接push一个B。【AAB】&lt;/li&gt;
&lt;li&gt;(0,0)C，同上。【AABC】&lt;/li&gt;
&lt;li&gt;(2,1)，又是meta信息，位置为2，长度为1，倒着数当前缓冲区，发现起点是B字符，长度为1，所以push一个B。【AABCB】&lt;/li&gt;
&lt;li&gt;(1,1)，参考步骤5，也是push一个B。【AABCBB】&lt;/li&gt;
&lt;li&gt;(5,3)，长度终于不为1了，首先在缓冲区倒着数5下，发现是左起第二个A，然后长度3，于是往右再获取2个字符，得到ABC，push到缓冲区，得到【AABCBBABC】&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的内容搞得懂的话，就差不多了，要继续深入就是看源码。但不急，先看完Huffman Coding。&lt;/p&gt;

&lt;h3&gt;Huffman Coding&lt;/h3&gt;

&lt;p&gt;待续。&lt;/p&gt;

&lt;h2&gt;zlib 和 deflate&lt;/h2&gt;

&lt;h3&gt;zlib&lt;/h3&gt;

&lt;p&gt;zlib自带CMakeLists.txt，在Mac上可以直接生成一个Xcode project，不仅可以方便地编译zlib，还可以用来学习zlib（本文的重心）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;cd build/
cmake .. -G &amp;#39;Xcode&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后打开zlib.xcodeproj，构建All，并选择运行example。能运行成功的话打开example.c，会发现有完整的zlib使用教程。&lt;/p&gt;

&lt;p&gt;我们重点放在deflate的最简单的使用实例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_deflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;test_inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncomprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第1行压缩，第2行解压。看懂了这两个函数代码，是理解deflate算法的第一步。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 该函数用到的外部代码片段，我搬运到这里，方便浏览&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 压缩强度级别&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define Z_NO_COMPRESSION         0&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define Z_BEST_SPEED             1&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define Z_BEST_COMPRESSION       9&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define Z_DEFAULT_COMPRESSION  (-1)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 这个结构大概相当于一个压缩控制器&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z_stream_s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z_const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bytef&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* 指向待压缩数据的第一个字节 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uInt&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 待压缩数据next_in的长度 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;total_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 当前已读取多少输入字节 */&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Bytef&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 指向输出缓冲区，只需要在一开始赋值一次 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uInt&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 输出缓冲区next_out的剩余空间 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;total_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 当前已输出多少输入字节*/&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;z_const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 错误信息 */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_state&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FAR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 暂时不用管这个 */&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;alloc_func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 压缩过程会分配新内存（internal state），用户可以设置自己的alloc函数给z_stream */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;free_func&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;cm&quot;&gt;/* 释放内存 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;voidpf&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;opaque&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* zalloc、zfree的第一个参数，默认设0即可 */&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;data_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 数据的类型的猜测：Z_BINARY 或者 Z_TEXT，即保存了detect_data_type的返回值 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;adler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* 未压缩数据的检验和 （Adler-32 or CRC-32) */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;reserved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//待压缩的字节串&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z_const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;hello, hello!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_deflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z_stream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 待压缩数据大小&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opaque&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voidpf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deflateInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_DEFAULT_COMPRESSION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;deflateInit&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_in&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z_const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 如果不使用1字节buffer模式的话，要执行这2行&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// c_stream.avail_in = len;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// c_stream.avail_out = comprLen;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 开始压缩&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 每次只处理1个字节，故意的*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_NO_FLUSH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;deflate&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 压缩末端的处理&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 依然每次只输出一个字节&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_FINISH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_STREAM_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 结束标记&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;deflate&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deflateEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;deflateEnd&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;纵观整个压缩流程，其实就是1个变量和3个函数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义z_stream局部变量c_stream&lt;/li&gt;
&lt;li&gt;deflateInit(&amp;amp;c_stream, Z_DEFAULT_COMPRESSION)，初始化c_stream&lt;/li&gt;
&lt;li&gt;deflate(&amp;amp;c_stream, Z_NO_FLUSH)和deflate(&amp;amp;c_stream, Z_FINISH)，压缩数据&lt;/li&gt;
&lt;li&gt;deflateEnd(&amp;amp;c_stream)，结束&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个example故意让缓冲区每次迭代都只有1个字节可用，可以去掉那2行代码，并在开始压缩之前执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是解压缩：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncomprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncomprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z_stream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;garbage&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opaque&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voidpf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_in&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 如果不使用1字节buffer模式的话，要执行这2行&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// d_stream.avail_in = (uInt)comprLen;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// d_stream.avail_out = (uInt)uncomprLen;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflateInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;inflateInit&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncomprLen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_NO_FLUSH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_STREAM_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;inflate&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflateEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;inflateEnd&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strcmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;bad inflate&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;inflate(): %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;deflate和inflate函数的源码，非常恐怖，单个函数几百行。这里就不贴出来分析了。&lt;/p&gt;

&lt;h3&gt;deflate&lt;/h3&gt;

&lt;p&gt;待续。&lt;/p&gt;

&lt;h2&gt;adler32 和 CRC32&lt;/h2&gt;

&lt;p&gt;待续。&lt;/p&gt;

&lt;h2&gt;历史&lt;/h2&gt;

&lt;p&gt;一位答主写了压缩算法的演变史，很值得一看：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they&quot;&gt;https://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单来说，就是早期unix系统上面只有compress指令，compress使用了一个有版权的LZW算法，作者Phil Katz对LZW的免费使用有所争议。&lt;/p&gt;

&lt;p&gt;并且，zip format也是这个作者设计的，但庆幸zip format是无版权的，于是就有个叫Info-ZIP group的组织开发了同样可以压缩&amp;amp;解压缩zip的程序，开源免费跨平台，这个东西导致zip format被大范围使用。&lt;/p&gt;

&lt;p&gt;然后到了90年代早期，出现了新的压缩格式：gzip format（或.gz）以及对应的程序gzip。gzip的代码继承自Info-ZIP，gzip是打算用来取代unix的compress的。&lt;/p&gt;

&lt;p&gt;gzip单个文件时，会给该文件加上.gz后缀。&lt;/p&gt;

&lt;p&gt;然后又到了90年代中期，又遇到了版权问题，这次是关于gif格式的，gif用了带版权的LZW算法。于是又有人站出来开发了替代品：png。这是一种无损压缩图片的技术，同样使用了deflate作为内部格式。为了扩大png的使用范围，就弄出了libpng和zlib两个网站。libpng是用来处理png有关的所有事情，而zlib是作为libpng背后的支撑：提供了压缩和解压缩算法（当然现在也被用于别的软件）。注意，zlib的代码继承自gzip。&lt;/p&gt;

&lt;p&gt;小结2点：&lt;strong&gt;gzip是zlib之父；以上说的版权问题现在都已过期了&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;zlib兼容gzip，且提供了比gzip更多的功能选项。一是wrapping模式可选：无wrapping、zlib wrapping、gzip wrapping。无wrapping就是仅使用deflate内部格式；png使用的就是zlib wrapping。&lt;/p&gt;

&lt;p&gt;zlib wrapping和gzip wrapping的主要区别是：zlib wrapping更紧凑并且新增了Adler-32算法，比gzip用的CRC32更快。&lt;/p&gt;

&lt;p&gt;所以zlib源码会显得比较复杂，需要兼容gzip格式和CRC32，且新增了zlib格式和Adler32；gzip就显得比较原始，只有deflate和CRC32代码。&lt;/p&gt;

&lt;p&gt;zlib是目前最广泛使用的压缩库。&lt;/p&gt;

&lt;p&gt;再后来，就出现了新的基于deflate压缩库：7-Zip和google的zopfli。zopfli的压缩率比zlib的最高压缩率还高，压榨了最后的一些空间，但也花费了更多的CPU时间。当然这个最高压缩level是可选的。注意，zopfli只提供了压缩功能，解压缩依然得用zlib或gzip（大概是因为解压缩本来就足够优秀了）；zopfli虽然有3-8%的压缩率提升，但耗时增长得更厉害，觉得zopfli还是显得鸡肋。&lt;/p&gt;

&lt;p&gt;以上说的都是基于deflate算法的压缩库。实际上还存在别的算法：bzip2、LZMA等，他们有的甚至是完胜deflate。但很可惜，在互联网中要更替一种标准是非常困难的。deflate已经广泛运用到web的方方面面，难以取代。&lt;/p&gt;

&lt;p&gt;所以还是学习deflate先吧。并且，阅读zlib库最佳。&lt;/p&gt;

&lt;h2&gt;资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951 : DEFLATE Compressed Data Format Specification version 1.3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://qianwenjie.net/?p=17&quot;&gt;http://qianwenjie.net/?p=17&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://marknelson.us/1997/01/01/zlib-engine/&quot;&gt;http://marknelson.us/1997/01/01/zlib-engine/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zlib.net/feldspar.html&quot;&gt;http://www.zlib.net/feldspar.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/zlib-1/</link>
        <guid isPermaLink="true">http://localhost:4000/zlib-1/</guid>
      </item>
    
      <item>
        <title>多线程网络库开发笔记</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;收到EPOLLOUT事件，但write时返回了EAGAIN？&lt;/h2&gt;

&lt;p&gt;这是因为EAGAIN不止是在发送缓冲区满时返回，还可能是&lt;strong&gt;未ACK的包数量已经达到了拥塞窗口的大小&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而EPOLLOUT并不会检查拥塞窗口的情况，只要发送缓冲区不满，就返回EPOLLOUT了。&lt;/p&gt;

&lt;p&gt;用并发压力测试可以测出这种情况：在epoll_wait返回后，检测可写事件的fd是否发送缓冲区不满，不满的话尝试写入一个字节，然后通过write的返回值和错误码就可以知道有没出现&lt;strong&gt;缓冲区不满的EAGAIN&lt;/strong&gt;。同时打印出拥塞窗口信息，就可以看出EAGAIN原因：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/22.png&quot; alt=&quot;22.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;a href=&quot;https://stackoverflow.com/questions/3070127/will-eagain-return-on-send-for-anything-other-than-buffer-full&quot;&gt;https://stackoverflow.com/questions/3070127/will-eagain-return-on-send-for-anything-other-than-buffer-full&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://linuxgazette.net/136/pfeiffer.html&quot;&gt;https://linuxgazette.net/136/pfeiffer.html&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;EAGAIN/EWOULDBLOCK can also be returned (for TCP sockets) when the number of unacknowledged packets has reached the congestion window.&lt;/p&gt;

&lt;p&gt;To check the status of the socket w.r.t. the congestion window, then try this:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;netinet/tcp.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_tcp_cwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcp_info_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getsockopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOL_TCP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TCP_INFO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_info_length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;tcpi_snd_cwnd: %u, tcpi_unacked: %u&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcpi_snd_cwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcpi_unacked&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;If tcpi_unacked == tcpi_snd_cwnd then send() will return EAGAIN/EWOULDBLOCK for a non-blocking socket.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;write无限返回EAGAIN导致的cpu超载和FIN_WAIT1卡死&lt;/h2&gt;

&lt;p&gt;这是只会出现在非阻塞socket的问题。&lt;/p&gt;

&lt;p&gt;解决思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检查是不是意外调用了onWritable接口，即还没有监听可写事件，却调用了可写回调接口&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尝试用while循环来调用send data，直到send发完数据，或返回-1（EAGAIN）并添加可写监听。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，收到可写事件时，尝试write剩余字节，如果write能把所有字节都写进发送队列，那么就可以删除EPOLLOUT监听了。&lt;/p&gt;

&lt;h2&gt;atomic变量也会segment fault?&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#0  0x00000000004cb56b in std::atomic&amp;lt;wynet::TcpConnection::State&amp;gt;::load (this=0x58, &lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;4.8.2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;209&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#1  0x00000000004c9a6d in std::atomic&amp;lt;wynet::TcpConnection::State&amp;gt;::operator wynet::TcpConnection::State&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x58&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;4.8.2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;176&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#2  0x00000000004f0fa1 in wynet::TcpConnection::shutdown (this=0x0)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;github&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wynet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;74&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gdb查core文件，发现日志很奇怪，在atomic的load里crash了。&lt;/p&gt;

&lt;p&gt;最终发现是访问了一个null的shared_ptr的atomic变量。加if判断即可。&lt;/p&gt;

&lt;h2&gt;10k和10k+连接问题&lt;/h2&gt;

&lt;p&gt;10k数量级的网络连接，是非常容易暴露出自己写的网络代码的问题的。&lt;/p&gt;

&lt;p&gt;局域网下有2种测试方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;server和clients同主机（走回环，不需要经过网卡）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;server和clients不同主机，clients可以分散到多台主机（需要经过网卡）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我现在做的第一种，本地开2个进程，一个进程跑server，另一个进程发起10k+个客户端连接，pingpong发消息，可以测吞吐量并且也可以测下承载能力。&lt;/p&gt;

&lt;p&gt;目前遇到很多问题，逐个列举下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开文件描述符数量限制。可以用ulimit -n修改。Mac下有些特殊。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端的port不够用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先查看系统上限：cat /proc/sys/net/ipv4/ip_local_port_range，可能会输出32768   60999，只有28231个端口可用。
但由于port是双字节，理论上撑死只有3万个port可以用。改大这个范围的意义不大。此时要考虑多主机来测试30k+连接了。&lt;/p&gt;

&lt;h2&gt;多线程：wait morphing&lt;/h2&gt;

&lt;p&gt;以pthread为例，在C++中使用pthread的pthread_mutex_xxx和pthread_cond_xxx，实现RAII的mutex guard类以及阻塞队列(BlockingQueue)时，会遇到wait morphing的需求。&lt;/p&gt;

&lt;p&gt;例如，一般会先实现2个类：MutexLock，和MutexLockGuard：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutexLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutexLockGuard&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MutexLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MutexLockGuard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MutexLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MutexLockGuard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是BlockingQueue：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MutexLockGuard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_notEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// wait morphing&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 注意，lock是在退出本函数时才销毁，所以顺序是：cond signal -&amp;gt; unlock&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MutexLockGuard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m_notEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用BlockingQueue的put函数，做了几个事情：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;lock了mutex&lt;/li&gt;
&lt;li&gt;put一个对象到队列&lt;/li&gt;
&lt;li&gt;发射条件变量信号&lt;/li&gt;
&lt;li&gt;函数退出，unlock了mutex&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;MutexLockGuard对mutex lock/unlock的封装，是非常符合RAII的，只需要在函数开头声明一个栈变量，就可以保证成对的lock、unlock。&lt;/p&gt;

&lt;p&gt;然而，这个特性遇到条件变量时，就不是很好了。首先，因为unlock和notify是2个单独的操作，谁先谁后，效果并不一样。以上面的put函数为例，put完一个对象后，做2种情景假设。&lt;/p&gt;

&lt;p&gt;情景1：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;线程1先unlock了mutex&lt;/li&gt;
&lt;li&gt;线程1调用notify，唤醒等待线程2&lt;/li&gt;
&lt;li&gt;等待线程2被唤醒，因为mutex已经unlock，于是立即就lock到了mutex&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;情景2：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;线程1先调用notify，唤醒等待线程2&lt;/li&gt;
&lt;li&gt;等待线程2被唤醒，试图锁住mutex，但mutex还未解锁，于是又进入睡眠。&lt;/li&gt;
&lt;li&gt;线程1unlock了mutex&lt;/li&gt;
&lt;li&gt;线程2因为在第2步中试图锁住mutex，所以会被第3步的unlock唤醒，尝试第2次加锁，lock到了mutex&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分析可见，情景2中，线程2被唤醒了2次才锁到了mutex，有多余的性能开销。&lt;/p&gt;

&lt;p&gt;而我们的C++ RAII MutexLockGuard和BlockingQueue就是情景2.&lt;/p&gt;

&lt;p&gt;linux系统有专门针对这个问题的优化技术：wait morphing。&lt;/p&gt;

&lt;p&gt;wait morphing含义是，&lt;strong&gt;系统可以知道情景2的第2步的该次唤醒并不能锁住mutex，那么把挂在该condvar的所有等待线程，转移(morphing)到mutex的等待线程队列，并不去唤醒它们，从而免去多余的上下文切换&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当然这个优化是内核的，需要先了解你的linux有没实现这个优化。&lt;/p&gt;

&lt;h2&gt;tcp连接管理问题&lt;/h2&gt;

&lt;h3&gt;Mac下意外的RST：&lt;/h3&gt;

&lt;p&gt;出现情景：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端发送了一些数据包后，调用close或者shutdown(SHUT_WR)，此时客户端会发送FIN&lt;/li&gt;
&lt;li&gt;服务端收到FIN，如果没有待发送的数据，那么返回FIN+ACK，如果还有数据要发送，那么只返回ACK&lt;/li&gt;
&lt;li&gt;客户端收到自己发出的FIN的ACK&lt;/li&gt;
&lt;li&gt;服务端如果仅返回了对客户端FIN的ACK，然后继续发送剩下的数据，并会在最后发一个FIN&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重点&lt;/strong&gt;，如果客户端没有接收完服务端剩下的数据，就结束进程（会彻底关闭socket），那么客户端协议栈收到服务端余下的数据包时，只能返回RST，因为socket已经不见了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结论：在Mac下，客户端进程需要稍微延时关闭，例如在main最后一行加sleep(1)。&lt;/p&gt;

&lt;h2&gt;shared_ptr与多线程安全&lt;/h2&gt;

&lt;p&gt;线程安全要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;因为shared_ptr内部维护了2个指针，1个指向真实的对象，一个指向control block，所以修改shared_ptr时需要两步操作，于是就有了race condition问题。&lt;/li&gt;
&lt;li&gt;在两步操作中，shared_ptr修改control block是保证线程安全的，即ref count不会出问题，但修改对象指针则不是。&lt;/li&gt;
&lt;li&gt;多线程&lt;strong&gt;只读&lt;/strong&gt;shared_ptr仍然是安全的。&lt;/li&gt;
&lt;li&gt;多线程&lt;strong&gt;读写&lt;/strong&gt;shared_ptr不安全，其中不安全表现之一是出现&lt;strong&gt;空悬指针&lt;/strong&gt;。在这种情况下， 读写shared_ptr必须用mutex保护。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;shared_ptr细节特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;shared_ptr有ptr指针，control block里还有一个ptr指针：这是为了让shared_ptr无需虚析构函数(virtual destructor)，第一次构造shared_ptr时，就把目标对象的指针放进了control block的ptr里，从而记住类型，而shared_ptr的ptr则可以是对象类型也可以是父类型，并不影响计数降为0时的自动析构。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于特点1，于是可以实现更粗暴的多态，即任意shared_ptr&lt;T&gt;都可以转成shared_ptr&lt;void&gt;。可以用来防止对象过早析构，或者做泛型编程。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应尽量用make_shared，可以节约一次new操作，不过需要看构造函数的访问性，不一定可以替代new T。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;weak_ptr：weak_ptr可以提升为shared_ptr，提升操作lock()据说是线程安全的。&lt;/p&gt;

&lt;h2&gt;self connect 自连接问题&lt;/h2&gt;

&lt;p&gt;资料：&lt;a href=&quot;http://sgros.blogspot.jp/2013/08/tcp-client-self-connect.html&quot;&gt;http://sgros.blogspot.jp/2013/08/tcp-client-self-connect.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;就是客户端socket连接成功后，发现两端ip和port一模一样。&lt;/p&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端发起连接时，只知道对端的ip和port，以及自己的ip（localhost），但自己的port是操作系统随机分配的。&lt;/li&gt;
&lt;li&gt;每一个tcp连接都是由四元组(source IP, source port, destination IP, destination port)唯一标识的。&lt;/li&gt;
&lt;li&gt;source port可以认为是随机分配，但linux可能会先顺序地分配用户有方法自己决定port，用bind，但一般很少这样做。&lt;/li&gt;
&lt;li&gt;这个source port也叫Ephemeral port（转瞬即逝的端口），这些port是在某个范围段里选的，linux下调用cat /proc/sys/net/ipv4/ip_local_port_range可以查这个范围，会返回2个数字，例如 32768 60999&lt;/li&gt;
&lt;li&gt;self connect只出现在本机客户端连本机服务器的情景下，这是因为source IP和destination IP要一致。&lt;/li&gt;
&lt;li&gt;复现self connect的方法是，客户端connect本机ip_local_port_range里的某个端口，因为该端口并没有socket服务器在监听，所以一般情况下会返回RST。随着不断发起这些不可能成功的连接，可能会出现操作系统分配了一个和dest port一样的source port，于是self connect出现。&lt;/li&gt;
&lt;li&gt;之所以允许这种情况，是因为tcp标准里有&lt;strong&gt;simultaneous open 同时打开&lt;/strong&gt;这个概念。&lt;/li&gt;
&lt;li&gt;self connect可以成功，意味着“两端”之间完成了三次握手，进入了ESTABLISHED状态。&lt;/li&gt;
&lt;li&gt;self connect只可能发生在握手阶段，所以对于一个已经ESTABLISHED的socket，也无法利用self connect做什么坏事的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接着，剖析下当分配了和dest port一样的source port时，tcp状态机究竟是怎么进入ESTABLISHED的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先socket是CLOSED状态&lt;/li&gt;
&lt;li&gt;调用connect，发送SYN，进入SYN SENT状态&lt;/li&gt;
&lt;li&gt;这个socket马上又收到来自自己的SYN包，于是根据tcp状态机图所示，该socket状态机会走simultaneous open路径，发送SYN+ACK，并进入SYN RECEIVED状态&lt;/li&gt;
&lt;li&gt;因为第3步里面发送了ACK的，所以这个处于SYN RECEIVED状态的socket接着会收到ACK，根据状态机图，socket就进入了ESTABLISHED&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：避免self connect是最佳做法，也就是不要选择Ephemeral port作为server端的监听端口，就没事了。&lt;/p&gt;

&lt;h2&gt;wait-free V.S. lock-free&lt;/h2&gt;

&lt;p&gt;在wiki上这2个东西都是指&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;Non-blocking algorithm&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;非阻塞&lt;/h3&gt;

&lt;p&gt;一个算法被称作非阻塞的前提是：线程的失败或挂起（failure or suspension），不会导致其他线程的失败或挂起。&lt;/p&gt;

&lt;h3&gt;lock-free：&lt;/h3&gt;

&lt;p&gt;在系统级别保证该系统（即用户程序）总是有进展的（progress）。换句话说，如果该系统的所有线程运行足够长时间，能保证至少有一个线程取得进展(make progress），就是lock-free。&lt;/p&gt;

&lt;p&gt;在lock-free中，如果一个线程被挂起，其他线程依然能取得进展。lock-free优点在于CPU是可以一直繁忙的，当当前线程被挂起，CPU可以接着处理别的线程（没有核心处于空闲状态），因此增加了系统的吞吐量。但不足之处是，还是可能存在一些线程是被延迟处理的(waiting)，也就意味着这些线程的工作有延时。&lt;/p&gt;

&lt;p&gt;在lock-free系统中优化延时的办法是，建立调度器，维护一个较好的平均延时。&lt;/p&gt;

&lt;h3&gt;wait-free：&lt;/h3&gt;

&lt;p&gt;和lock-free的区别是，wait-free是在lock-free的前提上，进一步要求该系统的线程的操作在有限步骤内能保证完成。所以wait-free必然满足lock-free。&lt;/p&gt;

&lt;p&gt;就上面说的吞吐量而言，wait-free更佳，因为保证了每个线程只要有机会被CPU载入执行，就总是能在有限步内完成，没有等待延时，no waiting。例如实时交易系统就需要wait-free。&lt;/p&gt;

&lt;h3&gt;Q&amp;amp;A&lt;/h3&gt;

&lt;p&gt;Q：为什么lock-free不等于wait-free？&lt;/p&gt;

&lt;p&gt;A：假设一个情景，系统运行在n核环境，并且有n个线程在做一个长操作，其中有m个（m&amp;lt;n）线程能在有限步内完成操作，其他的n - m线程可能会操作失败(fail)并一直不断重试（retry on failure）（失败原因可能那n个线程有关），n-m线程是不能保证在有限步骤内完成操作的（也就是需要wait），所以这种系统就只是lock-free而已。而如果换作wait-free的话，每个线程都能保证操作能在有限步以内完成，并且每个线程和其他线程相互独立，没有依赖，就是无等待，即wait-free。&lt;/p&gt;

&lt;p&gt;Q：lock-free是不是就是无锁？&lt;/p&gt;

&lt;p&gt;A：确实是要求无锁。因为如果系统内有一个线程获得了锁，然后万一线程异常了没有释放锁（无法保证progress），就会导致等待该线程的其他线程永久饥饿。如果这个锁释不释放对其他线程无所谓，那这个锁也显然无意义。综上，lock-free必然要求无锁。 &lt;/p&gt;

&lt;p&gt;wait-free也是无锁？&lt;/p&gt;

&lt;p&gt;A：wait-free是比lock-free更进一步的东西，当然也得是无锁。&lt;/p&gt;

&lt;h2&gt;ABA problem&lt;/h2&gt;

&lt;h2&gt;指令重排和thread fence&lt;/h2&gt;

&lt;h3&gt;指令重排：&lt;/h3&gt;

&lt;p&gt;（参考资料：&lt;a href=&quot;http://preshing.com/20120625/memory-ordering-at-compile-time/%EF%BC%89&quot;&gt;http://preshing.com/20120625/memory-ordering-at-compile-time/）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编译器为了优化性能，可能会按和c/c++代码不一样的顺序重新排列指令。&lt;/p&gt;

&lt;p&gt;指令重排需要打开编译优化选项。&lt;/p&gt;

&lt;p&gt;指令重排保证对单线程程序没有影响。但对多线程程序来说，就惨了。&lt;/p&gt;

&lt;p&gt;例子（Linux 3.10.0-514.26.2.el7.x86_64，gcc 4.8.5）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行 gcc -S -masm=intel test.c，得到：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    mov eax, DWORD PTR B[rip]   // 取出B值并写入eax
    add eax, 1                  // eax = eax + 1
    mov DWORD PTR A[rip], eax   // 把eax写入A
    mov DWORD PTR B[rip], 0     // B = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行 gcc -S -masm=intel -O2 test.c，得到：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    mov eax, DWORD PTR B[rip]   // 取出B值并写入eax
    mov DWORD PTR B[rip], 0     // B = 0
    add eax, 1                  // eax = eax + 1
    mov DWORD PTR A[rip], eax   // 把eax写入A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，两者区别是第四行B=0指令被提前到第二行了，即B=0发生在对A的赋值之前，和c代码是不同的顺序。&lt;/p&gt;

&lt;p&gt;单线程程序不会感知到这个区别。但考虑在多线程环境下，就容易引发一些问题。&lt;/p&gt;

&lt;p&gt;一是影响到了lock-free代码，考虑下面的代码，用了一个共享变量IsPublished来标志Value是否有数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IsPublished&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sendValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IsPublished&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果编译器重排了指令，使得IsPublished=1(Store)发生在Value = x(Store)之前。如果有一个线程在这2次store之间抢占了CPU，它看到IsPublished为1，但其实Value是还未赋值的，就引发了错误。&lt;/p&gt;

&lt;p&gt;如果不想受到重排指令的危害，那就得考虑使用thread fence了。&lt;/p&gt;

&lt;h3&gt;memory_order（访存次序）和thread fence&lt;/h3&gt;

&lt;p&gt;中文：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://zh.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;http://zh.cppreference.com/w/cpp/atomic/memory_order&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;英文：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;http://en.cppreference.com/w/cpp/atomic/memory_order&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;分成三大类：&lt;/p&gt;

&lt;p&gt;一. 顺序一致性模型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;memory_order_seq_cst：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;二. relax模型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;memory_order_relaxed：没有顺序限制，仅保证该操作的原子性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三. Acquire-Release模型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;memory_order_consume：&lt;/li&gt;
&lt;li&gt;memory_order_acquire：&lt;/li&gt;
&lt;li&gt;memory_order_release：&lt;/li&gt;
&lt;li&gt;memory_order_acq_rel：&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;cache line 和 cache line bouncing&lt;/h2&gt;

&lt;h2&gt;little&amp;#39;s law 律特定律&lt;/h2&gt;

&lt;h2&gt;consistent hashing 一致性哈希&lt;/h2&gt;

&lt;p&gt;参考代码（python）：&lt;a href=&quot;https://github.com/goller/hashring&quot;&gt;https://github.com/goller/hashring&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考代码（go）：&lt;a href=&quot;https://godoc.org/stathat.com/c/consistent#example-New&quot;&gt;https://godoc.org/stathat.com/c/consistent#example-New&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ioriiod0/consistent_hash&quot;&gt;https://github.com/ioriiod0/consistent_hash&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/wynet-1/</link>
        <guid isPermaLink="true">http://localhost:4000/wynet-1/</guid>
      </item>
    
      <item>
        <title>《TCP IP详解卷1》12-17章TCP笔记</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;12章 TCP初步&lt;/h2&gt;

&lt;p&gt;tcp features：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tcp有差错纠正，ip udp 没有&lt;/li&gt;
&lt;li&gt;窗口：分组数量的大小限制了网络利用率（吞吐量）&lt;/li&gt;
&lt;li&gt;窗口滑动：收到ACK时，窗口可能会向右滑动&lt;/li&gt;
&lt;li&gt;流控：基于发送速率和基于窗口&lt;/li&gt;
&lt;li&gt;窗口更新(通告)：接收方发送窗口通告给发送方，一般和和ACK一起发，窗口向友滑动的时候同事变更窗口大小&lt;/li&gt;
&lt;li&gt;通信速率SW/R (bits/s)：S是分组比特总大小，W是窗口大小，R是RTT&lt;/li&gt;
&lt;li&gt;如果发送速率超过中间路由器的能力，就需要拥塞控制(congestion control)，否则会路由器丢包&lt;/li&gt;
&lt;li&gt;显性通告：用协议字段告诉发送方网络情况&lt;/li&gt;
&lt;li&gt;隐性通告：根据其他网络特征自主减慢发送速率&lt;/li&gt;
&lt;li&gt;组包(packetization)：把一个字节流转换成一组IP可以携带的分组&lt;/li&gt;
&lt;li&gt;分组序列号：代表了每个分组的第一个字节在整个数据流中的字节偏移，而不是分组号&lt;/li&gt;
&lt;li&gt;分组大小可变，并允许分组重新组合（repacketization)&lt;/li&gt;
&lt;li&gt;校验和：报文段收到时如果检验和不对，会丢弃分组&lt;/li&gt;
&lt;li&gt;差错保护：发送大数据时检验和可能会失效，需要用户自己做更强大的校验和（CRC）&lt;/li&gt;
&lt;li&gt;ACK：一个指示字节号N的ACK暗示了所有&amp;lt;=N的字节都呗成功接收了&lt;/li&gt;
&lt;li&gt;若前面的ACK丢失，后续的ACK也可以确认前面的分组（robust）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不带数据的包可能没有可靠性保证，如Window Update ACK包&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重要性能问题：重传超时时间&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;往返时间估计（RTT estimation）：采样最近的多个RTT并取平均&lt;/li&gt;
&lt;li&gt;超时并不能等于RTT均值，因为可能有很多RTT是超过均值的，从而导致不断超时重传&lt;/li&gt;
&lt;li&gt;超时应略大于RTT均值，但也不能过大，否则网络会变得空闲&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;tcp头部：&lt;/p&gt;

&lt;p&gt;-2字节：源端口
-2字节：目的端口
-4字节：序列号seq
-4字节：ACK
-4位：头部长度
-4位：保留
-8位：flags
-2字节：窗口大小
-2字节：校验和
-2字节：紧急指针
-40字节：选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;长度：默认20字节，带选项的话最多60字节&lt;/li&gt;
&lt;li&gt;四元组：客户端主机IP+socket端口号、服务端主机IP+socket端口号&lt;/li&gt;
&lt;li&gt;SACK: Seletive地ACK，要比普通ACK高效，因为可以对次序杂乱的报文先ACK。&lt;/li&gt;
&lt;li&gt;头部长度：虽然只有4位，但是单位是word（32bits），所以可表示(2&lt;sup&gt;4&lt;/sup&gt; - 1)* 4bytes = 60字节的头部长度。&lt;/li&gt;
&lt;li&gt;窗口大小：字节数，所以最大窗口大小字节数为2&lt;sup&gt;16&lt;/sup&gt; - 1 = 65535字节&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;处理差错的办法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;差错矫正码&lt;/li&gt;
&lt;li&gt;数据重传&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;13章 TCP连接管理&lt;/h2&gt;

&lt;p&gt;建立连接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C发送ISN(c)（主动打开）&lt;/li&gt;
&lt;li&gt;S收到ISN(c)，发送ACK=ISN(c)+1 、 ISN(s) （被动打开）&lt;/li&gt;
&lt;li&gt;C收到ACK和ISN(s)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;断开连接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一方发送FIN（主动关闭者），要发送当前序列号K，且带有一个ACK（序列号L，代表最近一次收到的数据）&lt;/li&gt;
&lt;li&gt;另一方收到FIN后，发送ACK=k+1作为响应（被动关闭者），同时通知上层应用程序&lt;/li&gt;
&lt;li&gt;另一方应用程序发FIN（转变为主动关闭者），序列号为L&lt;/li&gt;
&lt;li&gt;一方收到FIN，发给另一方ACK确认&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两次半关闭：两边都要发FIN，才能变成完全关闭&lt;/p&gt;

&lt;p&gt;半关闭：close、shutdown双方都可以调用，close是全关闭，shutdown能实现半关闭&lt;/p&gt;

&lt;p&gt;ISN：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4微秒+1&lt;/li&gt;
&lt;li&gt;伪造包问题：只要四元组一样，就能伪造发包。ISN需要设计成难以被猜出，方法是：随机、散列、加密。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;连接建立超时：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;syn重发次数：cat /proc/sys/net/ipv4/tcp_syn_retries（或sysctl net.ipv4.tcp_syn_retries），一般等于6&lt;/li&gt;
&lt;li&gt;synack重发次数：cat /proc/sys/net/ipv4/tcp_synack_retries，一般等于2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MTU： 最大传输单元。路径MTU为1500字节。ipv4：1460+40字节，ipv6：1440+60字节。&lt;/p&gt;

&lt;h3&gt;选项：&lt;/h3&gt;

&lt;p&gt;MSS：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最大段大小，记录数据（不包括头部）长度，占2个字节。最小保证536字节（默认值），一般是1460字节&lt;/li&gt;
&lt;li&gt;最大段大小不是协商值，而是限定值，&lt;/li&gt;
&lt;li&gt;65535特殊值，ipv6网络中超长数据报会用到。但实际MSS仍受路径MTU限制，所以MSS值为MTU-(40 IPv6头+20 tcp头）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SACK：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发SYN/SYNACK时就得发这个SACK告诉对方支持SACK（双向）&lt;/li&gt;
&lt;li&gt;当接收到乱序的数据时，可向发送方发送SACK选项&lt;/li&gt;
&lt;li&gt;长度为8n+2，2个字节一个表示选项种类一个表示n，n等于SACK块数量&lt;/li&gt;
&lt;li&gt;SACK块：已经成功接收的序列号范围（序列号32位，需要start和end，所以总共要8个字节）&lt;/li&gt;
&lt;li&gt;最大n为3，SACK最多占8*3 + 2 = 26字节（因为一般还有个时间戳）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;窗口缩放选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;字节：16bits&lt;/li&gt;
&lt;li&gt;范围： 0-14，0表示没有缩放。&lt;/li&gt;
&lt;li&gt;最大窗口大小：65535 x 2&lt;sup&gt;14&lt;/sup&gt; ，约1GB。&lt;/li&gt;
&lt;li&gt;tcp终端内部会维护这个真实的窗口大小&lt;/li&gt;
&lt;li&gt;主动打开者发WSCALE，被动打开者接收到WSCALE才能在SYNACK中发WSCALE&lt;/li&gt;
&lt;li&gt;如果主动打开者没接收到被动打开者的WSCALE，就设为0&lt;/li&gt;
&lt;li&gt;自己的为S，发窗口大小给对方时，右移S位后将16数值填充到头部&lt;/li&gt;
&lt;li&gt;对方的为R，收到对方的窗口大小时，左移R位才是真实大小&lt;/li&gt;
&lt;li&gt;缩放大小是根据接收缓存的大小自动选取的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;时间戳选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作用1：估算RTT&lt;/li&gt;
&lt;li&gt;作用2：用来防止序列号回绕导致的旧包无法去除问题&lt;/li&gt;
&lt;li&gt;TSV：发送报文时放自己的当前时间戳 （Timestamp Value)&lt;/li&gt;
&lt;li&gt;TSER：发ACK的时候把最新的TSV（TsRecent）复制进去（Timesatamp Echo Reply）&lt;/li&gt;
&lt;li&gt;TsRecent并不是来自最新到达的报文段，而是来自最早的一个未经确认的报文段&lt;/li&gt;
&lt;li&gt;RTT = current time - TSER&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;路径MTU发现&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;主要方案是：发大包，收到PTB（packet too big）消息后，调整自己MSS&lt;/li&gt;
&lt;li&gt;黑洞问题：防火墙导致无法收到PTB消息，无法知道是网络不通还是包太大&lt;/li&gt;
&lt;li&gt;黑洞探测：报文重传失败多次后，尝试改成较小报文段（分片）&lt;/li&gt;
&lt;li&gt;路由是动态变化的，所以每10分钟要尝试一个更大的MSS（接近初始的发送方MSS）&lt;/li&gt;
&lt;li&gt;MSS大小影响吞吐量和窗口大小&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;TCP状态转换&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/20.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/19.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;TIME_WAIT：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;让迷途的报文可以在网络中消失&lt;/li&gt;
&lt;li&gt;防止新连接错误接收旧的迷途的报文&lt;/li&gt;
&lt;li&gt;一般要持续2个MSL（60秒）&lt;/li&gt;
&lt;li&gt;静默时间：如果TIME_WAIT主机崩溃重启，需要等待2MSL后才能建立新连接（但一般操作系统不会这样做）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TIME_WAIT状态其实不做什么事情，就是限制1分钟内这条连接的其中一端不能发起对另一端的新连接，这也是为什么只有一端进入TIME_WAIT而另一端可以直接CLOSED的原因。&lt;/p&gt;

&lt;p&gt;FIN_WAIT_2:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主动关闭方发送fin并收到finack就进入了FIN_WAIT_2&lt;/li&gt;
&lt;li&gt;处于FIN_WAIT_2时需要等另一方发送fin（永久等待）&lt;/li&gt;
&lt;li&gt;close系统调用会自动启动定时器，60秒后强制进入CLOSED状态&lt;/li&gt;
&lt;li&gt;用shutdown的半关闭不会启动定时器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时打开同时关闭：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;是可以正确处理的，并且只会建立一条连接&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;RST重置报文段&lt;/h3&gt;

&lt;p&gt;发送时机：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端连接请求没有对应的监听socket时&lt;/li&gt;
&lt;li&gt;强制终止连接时。排队报文会被丢弃，并马上发RST&lt;/li&gt;
&lt;li&gt;一端崩溃重启，收到正常工作（半开连接）的另一端的报文时&lt;/li&gt;
&lt;li&gt;TIME_WAIT错误时，TIME_WAIT端收到迷途的报文并发送ACK但被CLOSED的对端RST&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TIME_WAIT错误：是一种需要避免的错误，TIME_WAIT状态需要忽略RST，否则就会过早地进入CLOSED&lt;/p&gt;

&lt;p&gt;强制终止方法：SO_LINGER设0（socket逗留选项），含义是，不会为了确定数据是否到达另一端而逗留任何时间。&lt;/p&gt;

&lt;p&gt;接收到的RST，必然要带ACK，且序列号要在对端窗口范围内，否则可能会遭到伪造RST攻击。&lt;/p&gt;

&lt;p&gt;发送RST，不需要一个RSTACK。对端收到RST就自然重置连接了（可能对端会丢失RST）。&lt;/p&gt;

&lt;p&gt;UDP没有RST，但是有ICMP目的地不可达消息&lt;/p&gt;

&lt;h2&gt;14章 TCP超时和重传&lt;/h2&gt;

&lt;p&gt;tcp_retries1：连接已经建立后，基本重传次数。次数达到后，会先尝试让网络层更新路由再继续发包。一般为3次.&lt;/p&gt;

&lt;p&gt;tcp_retries2：连接已经建立后，最大重传次数。次数达到后，会断开连接。&lt;/p&gt;

&lt;p&gt;重传超时&amp;lt;RTT：对网络引入不必要的重复数据&lt;/p&gt;

&lt;p&gt;重传超时&amp;gt;RTT：网络利用率(吞吐量)下降&lt;/p&gt;

&lt;p&gt;RTT是每个tcp连接独立计算的。&lt;/p&gt;

&lt;h3&gt;RTO估算方法：&lt;/h3&gt;

&lt;p&gt;经典方法：&lt;/p&gt;

&lt;p&gt;SRTT = a(SRTT) + (1-a)RTT，a一般为0.8~0.9，称为指数加权移动平均/低通过滤器（EWMA）&lt;/p&gt;

&lt;p&gt;RTO = min(ubound, max(lbound, (SRTT)b))，b为时延离散因子，推荐值1.3 ～ 2.0&lt;/p&gt;

&lt;p&gt;ubound：1分钟，lbound：1秒。&lt;/p&gt;

&lt;p&gt;适用于稳定RTT的网络。&lt;/p&gt;

&lt;p&gt;标准方法：&lt;/p&gt;

&lt;p&gt;srtt = (1-g)srtt + (g)M
rttvar = (1-h)rttvar + (h)(|M - srtt|)
RTO = srtt + 4(rttvar)&lt;/p&gt;

&lt;p&gt;M就是经典方法里的RTT；srtt和SRTT等价；|M - srtt|为平均偏差，所以rttvar为平均偏差的EWMA。&lt;/p&gt;

&lt;p&gt;g：新样本M占srtt估计值的权重，1/8&lt;/p&gt;

&lt;p&gt;h：新平均偏差样本|M-srtt|占rttvar的权重，1/4&lt;/p&gt;

&lt;p&gt;最终，RTO为srtt加上4倍rttvar，4是一个研究出来的常量值。&lt;/p&gt;

&lt;p&gt;当M变化时，|M-srtt|越大，rttvar也越大，RTO增长越快&lt;/p&gt;

&lt;p&gt;时钟粒度：&lt;/p&gt;

&lt;p&gt;Linux计时器时钟粒度为1ms，设为G。&lt;/p&gt;

&lt;p&gt;RTO = srtt + max(G，4(rttvar))&lt;/p&gt;

&lt;p&gt;Linux RTO默认RTO最小值200ms&lt;/p&gt;

&lt;p&gt;收到第一个RTT测量值时再次初始化：&lt;/p&gt;

&lt;p&gt;srtt = M&lt;/p&gt;

&lt;p&gt;rttvar = M/2&lt;/p&gt;

&lt;p&gt;RTO = srtt + 4(rttvar) = 3M &lt;/p&gt;

&lt;p&gt;重传二义性：&lt;/p&gt;

&lt;p&gt;发生重传时，若收到ACK，并不能知道是对第一次还是第二次发包的确认，所以无法计算RTT，需要跳过。(Karn算法第一部分)&lt;/p&gt;

&lt;p&gt;若用了时间戳选项则可以处理二义性，因为ACK包附带了发包的时间戳，就可以知道ACK是对第一次还是第二次发包的确认。&lt;/p&gt;

&lt;p&gt;退避系数(backoff factor)：每当重传计时器出现超时，退避系数加倍，&lt;strong&gt;直到接收到非重传数据时重设为1&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;基于定时器的重传：&lt;/h3&gt;

&lt;p&gt;需要记录被计时的报文段序列号，若及时收到该报文段的ACK，那么计时器被取消。&lt;/p&gt;

&lt;p&gt;没丢包的话计时器不会超时。&lt;/p&gt;

&lt;p&gt;若在设定的RTO内，没收到ACK，就会触发超时重传。&lt;/p&gt;

&lt;p&gt;此时需要降低发送速率：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;减小发送窗口大小&lt;/li&gt;
&lt;li&gt;重传大于1次时，增大RTO退避因子，RTO = γRTO，γ = 1 2 4 8 ··· 。但RTO不会TCP_RTO_MAX&lt;/li&gt;
&lt;li&gt;一旦收到ACK，γ重置为1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于定时器的重传不是好东西，会导致网络利用率下降。&lt;/p&gt;

&lt;h3&gt;快速重传&lt;/h3&gt;

&lt;p&gt;基于对端的反馈信息来引发重传。（和基于计时器的重传的本质区别）&lt;/p&gt;

&lt;p&gt;更加及时。&lt;/p&gt;

&lt;p&gt;tcp一般都实现了基于计时器的重传和快速重传。&lt;/p&gt;

&lt;p&gt;重点：接收端收到失序报文段时，需要&lt;strong&gt;立即&lt;/strong&gt;生成&lt;strong&gt;重复ACK&lt;/strong&gt;并&lt;strong&gt;立即发送&lt;/strong&gt;，失序情况表明出现了丢段（接收缓存出现空洞）。&lt;/p&gt;

&lt;p&gt;重复ACK：这个ACK可以表明是哪一个分组没有收到。但因为是用了tcp的seq段，所以一个RTT内只能填补一个空缺。&lt;/p&gt;

&lt;p&gt;立即发送重复ACK是为了让发送端尽早得知有失序报文段，并告知空缺在哪。&lt;/p&gt;

&lt;p&gt;当接收端收到&lt;strong&gt;当前期望序列号的后续分组&lt;/strong&gt;时，当前期望的包可能丢失了，也可能是延迟到达，2者无法区分。&lt;/p&gt;

&lt;p&gt;因此需要等待一定数目的重复ACK（重复ACK阈值 dupthresh，一般为3，也有动态的），才能判断数据是否丢失并快速重传。&lt;/p&gt;

&lt;p&gt;总之，发送端收到至少3个重复ACK后，马上重传&lt;strong&gt;可能丢失的分组&lt;/strong&gt;，而不必等计时器超时。&lt;/p&gt;

&lt;h3&gt;带选择确认的重传SACK&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://packetlife.net/blog/2010/jun/17/tcp-selective-acknowledgments-sack/&quot;&gt;http://packetlife.net/blog/2010/jun/17/tcp-selective-acknowledgments-sack/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SACK是指已接收的失序报文段，并不是指丢失的报文段。&lt;/p&gt;

&lt;p&gt;SACK会重复发，例如收到连续的2个报文段3和4，返回2个ACK，ACK都为1（duplicate ACK），但第一个包带了SACK=3，第二个包带了SACK=3、4。发送端收到这2个ACK时，就会知道报文段2丢失，那么重传2。&lt;/p&gt;

&lt;p&gt;一个tcp头的SACK最多3块。&lt;/p&gt;

&lt;p&gt;收到SACK并重传了包，也不能清空重传缓存的该包（食言问题）。只有接收端发来的普通tcp ACK号大于发送端最大序列号值才可清除。&lt;/p&gt;

&lt;p&gt;RTT较大，丢包严重时，SACK的优势就能体现出来。因为一个RTT可以填补多个空缺很重要。&lt;/p&gt;

&lt;h3&gt;伪超时与重传&lt;/h3&gt;

&lt;p&gt;GBN：连续发了n个报文段，如果网络突然缓慢，最前面的那个超时了，会触发重传，此时后面的n-1个包也没被确认，那么n个报文段都重传（回退）。&lt;/p&gt;

&lt;p&gt;伪重传：没有丢包也发生了重传，叫伪重传。原因：网络延迟、包失序、包重复、ACK丢失。&lt;/p&gt;

&lt;p&gt;RTT增加，超过当前RTO时，就有可能出现伪超时（重传）。&lt;/p&gt;

&lt;p&gt;重要任务：检测出伪重传，几种方法：D-SACK、F-RTO、Eifel检测&lt;/p&gt;

&lt;p&gt;D-SACK：重复SACK，一个操作系统的选项。&lt;/p&gt;

&lt;p&gt;开启后，可在第一个SACK块中告知接收端收到的重复报文段序列号。&lt;/p&gt;

&lt;p&gt;允许tcp一端开启D-SACK而另一端没有D-SACK，不需要对称，没有开启D-SACK的一端不能使用D-SACK。&lt;/p&gt;

&lt;p&gt;原理是，SACK接收端允许了包含seq&amp;lt;=累计ACK的SACK块。&lt;/p&gt;

&lt;p&gt;和通常的SACK的区别：DSACK只包含在单个ACK中，并且不会在多个SACK中重复。鲁棒性比SACK低。&lt;/p&gt;

&lt;p&gt;Eifel检测算法：发生超时重传时，Eifel算法等待接收下一个ACK，若为针对第一次传输（即原始传输）的ACK（用时间戳判断），则可以知道该重传是伪重传（利用TSOPT来检测伪重传）。&lt;/p&gt;

&lt;p&gt;Forward RTO-recovery（路由转发延迟导致的RTO的恢复机制，简称F-RTO）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检测伪重传的标准算法&lt;/li&gt;
&lt;li&gt;不需要任何tcp选项&lt;/li&gt;
&lt;li&gt;是发送端自己的算法&lt;/li&gt;
&lt;li&gt;接收端不支持时间戳选项，也能工作&lt;/li&gt;
&lt;li&gt;只检测由重传计时器超时引发的伪重传，别的无法判断&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F-RTO会修改TCP的行为&lt;/strong&gt;。其实就是GBN的问题。在超时重传后收到第一个ACK时，改成发送新数据。等到下一个ACK到达时，如果2个ACK中至少有一个是&lt;strong&gt;重复ACK&lt;/strong&gt;，则认为此次重传没问题（确实发生了丢包，重复ACK指出了丢失的报文段）。如果2个都不是重复ACK，那么就是伪重传。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用上面的任意检测算法检测到伪重传后，要应用Eifel响应算法：&lt;/p&gt;

&lt;p&gt;说白了就是更新srtt和rttvar。因为伪超时导致临时修改了srtt和rttvar（RTO变了），检测发现伪超时，那就得恢复到正常的srtt、rttvar。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;计时器超时时，记录srtt_prev = srtt+2(G)、rttvar_prev = rttvar。但直到发现有伪超时前，都不会使用它们。&lt;/li&gt;
&lt;li&gt;执行某种伪超时检测。&lt;/li&gt;
&lt;li&gt;检测到伪超时，设置&lt;strong&gt;伪恢复&lt;/strong&gt;为SPUR_TO（spurious timeout)&lt;/li&gt;
&lt;li&gt;若伪恢复为SPUR_TO，把下一个要发送的报文段的序列号改为最新的未发送过的报文段。就可以避免GBN。&lt;/li&gt;
&lt;li&gt;更新srtt、rttvar、RTO：srtt = max(srtt_prev，m)，rttvar = max(rttvar_prev, m/2)，RTO = srtt + max(G, 4(rttvar))。为了抛弃RTT历史值。另外，RTO更新方式不变。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;包失序与包重复&lt;/h3&gt;

&lt;p&gt;包的问题有三种：丢失、失序、重复。tcp需要区分。&lt;/p&gt;

&lt;p&gt;失序：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果发生在反向链路（ACK），发送端收到的ACK是乱序，那么可能先收到后面的ACK，导致发送窗口快速前移（并且后面收到的ACK被丢弃）。快速前移会导致&lt;strong&gt;流量突发&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;发生在正向链路，tcp可能无法正确识别失序or丢包。失序程度不大时，可以迅速得到处理；反之，tcp可能会误认为数据丢失，也就导致伪重传（主要是指快速重传）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;区分丢失和失序不是重要问题；互联网中严重的失序并不常见，dupthresh设3就足够了。&lt;/p&gt;

&lt;p&gt;重复：&lt;/p&gt;

&lt;p&gt;链路层重传时会生成重复副本。会导致接收端生成一系列重复的ACK，触发伪快速重传。&lt;/p&gt;

&lt;p&gt;但DSACK能处理这种情况，因为重复ACK没有包含失序信息，意味着ACK是重复数据。&lt;/p&gt;

&lt;h3&gt;目的度量&lt;/h3&gt;

&lt;p&gt;即操作系统在tcp断开连接后依然缓存了该条路径的rtt之类的信息。方便下次和该地址建立连接时，初始化srtt rttvar。&lt;/p&gt;

&lt;h3&gt;重新组包&lt;/h3&gt;

&lt;p&gt;当发生重传，并不需要完全重传相同的报文段，而可以重新组包，发送一个更大的报文段来提高性能。&lt;/p&gt;

&lt;h3&gt;重传相关的攻击&lt;/h3&gt;

&lt;p&gt;低速率DoS攻击：&lt;/p&gt;

&lt;p&gt;每次受害tcp重传时，就发一堆数据给它并导致重传超时，进而导致对方减小发送速率、退避发送，最终导致无法正常使用网络带宽。&lt;/p&gt;

&lt;p&gt;预防方法是，随机随选RTO，使得攻击者无法预知确切的重传时间。&lt;/p&gt;

&lt;p&gt;减慢受害tcp的发送并使RTT估计值过大（过分被动）：&lt;/p&gt;

&lt;p&gt;导致丢包后不会立即重传。&lt;/p&gt;

&lt;p&gt;伪造ACK使受害tcp的RTT估计值过小（过分积极）：&lt;/p&gt;

&lt;p&gt;导致过分发送，造成大量的无效传输。&lt;/p&gt;

&lt;h2&gt;15章 TCP数据流和窗口管理&lt;/h2&gt;

&lt;h3&gt;Nagle算法：&lt;/h3&gt;

&lt;p&gt;算法要求：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当一个tcp连接中有在传数据（已发送但未确认），小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK。&lt;/li&gt;
&lt;li&gt;并且，在收到ACK后，tcp需要收集这些小数据，将其整合到一个报文段中发送。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;迫使tcp遵循停等规程（stop-and-wait）。发一个包就得等到收到ACK后再发下一个包，发包间隔等于RTT。&lt;/li&gt;
&lt;li&gt;因此每一时刻最多只有一个包在传&lt;/li&gt;
&lt;li&gt;因此减少了小包数，同时也增大了延迟。&lt;/li&gt;
&lt;li&gt;实现了自时钟控制（self-clocking）。ACK返回越快，数据传输也越快。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在高延迟网络中，需要减少🛰报文数。算法使得单位时间内发送的报文段数目更少。&lt;/p&gt;

&lt;h3&gt;延时ACK和Nagle算法结合：&lt;/h3&gt;

&lt;p&gt;简单来说就是会死锁：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务端（Nagle）发一个包后开始等待ACK&lt;/li&gt;
&lt;li&gt;客户端（延时ACK）收包后不马上发送ACK而是等待一段时间再发&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为客户端最终会发出ACK，所以死锁可解。但等待过程中，连接处于空闲状态（明明有事忙），性能变差。&lt;/p&gt;

&lt;p&gt;禁用Nagle：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对socket设置TCP_NODELAY&lt;/li&gt;
&lt;li&gt;整个系统设置nodelay&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;流量控制和窗口管理&lt;/h3&gt;

&lt;p&gt;发送窗口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;字节为单位&lt;/li&gt;
&lt;li&gt;SND.UNA，发送窗口左边界&lt;/li&gt;
&lt;li&gt;SND.WND，发送窗口大小&lt;/li&gt;
&lt;li&gt;SND.UNA + SND.WND，发送窗口右边界&lt;/li&gt;
&lt;li&gt;SND.NXT，下个要发送的数据序列号&lt;/li&gt;
&lt;li&gt;SND.UNA + SND.WND - SND.NXT，可用发送窗口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;窗口运动术语：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;close：左边界右移（窗口缩小）。发生在已发送数据得到ACK确认。&lt;/li&gt;
&lt;li&gt;open：右边界右移（窗口变大）。可发送数据量变大。同样发生在已发送数据得到ACK确认。&lt;/li&gt;
&lt;li&gt;shrink：收缩，右边界左移。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note：左边界不可能左移。&lt;/p&gt;

&lt;p&gt;接收窗口：类似发送窗口。但窗口中间因为SACK选项，可能会有被ACK的序列号（未确认的就是空洞）。但必须RCV.NXT接收了，窗口才能右移。&lt;/p&gt;

&lt;p&gt;零窗口导致的问题：&lt;/p&gt;

&lt;p&gt;左右边界相等时，叫零窗口。此时发送端不能发数据。&lt;/p&gt;

&lt;p&gt;接收端重新获得可用空间时，会给发送端发送一个窗口更新（window update），当然还是用通告窗口。但这个发包不带数据（因为这是接收端，若发了数据就变成全双工的发送端了），所以是一个典型的ACK消息。这个ACK是可能丢失的。&lt;/p&gt;

&lt;p&gt;如果丢失了，就会进入死锁状态。发送端不知道接收端已经可以接收数据。&lt;/p&gt;

&lt;p&gt;所以发送端会定时探测probe对方窗口，用来伺机增大发送窗口，接收端收到时必须返回ACK（包含了窗口大小字段）。&lt;/p&gt;

&lt;p&gt;探测时机为一个RTO超时后，然后指数间隔发送。&lt;/p&gt;

&lt;p&gt;probe是带有一个字节的数据的（用户的数据），所以tcp会可靠传输它。不过如果接收端依然没有可用缓存空间，就会丢掉这个包。&lt;/p&gt;

&lt;h4&gt;糊涂窗口综合征(silly window syndrome，SWS)：&lt;/h4&gt;

&lt;p&gt;百度百科解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;糊涂窗口综合症是指当发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会使应用进程间传送的报文段很小，特别是有效载荷很小； 极端情况下，有效载荷可能只有1个字节；传输开销有40字节(20字节的IP头+20字节的TCP头) 这种现象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;接收端通告窗口较小&lt;/li&gt;
&lt;li&gt;发送端发送的数据段较小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接收端：不应通告小的窗口值&lt;/li&gt;
&lt;li&gt;发送端：不应发送小的报文段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发送端需满足以下条件才能发送：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全长（MSS）的报文段&lt;/li&gt;
&lt;li&gt;数据段长度&amp;gt;=接收端通告过的&lt;strong&gt;最大窗口值&lt;/strong&gt;的一半。（要记录一个最大值，发送端才可猜测接收缓存大小）&lt;/li&gt;
&lt;li&gt;ACK不是目前期望的（或者说没有未经确认的数据，那么发送端立即发送新数据是合理的） 或 禁用了Nagle算法 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三点反过来说就是：如果启用了Nagle或者有未确认的在传数据，那么不应该发送小包&lt;/p&gt;

&lt;h4&gt;大容量缓存与自动调优&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;在相似环境下，使用较小接收缓存的tcp吞吐量会较差&lt;/li&gt;
&lt;li&gt;即使接收端指定了大容量缓存，但发送端指定了小缓存，性能还是差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这2个问题很关键，并且因为第二个问题，很多tcp协议栈中应用层是不能指定缓存大小的。操作系统会自己定一个定值或弄成动态值。&lt;/p&gt;

&lt;p&gt;窗口大小的自动调优：只能按类型选，没有具体值，disabled、 highlyrestricted、 reStricted、 normal、experimental。&lt;/p&gt;

&lt;p&gt;缓存大小的动态调整：通过估算发送方的拥塞窗口的大小，来动态设置TCP接收缓存的大小。&lt;/p&gt;

&lt;h3&gt;紧急机制&lt;/h3&gt;

&lt;p&gt;虽然tcp的紧急机制调用用了一个叫MSG_OOB的flag，但是其实并不是带外数据，这个紧急数据一样是在用户的数据流中传输，只是优先级更高。&lt;/p&gt;

&lt;p&gt;发送的紧急数据只能是一个字节，并放进当前缓冲区末尾。因为用了tcp的可靠传输，所以只需要插入一次。&lt;/p&gt;

&lt;p&gt;因为窗口大小原因，可能不能立即发出这个字节，但是tcp会知道已经进入紧急状态，所有发出去的包都打开了URG标志。&lt;/p&gt;

&lt;p&gt;对接收端来说，收到URG的包头，不等于该报文段里就有紧急数据（还在收到）。要用紧急指针来判断。在收到紧急数据前可能有多个包头，包头里的紧急指针都一样。&lt;/p&gt;

&lt;p&gt;为了让用户及时recv拿到紧急数据，需要用信号SIGURG的方式通知。SIGURG在第一次收到URG包头时触发一次。&lt;/p&gt;

&lt;p&gt;带外数据缓冲区：到达的紧急数据不能混在用户数据缓冲区，所以另外用这个来存，等用户来读取。&lt;/p&gt;

&lt;p&gt;send(sockfd, &amp;#39;x&amp;#39;, 1, MSG_OOB);&lt;/p&gt;

&lt;p&gt;recv(sockfd, &amp;amp;ch, 1, MSG_OOB);&lt;/p&gt;

&lt;p&gt;recv：在紧急状态下，带外数据仍未到达，函数返回EWOULDFBLOCK；非紧急状态下，调用上述函数，返回EINVAL。&lt;/p&gt;

&lt;h2&gt;TCP拥塞控制&lt;/h2&gt;

&lt;p&gt;回顾：流量控制机制是基于通告窗口大小字段来实现，明确地告诉了发送端，接收端的缓存大小，避免了接收端缓存溢出。发送端降低了发送速率。&lt;/p&gt;

&lt;p&gt;对路由器而言：超负荷时，降低发送速率或丢弃部分数据。原因是，即使路由器能缓存一部分数据，然后慢慢发出去，但源源不断的数据到达，到达速率高于发出速率，任何容量都得溢出。（排队理论！）&lt;/p&gt;

&lt;p&gt;拥塞：路由器无法处理高速率到达的流量而被迫丢弃数据信息的现象&lt;/p&gt;

&lt;p&gt;拥塞控制机制：是为了缓解拥塞情况，tcp连接两端都要进行&lt;/p&gt;

&lt;h3&gt;tcp拥塞检测：&lt;/h3&gt;

&lt;p&gt;回顾：对于丢包，tcp采取首要机制是重传：超时重传和快速重传。&lt;/p&gt;

&lt;p&gt;但当网络拥塞时，重传会导致火上浇油。所以要避免这个情况。&lt;/p&gt;

&lt;p&gt;当拥塞情况出现时的处理措施：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;减缓发送速率&lt;/li&gt;
&lt;li&gt;拥塞情况好转时，检测和使用新的可用带宽&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而很难做到：因为对于tcp发送方而言，没有一个准确的方法去知晓路由器的状态。&lt;/p&gt;

&lt;p&gt;只能用一些信息来推断：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;出现丢包&lt;/li&gt;
&lt;li&gt;时延测量&lt;/li&gt;
&lt;li&gt;显式拥塞通知（ECN）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检测出拥塞后，就是对拥塞的处理。其实就是when减速和how减速、how恢复速率。&lt;/p&gt;

&lt;h3&gt;减缓TcP发送&lt;/h3&gt;

&lt;p&gt;拥塞窗口：反映网络传输能力的变量，cwnd&lt;/p&gt;

&lt;p&gt;接收端通知窗口：awnd&lt;/p&gt;

&lt;p&gt;发送端实际可用窗口：W = min(cwnd, awnd)&lt;/p&gt;

&lt;p&gt;在外数据大小（flight size）：发送端发送的数据中，未收到ACK的数据不能多于W（字节）。&lt;/p&gt;

&lt;p&gt;cwnd无法拿到准确值：缺乏显示拥塞的信号&lt;/p&gt;

&lt;p&gt;W、cwnd、awnd需要根据经验设定并动态调节。&lt;/p&gt;

&lt;p&gt;所以，W的值不能过大或过小，应接近BDP（bandwidth-delay prodcut），带宽延迟积，也称作最佳窗口大小（optimal window size）。&lt;/p&gt;

&lt;p&gt;W反映网络中可存储的待发送数据量大小。&lt;/p&gt;

&lt;p&gt;实际计算方法：W = RTT * 链路中最小通行速率&lt;/p&gt;

&lt;p&gt;W越接近BDP，网络资源利用得越高效。&lt;/p&gt;

&lt;p&gt;确定BDP是难点。&lt;/p&gt;

&lt;h3&gt;经典方法&lt;/h3&gt;

&lt;p&gt;同时只运行一个，可以互相切换。&lt;/p&gt;

&lt;p&gt;基于包守恒。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;建立tcp时执行慢启动&lt;/li&gt;
&lt;li&gt;直至有丢包时，执行拥塞避免算法&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;慢启动&lt;/h4&gt;

&lt;p&gt;原因：由于未知网络传输能力，需要缓慢探测可用传输资源，防止短时间内大量数据注入导致拥塞。&lt;/p&gt;

&lt;p&gt;作用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使TCP在用拥塞避免探寻更多可用带宽之前得到cwnd值&lt;/li&gt;
&lt;li&gt;帮助tcp建立ack时钟&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;时机：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新连接&lt;/li&gt;
&lt;li&gt;检测到RTO导致的丢包时&lt;/li&gt;
&lt;li&gt;长时间处于空闲状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原理：&lt;/p&gt;

&lt;p&gt;SMSS: 发送方的最大段大小 = min（接收方MSS，路径MTU）&lt;/p&gt;

&lt;p&gt;IW：初始窗口，一开始发送的数据段大小（SYN交换后）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IW = 2 * SMSS，if SMSS &amp;gt; 2190&lt;/li&gt;
&lt;li&gt;IW = 3 * SMSS，if 2190 &amp;gt;= SMS &amp;gt; 1095&lt;/li&gt;
&lt;li&gt;IW = 4 * SMSS，else&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;初始cwnd = IW = 1 * SMSS（简单起见，设1）&lt;/p&gt;

&lt;p&gt;每次收到ACK，cwnd会慢慢增加：cwnd += min(N, SMSS)&lt;/p&gt;

&lt;p&gt;N：未ACK的数据，通过这一”好的ACK“能确认的数据大小&lt;/p&gt;

&lt;p&gt;好的ACK：新收到ACK大于之前收到的ACK&lt;/p&gt;

&lt;p&gt;这样设计是因为：如果每次收到ACK都直接+=SMSS，可能会遭到“ACK分裂”攻击，通过发送小ACK导致发送方加速发送。&lt;/p&gt;

&lt;p&gt;如果N大于SMSS，说明正在发送大量数据，那么就只+=SMSS，cwnd = 2 * SMSS.&lt;/p&gt;

&lt;p&gt;此时就可以发送2个数据段，如果继续接收ACK成功（2个ACK），则2变4、4变8，指数增加。&lt;/p&gt;

&lt;p&gt;k：k轮后，W = 2&lt;sup&gt;k，k&lt;/sup&gt; = log2(W)，需要k个RTT时间，窗口才能达到W。&lt;/p&gt;

&lt;p&gt;指数增长看似快，但还是比一开始就以最大速率（接收方最大窗口）慢（W不会超过awnd）。&lt;/p&gt;

&lt;p&gt;另外，如果接收端开启了ACK时延，接收端就不会发2个ACK，而是合并1个，那么增速变得更慢。&lt;/p&gt;

&lt;p&gt;非交互式tcp流：其实就是指单方发送大数据的情况，不是短消息的一问一答（http）。&lt;/p&gt;

&lt;p&gt;对于非交互式tcp流来说，delayed ACK是不好的，此时接收端是不会发数据的，所以没可能在数据包里带上ACK。此时可以使用Quick ACK机制。&lt;/p&gt;

&lt;p&gt;通过QuickACK，接收端recv后可以立即发送ACK，没有delay。&lt;/p&gt;

&lt;p&gt;但tcp本身很难知道是不是非交互式的流。可以这样做：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新tcp连接开启quick ACK，直到检测到该tcp有交互式特征时关闭。（Linux默认如此）&lt;/li&gt;
&lt;li&gt;新tcp连接关闭quick ACK，当连接不是交互式时，开启。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jauu.net/2010/10/02/tcp-quick-ack-versus-packet-overhead/&quot;&gt;http://www.jauu.net/2010/10/02/tcp-quick-ack-versus-packet-overhead/&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;拥塞避免&lt;/h4&gt;

&lt;p&gt;当指数增长到一定程度，就会开始丢包。&lt;/p&gt;

&lt;p&gt;此时设置一个慢启动阈值（ssthresh），公式下面说；当前拥塞窗口大小（cwnd）减到一半（不一定，只是经典做法）。&lt;/p&gt;

&lt;p&gt;只留一半是避免占满全部带宽，导致路由器其他连接丢包。&lt;/p&gt;

&lt;p&gt;拥塞避免：&lt;/p&gt;

&lt;p&gt;当确立了慢启动阈值，tcp就进入拥塞避免阶段。cwnd不再翻倍，而是线性增大。这就可以得到更多的传输资源而不至于影响其他连接。&lt;/p&gt;

&lt;p&gt;\( cwnd_{t+1} = cwnd_t  + SMSS * SMSS/cwnd_t \)&lt;/p&gt;

&lt;p&gt;其实就是每次收到ACK就增加（1/k）倍 (次线性)&lt;/p&gt;

&lt;h4&gt;慢启动和拥塞避免的选择&lt;/h4&gt;

&lt;p&gt;慢启动和拥塞避免之间的区别：当新的ACK到达时，cwnd怎样增长。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当cwnd &amp;lt; ssthresh：慢启动&lt;/li&gt;
&lt;li&gt;当cwnd &amp;gt; ssthresh：拥塞避免&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ssthresh在整个连接中不是保持不变的。没有丢包时，记住上一次最好的窗口估计值。有丢包时，按下面公式更新：&lt;/p&gt;

&lt;p&gt;ssthresh=max (cwnd/2, 2*SMSS)&lt;/p&gt;

&lt;h4&gt;Tahoe、 Reno以及快速恢复算法&lt;/h4&gt;

&lt;p&gt;Tahoe：有丢包时，cwnd直接变1，重新慢启动。会导致带宽利用率低下。&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;超时丢包：cwnd = 1&lt;/li&gt;
&lt;li&gt;重复ACK引起的丢包：cwnd = 上一个ssthresh（快速重传就会有这种丢包）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reno快速恢复：&lt;/p&gt;

&lt;p&gt;因为丢包进入的慢启动阶段，可以快速恢复，方法是每接收到一个ACK（重复ACK），cwnd就增长1 SMSS（急速），直到接收到一个”好的ACK“。&lt;/p&gt;

&lt;h3&gt;标准TCP&lt;/h3&gt;

&lt;p&gt;可以小结出一套标准算法：&lt;/p&gt;

&lt;p&gt;在TCP连接建立之初首先是慢启动阶段(cwnd = IW), ssthresh通常取一较大值(至少为awnd)。当接收到一个好的ACK (表明新的数据传输成功),
cwnd会相应更新。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cwnd += SMSS (若cwnd&amp;lt;ssthresh)慢启动&lt;/li&gt;
&lt;li&gt;cwnd += SMSS*SMSS/cwnd (若cwnd&amp;gt;ssthresh)拥塞避免&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当收到三次重复ACK (或其他表明需要快速重传的信号)肘，会执行以下行为：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ssthresh更新为大于等式 ssthresh = max(在外数据值/2, 2*SMSS) 中的值&lt;/li&gt;
&lt;li&gt;启用快速重传算法，将cwnd设为(ssthresh + 3*SMSS)&lt;/li&gt;
&lt;li&gt;每接收一个重复ACK, CWnd值暂时增加1 SMSS&lt;/li&gt;
&lt;li&gt;当接收到一个好的ACK，将cwnd重设为ssthresh（收缩）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上第2步和第3步构成了快速恢复。&lt;/p&gt;

&lt;h3&gt;对标准算法的改进&lt;/h3&gt;

&lt;p&gt;NewReno：&lt;/p&gt;

&lt;p&gt;因为Reno需要收到重复ACK才能快速恢复，但如果先收到了好的ACK（局部ACK）（但还有别的包已发送未确认），导致了窗口膨胀过早结束，此时传输通道就会很空闲。且如果重复ACK不足三个（网络中没有足够的数据表在传输就会这样)，不会进入快速重传，而确实又有丢包，那么最终就是RTO超时，进行超时重传，并慢启动。&lt;/p&gt;

&lt;p&gt;Reno记录了一个最高序列号来解决。效果就是避免过早结束膨胀。&lt;/p&gt;

&lt;p&gt;（其他改进之后再学习）&lt;/p&gt;

&lt;h3&gt;共享拥塞状态信息&lt;/h3&gt;

&lt;p&gt;其实就是操作系统的本地优化。新连接可以利用旧连接的信息，来优化。&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_no_metrics_save = 0，默认开启&lt;/p&gt;

&lt;p&gt;每个tcp关闭前，保存信息：srtt、rttvar、重排估计值、cwnd、ssthresh&lt;/p&gt;

&lt;h3&gt;TCP友好性&lt;/h3&gt;

&lt;p&gt;就是多条tcp连接对资源的竞争问题。有一条很复杂的公式。篇幅很短，应该不是重点。&lt;/p&gt;

&lt;h3&gt;高速环境下的TCP&lt;/h3&gt;

&lt;h3&gt;基于延迟的拥塞控制算法&lt;/h3&gt;

&lt;h3&gt;缓冲区膨胀&lt;/h3&gt;

&lt;p&gt;网络中的路由设备，其缓冲区的大小不是越大越好，过大的缓冲区反而会导致网络拥塞。&lt;/p&gt;

&lt;p&gt;缓冲区过小：&lt;/p&gt;

&lt;p&gt;很容易就被写满，丢包率变高，导致传输效率差&lt;/p&gt;

&lt;p&gt;缓冲区过大： &lt;/p&gt;

&lt;p&gt;如果路由器接收速率大于发送速率，就会有大量数据在路由器排队，延迟很大，此时还不算是丢包。丢包要等到发送端超时才算，然后又往路由器塞入了重复报文段。&lt;/p&gt;

&lt;p&gt;拥塞信号反馈过慢。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zerooffdate/article/details/77688460&quot;&gt;https://blog.csdn.net/zerooffdate/article/details/77688460&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;积极队列管理和ECN：&lt;/p&gt;

&lt;p&gt;一般，路由器没有义务把拥塞信息发给tcp发送端。就不利于拥塞控制。&lt;/p&gt;

&lt;p&gt;路由器默认只有FIFO和尾部丢弃机制，先到的包会发出去，后到的包如果塞不下了，就丢弃。&lt;/p&gt;

&lt;p&gt;应用FIFO和尾部丢弃以外的调度算法和缓存管理策略被认为是积极的。&lt;/p&gt;

&lt;p&gt;AQM：积极队列管理&lt;/p&gt;

&lt;p&gt;ECN：非常依赖路由器、交换机的拥塞通知机制。&lt;/p&gt;

&lt;p&gt;路由器会给发送中的报文打上ECN标识，报文送到接收端后，接收端再通过ACK包告诉发送端ECN。发送端就可以降低发送速率。&lt;/p&gt;

&lt;h3&gt;与TCP拥塞控制相关的攻击&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;ACK分裂攻击：拆分ACK，从而让发送端的cwnd加速增长。解决办法：前面说到了。&lt;/li&gt;
&lt;li&gt;重复ACK攻击：就是本来没重复ACK，强行发重复的，也是导致发送端在快速恢复阶段增长得更快。解决办法：限制发送端在恢复阶段的在外数据值&lt;/li&gt;
&lt;li&gt;乐观响应攻击：对还没有收到的报文段产生ACK。导致发送端计算出来的RTT变小，发送端就会比正常情况下发得更快。解决办法：发送报文大小加一点随机，使得接收端难以猜出。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;TCP保括机制&lt;/h2&gt;

&lt;p&gt;这一章很短，不是很重点。&lt;/p&gt;

&lt;p&gt;keepalive是一种不怎么纳入标准的技术。因为keepalive是有问题的：对于一个长连接，如果发送保活探测的时候，刚好这段时间中间网络出了点问题（例如路由器重启），就会导致好的连接被中断掉。&lt;/p&gt;

&lt;p&gt;保活功能是为服务器提供的。服务器需要知道客户端是否崩溃或离开，才能释放连接资源。&lt;/p&gt;

&lt;p&gt;一般，长时间交互式服务就不期望保活功能（ssh）；短时间非交互式服务就期望保活功能（Web服务器）。&lt;/p&gt;

&lt;p&gt;默认关闭。&lt;/p&gt;

&lt;p&gt;非对称，两端都可以各自做keepalive。&lt;/p&gt;

&lt;p&gt;组成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;keepalive time：保活时间，即发送保活探测的计时器的timeout时间。一般为无数据传输后2小时。&lt;/li&gt;
&lt;li&gt;keepalive interval：第一个探测发送后，如果没收到回包，就需要紧跟着再次发送探测。一般为75秒。&lt;/li&gt;
&lt;li&gt;keepalive probe：探测多少次后才认为对端不可达，中断连接。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;探测报文：&lt;/p&gt;

&lt;p&gt;一个空报文段或带一个字节（垃圾数据）的报文段。序列号等于对端发送的ACK最大序列号减1，因为这个序列号已经被成功接收，所以不会对对端造成影响。&lt;/p&gt;

&lt;p&gt;探测报文返回的响应可以确定连接是否在工作。&lt;/p&gt;

&lt;p&gt;响应报文也是不带数据或者只带垃圾数据。&lt;/p&gt;

&lt;p&gt;2种报文丢失了都不会重传。（所以需要重复探测）&lt;/p&gt;

&lt;p&gt;探测前后，对端可能的四种状态：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对端正常工作，正常响应了探测。探测定时器重置。&lt;/li&gt;
&lt;li&gt;对端已崩溃或重启中，此时不会响应探测。探测端会一直探测直到超过探测次数，就认为对端已经关闭，断开这个连接。&lt;/li&gt;
&lt;li&gt;对端已崩溃但已重启，会发送RST重置报文段作为响应。探测端会断开连接。&lt;/li&gt;
&lt;li&gt;对端正常工作，但因其他原因探测报文不能到达。4和2相同，因为tcp无法区分开。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note：对端正常关闭然后重启，是没问题的。对端会发送FIN，正常断开连接。&lt;/p&gt;

&lt;p&gt;欺骗攻击：因为保活报文不包含用户数据，加密强度有限。容易伪造。导致连接一直保持，浪费服务端资源。&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/tcpip-1/</link>
        <guid isPermaLink="true">http://localhost:4000/tcpip-1/</guid>
      </item>
    
      <item>
        <title>碰撞检测算法(二)：原始GJK详解</title>
        <description>&lt;p&gt;GJK，全称&lt;a href=&quot;https://en.wikipedia.org/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm&quot;&gt;Gilbert–Johnson–Keerthi distance algorithm&lt;/a&gt;，是非常常用的碰撞检测算法。&lt;/p&gt;

&lt;p&gt;原始GJK的功能：准确地告诉调用者2个几何体&lt;strong&gt;是否&lt;/strong&gt;碰撞。&lt;/p&gt;

&lt;p&gt;GJK的主要特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只适用于凸体&lt;/li&gt;
&lt;li&gt;GJK算法与维度无关，2D、3D都可以用&lt;/li&gt;
&lt;li&gt;不要求对顶点数组做排序&lt;/li&gt;
&lt;li&gt;存在一些技巧可以大大优化GJK的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文将详解原始GJK的来龙去脉。&lt;/p&gt;

&lt;h3&gt;目录：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;数学知识点&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1.1&quot;&gt;闵可夫斯基数学 Minkowski Math&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1.2&quot;&gt;单纯形 Simplex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1.3&quot;&gt;向量混合积 Vector Triple Product&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;GJK算法原理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#2.1&quot;&gt;GJK伪代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2.2&quot;&gt;Support函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2.3&quot;&gt;NearestSimplex函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3&quot;&gt;二维平面的GJK算法实现&lt;/a&gt; 

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#3.1&quot;&gt;b2Distance核心逻辑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3.2&quot;&gt;b2Simplex::GetSearchDirection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3.3&quot;&gt;b2Simplex::Solve2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3.4&quot;&gt;b2Simplex::Solve3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3.5&quot;&gt;b2DistanceProxy::GetSupport&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4&quot;&gt;其他细节&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5&quot;&gt;参考资料&lt;/a&gt; 

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#5.1&quot;&gt;GJK各种实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h1&gt;&lt;div id=&quot;1&quot;&gt;数学知识点&lt;/div&gt;&lt;/h1&gt;

&lt;p&gt;原始GJK包含的知识点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;闵可夫斯基和 Minkowski sum&lt;/li&gt;
&lt;li&gt;向量混合积 vector triple product&lt;/li&gt;
&lt;li&gt;2D叉积公式&lt;/li&gt;
&lt;li&gt;质心坐标公式&lt;/li&gt;
&lt;li&gt;k阶单纯形 k-Simplex&lt;/li&gt;
&lt;li&gt;supporting point和Support函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中有几个点放到后面的算法实现一节再介绍。&lt;/p&gt;

&lt;h2&gt;&lt;div id=&quot;1.1&quot;&gt;闵可夫斯基数学 Minkowski Math&lt;/div&gt;&lt;/h2&gt;

&lt;h3&gt;Minkowski扩大运算  &lt;a href=&quot;https://en.wikipedia.org/wiki/Minkowski_addition&quot;&gt;Minkowski Sum&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;\[ A \oplus B = \bigcup _{b \in B} A^{b}  \]&lt;/p&gt;

&lt;p&gt;其中，\(A^{b} = \{ a + b | a \in A\}  = A + b \)，代表集合A整体移动b&lt;/p&gt;

&lt;p&gt;（可以理解为几何形状的Union并集运算）&lt;/p&gt;

&lt;h3&gt;Minkowski收缩运算&lt;/h3&gt;

&lt;p&gt;\[ A \ominus B = \bigcap _{b \in B} A^{-b}  \]&lt;/p&gt;

&lt;p&gt;其中，\(A^{-b} = \{ a - b | a \in A\}  = A - b \)，代表集合A整体移动-b&lt;/p&gt;

&lt;p&gt;（可以理解为几何形状的Intersect交集运算）&lt;/p&gt;

&lt;h3&gt;Minkowski减法运算（Minkowski差)&lt;/h3&gt;

&lt;p&gt;\[ A - B =  A \oplus (-B)  \]&lt;/p&gt;

&lt;p&gt;这条公式才是真正应用到GJK算法里的公式。&lt;/p&gt;

&lt;p&gt;可以理解为B先做了一次镜像，然后再和A做并集运算。&lt;/p&gt;

&lt;p&gt;所以，说到GJK的Minkowski运算时，可以叫Minkowski和，也可以叫Minkowski差。anyway。&lt;/p&gt;

&lt;h2&gt;向量混合积 Vector Triple Product&lt;/h2&gt;

&lt;p&gt;曾经，我在我的&lt;a href=&quot;http://127.0.0.1:4000/triangle-intersect/&quot;&gt;用线性代数知识解决光线和三角形的交点问题&lt;/a&gt;一文中提到了一个数学公式，叫&lt;strong&gt;标量混合积(Scalar Triple Product)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而在GJK中，需要用到相似的另一个东西——&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Triple_product&quot;&gt;向量混合积(Vector Triple Product)&lt;/a&gt;&lt;/strong&gt;, 同时也被称为&lt;strong&gt;BAC-CAB特性&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;\[ A\times (B\times C) = B(A\cdot C) - C(A\cdot B) \]&lt;/p&gt;

&lt;p&gt;\[ (A\times B)\times C = -C\times (A\times B) \]&lt;/p&gt;

&lt;p&gt;\[ (A\times B)\times C = B(A\cdot C) - A(B\cdot C)  \]&lt;/p&gt;

&lt;p&gt;Proof: &lt;a href=&quot;https://en.wikipedia.org/wiki/Triple_product#Proof&quot;&gt;https://en.wikipedia.org/wiki/Triple_product#Proof&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GJK使用的第三条公式。&lt;/p&gt;

&lt;h2&gt;&lt;div id=&quot;1.2&quot;&gt;单纯形 &lt;a href=&quot;https://en.wikipedia.org/wiki/Simplex&quot;&gt;Simplex&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;

&lt;p&gt;按照wiki的解释，k阶单纯形，指的是k维空间中的多胞形，且多胞形是k+1个顶点组成的凸包。根据这个定义出发，就可以理解GJK算法中会提到的各种Simplex是什么东西：&lt;/p&gt;

&lt;h3&gt;0阶单纯形 0-Simplex&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;根据前面的定义，0阶单纯形是0维空间下的0+1=1个顶点组成的凸包，显然只能是一个点。&lt;/p&gt;

&lt;h3&gt;1阶单纯形 1-Simplex&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;1阶单纯形，1维空间，1+1=2个顶点，所以就是一条直线（1维空间）上的一个线段。&lt;/p&gt;

&lt;h3&gt;2阶单纯形 2-Simplex&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;2阶单纯形，2维空间，2+1=3个顶点，所以就是一个平面（2维空间）上的一个三角形，三角形我们就熟悉了，显然是一个凸包无误。&lt;/p&gt;

&lt;h3&gt;3阶单纯形 3-Simplex&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/6.png&quot; alt=&quot;6.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;3阶单纯形，3维空间，3+1=4个顶点，所以就是3维立体空间里的一个四面体(tetrahedron)，显然也是一个凸包。&lt;/p&gt;

&lt;h3&gt;k&amp;gt;3阶单纯形&lt;/h3&gt;

&lt;p&gt;我想读者做的都是2D或3D的项目，2D项目最多用到2-Simplex，3D项目最多用到3-Simplex。k&amp;gt;3的Simplex，忽略吧。&lt;/p&gt;

&lt;h1&gt;&lt;div id=&quot;2&quot;&gt;GJK算法原理&lt;/div&gt;&lt;/h1&gt;

&lt;p&gt;GJK算法，本质就是利用Minkowski差来判断2个几何体有没碰撞。&lt;/p&gt;

&lt;p&gt;因为如果碰撞了，那么2个几何体至少包含了同一个点，也就意味着它们的Minkowski差必然包含原点。&lt;/p&gt;

&lt;p&gt;明白这一点后，GJK其实就已经学到大半了。&lt;/p&gt;

&lt;h2&gt;&lt;div id=&quot;2.1&quot;&gt;划重点：来自wiki的GJK伪代码&lt;/div&gt;&lt;/h2&gt;

&lt;p&gt;经过查阅大量资料，发现还是wiki对GJK的解释一语中的，所以下面介绍下wiki给出的GJK伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;GJK_intersection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shape&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;shape&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;vector&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;vector&lt;/span&gt;  &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;simplex&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;reject&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;contains_origin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NearestSimplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;contains_origin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;accept&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这份代码准确描述了&lt;strong&gt;原始&lt;/strong&gt;GJK的核心逻辑：&lt;strong&gt;只需要输入2个shape和一个初始方向，就能告诉你这2个shape有没碰撞&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;分别沿着初始方向D和反方向-D，求出p和q的supporting point，并计算Minkowski差，得到向量A。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把A输入单纯形s，此时单纯形为0-simplex (如果你不知道是什么，说明没看上文)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;D重新设置为-A (这一步操作不是很关键，可以不深究为什么)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入循环:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同步骤1类似，计算下一个Minkowski差，并依然赋值给A（这里要注意到，A永远是最新计算得到的Minkowski差向量）&lt;/li&gt;
&lt;li&gt;判断A和D的点积是否小于0，实际上就是判断A和D的夹角是不是大于90度。或者换句话说，A在D方向上的投影距离，是否小于0，小于0说明投影在了D的反方向上。所以，如果点积小于0，说明不能在DO方向上找到离原点Origin更近的Minkowski差顶点，这个A被reject，GJK返回false，2个shape没有碰撞。&lt;/li&gt;
&lt;li&gt;到了这里，说明新的A离原点更近了，那么把A加进单纯形，此时单纯形含有2个顶点，所以是1-simplex&lt;/li&gt;
&lt;li&gt;经过NearestSimplex过滤，得到新的单纯形s，以及更新了方向向量D，contains_origin表示这个单纯形是否包含原点。&lt;/li&gt;
&lt;li&gt;如果contains_origin为true，那么说明2个shape里分别存在2个点，坐标相同，使得Minkowski差为0（原点），也就意味着2个shape发生了碰撞，GJK返回true。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面章节继续介绍伪代码里出现的&lt;strong&gt;Support和NearestSimplex函数&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;&lt;div id=&quot;2.2&quot;&gt;Support函数&lt;/div&gt;&lt;/h2&gt;

&lt;p&gt;在不同的资料中，Support函数可能有不同的定义，函数声明如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Point support(Shape&amp;amp; shape, Vector&amp;amp; d)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Point support(Shape&amp;amp; shape1, Shape&amp;amp; shape2, Vector&amp;amp; d)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以把上面的第二个support改名为supprot2，方便区分。supprot2其实是对supprot的一层封装。&lt;/p&gt;

&lt;p&gt;先介绍support。用伪代码表示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// wiki：returns the point on shape which has the highest dot product with d&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 即找出shape里的一个点，把这个点投影到d方向向量上，它离原点的距离最大（要区分正负）&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 具体实现可以自行设计，这里展示的是暴力遍历算法，brute-force&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;VertexID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FirstVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;REAL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;REAL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxv&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;maxv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;maxp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;support的返回值，就是所谓的supporting point。&lt;/p&gt;

&lt;p&gt;有了support，就可以实现supprot2了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 给定2个静态几何形状和一个方向向量，求出经过Minkowski减法运算得到的点（唯一）&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;support2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shape1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shape2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 沿着d方向找出shape1中最远的点p1&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 沿着-d方向找出shape2中最远的点p2&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Minkowski减法运算（其实只是普通的向量运算）&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// p3刚好就落在shape1、shape2闵可夫斯基差的凸包的边上&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;div id=&quot;2.3&quot;&gt;NearestSimplex函数&lt;/div&gt;&lt;/h2&gt;

&lt;p&gt;wiki:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;takes a simplex &lt;strong&gt;s&lt;/strong&gt; and returns the simplex on &lt;strong&gt;s&lt;/strong&gt; closest to the origin, and a direction toward the origin normal to the new simplex. If &lt;strong&gt;s&lt;/strong&gt; itself contains the origin, &lt;strong&gt;NearestSimplex&lt;/strong&gt; accepts &lt;strong&gt;s&lt;/strong&gt; and the two shapes are determined to intersect.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NearestSimplex很不凡，做了很多事情。一是NearestSimplex可以判定2个shape是否碰撞；二是更新单纯形s；三是给出新的迭代方向d。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;要判定2个shape是否碰撞，有前提条件：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;对于2D空间，单纯形s需是2-simplex，即s要含有3个顶点，才能判断s是否包含原点origin；&lt;/li&gt;
&lt;li&gt;对于3D空间，单纯形s需是3-simplex，即s要含有4个顶点，构成一个4面体，才能判断s是否包含原点origin。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以执行到NearestSimplex时，如果s里只有不到3个顶点的话，肯定不算碰撞。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;更新单纯形，目的是保证s满足k-simplex的定义。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例如在2D空间，四边形并不是2-simplex，三角形才是2-simplex。假设s包含4个顶点的时候，就需要去掉1个顶点，才能构成2-simplex。&lt;/p&gt;

&lt;p&gt;对于NearestSimplex函数，它有一些小动作。以2D空间为例：&lt;/p&gt;

&lt;p&gt;因为构成2-simplex仅需要3个顶点，如果最新push进s的点，构成的2-simplex并没有包含原点，那么可以直接丢弃s里的上上个顶点，使得s退化到1-simplex，即s是一条线段。&lt;/p&gt;

&lt;p&gt;而如果构成的2-simplex包含了原点，GJK_intersection就可以直接返回true了。所以就是说，&lt;strong&gt;s变成2-simplex的时候，就是GJK_intersection返回true的时候&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而因为算法的流程设计，执行到NearestSimplex的时候，s必然起码含有2个顶点。综上，NearestSimplex返回的s必然是2-simplex或1-simplex，而不可能是0-simplex。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;新的迭代方向d&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据第二点，如果s不能构成2-simplex（没有碰撞），就还需要继续迭代。&lt;/p&gt;

&lt;p&gt;新的迭代方向是1-simplex里的2个顶点构成的线段的法向量。&lt;/p&gt;

&lt;p&gt;法向量方向有2个，需要选择朝向origin的那一侧的法向。&lt;/p&gt;

&lt;h1&gt;&lt;div id=&quot;3&quot;&gt;二维平面的GJK算法实现&lt;/div&gt;&lt;/h1&gt;

&lt;p&gt;为了学到真正靠谱的GJK算法，所以下面使用Box2D的b2Distance函数，作为学习对象。（找到的其他GJK代码都觉得奇奇怪怪的）&lt;/p&gt;

&lt;p&gt;b2Distance不仅实现了GJK算法，还实现了Simplex Cache机制，即支持时间相干性，从而提升计算效率。&lt;/p&gt;

&lt;p&gt;不过有个问题是，b2Distance不一定能直接改成支持3D，因为用到了一些2D几何公式，例如b2Cross。&lt;/p&gt;

&lt;p&gt;下面将精简b2Distance代码（去掉了Simplex Cache、input-&amp;gt;useRadii等），只保留和GJK相关的，来方便读者理解b2Distance。&lt;/p&gt;

&lt;h2&gt;&lt;div id=&quot;3.1&quot;&gt;b2Distance核心逻辑&lt;/div&gt;&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b2Distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2DistanceOutput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;b2SimplexCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2DistanceInput&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2DistanceProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxyA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proxyA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2DistanceProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxyB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proxyB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;b2Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transformA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transformB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 单纯形类实例！&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2Simplex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;b2SimplexVertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k_maxIters&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// saveA、saveB、saveCount保存上一轮迭代的结果，用来防止进入死循环&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saveA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saveB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saveCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 这就是传说中的GJK迭代loop了&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k_maxIters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;saveCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saveCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;saveA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;saveB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 根据当前的单纯形拥有的顶点数量，选择不同的处理流程&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solve2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solve3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;b2Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 单纯形已经有3个顶点，说明原点已经在单纯形里面了&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 根据s计算新的搜索方向d&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetSearchDirection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;


        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LengthSquared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2_epsilon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2_epsilon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// d的长度几乎等于0，说明当前的单纯形很可能已经包含原点了&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 可能是s的一条边压到，也可能是三角形区域包含了原点&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// 尽管很可能几何体重叠了，但不能认为几何体之间的距离为0&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 因为simplex仅包含1或2个顶点，这时候会遇到浮点数精度问题，&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 很难判断这2个几何体是碰撞了还是距离非常近&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 计算下一个Minkowski差vertex&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// simplex里的要被写入的顶点&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b2SimplexVertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 分别对2个几何体调用support函数&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxyA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetSupport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2MulT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxyA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxyB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetSupport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2MulT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transformB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proxyB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetVertex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Minkowski差 &lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

        &lt;span class=&quot;c1&quot;&gt;// iter的值等同于被计算出来的support point数量&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 判断是否重复，也是退出这个循环的主要条件&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;duplicate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saveCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saveA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indexB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;saveB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;duplicate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;duplicate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 到了这里说明新的vertex符合期望&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 计算witness point，下一篇GJK文章再介绍&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 总之pointA pointB是距离原点最近的Minkowski差(一个顶点)对应的2个点&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetWitnessPoints&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 这里调用的是重载函数&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// distance存储了pointA pointB之间的差值（&amp;gt;=0)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// distance小于一个预期阈值时，就认为这2个几何体发生碰撞&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 缓存&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;simplex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面继续介绍这段代码里出现的GetSearchDirection、Solve2、Solve3、GetSupport函数。&lt;/p&gt;

&lt;h2&gt;&lt;div id=&quot;3.2&quot;&gt;b2Simplex::GetSearchDirection&lt;/div&gt;&lt;/h2&gt;

&lt;p&gt;根据算法上下文，执行到GetSearchDirection时，单纯形顶点数只能是1或2。&lt;/p&gt;

&lt;p&gt;如果顶点数为1，下个搜索方向就是该顶点向量的反方向。so easy。&lt;/p&gt;

&lt;p&gt;如果顶点数为2，需要判断原点在\( e_{12} \)的哪一侧，并计算朝向那一侧的垂直于w1w2的向量。&lt;/p&gt;

&lt;p&gt;这个问题的解决，需要用到2D叉积公式。读者可能不清楚这是什么但没关系。现先从3D叉积公式说起。&lt;/p&gt;

&lt;p&gt;叉积(&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross_product&quot;&gt;cross product&lt;/a&gt;)运算\( \times \)，本是3D空间特有的一种向量二元运算。执行\( \mathbf a \times \mathbf b \)，会得到一个同时和\( \mathbf a 、 \mathbf b \)正交的向量\( \mathbf c\)，\( \mathbf c\)的方向可以按右手规则推知：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/10.png&quot; alt=&quot;10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;可把\( \mathbf a 、 \mathbf b \)用标准基&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_basis&quot;&gt;Standard basis&lt;/a&gt; \( \mathbf i、  \mathbf j 、 \mathbf k\)表示：&lt;/p&gt;

&lt;p&gt;\[ \mathbf a = u_1 \mathbf i + u_2 \mathbf j + u_3 \mathbf k \]&lt;/p&gt;

&lt;p&gt;\[ \mathbf b = v_1 \mathbf i + v_2 \mathbf j + v_3 \mathbf k \]&lt;/p&gt;

&lt;p&gt;此时，\( \mathbf a 、 \mathbf b \)的叉积可以用矩阵秩(determinant)表示：&lt;/p&gt;

&lt;p&gt;\[ \mathbf a \times \mathbf b =    \left| \begin{matrix} \mathbf i \  \mathbf j \  \mathbf k \\  u_1 \   u_2 \  u_3 \\  v_1 \  v_2 \  v_3\\ \end{matrix} \right|  \]&lt;/p&gt;

&lt;p&gt;展开这个式子，得到向量形式的公式：&lt;/p&gt;

&lt;p&gt;\[ \mathbf a \times \mathbf b =    \left| \begin{matrix} u_2 \  u_3 \\  v_2 \  v_3\\ \end{matrix} \right|  \mathbf i -    \left| \begin{matrix} u_1 \  u_3 \\  v_1 \  v_3\\ \end{matrix} \right|  \mathbf j +    \left| \begin{matrix} u_1 \  u_2 \\  v_1 \  v_2\\ \end{matrix} \right|  \mathbf k  \]&lt;/p&gt;

&lt;p&gt;对于2D空间下的\( \mathbf a 、 \mathbf b \)，可认为它们是z分部为0的3D向量，从而可以套进上述公式：&lt;/p&gt;

&lt;p&gt;\[ \mathbf a = u_1 \mathbf i + u_2 \mathbf j + 0 \mathbf k \]&lt;/p&gt;

&lt;p&gt;\[ \mathbf b = v_1 \mathbf i + v_2 \mathbf j + 0 \mathbf k \]&lt;/p&gt;

&lt;p&gt;\[ \mathbf a \times \mathbf b =    \left| \begin{matrix} u_2 \  u_3 \\  v_2 \  v_3\\ \end{matrix} \right|  \mathbf i -    \left| \begin{matrix} u_1 \  u_3 \\  v_1 \  v_3\\ \end{matrix} \right|  \mathbf j +    \left| \begin{matrix} u_1 \  u_2 \\  v_1 \  v_2\\ \end{matrix} \right|  \mathbf k  \]&lt;/p&gt;

&lt;p&gt;\[ = 0\mathbf i - 0\mathbf j +    \left| \begin{matrix} u_1 \  u_2 \\  v_1 \  v_2\\ \end{matrix} \right|  \mathbf k \]&lt;/p&gt;

&lt;p&gt;\[ =    \left| \begin{matrix} u_1 \  u_2 \\  v_1 \  v_2\\ \end{matrix} \right| \]&lt;/p&gt;

&lt;p&gt;\[ = u_1 v_2 - u_2 v_1 \]&lt;/p&gt;

&lt;p&gt;最后一步用到了2阶的determinant公式(&lt;a href=&quot;https://en.wikipedia.org/wiki/Determinant&quot;&gt;from wiki&lt;/a&gt;) ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/9.png&quot; alt=&quot;9.png&quot;&gt;  &lt;/p&gt;

&lt;p&gt;这就是所谓的2D叉积公式了，其实只是3D叉积的一种特殊情况。&lt;/p&gt;

&lt;p&gt;2D叉积公式有什么用呢？请注意，2D叉积后得到的是一个标量s。这个标量的正负号，就告诉了我们\( \mathbf a \times \mathbf b \)得到的向量( \( 0\mathbf i - 0\mathbf j + s\mathbf k \) )在z轴上的朝向。&lt;/p&gt;

&lt;p&gt;但知道朝向后又有什么意义呢？这时，要结合右手坐标系来理解（可回顾下上面的手势图）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当标量s符号为正时，根据右手坐标系规则，可知\( \mathbf b \)在\( \mathbf a \)的左侧（记住观察视角是从+z到-z）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当标量s符号为负时，根据右手坐标系规则，可知\( \mathbf b \)在\( \mathbf a \)的右侧&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解2D叉积后，GetSearchDirection理解起来就轻松了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 2D叉积公式&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 这2条公式其实是为了得到和a正交的向量，s的值一般为1&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// b2Cross(a, 1.0)返回一个在a右侧的正交向量&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// b2Cross(1.0, a)返回一个在a左侧的正交向量&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetSearchDirection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 直接取w1的反方向就行了&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 计算2D叉积&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sgn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sgn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;c1&quot;&gt;// -m_v1.w在e12左侧，即原点也在左侧&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// -m_v1.w在e12右侧，即原点也在右侧&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2_zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;div id=&quot;3.3&quot;&gt;b2Simplex::Solve2&lt;/div&gt;&lt;/h2&gt;

&lt;p&gt;Solve2主要目的：找出原点在当前这个1-simplex的哪个区域。&lt;/p&gt;

&lt;p&gt;以下图为例，区域总共有3个，w1、w2、w12：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;w12就是w1和w2两个顶点夹住的那片黄色。&lt;/p&gt;

&lt;p&gt;solve2的原理是，通过求原点在w1w2的投影点p（最近点），从而知道原点和线段w1w2的关系。&lt;/p&gt;

&lt;p&gt;投影点p既然在w1w2上，那么可用&lt;a href=&quot;https://en.wikipedia.org/wiki/Barycentric_coordinate_system&quot;&gt;质心坐标公式&lt;/a&gt;表示：&lt;/p&gt;

&lt;p&gt;\[ (a_{1} + a_{2})\mathbf p = a_{1} \mathbf w_{1} + a_{2} \mathbf w_{2}  \]&lt;/p&gt;

&lt;p&gt;为了唯一确定这个点p，再加入限制条件：&lt;/p&gt;

&lt;p&gt;\[ a_{1} + a_{2} = 1   \]&lt;/p&gt;

&lt;p&gt;上式简化：&lt;/p&gt;

&lt;p&gt;\[ \mathbf p = a_{1} \mathbf w_{1} + a_{2} \mathbf w_{2}  \]&lt;/p&gt;

&lt;p&gt;op（即向量\(\mathbf p\)）必然垂直于w1w2，所以有：&lt;/p&gt;

&lt;p&gt;\[  \mathbf e_{12} = \mathbf w_{2} - \mathbf  w_{1} \]&lt;/p&gt;

&lt;p&gt;\[ \mathbf p \cdot \mathbf e_{12} = 0\]&lt;/p&gt;

&lt;p&gt;把上面的\(\mathbf p\)代入，得到：&lt;/p&gt;

&lt;p&gt;\[ (a_{1} \mathbf w_{1} + a_{2} \mathbf w_{2}) \cdot \mathbf e_{12} = 0\]&lt;/p&gt;

&lt;p&gt;\[ a_{1} (\mathbf w_{1} \cdot \mathbf e_{12}) + a_{2} (\mathbf w_{2} \cdot \mathbf e_{12}) = 0\]&lt;/p&gt;

&lt;p&gt;解得：&lt;/p&gt;

&lt;p&gt;\[ a_{1} = \frac { \mathbf w_{2} \cdot \mathbf e_{12} } { -\mathbf w_{1} \cdot \mathbf e_{12}  + \mathbf w_{2} \cdot \mathbf e_{12} } \]&lt;/p&gt;

&lt;p&gt;\[ a_{2} = \frac { -\mathbf w_{1} \cdot \mathbf e_{12} } { -\mathbf w_{1} \cdot \mathbf e_{12} + \mathbf w_{2} \cdot \mathbf e_{12} } \]&lt;/p&gt;

&lt;p&gt;设:&lt;/p&gt;

&lt;p&gt;\[ d12\_2 = -\mathbf w_{1} \cdot \mathbf e_{12} \]&lt;/p&gt;

&lt;p&gt;\[ d12\_1 = \mathbf w_{2} \cdot \mathbf e_{12} \]&lt;/p&gt;

&lt;p&gt;\( a_{1} 、 a_{2} \) 就可以表示成:&lt;/p&gt;

&lt;p&gt;\[ a_1 = \frac { d12\_1 } { d12\_2  + d12\_1 } \]&lt;/p&gt;

&lt;p&gt;\[ a_2 = \frac { d12\_2 } { d12\_2 + d12\_1 } \]&lt;/p&gt;

&lt;p&gt;因为\( a_1 、a_2 \)之和等于1，所以\( a_1 、a_2 \)不可能同时小于0，可列出所有情况：&lt;/p&gt;

&lt;p&gt;\(a_1 、a_2  \)都大于0时，p点在线段w1w2里面；&lt;/p&gt;

&lt;p&gt;\(a_1 \) 小于0时，p在w2区域里面；&lt;/p&gt;

&lt;p&gt;\(a_2 \) 小于0时，p在w1区域里面。&lt;/p&gt;

&lt;p&gt;（后面2个，不好解释，最好自己画图理解下）&lt;/p&gt;

&lt;p&gt;这里可能会有个担忧：如果d12_1、d12_2都小于0的话，分母会小于0，结果会如何？&lt;/p&gt;

&lt;p&gt;实际上是不可能的，可以反证下：&lt;/p&gt;

&lt;p&gt;\[ d12\_2 + d12\_1 &amp;lt; 0 \]&lt;/p&gt;

&lt;p&gt;\[ -\mathbf w_{1} \cdot \mathbf e_{12} +  \mathbf w_{2} \cdot \mathbf e_{12}  &amp;lt; 0 \]&lt;/p&gt;

&lt;p&gt;\[ ( \mathbf w_{2} - \mathbf w_{1} ) \cdot \mathbf e_{12}  &amp;lt; 0 \]&lt;/p&gt;

&lt;p&gt;\[ \mathbf e_{12} \cdot \mathbf e_{12}  &amp;lt; 0 \]&lt;/p&gt;

&lt;p&gt;\[ | \mathbf e_{12} |^{2} &amp;lt; 0 \]&lt;/p&gt;

&lt;p&gt;显然不成立。&lt;/p&gt;

&lt;p&gt;下面展示的Box2D的Solve2，就用到了说到的这些数学知识。其中，Solve2用d12_2、d12_1的正负来等价表示\( a_1 、a_2 \)的正负。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Simplex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solve2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// w1 region&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d12_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 根据上面的公式，可知此时a2也是&amp;lt;=0&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 所以p在w1区域&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 保留w1，干掉w2，单纯形退化成0-simplex&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// w2 region&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d12_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// p在w2区域，那么保留w2，干掉w1，单纯形退化成0-simplex&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// p在w2区域&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 保留下来的顶点需要放到数组第一个位置&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// p必然在w1w2中间了，求出a1、a2，并分别保存进m_v1 m_v2里&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d12_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;div id=&quot;3.4&quot;&gt;b2Simplex::Solve3&lt;/div&gt;&lt;/h2&gt;

&lt;p&gt;Solve3大同小异，也是各种找原点在simplex的哪个区域，用一个图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/11.png&quot; alt=&quot;11.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果原点落在w1、w2、w3区域，会导致simplex退化成0-simplex；&lt;/p&gt;

&lt;p&gt;如果原点落在e12、e13、e23区域，会导致simplex退化成1-simplex；&lt;/p&gt;

&lt;p&gt;否则，原点必然落在三角形内部，simplex仍然是2-simplex。&lt;/p&gt;

&lt;p&gt;还有就是，因为现在有3个顶点了，质心坐标公式会需要3个参数\( a_1 、a_2 、a_3\)。可以参考Solve2小节的方法，解出3个参数。&lt;/p&gt;

&lt;p&gt;（有空再更新解法）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Simplex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Solve3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1e12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2e12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w1e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e13&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1e13&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w3e13&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d13_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w3e13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d13_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w1e13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e23&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2e23&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w3e23&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d23_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w3e23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d23_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w2e23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 这里的n123、d123_1、d123_2、d123_3都和质心坐标公式有关&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Triangle123&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n123&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n123&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n123&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n123&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// w1 region&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d12_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d13_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// e12&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d12_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d12_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d12_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// e13&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d13_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d13_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d13&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d13_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d13_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d13_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d13_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// w2 region&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d12_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d23_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// w3 region&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d13_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d23_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// e23&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d23_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d23_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d23&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d23_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d23_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d23_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d23_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Must be in triangle123&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d123&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d123_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d123_3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inv_d123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;div id=&quot;3.5&quot;&gt;b2DistanceProxy::GetSupport&lt;/div&gt;&lt;/h2&gt;

&lt;p&gt;b2DistanceProxy的GetSupport和上面章节给出的support伪代码，几乎是一样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2DistanceProxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetSupport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Vec2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bestIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bestValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;float32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bestValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bestIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bestValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bestIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;&lt;div id=&quot;4&quot;&gt;GJK的其他细节&lt;/div&gt;&lt;/h1&gt;

&lt;h2&gt;2D/3D泛化实现&lt;/h2&gt;

&lt;p&gt;虽然说GJK原理没有对维度有什么限制，但2D版本的GJK代码还是很难直接泛化成2D+3D的。因为其中有一些细节，很难用维数参数化。具体有什么坑，等我踩一遍再回来更新。&lt;/p&gt;

&lt;h2&gt;几何体的定义：连续or离散&lt;/h2&gt;

&lt;p&gt;从GJK用到的数学知识来看，GJK并不要求输入的2个几何体必须是离散顶点定义的几何体。&lt;/p&gt;

&lt;p&gt;所以GJK的一个优点是，GJK是支持非离散几何体的碰撞检测的，例如参数方程\(x^{2} + y^{2} = r^{2} \)定义的圆，或者样条曲线、NURBS曲线定义的曲面几何体。&lt;/p&gt;

&lt;p&gt;至于如何抽象，切入点就是GJK的support函数。只有support函数使用到了输入参数Shape p和q，所以，可以针对非离散Shape设计特殊的support函数，从而泛化GJK算法。&lt;/p&gt;

&lt;h2&gt;GJK的时间复杂度问题&lt;/h2&gt;

&lt;p&gt;GJK中的方向向量\(d\)，\(d\)如何选取，基本就决定了GJK的收敛速度。&lt;/p&gt;

&lt;h1&gt;&lt;div id=&quot;5&quot;&gt;参考资料&lt;/div&gt;&lt;/h1&gt;

&lt;h2&gt;文字资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm&quot;&gt;Gilbert–Johnson–Keerthi distance algorithm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;file:///Users/wyman/Downloads/Tomiczkova.pdf&quot;&gt;Algorithms for the computation of the
Minkowski difference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.dyn4j.org/2010/04/gjk-gilbert-johnson-keerthi/&quot;&gt;http://www.dyn4j.org/2010/04/gjk-gilbert-johnson-keerthi/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.haroldserrano.com/blog/visualizing-the-gjk-collision-algorithm&quot;&gt;Visualizing the GJK Collision detection algorithm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PPT：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://slideplayer.com/slide/689954/&quot;&gt;http://slideplayer.com/slide/689954/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Youtube视频资料&lt;/h2&gt;

&lt;p&gt;1个小时的课程：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://caseymuratori.com/blog_0003&quot;&gt;https://caseymuratori.com/blog_0003&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;&lt;div id=&quot;5.1&quot;&gt;GJK各种实现&lt;/div&gt;&lt;/h1&gt;

&lt;p&gt;(Warning: 如果不能先参透GJK的原理，看下面这些代码的时候是非常折磨人的)&lt;/p&gt;

&lt;h2&gt;2D&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一份来自2000年左右的代码，巨复杂，阅读起来很有心理障碍：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cs.ox.ac.uk/people/stephen.cameron/distances/&quot;&gt;Computing the Distance between Objects&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cs.ox.ac.uk/people/stephen.cameron/distances/gjk2.4/&quot;&gt;http://www.cs.ox.ac.uk/people/stephen.cameron/distances/gjk2.4/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Box2D：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/erincatto/Box2D/blob/master/Box2D/Box2D/Collision/b2Distance.cpp&quot;&gt;https://github.com/erincatto/Box2D/blob/master/Box2D/Box2D/Collision/b2Distance.cpp&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gjk.c，200多行纯C代码实现GJK：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kroitor/gjk.c&quot;&gt;https://github.com/kroitor/gjk.c&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dyn4j，一个java写的物理引擎：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dyn4j/dyn4j/blob/master/src/main/java/org/dyn4j/collision/narrowphase/Gjk.java&quot;&gt;https://github.com/dyn4j/dyn4j/blob/master/src/main/java/org/dyn4j/collision/narrowphase/Gjk.java&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;js实现，这个自带演示程序，很厉害：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/juhl/collision-detection-2d&quot;&gt;https://github.com/juhl/collision-detection-2d&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3D&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bullet，重量级引擎，全局搜btGjkPairDetector可找到GJK代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/bulletphysics/bullet3&quot;&gt;https://github.com/bulletphysics/bullet3&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;reactphysics3d，非产品级的轻量物理引擎，适合学习用：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/DanielChappuis/reactphysics3d&quot;&gt;https://github.com/DanielChappuis/reactphysics3d&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/collision-detection-2/</link>
        <guid isPermaLink="true">http://localhost:4000/collision-detection-2/</guid>
      </item>
    
      <item>
        <title>Canvas的transform函数与2D仿射变换矩阵分解</title>
        <description>&lt;p&gt;最近偶然接触了一下canvas的2D仿射变换。和3D一样，canvas有scale、translate、rotate操作，本质上这3个函数也是矩阵乘法。&lt;/p&gt;

&lt;p&gt;canvas应该内置了一套矩阵运算系统，并且canvas内含有一个仿射变换矩阵（大概认为是3x3=9个浮点数变量即可，2D是3x3矩阵，3D是4x4矩阵）。每次调用scale、translate、rotate就是对这个矩阵做矩阵乘法。&lt;/p&gt;

&lt;p&gt;另外还有3个函数可以控制canvas的仿射变换：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;resetTransform 重置为单位矩阵&lt;/li&gt;
&lt;li&gt;transform(a,b,c,d,e,f) 以a,b,c,d,e,f构造一个仿射变换矩阵并乘到当前canvas的仿射变换矩阵&lt;/li&gt;
&lt;li&gt;setTransform(a,b,c,d,e,f) 重置为单位矩阵并应用transform(a,b,c,d,e,f)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我遇到的需求是，&lt;strong&gt;如果canvas没有提供transform函数，怎么用scale、translate、rotate三个函数的组合，来模拟transform函数？&lt;/strong&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;自定义的transform函数实现&lt;/h2&gt;

&lt;p&gt;先抛出答案：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 旋转度数&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// x 轴缩放倍数&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// y 轴缩放倍数&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 斜切度数 &lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x轴平移&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ty&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// y轴平移&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;sx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;sx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;transform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;angle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;atan2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;denom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scaleX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;denom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scaleY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scaleX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;skewX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;atan2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;denom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;skewY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;translateX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;translateY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;angle&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;angle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;skewX&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;skewX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;scale&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scaleX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scaleY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;translate&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;translateX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;translateY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    Outout:&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    angle 45&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    skewX 0&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    scale 0.5 2&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    translate 200 100&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;    */&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;translate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;translateX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;translateY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;angle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scaleX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scaleY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;canvas&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;test2&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;canvas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;2d&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fillRect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;font&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;30px Verdana&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fillText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;Hello, World&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;90&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码大意是，用户输入任意degree，sx， sy，t，tx，ty，并计算出它们的a,b,c,d,e,f，然后调用这个自定义transform函数，就能得到和内置的transform一样的变换效果。&lt;/p&gt;

&lt;p&gt;下面将逐步讲解transform函数怎么得来。&lt;/p&gt;

&lt;h2&gt;2D仿射变换矩阵的分解&lt;/h2&gt;

&lt;p&gt;transform的参数a, b, c, d, e, f组成了一个3x3仿射变换矩阵A：&lt;/p&gt;

&lt;p&gt;\( A =  \left[ \begin{matrix} a&amp;amp;c&amp;amp;e\\ b&amp;amp;d&amp;amp;f\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \)&lt;/p&gt;

&lt;p&gt;设有2维向量\(\mathbf p=(x, y, 1)\)，让它左乘A，就会得到经过A变换后的向量\(\mathbf p&amp;#39;=(x&amp;#39;, y&amp;#39;, 1)\)。&lt;/p&gt;

&lt;p&gt;\( \mathbf p =  \left[ \begin{matrix} x\\ y\\ 1\\ \end{matrix} \right]  \)&lt;/p&gt;

&lt;p&gt;\( \mathbf p&amp;#39; = A\mathbf p  =  \left[ \begin{matrix} x&amp;#39;\\ y&amp;#39;\\ 1\\ \end{matrix} \right] =  \left[ \begin{matrix} a&amp;amp;c&amp;amp;e\\ b&amp;amp;d&amp;amp;f\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} x\\ y\\ 1\\ \end{matrix} \right] =  \left[ \begin{matrix} ax+cy+e\\ bx+dy+f\\ 1\\ \end{matrix} \right] \)&lt;/p&gt;

&lt;p&gt;现在问题是，怎么把A分解成T(translate)、R(rotate)、S(scale)三个矩阵。&lt;/p&gt;

&lt;h3&gt;提取T&lt;/h3&gt;

&lt;p&gt;首先先把translate矩阵提取出来：&lt;/p&gt;

&lt;p&gt;\( T =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;e\\ 0&amp;amp;1&amp;amp;f\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \)&lt;/p&gt;

&lt;p&gt;显然这是正确的，可以试一下：&lt;/p&gt;

&lt;p&gt;\( \mathbf p&amp;#39; = T\mathbf p =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;e\\ 0&amp;amp;1&amp;amp;f\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} x\\ y\\ 1\\ \end{matrix} \right] =  \left[ \begin{matrix} x+e\\ y+f\\ 1\\ \end{matrix} \right] \)&lt;/p&gt;

&lt;p&gt;x偏移了e，y偏移了f。&lt;/p&gt;

&lt;p&gt;再设等式：A = TQ。Q是未知矩阵，且Q包含了scale、rotate变换。&lt;/p&gt;

&lt;p&gt;Q可以用参数a, b, c, d, e, f表示：&lt;/p&gt;

&lt;p&gt;\( Q =  \left[ \begin{matrix} a&amp;amp;c&amp;amp;0\\ b&amp;amp;d&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \)&lt;/p&gt;

&lt;p&gt;验证下：&lt;/p&gt;

&lt;p&gt;\( TQ =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;e\\ 0&amp;amp;1&amp;amp;f\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} a&amp;amp;c&amp;amp;0\\ b&amp;amp;d&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \)&lt;/p&gt;

&lt;p&gt;\( =  \left[ \begin{matrix} a&amp;amp;c&amp;amp;e\\ b&amp;amp;d&amp;amp;f\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] = A \)&lt;/p&gt;

&lt;h3&gt;分解Q&lt;/h3&gt;

&lt;p&gt;设 Q = RS，S是scale，R是rotate。2D的R、S矩阵分别为：&lt;/p&gt;

&lt;p&gt;\( R =  \left[ \begin{matrix} cosθ&amp;amp; -sinθ&amp;amp; 0\\  sinθ&amp;amp; cosθ&amp;amp; 0\\  0&amp;amp; 0&amp;amp; 1\\ \end{matrix} \right]  \)&lt;/p&gt;

&lt;p&gt;\( S =  \left[ \begin{matrix} x&amp;amp; 0&amp;amp; 0\\  0&amp;amp; y&amp;amp; 0\\  0&amp;amp; 0&amp;amp; 1\\ \end{matrix} \right]  \)&lt;/p&gt;

&lt;p&gt;其实，Q还可能包含了shear斜切变换。一般来说斜切是比较少见到的一种变换，且canvas并没有单独的shear函数。所以本文开头的目标，自定义custom，怎么弄都不能实现shear变换（只有scale、translate、rotate可用）。&lt;/p&gt;

&lt;p&gt;现在要分解Q，可以把shear也一并考虑。shear矩阵形式如下；&lt;/p&gt;

&lt;p&gt;\( Shear =  \left[ \begin{matrix} 1&amp;amp; s&amp;amp; 0\\  t&amp;amp; 1&amp;amp; 0\\  0&amp;amp; 0&amp;amp; 1\\ \end{matrix} \right]  \)&lt;/p&gt;

&lt;p&gt;如果没有shear变换，那么s=t=0。&lt;/p&gt;

&lt;p&gt;同时用s和t是不对的，其中一个必需为0。下面推导的前提是s != 0，t = 0。&lt;/p&gt;

&lt;p&gt;综上，得到Q&amp;#39; = Rotate * Scale * Shear&lt;/p&gt;

&lt;p&gt;\( Q&amp;#39; = \left[ \begin{matrix} cosθ&amp;amp; -sinθ&amp;amp; 0\\  sinθ&amp;amp; cosθ&amp;amp; 0\\  0&amp;amp; 0&amp;amp; 1\\ \end{matrix} \right]  \left[ \begin{matrix} x&amp;amp; 0&amp;amp; 0\\  0&amp;amp; y&amp;amp; 0\\  0&amp;amp; 0&amp;amp; 1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;amp; s&amp;amp; 0\\  t&amp;amp; 1&amp;amp; 0\\  0&amp;amp; 0&amp;amp; 1\\ \end{matrix} \right]   \)&lt;/p&gt;

&lt;p&gt;\( =   \left[ \begin{matrix} xcosθ&amp;amp; -ysinθ&amp;amp; 0\\  xsinθ&amp;amp; ycosθ&amp;amp; 0\\  0&amp;amp; 0&amp;amp; 1\\ \end{matrix} \right]   \left[ \begin{matrix} 1&amp;amp; s&amp;amp; 0\\  t&amp;amp; 1&amp;amp; 0\\  0&amp;amp; 0&amp;amp; 1\\ \end{matrix} \right] \)&lt;/p&gt;

&lt;p&gt;\( =  \left[ \begin{matrix} xcosθ - tysinθ&amp;amp; sxcosθ - ysinθ&amp;amp; 0\\  xsinθ + tycosθ&amp;amp; sxsinθ + ycosθ&amp;amp; 0\\  0&amp;amp; 0&amp;amp; 1\\ \end{matrix} \right]  \)&lt;/p&gt;

&lt;p&gt;再回顾上一小节的Q：&lt;/p&gt;

&lt;p&gt;\( Q =  \left[ \begin{matrix} a&amp;amp;c&amp;amp;0\\ b&amp;amp;d&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \)&lt;/p&gt;

&lt;p&gt;对比Q和Q&amp;#39;，可以得到方程组：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;\( a =  x cosθ - t y sinθ = x cosθ  \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( b = x sinθ + t y cosθ = x sinθ  \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( c = s x cosθ - y sinθ = sa - y sinθ = sa - y(b/x) \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( d = s x sinθ + y cosθ = sb + y cosθ = sb + y(a/x) \)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看起来有点乱，慢慢拆解下吧:&lt;/p&gt;

&lt;p&gt;一二等式相除解出θ：&lt;/p&gt;

&lt;p&gt;\( tanθ = \frac { b } { a } \)&lt;/p&gt;

&lt;p&gt;\( θ = atan2(b, a) \)&lt;/p&gt;

&lt;p&gt;一二等式分别平方后相加，解出x：&lt;/p&gt;

&lt;p&gt;\( a^{2} + b^{2} = x^{2} \)&lt;/p&gt;

&lt;p&gt;\( x = \sqrt { a^{2} + b^{2} } \)&lt;/p&gt;

&lt;p&gt;三四等式消去s：&lt;/p&gt;

&lt;p&gt;\( c = sa - y(b/x) \)&lt;/p&gt;

&lt;p&gt;\( s = (c + y(b/x))/a \)&lt;/p&gt;

&lt;p&gt;\( d = sb + y(a/x) =  b(c + y(b/x))/a + y(a/x)  \)&lt;/p&gt;

&lt;p&gt;对上式两边乘a：&lt;/p&gt;

&lt;p&gt;\( ad =  b(c + y(b/x)) + ay(a/x)  \)&lt;/p&gt;

&lt;p&gt;\( ad =  bc + by(b/x) + ay(a/x)  \)&lt;/p&gt;

&lt;p&gt;\( ad -  bc = by(b/x) + ay(a/x)  \)&lt;/p&gt;

&lt;p&gt;\( ad -  bc = y(b^{2}/x + a^{2}/x)  \)&lt;/p&gt;

&lt;p&gt;\( ad -  bc = y(a^{2} + b^{2})/ \sqrt { a^{2} + b^{2} }    \)&lt;/p&gt;

&lt;p&gt;\( ad -  bc = y \sqrt { a^{2} + b^{2} }    \)&lt;/p&gt;

&lt;p&gt;\( y = \frac { ad -  bc } {  \sqrt { a^{2} + b^{2} }  } \)&lt;/p&gt;

&lt;p&gt;然后可以求s了：&lt;/p&gt;

&lt;p&gt;\( s = (c + y(b/x))/a \)&lt;/p&gt;

&lt;p&gt;\( s = \frac { c } { a } + \frac { yb } { xa } \)&lt;/p&gt;

&lt;p&gt;y/x上面已经有了，代入：&lt;/p&gt;

&lt;p&gt;\( s = \frac { c } { a } + \frac { (ad -  bc)b } { (a^{2} + b^{2})a } \)&lt;/p&gt;

&lt;p&gt;\( s = \frac { c(a^{2} + b^{2}) + (ad -  bc)b } { (a^{2} + b^{2})a } \)&lt;/p&gt;

&lt;p&gt;\( s = \frac { ca^{2} + cb^{2} + adb -  cb^{2} } { (a^{2} + b^{2})a } \)&lt;/p&gt;

&lt;p&gt;\( s = \frac { ca^{2} + adb } { (a^{2} + b^{2})a } \)&lt;/p&gt;

&lt;p&gt;\( s = \frac { a(ca + bd) } { (a^{2} + b^{2})a } \)&lt;/p&gt;

&lt;p&gt;\( s = \frac { ca + bd } { a^{2} + b^{2} } \)&lt;/p&gt;

&lt;p&gt;逆向思维一下，现在已经求出未知数x,y,sx,sy,s,θ，它们都可以用a,b,c,d,e,f来表示。&lt;/p&gt;

&lt;p&gt;那么反过来，用户自己提供了x,y,sx,sy,s,θ，那么就可以求出a,b,c,d,e,f，从而调用这个自定义函数。&lt;/p&gt;

&lt;p&gt;回去上面再比对下代码和公式就清楚了。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;用这个自定义函数就能几乎满足需求了。只不过这个自定义函数是不能实现斜切效果的，&lt;/p&gt;

&lt;p&gt;对于符合标准的web js，一般是用transform函数来做斜切，TRS就分别用translate、rotate、scale函数来做。&lt;/p&gt;

&lt;p&gt;如果canvas再提供一个单独的skew函数就完美了。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5107134/find-the-rotation-and-skew-of-a-matrix-transformation/32125700#32125700&quot;&gt;stackoverflow - Find the Rotation and Skew of a Matrix transformation
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/matthewmueller/unmatrix/blob/master/index.js&quot;&gt;unmatrix - parse(str) &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp&quot;&gt;DecomposeMatrix 此代码最原始出处（有注释）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;《GRAPHICS GEMS II edited by JAMES ARVO》&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/linear-algebra-20/</link>
        <guid isPermaLink="true">http://localhost:4000/linear-algebra-20/</guid>
      </item>
    
  </channel>
</rss>