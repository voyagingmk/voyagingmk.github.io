<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>伪技术宅，兴趣点：服务器编程、游戏开发、人工智能</description>
    <link>http://www.qiujiawei.com</link>
    <atom:link href="http://www.qiujiawei.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>线性代数之平移、缩放、旋转矩阵</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;平移矩阵 Translate Matrix&lt;/h2&gt;

&lt;p&gt;\[ T =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;x\\  0&amp;amp;1&amp;amp;0&amp;amp;y\\  0&amp;amp;0&amp;amp;1&amp;amp;z\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h2&gt;缩放矩阵 Scale Matrix&lt;/h2&gt;

&lt;p&gt;\[ S =  \left[ \begin{matrix} x&amp;amp;0&amp;amp;0&amp;amp;0\\  0&amp;amp;y&amp;amp;0&amp;amp;0\\  0&amp;amp;0&amp;amp;z&amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h2&gt;旋转矩阵 Rotate Matrix&lt;/h2&gt;

&lt;h3&gt;绕(1,0,0)旋转\(\theta \)角度&lt;/h3&gt;

&lt;p&gt;\[ R_{(1,0,0)} =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\  0&amp;amp;cos\theta &amp;amp;sin\theta &amp;amp;0\\  0&amp;amp;-sin\theta &amp;amp;cos\theta &amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h3&gt;绕(0,1,0)旋转\(\theta \)角度&lt;/h3&gt;

&lt;p&gt;\[ R_{(0,1,0)} =  \left[ \begin{matrix} cos\theta&amp;amp;0&amp;amp;-sin\theta&amp;amp;0\\    0&amp;amp;1&amp;amp;0&amp;amp;0\\  sin\theta &amp;amp;0&amp;amp;cos\theta &amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h3&gt;绕(0,0,1)旋转\(\theta \)角度&lt;/h3&gt;

&lt;p&gt;\[ R_{(0,0,1)} =  \left[ \begin{matrix} cos\theta&amp;amp;sin\theta&amp;amp;0&amp;amp;0\\  -sin\theta &amp;amp;cos\theta &amp;amp;0&amp;amp;0\\   0&amp;amp;0&amp;amp;1&amp;amp;0\\   0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h3&gt;绕任意轴旋转\(\theta \)角度&lt;/h3&gt;

&lt;p&gt;设旋转轴为\(\vec n\)，这是一个单位化的方向向量。设被旋转的向量为\(\vec v\)，被旋转后是\(\vec v&amp;#39; \)。&lt;/p&gt;

&lt;p&gt;为了求出\(\vec v&amp;#39; \)，需要迂回地处理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将\(\vec v\) 分解为 \(\vec v = \vec v_{\perp }+\vec v_{\parallel } \) ，\( \vec v_{\parallel } \)指的是\(\vec v\)与\(\vec n\)平行的部分，\( \vec v_{\perp } \) 指的是\(\vec v\) 与\(\vec n\)垂直的部分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分解为两部分后，可以分别对这两个部分做旋转，然后再合并，所以有： \(\vec v&amp;#39; = \vec v&amp;#39;_{\perp }+\vec v&amp;#39;_{\parallel } \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;让 \( \vec v_{\parallel } \) 绕旋转轴\(\vec n\)旋转\(\theta \)角度，它依然保持不变，因为它和\(\vec n\)是同方向的向量，所以有 \( \vec v_{\parallel } = \vec v&amp;#39;_{\parallel } \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据上一点，可以得到： \(\vec v&amp;#39; = \vec v&amp;#39;_{\perp }+\vec v_{\parallel } \)。因此，问题简化为求\( \vec v&amp;#39;_{\perp } \)和\( \vec v_{\parallel } \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分析\( \vec v_{\parallel } \)，可以发现它相当于是\(\vec v\)在\(\vec n\)上的投影，根据向量的点积公式：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ \vec A\cdot \vec B = |\vec A||\vec B|cos\alpha  \]&lt;/p&gt;

&lt;p&gt;代入\(\vec v\)、\(\vec n\)后，得到：\( \vec v\cdot \vec n = |\vec v||\vec n|cos\alpha = |\vec v|cos\alpha = |\vec v_{\parallel }| \)，即算出了\( \vec v_{\parallel } \)的长度，又因为\vec v_{\parallel } \)和\(\vec n\)方向一致、\(\vec n\)长度为1，所以有:&lt;/p&gt;

&lt;p&gt;\[ \vec v_{\parallel } = (\vec v\cdot \vec n) \vec n \]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;上一步已经解决了\( \vec v_{\parallel } \)，剩下的就是求\( \vec v&amp;#39;_{\perp } \)。求\( \vec v&amp;#39;_{\perp } \)之前需要先求出\( \vec v_{\perp } \)，而显然\( \vec v_{\perp } = v - \vec v_{\parallel} \) &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着，需要计算一个新的向量\(\vec w \)，\( \vec w = \vec n \times \vec v_{\perp } \) （注意叉乘的顺序不能错），所以\(\vec w \)是一个垂直于\(  \vec n \)、\( \vec v_{\perp } \)所构成平面的向量。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把\( \vec v_{\perp }\)、\(\vec w \) 分别当做是\(  \vec n \)、\( \vec v_{\perp } \)平面的x、y轴(2D坐标系)，那么\( \vec v&amp;#39;_{\perp } \)的含义就是指\( \vec v_{\perp } \)在这个2D坐标系下旋转\(\theta \)度。从而得到等式：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ \vec v&amp;#39;_{\perp } =  cos\theta \vec v_{\perp } + sin\theta \vec w \]&lt;/p&gt;

&lt;p&gt;好了，所有变量都得到了，总结下最终的公式：&lt;/p&gt;

&lt;p&gt;\( \vec v_{\parallel } = (\vec v\cdot \vec n) \vec n \)&lt;/p&gt;

&lt;p&gt;\( \vec v_{\perp } = \vec v - \vec v_{\parallel} = \vec v -  (\vec v\cdot \vec n) \vec n \) &lt;/p&gt;

&lt;p&gt;\( \vec w = \vec n \times \vec v_{\perp } \) &lt;/p&gt;

&lt;p&gt;\( = \vec n \times (\vec v - \vec v_{\parallel}) \) &lt;/p&gt;

&lt;p&gt;\( = \vec n \times \vec v - \vec n \times \vec v_{\parallel}) \) &lt;/p&gt;

&lt;p&gt;\( = \vec n \times \vec v \) &lt;/p&gt;

&lt;p&gt;\( \vec v&amp;#39;_{\perp } =  cos\theta \vec v_{\perp } + sin\theta \vec w \)&lt;/p&gt;

&lt;p&gt;\( =  cos\theta (v - (\vec v\cdot \vec n) \vec n) + sin\theta (\vec n \times \vec v)  \)&lt;/p&gt;

&lt;p&gt;\( \vec v&amp;#39; = \vec v&amp;#39;_{\perp } + \vec v_{\parallel } \)&lt;/p&gt;

&lt;p&gt;\( = cos\theta (v - (\vec v\cdot \vec n) \vec n) + sin\theta (\vec n \times \vec v) + (\vec v\cdot \vec n) \vec n \)&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-14/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-14/</guid>
      </item>
    
      <item>
        <title>线性代数之视角矩阵Lookat Matrix</title>
        <description>&lt;h1&gt;引言&lt;/h1&gt;

&lt;p&gt;我对视角矩阵的理解是这样子的，假设3维空间有一个观察者（摄像机），这个观察者必然有它的坐标位置、视角、焦点，根据这3个参数，可以建立一个正交化、规范化的坐标系（一个正交化、单位化的3x3矩阵），这个坐标系对应的矩阵就是Lookat矩阵。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;根据上面这个我自己创造的定义，可以知道，Lookat矩阵只和观察者的坐标、焦点、视角有关，和被观察的东西完全无关，也就是说，Lookat矩阵是independent的，这个性质的好处是，这个观察者的Lookat矩阵，可以应用到任意目标上。&lt;/p&gt;

&lt;p&gt;观察者的坐标、焦点、视角，可以进一步抽象。观察者坐标位置设为eye向量，焦点位置设为focal向量，视角呢，比较特殊，是设为一个up向量，含义是这个观察者的头顶朝向。&lt;/p&gt;

&lt;p&gt;可以想象成，观察者就是你自己，你站在地面上，盯着远处一个美女，可以是盯着她的腿、她的腰，都无妨。&lt;/p&gt;

&lt;p&gt;看的过程中，你可以往左侧着头看，也可以倒立着看，不会影响focal向量，因为你的眼睛还是能看见美女。&lt;/p&gt;

&lt;p&gt;但是当你低头时，情况就有些变化了。第一种情况：你对着美女弯腰90度，focal向量变成指向了地面上的某个点，up向量虽然还是沿着你头部的方向，不过因为弯腰90度的关系，已经不是朝着上方了(大约是指向了美女的方向)；第二种情况是，你只是微微低头(大于15度这样子)，眼睛还是能看到美女（低头15度的视野和完全直立时一致），不过，up向量被改变了，因为你的头转了15度。&lt;/p&gt;

&lt;p&gt;通过这个例子，可以知道，focal向量和up向量之间是存在联系的，而eye向量则和focal、up向量没有关系，eye向量决定的是你所在的位置。&lt;/p&gt;

&lt;p&gt;唠嗑到这里，下面进入数学环节。&lt;/p&gt;

&lt;h1&gt;推导&lt;/h1&gt;

&lt;p&gt;当eye、focal、up三个向量的值确定后，就可以构造Lookat矩阵了。&lt;/p&gt;

&lt;p&gt;(额外补充：focal向量一般是通过计算被观察位置center和观察者的位置eye的差值得到的，focal = center - eye)&lt;/p&gt;

&lt;p&gt;首先明确2点：一，Lookat矩阵是正交且规范化的；二，我们使用的是右手坐标系。&lt;/p&gt;

&lt;p&gt;这个Lookat矩阵，相当于是一个坐标系，那么可以设三个坐标轴的方向向量分别为\(\vec r\)、\(\vec u\)、\(\vec f\)，分别的含义是，观察者坐标系的right、up、forward方向。&lt;/p&gt;

&lt;p&gt;\(\vec f\)可以轻松得到：它的朝向是focal的反方向。为什么呢？很简单，focal是指从观察者位置到焦点位置的方向向量，又因为我们用的是右手坐标系，那么观察者坐标系的f轴朝向当然是focal的反方向了。&lt;/p&gt;

&lt;p&gt;\[\vec f = - \frac {\overrightarrow {focal} }{|\overrightarrow {focal}|} \]&lt;/p&gt;

&lt;p&gt;接着是\(\vec r\)。显然，\(\vec r\)指的方向是，focal和up所构成的平面的垂线的正方向，即focal和up的叉积。&lt;/p&gt;

&lt;p&gt;\[\vec r = \frac {\overrightarrow {focal} \times \overrightarrow {up}}{|\overrightarrow {focal} \times \overrightarrow {up}|} \]&lt;/p&gt;

&lt;p&gt;\(\vec r\)、\(\vec f\)都得到后，\(\vec u\)就简单了，因为\(\vec r\)、\(\vec f\)已经规范化、正交化了的，那么\(\vec u\)就是他们的叉积：&lt;/p&gt;

&lt;p&gt;\[\vec u = \vec f \times \vec r \]&lt;/p&gt;

&lt;p&gt;设Lookat矩阵为M，则M等于：&lt;/p&gt;

&lt;p&gt;\[ M =  \left[ \begin{matrix} r_{x}&amp;amp;r_{y}&amp;amp;r_{z}&amp;amp;0\\  u_{x}&amp;amp;u_{y}&amp;amp;u_{z}&amp;amp;0\\  f_{x}&amp;amp;f_{y}&amp;amp;f_{z}&amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;拿这个M和单位矩阵I对比下：&lt;/p&gt;

&lt;p&gt;\[ I =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;可以发现，单位矩阵I相当于是把观察者放在世界空间的原点。因为I的\(\vec r\)、\(\vec u\)、\(\vec f\)已经是规范化、正交化的，且和世界坐标系一致。&lt;/p&gt;

&lt;p&gt;所以上面的M可以理解为：M等于M乘以I。含义是，把世界坐标系变换到观察者坐标系。也即相当于调整了对world的观察角度。&lt;/p&gt;

&lt;p&gt;到了这里，事情还没完，因为这个M并不能体现出观察者的&lt;strong&gt;位置&lt;/strong&gt;，为什么呢？因为\(\vec r\)、\(\vec u\)、\(\vec f\)是规范化的向量，长度都为1，并不包含位置信息。&lt;/p&gt;

&lt;p&gt;和单位矩阵I对比的话就清楚了，单位矩阵I之所以不需要位置信息，是因为单位矩阵I已经隐含了一个信息：观察位置就在(0,0,0)。&lt;/p&gt;

&lt;p&gt;观察位置，上面已经定义过了，它就是eye向量。&lt;/p&gt;

&lt;p&gt;把观察者放到eye位置，反过来想，相当于是把被观察的东西偏移-eye的距离。实际上，我们正在构造的Lookat矩阵，不是要作用到观察者身上，而是要作用到被观察者（world）身上的。&lt;/p&gt;

&lt;p&gt;因此，现在可以根据eye向量构造一个移动矩阵T(Translate)了：&lt;/p&gt;

&lt;p&gt;\[ T =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;-eye_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;-eye_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;-eye_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;然后把M和T合并，即得到了Lookat矩阵：&lt;/p&gt;

&lt;p&gt;\[ Lookat = MT \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} r_{x}&amp;amp;r_{y}&amp;amp;r_{z}&amp;amp;0\\  u_{x}&amp;amp;u_{y}&amp;amp;u_{z}&amp;amp;0\\  f_{x}&amp;amp;f_{y}&amp;amp;f_{z}&amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;-eye_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;-eye_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;-eye_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} r_{x}&amp;amp;r_{y}&amp;amp;r_{z}&amp;amp;-r_{x}eye_{x}-r_{y}eye_{y}-r_{z}eye_{z}\\  u_{x}&amp;amp;u_{y}&amp;amp;u_{z}&amp;amp;-u_{x}eye_{x}-u_{y}eye_{y}-u_{z}eye_{z}\\  f_{x}&amp;amp;f_{y}&amp;amp;f_{z}&amp;amp;-f_{x}eye_{x}-f_{y}eye_{y}-f_{z}eye_{z}\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;简化下：&lt;/p&gt;

&lt;p&gt;\[ Lookat =  \left[ \begin{matrix} r_{x}&amp;amp;r_{y}&amp;amp;r_{z}&amp;amp;-(\vec r\cdot \overrightarrow {eye})\\  u_{x}&amp;amp;u_{y}&amp;amp;u_{z}&amp;amp;-(\vec u\cdot \overrightarrow {eye})\\  f_{x}&amp;amp;f_{y}&amp;amp;f_{z}&amp;amp;-(\vec f\cdot \overrightarrow {eye})\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-13/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-13/</guid>
      </item>
    
      <item>
        <title>线性代数之透视矩阵Perspective Matrix</title>
        <description>&lt;p&gt;本文部分内容翻译自：&lt;a href=&quot;http://www.ogldev.org/www/tutorial12/tutorial12.html&quot;&gt;Tutorial 12: Perspective Projection&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文介绍的是OpenGL中的透视矩阵。&lt;/p&gt;

&lt;h1&gt;介绍&lt;/h1&gt;

&lt;p&gt;所谓的透视矩阵，指的是一个“降维”的转换过程。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;设想下一个在3维空间里的3D模型，它必然拥有一些顶点信息，设其中任意顶点的坐标为(x,y,z,1)（后面的1是齐次坐标的意思），当我们需要把这个模型投影到某个平面上时，它就从3维变成了2维（看过三体3的童鞋就容易理解了，这就是二向箔!），而顶点坐标(x,y,z,1)则变成(x&lt;code&gt;,y&lt;/code&gt;,d,?)。&lt;/p&gt;

&lt;p&gt;可以注意到，经过透视变换后的顶点，依然是四维的形式，只是含义变了，其中的(x&lt;code&gt;,y&lt;/code&gt;)分量指的是这个顶点在投影平面上的坐标(显然是因为投影平面相当于一个2维坐标系)。d指的是这个投影点的深度(depth)，d一般是规范化的，范围是[-1,1]。d的作用在下一个渲染阶段(Depth Test)大有用处。而后面的?，无法一言蔽之，下文会讲到这个问题。&lt;/p&gt;

&lt;h1&gt;视锥体 Frustum&lt;/h1&gt;

&lt;p&gt;视锥体，指的是一个有限的椎体空间，处于这个视锥体里的对象，才是“可见”的对象，可见的对象会被渲染到“视平面”上（三维到二维的投影）。视锥体有4个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aspect ratio，简称ar，ar = 视平面width/视平面height&lt;/li&gt;
&lt;li&gt;（vertical）field of view，简称fov，指yz平面的视角大小，即下文的\( \alpha \)角。&lt;/li&gt;
&lt;li&gt;near Z Plane，简称near面，是一个平行于xy平面的面，世界坐标系下是一个浮点值，可以用来裁剪太靠近摄像机的物体&lt;/li&gt;
&lt;li&gt;far Z Plane，简称far面，含义类似near面，可以用来裁剪太远离摄像机的物体&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;视平面可以认为是视锥体的near面；far面相对来说并没有那么重要，因为我们知道人眼的“视锥体”是没有far面的（比如裸眼可以看到月亮星星，far面其实是无限远的），在图形学中，far面主要是用来裁剪太过遥远的物体、提高渲染效率的。&lt;/p&gt;

&lt;p&gt;下面这个是我找到的一个视锥体的演示程序，非常直观地展示了视锥体的作用：&lt;/p&gt;

&lt;div&gt;
  &lt;iframe class=&quot;webgl_example&quot; style=&quot;width: 400px; height: 600px;&quot; src=&quot;http://webglfundamentals.org/webgl/frustum-diagram.html&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://webglfundamentals.org/webgl/lessons/webgl-3d-perspective.html&quot;&gt;演示程序来源：http://webglfundamentals.org/webgl/lessons/webgl-3d-perspective.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从摄像机位置（一个点）观察视平面的话，是长这样子的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.3/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图片来自www.ogldev.org)&lt;/p&gt;

&lt;p&gt;y轴范围是[-1,1]，x轴范围是[-ar,ar]，因为ar = 视平面width/视平面height，其实也就是ar=屏幕width/屏幕height，因为大部分屏幕都是宽屏，所以ar的值一般是大于1的。当屏幕宽高一致时，视平面才是上面这幅图的样子。&lt;/p&gt;

&lt;p&gt;现在，换成侧视角来观察这个视锥体(yz平面)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.3/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图片来自www.ogldev.org，有修改)&lt;/p&gt;

&lt;p&gt;红线是投影面(视平面)，绿色线是摄像机到投影面的向量d，\(\alpha \)角即是fov。注意，OpenGL在“世界坐标系”中，用的是右手坐标系，所以上图中，z轴的左边才是1、右边是-1。因此，向量d的长度是-d（要取反，不然会计算错误）。综上，可以得出：&lt;/p&gt;

&lt;p&gt;\[ tan(\frac {\alpha } { 2 } ) = \frac {1} {|\vec d|} \]&lt;/p&gt;

&lt;p&gt;\[  |\vec d| = -d = \frac {1} { tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;接下来是求某顶点\( (x,y,z,w) \)在投影面上的投影坐标\( (x_{p},y_{p},z_{p},w_{p}) \)。 看下面的侧视图，我们可以先求解\( y_{p} \)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.3/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;根据相似三角形定理，可以得到：&lt;/p&gt;

&lt;p&gt;\[ \frac {y_{p} } { |\vec d| } = \frac { y } { -z } \]&lt;/p&gt;

&lt;p&gt;\[ y_{p} = \frac { y * |\vec d| } { -z } = \frac { y } { -z * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;注意，这里的z需要取反，因为上面的等式里，\(y_{p}\)和y同符号，\(|\vec d|\)是正号，而z显然本身是负值，所以z要取反。&lt;/p&gt;

&lt;p&gt;同样的，x分量也可以用相同的公式求得：&lt;/p&gt;

&lt;p&gt;\[ \frac {x_{p} } { |\vec d| } = \frac { x } { -z } \]&lt;/p&gt;

&lt;p&gt;\[ x_{p} = \frac { x * |\vec d| } { -z } = \frac { x } { -z * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;此时要考虑到一个问题： \( y_{p} \)的范围是[-1,1]，而\( x_{p} \)是[-ar, ar]。为了让\( x_{p} \)和\( y_{p} \)一致，需要让\( x_{p} \)除以ar，从而得到：&lt;/p&gt;

&lt;p&gt;\[ x_{p} = \frac { x } { -z * ar * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;\[ y_{p} = \frac { y } { -z * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;到了这里，我们可以开始构造下透视矩阵了：&lt;/p&gt;

&lt;p&gt;\[ Perspective Matrix = M =  \left[ \begin{matrix} a&amp;amp;b&amp;amp;c&amp;amp;d\\ e&amp;amp;f&amp;amp;g&amp;amp;h\\ i&amp;amp;j&amp;amp;k&amp;amp;l\\ m&amp;amp;n&amp;amp;o&amp;amp;p\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;被转换的顶点的坐标(矩阵)是：&lt;/p&gt;

&lt;p&gt;\[ V =  \left[ \begin{matrix} x\\ y\\ z\\ w\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;转换后的投影点是:&lt;/p&gt;

&lt;p&gt;\[ V_{p} =  \left[ \begin{matrix} x_{p} \\ y_{p} \\ z_{p} \\ w_{p} \\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;转换过程:&lt;/p&gt;

&lt;p&gt;\[ MV = V_{p} \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} a&amp;amp;b&amp;amp;c&amp;amp;d\\ e&amp;amp;f&amp;amp;g&amp;amp;h\\ i&amp;amp;j&amp;amp;k&amp;amp;l\\ m&amp;amp;n&amp;amp;o&amp;amp;p\\ \end{matrix} \right]  \left[ \begin{matrix} x\\ y\\ z\\ w\\ \end{matrix} \right]  =  \left[ \begin{matrix} x_{p} \\ y_{p} \\ z_{p} \\ w_{p} \\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;从以上等式可以得到:&lt;/p&gt;

&lt;p&gt;\[ ax + by + cz + dw = x_{p} = \frac { x } {  -z * ar * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;这是M矩阵第一行和V的点积等式。求解这个等式的话，会发现可以让b=0、d=0，从而等式简化成:&lt;/p&gt;

&lt;p&gt;\[ ax + cz = \frac { x } { -z * ar * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;这样做后就有了个问题：找不到可以代入a、c的常量值。其中左边比较多余的cz项，如果可以干掉的话，意味着c必须等于0。这么做后，等式进而变成:&lt;/p&gt;

&lt;p&gt;\[ ax = \frac { x } { -z * ar * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;观察等式，可以发现等式右边有个多余的z。OpenGL中对这个问题的处理是，在变换过程中强(偷)制(偷)插入一个步骤：把矩阵相乘的结果值再统一除以-z。对，没错，确实是-z而不是z，负号的作用是把坐标从右手坐标系转换到左手坐标系，原因是NDC(Normalized Device Coord)坐标系是左手坐标系，即NDC的z轴的正方向是朝向屏幕里面的。这个除以-z的技巧被称为&lt;strong&gt;Perspective Divide&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这么做之后，事情就简单了，上面的等式可以推出：&lt;/p&gt;

&lt;p&gt;\[ a = \frac { 1 } { ar * tan(\frac {\alpha } { 2 } ) }  \]&lt;/p&gt;

&lt;p&gt;对于M矩阵的f，用同样的做法可以得到:&lt;/p&gt;

&lt;p&gt;\[ f = \frac { 1 } { tan(\frac {\alpha } { 2 } ) }   \]&lt;/p&gt;

&lt;p&gt;从而得到了M的前两行的值：&lt;/p&gt;

&lt;p&gt;\[ M =  \left[ \begin{matrix} \frac { 1 } { ar * tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;\frac { 1 } { tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0\\ i&amp;amp;j&amp;amp;k&amp;amp;l\\ m&amp;amp;n&amp;amp;o&amp;amp;p\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;到了这里，其实透视变换问题已经解决大半了，因为\(x_{p}\)和\(y_{p}\)都可以算了，并且可以规范化到[-1,1]范围。剩下的问题是\(z_{p}\)，即顶点的深度信息。&lt;/p&gt;

&lt;p&gt;前面提到的&lt;strong&gt;Perspective Divide&lt;/strong&gt;会导致一个问题：z分量在转换过程中会因为&lt;strong&gt;Perspective Divide&lt;/strong&gt;而导致变成-1。针对这个问题，OpenGL的解决方案是，把V的z值取反并复制覆盖到w上，从而把原始z值保存起来（也就是M矩阵的第四行所负责的事情），同时&lt;strong&gt;Perspective Divide&lt;/strong&gt;仅对x、y、z有效（跳过w）。&lt;/p&gt;

&lt;p&gt;因此，M的后两行也可以得到了：&lt;/p&gt;

&lt;p&gt;\[ M =  \left[ \begin{matrix} \frac { 1 } { ar * tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;\frac { 1 } { tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;-1&amp;amp;0\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;然而，事情还没有结束。现在用这个新的M去做透视变换后，得不到规范化的z分量。规范化的，可以使得后续的渲染步骤不需要知道near Z和far Z。为了完成这个事情，需要对M做改进，着手点就是row 3，全为0的第三行。&lt;/p&gt;

&lt;p&gt;再阐述一下问题：我们需要求出row3=(i,j,k,l)，使得row3和V做点积运算能得到规范化的\(z_{p}\)。用公式表示：&lt;/p&gt;

&lt;p&gt;\[z_{p} = Az + B , z_{p}\in [-1,1] \]&lt;/p&gt;

&lt;p&gt;再考虑上&lt;strong&gt;Perspective Divide&lt;/strong&gt;，上式变成：&lt;/p&gt;

&lt;p&gt;\[z_{p} = A + \frac {B}{-z} , z_{p}\in [-1,1] \]&lt;/p&gt;

&lt;p&gt;思路非常明确了：把公式中的A、B求出来，代入row3，就能解决问题。&lt;/p&gt;

&lt;p&gt;因为当z等于near Z时，\(z_{p}\)必然等于1；当z等于far Z时，\(z_{p}\)必然等于-1 (Note：这里用的是右手坐标系）。因此得到：&lt;/p&gt;

&lt;p&gt;\[ A + \frac {B}{-NearZ} = 1 \]&lt;/p&gt;

&lt;p&gt;\[ A = 1 - \frac {B}{-NearZ} = 1 + \frac {B}{NearZ}  \]&lt;/p&gt;

&lt;p&gt;接着：&lt;/p&gt;

&lt;p&gt;\[ A + \frac {B}{-FarZ} = -1 \]&lt;/p&gt;

&lt;p&gt;\[ 1 + \frac {B}{NearZ} - \frac {B}{FarZ} = -1 \]&lt;/p&gt;

&lt;p&gt;\[ \frac {B*FarZ - B*NearZ}{NearZ*FarZ} = -2 \]&lt;/p&gt;

&lt;p&gt;\[ B = \frac {-2*NearZ*FarZ}{FarZ - NearZ} = \frac {2*NearZ*FarZ}{NearZ - FarZ}  \]&lt;/p&gt;

&lt;p&gt;B解决了，求A：&lt;/p&gt;

&lt;p&gt;\[ A = 1 + \frac {B}{NearZ}  = 1 + \frac {2*FarZ*NearZ}{NearZ*(NearZ - FarZ)} \]&lt;/p&gt;

&lt;p&gt;\[ A = 1 + \frac {2*FarZ}{NearZ - FarZ}  \]&lt;/p&gt;

&lt;p&gt;\[ A =\frac {NearZ - FarZ + 2*FarZ}{NearZ - FarZ}\]&lt;/p&gt;

&lt;p&gt;\[ A = \frac {NearZ + FarZ}{NearZ - FarZ} \]&lt;/p&gt;

&lt;p&gt;有了A、B后，就可以求row3了:&lt;/p&gt;

&lt;p&gt;\[ ix +jy +kz +lw = Az + B \]&lt;/p&gt;

&lt;p&gt;显然，可让i = j = 0，那么上式变成:&lt;/p&gt;

&lt;p&gt;\[ kz + lw = Az + B \]&lt;/p&gt;

&lt;p&gt;因为V的w分量必然是1，所以可以得知：k = A，l = B。&lt;/p&gt;

&lt;p&gt;代入M，得到最终完善的M：&lt;/p&gt;

&lt;p&gt;\[ M =  \left[ \begin{matrix} \frac { 1 } { ar * tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;\frac { 1 } { tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;\frac {NearZ + FarZ}{NearZ - FarZ}&amp;amp;\frac {2*FarZ*NearZ}{NearZ - FarZ}\\ 0&amp;amp;0&amp;amp;-1&amp;amp;0\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;再对比下superbible7中构造透视矩阵的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mat4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;perspective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fovy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;radians&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fovy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mat4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细观察，发现有1处不同：这个函数构造的矩阵是列主导的矩阵。其中元素的取值和本文的推导完全一致！&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-12/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-12/</guid>
      </item>
    
      <item>
        <title>《OpenGL编程指南(第8版)》阅读笔记01</title>
        <description>&lt;h1&gt;Example源码Bug备忘&lt;/h1&gt;

&lt;h2&gt;第三章&lt;/h2&gt;

&lt;h3&gt;ch03_drawcommands&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;n&quot;&gt;glUniformMatrix4fv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;render_model_matrix_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model_matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应改为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;n&quot;&gt;glUniformMatrix4fv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;render_model_matrix_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model_matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原因：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);&lt;/p&gt;

&lt;p&gt;Parameters&lt;/p&gt;

&lt;p&gt;location&lt;/p&gt;

&lt;p&gt;Specifies the location of the uniform value to be modified.&lt;/p&gt;

&lt;p&gt;count&lt;/p&gt;

&lt;p&gt;Specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is &amp;gt; not an array of matrices, and 1 or more if it is an array of matrices.&lt;/p&gt;

&lt;p&gt;transpose&lt;/p&gt;

&lt;p&gt;Specifies whether to transpose the matrix as the values are loaded into the uniform variable. Must be GL_FALSE.&lt;/p&gt;

&lt;p&gt;value&lt;/p&gt;

&lt;p&gt;Specifies a pointer to an array of count values that will be used to update the specified uniform variable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为例子使用的是primitive_restart.vs.glsl顶点着色器，model_matrix不是数组，所以参数count应该为1。&lt;/p&gt;

&lt;p&gt;还发现了一句注释： // &amp;quot;model_matrix&amp;quot; is actually an array of 4 matrices&lt;/p&gt;

&lt;p&gt;不明白为什么model_matrix会是一个包含4个矩阵的数组。并且确实改成1后就能运行了。&lt;/p&gt;

&lt;p&gt;(后面发现有一个shader里面的model_matrix确实是一个长度4的数组...估计是混淆了吧)&lt;/p&gt;

&lt;p&gt;真是坑。&lt;/p&gt;

&lt;h3&gt;vmath&lt;/h3&gt;

&lt;p&gt;vmath::rotation 要改为 vmath::rotate
vmath::translation 要改为 vmath::translate&lt;/p&gt;

&lt;h3&gt;绝对路径....&lt;/h3&gt;

&lt;p&gt;ch03_instancing的Initialize函数里：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;c1&quot;&gt;// Load the object&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoadFromVBM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;C:/Vermilion-Book/trunk/Code/media/armadillo_low.vbm&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;太坑了。&lt;/p&gt;

&lt;h3&gt;把vs和fs写在cpp文件里&lt;/h3&gt;

&lt;p&gt;如果是为了演示如何手动编译shader，也不用放在多个example里吧。&lt;/p&gt;

&lt;h2&gt;第四章&lt;/h2&gt;

&lt;h3&gt;ch04_shadowmap的vbm.h和vbm.cpp是不对的，运行会出错&lt;/h3&gt;

&lt;p&gt;换成第三章的工程里的就OK了。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/openl-01/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/openl-01/</guid>
      </item>
    
      <item>
        <title>我的2015总结</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;Career&lt;/h1&gt;

&lt;p&gt;2015年是我career发生大改变的一年。&lt;/p&gt;

&lt;p&gt;毕业后我在某益工作了接近两年。在2015年春季，我选择了离去。&lt;/p&gt;

&lt;p&gt;为什么要走呢?说大了讲，是个人和公司价值观的不同，说小了讲，是对这种生活的厌倦。&lt;/p&gt;

&lt;p&gt;做这个决定并不轻松。家里人和女朋友其实是不喜欢我跳槽的，个中原因主要是收入。钱、时间、理想，这3个东西太难权衡，本文最后再分享下我对它们的思考。&lt;/p&gt;

&lt;p&gt;走的时候是4月份，走之前，我完成了项目的战斗系统的构建，算是有始有终；走之后，这项目也如预期一样，砍掉了。&lt;/p&gt;

&lt;p&gt;2年时间，参与的项目一个个地因为各种和我个人没有关系的原因而失败，深深体会到作为普通软件工程师的无力感。为了改变现状，我想我必须去做一些和以往不同的事情。如何实施？这是我2015年下旬的思考内容。&lt;/p&gt;

&lt;p&gt;2015下旬，我进入了一家创业公司：壕游戏。整个公司包括我只有10个人左右。目前，一切安好。&lt;/p&gt;

&lt;p&gt;虽然这是一家创业公司，但是没有当年刚加入某益时的那种压力。公司一切相对轻松、自由，每个员工都可以畅所欲言，即使是程序员也能对项目提出建议。这也是我认为的正确的企业文化之一。然而，这种轻松的氛围却容易导致员工的松懈。我下了决心换了工作，并不是为了放松、享乐，我是为了改变现状而离开某益。我不安，因周围的同学跑得太快，生怕懒惰而落下，且我也没有在20多岁就开始享乐的资本。&lt;/p&gt;

&lt;p&gt;所以，我接受了工作上的任何挑战。这半年时间，我给公司开发了一套游戏服务器系统，做各种小优化工具，解决各种疑难问题，并独立负责3个项目的开发(实际上有2个已经因为某些原因而搁置)。做的事情还算不少吧。我也顺利地从python阵营转入js阵营。js和c++将是我今后在编程上的两把重要兵器。&lt;/p&gt;

&lt;p&gt;新工作因为不用加班，给了我更多的时间做自己的事情，很多计划都得以实施，看书的时间变多，也有时间写blog、学英语。甚至还学会了做各种中式饭菜= =。&lt;/p&gt;

&lt;p&gt;这半年时间，我也对自己今后的career有了新的决策，以下是todolist(也是2016年的计划)：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;努力提高技术实力。我相信个人技术的提升，在达到一定程度时会对我的career有重大影响。打算在2016年逐步把以前半懂半不懂的东西都给研究清楚，包括图形学、机器学习等我感兴趣的学科的数学、算法基础知识。搞懂了原理后，要做什么开发都会更得心应手。具体做法是，看书、写代码实践。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写博客。作为engineer，怎么可以没有一个自己的技术博客呢。写博客这个事情，我觉得有不少好处：巩固学到的知识、方便日后复习知识、锻炼写作表达能力、方便个人marketing(目前还没有效果)。百利而无一害，除了打字比较费功夫(把娱乐节目砍掉就抵消了)。实际上，我写博客是从大二开始的，期间写写停停，陆陆续续换了几个博客系统，从cppblog第三方博客到github静态博客，然而毕业后因为工作繁忙，完全荒废了。辞职前，我开始捡回我“写博客的梦想”。辞旧迎新，我把旧的博客git整个删了(旧博文现在看来，太无聊了)，同时也因为那个博客的框架代码是大三时借鉴其他博主的代码弄出来的，不是自己的代码，难以维护。现在我改用jekyll-now来搭建博客，更简单易用。也因为2014年下半年的驻梦项目，我的web开发实力有了大大的提高，新博客在技术上也没什么隐患了。目前新博客已经持续写了半年。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提高英语能力。“听”会通过听有声书提高，“读”和“说”通过阅读英文文章(技术书、Quora等)、朗读英文小说来提高。我在EF的学习也即将步入尾声。总的来说，这段经历使得我对语言学习产生了更大的兴趣和自信，是一个好的转折点。但之后应该不会再花大钱在外语学习上了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;Life&lt;/h1&gt;

&lt;p&gt;2015年除了过年时去了杭州，由于工作上的不顺心(其实是没钱)，之后都没有外出旅行。2015开始，更重视的是积蓄的问题，因为我发现工作2年后，依然存不到多少钱，对建立家庭来说，远远不足。在中国白手起家想要做到安居乐业，有车有房，完全就是一个Hard难度的游戏。当然，游戏虽难，但仍有希望。&lt;/p&gt;

&lt;p&gt;2015年，家庭关系比较和谐，没出啥状况。和GF也还行，有波澜但终归和睦。2014年年底我们一起通宵打Minecraft，那时候她是一名见习医生；2015年年底我们一起通宵打Don&amp;#39;t Starve Together，这时候，她已经走在职业转型的道路上，即将成为一名美术生。也许以后我们会一起做独立游戏。可能这就是destiny吧。&lt;/p&gt;

&lt;p&gt;对于物质生活，我是有期待的，但是暂时无法提高，也就不勉强。其它不实际的期待也没有了，只但愿这副身子骨不散架，平平安安，就好。&lt;/p&gt;

&lt;p&gt;存钱的问题，其实就是买房结婚生孩子的问题，连这个问题都搞不定，事业就不算成功。2016年如无意外，也不能够解决这个问题。现在唯一能做的事情只是投资自己、好好学习。通过游戏开发以外的方法赚钱，也难。&lt;/p&gt;

&lt;h1&gt;My Philosophy Changed&lt;/h1&gt;

&lt;p&gt;最近和朋友分享过我的哲学观:一个我自己都认为不对的效益主义(utilitarianism)。凡事衡量、计算得失，择优而行。然而，这个方法不总是有效，因为有些事情，做不做，无法立即得到回报，相当于长远的、有一定风险的投资。譬如我可以花很多时间精力去广交朋友，做个人marketing，然而我无法确定这对我是不是一件好事。我现在的哲学观是：喜欢就做，不喜欢就不做。这可能无法得到最优解，但起码可以让我活得不像是个只会计算得失的机器。有时候想太多真的没用。&lt;/p&gt;

&lt;p&gt;至于钱、时间、理想，我是这样看的：没钱的时候不能一味追求理想，应该先求生存再求发展；没钱的时候可以用时间换钱(去打工，哪怕是派传单)；有钱的时候用钱买时间(譬如回家不坐火车坐飞机，买高配的机器提高开发效率节省时间)。也即是说，要根据当下条件，做相应的决策。&lt;/p&gt;

&lt;p&gt;所以我觉得我现在，是最适合追求理想的，因未成家，没有太多开销，时间基本都是自己的(有一定的时间)，同时收入也足够维持日常开销(有一定的钱)。怕是再过几年，再追求什么大理想，就更艰难了。&lt;/p&gt;

&lt;p&gt;珍惜当下。&lt;/p&gt;

&lt;p&gt;Goodbye 2015。&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/summarize/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/summarize/</guid>
      </item>
    
      <item>
        <title>曲线数学之B样条曲线B-Spline</title>
        <description>&lt;p&gt;上一篇文章已经介绍了贝塞尔曲线。本篇文章接着介绍B样条曲线。&lt;/p&gt;

&lt;p&gt;B样条曲线，简单来说，它是对贝塞尔曲线的一个补充。为什么这样说呢？是因为贝塞尔曲线某些情况下不实用：曲线上每个点受所有控制点影响，这会给调整曲线工作带来麻烦。可以想到的第一个优化是，把整个贝塞尔曲线变成多段贝塞尔子曲线的拼接。然而，这个方案也不好用，因为拼接工作很难做好，因为要拼接曲线显得“光滑”前提是保证相邻曲线之间的连续性。&lt;/p&gt;

&lt;p&gt;于是，老外发明了一个算法:&lt;a href=&quot;https://en.wikipedia.org/wiki/De_Boor%27s_algorithm&quot;&gt;De Boor&amp;#39;s algorithm&lt;/a&gt;，基于这个算法的曲线也被称为贝塞尔曲线的变种：B-Spline(B样条)曲线。为什么叫Spline曲线呢？我猜是因为Spline曲线在4个控制点的情况下，有个典型的形状：&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.12/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;是不是有点像一条脊椎(spine)？(跑题了= =)&lt;/p&gt;

&lt;p&gt;下文开始进入数学部分。&lt;/p&gt;

&lt;h1&gt;B-Spline的定义&lt;/h1&gt;

&lt;p&gt;B-Spline曲线我所知道的第一种估计也是最主要的定义：递归定义，其实是贝塞尔曲线的递归定义的一般化。先搬出贝塞尔的递归定义：&lt;/p&gt;

&lt;p&gt;\[ P_{i}^{k} =\begin {cases} P_{i}  【k=0】 \\  (1-t)P_{i}^{k-1}+tP_{i+1}^{k-1} 【k=1,2,\cdots ,n,i=0,1,\cdots ,n-k】 \end {cases}  \]&lt;/p&gt;

&lt;p&gt;而B-Spline是：&lt;/p&gt;

&lt;p&gt;\[ N_{i}^{n}(x) = \frac {x-u_{i}}{u_{i+n}-u_{i}}N_{i}^{n-1}(x) + \frac {u_{i+n+1} - x}{u_{i+n+1}-u_{i+1}}N_{i+1}^{n-1}(x) \]&lt;/p&gt;

&lt;p&gt;\[ N_{i}^{0}(x) =\begin {cases} 1  【x \in [ u_{i},u_{i+1} ) 】 \\ 0  【otherwise】 \end {cases} \]&lt;/p&gt;

&lt;p&gt;(怎么也能看出一丝相似吧。)&lt;/p&gt;

&lt;p&gt;从公式来看，似乎是变复杂了。然而其实现代码可以很简单，比如github上的这个js实现:&lt;a href=&quot;https://github.com/thibauts/b-spline&quot;&gt;https://github.com/thibauts/b-spline&lt;/a&gt;，它的B-Spline核心代码只有10行不到(OTL)。&lt;/p&gt;

&lt;p&gt;对于这条公式的剖析，我发现有人已经做得机好了：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/tuqu/article/details/4749586&quot;&gt;B-样条曲线教程B-spline Curves Notes目录&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/tuqu/article/details/5177405&quot;&gt;B-样条基函数：定义 B-spline Basis Functions: Definition&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;扒了下原文，原来是密西根理工大学的教学讲义: &lt;a href=&quot;http://www.cs.mtu.edu/%7Eshene/COURSES/cs3621/NOTES/&quot;&gt;http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果认真看完这些资料，基本该懂的都懂了。&lt;/p&gt;

&lt;p&gt;因为我自己来写B-Spline剖析肯定写不到这个深度，当然也没必要。所以我做了点别的事情：写了一个curve designer：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://voyagingmk.github.io/curvedesigner/&quot;&gt;curve designer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(这个东西基于zebra WebUI和上面那个bspline，顺便吐槽下，zebra没有看起来那么好用)&lt;/p&gt;

&lt;p&gt;目的是实现一个B样条曲线的可视化编辑器，通过改变参数来理解B样条的实际特性。这可比看公式看论文爽多了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.12/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/b-spline-1/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/b-spline-1/</guid>
      </item>
    
      <item>
        <title>曲线数学之贝塞尔曲线Bézier Curves</title>
        <description>&lt;p&gt;本文主要关注的是公式的推导。&lt;/p&gt;

&lt;p&gt;在讲贝塞尔曲线之前先复习下组合数学。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;组合数学&lt;/h1&gt;

&lt;h2&gt;排列 permutation&lt;/h2&gt;

&lt;p&gt;注意，排列的英文是permutation，这个词也就是线性代数里的“置换”。联想置换矩阵的概念，就可以近似理解“排列”的意义。&lt;/p&gt;

&lt;p&gt;permutation的公式是：&lt;/p&gt;

&lt;p&gt;\[ P(n,k) = P_{n}^{k} = \frac {n!}{(n-k)!} \]&lt;/p&gt;

&lt;p&gt;含义：从n个数取出某k个数总共有多少种排列。&lt;/p&gt;

&lt;p&gt;所以，排列是&lt;strong&gt;有顺序&lt;/strong&gt;的。&lt;/p&gt;

&lt;h2&gt;组合 combination&lt;/h2&gt;

&lt;p&gt;组合这个东西可以用“排列”来理解，比如对于某3个不同的数a、b、c，有\[ P_{3}^{3} = \frac {3!}{(3-3)!} = 6 \]种排列: abc、acb、bac、bca、cab、cba，然而，组合数只有一个，也就是[a、b、c]。&lt;/p&gt;

&lt;p&gt;所以，组合是&lt;strong&gt;没有顺序&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;combination的公式是：&lt;/p&gt;

&lt;p&gt;\[ C(n,k)  = C_{n}^{k} = \frac { P_{n}^{k} } { P_{k}^{k} } = \frac {n!}{k!(n-k)!} , 0 &amp;lt; k &amp;lt;= n\]&lt;/p&gt;

&lt;p&gt;性质1：&lt;/p&gt;

&lt;p&gt;\(  C_{n}^{k} = \frac {n!}{k!(n-k)!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{(n-(n-k))!(n-k)!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{(n-k)!(n-(n-k))!} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{n-k} \)&lt;/p&gt;

&lt;p&gt;性质2：&lt;/p&gt;

&lt;p&gt;\[  C_{n}^{k} = \frac {n!}{k!(n-k)!} = 0 【 k &amp;lt; 0 ， k &amp;gt; n】 \] &lt;/p&gt;

&lt;p&gt;(当k&lt;0或k&gt;n时，右边的式子会出现负数的阶乘。负数阶乘在组合数公式的计算中，可以认为等于0)&lt;/p&gt;

&lt;p&gt;combination很重要，比如说二项式定理里的展开式就用到了它：&lt;/p&gt;

&lt;p&gt;\[ (a+b)^{n} = \sum_{r=0}^{n}C_{n}^{r}a^{n-r}b^{r} \]&lt;/p&gt;

&lt;p&gt;combination还有一条公式要注意下：&lt;/p&gt;

&lt;p&gt;\[ C_{n}^{k} = C_{n-1}^{k-1} + C_{n-1}^{k} , 0 &amp;lt; k &amp;lt; n \]&lt;/p&gt;

&lt;p&gt;顺便给个简单证明：&lt;/p&gt;

&lt;p&gt;\( C_{n-1}^{k-1} + C_{n-1}^{k} = \)&lt;/p&gt;

&lt;p&gt;\( \frac {(n-1)!}{(n-1-(k-1))!(k-1)!} + \frac {(n-1)!}{(n-1-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {(n-1)!}{(n-k)!(k-1)!} + \frac {(n-1)!}{(n-1-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {k(n-1)!}{k(n-k)!(k-1)!} + \frac {(n-k)(n-1)!}{(n-k)(n-1-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {k(n-1)!}{(n-k)!k!} + \frac {(n-k)(n-1)!}{(n-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {k(n-1)!+(n-k)(n-1)!}{(n-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {n(n-1)!}{(n-k)!k!}  =  \frac {n!}{(n-k)!k!}  =   C_{n}^{k} \)&lt;/p&gt;

&lt;h1&gt;贝塞尔曲线&lt;/h1&gt;

&lt;h2&gt;定义&lt;/h2&gt;

&lt;p&gt;给定n个控制点\(P_{0},P_{1},\cdots ,P_{n}\)，贝塞尔曲线的公式如下：&lt;/p&gt;

&lt;p&gt;\[ P(t) = \sum_{i=0}^{n}P_{i}B_{i,n}(t) , t\in [0,1] \]&lt;/p&gt;

&lt;p&gt;其中的\( B_{i,n}(t) \)叫Bernstein polynomial，定义如下：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(t) = C_{n}^{i}t^{i}(1-t)^{n-i} = \frac {n!}{i!(n-i)!}t^{i}(1-t)^{n-i} 【i=0,1,\cdots ,n】 \]&lt;/p&gt;

&lt;h2&gt;Bézier曲线的特性&lt;/h2&gt;

&lt;p&gt;特性1：改变单个控制点会引起整条曲线的改变。&lt;/p&gt;

&lt;h2&gt;Bernstein polynomial的特性&lt;/h2&gt;

&lt;h4&gt;递归性&lt;/h4&gt;

&lt;p&gt;\[ B_{i,n}(t) = (1-t)B_{i,n-1}(t) + tB_{i-1,n-1}(t)   【i=0,1,\cdots ,n】 \]&lt;/p&gt;

&lt;p&gt;证明：&lt;/p&gt;

&lt;p&gt;\( B_{i,n}(t) \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{i}t^{i}(1-t)^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n-1}^{i-1} + C_{n-1}^{i})t^{i}(1-t)^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n-1}^{i-1}t^{i}(1-t)^{n-i} + C_{n-1}^{i}t^{i}(1-t)^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)C_{n-1}^{i}t^{i}(1-t)^{(n-1)-i} + tC_{n-1}^{i-1}t^{i-1}(1-t)^{(n-1)-(i-1)} \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)B_{i,n-1}(t) + tB_{i-1,n-1}(t) \)&lt;/p&gt;

&lt;h4&gt;归一性&lt;/h4&gt;

&lt;p&gt;\[ \sum_{i=0}^{n}B_{i,n}(t) \equiv 1   【t\in (0,1)】 \]&lt;/p&gt;

&lt;p&gt;证明：&lt;/p&gt;

&lt;p&gt;根据二项式定理有：&lt;/p&gt;

&lt;p&gt;\[ \sum_{i=0}^{n}B_{i,n}(t) \]
\[ = \sum_{i=0}^{n}C_{n}^{i}t^{i}(1-t)^{n-i} \]
\[ [(1-t)+t]^{n} \equiv 1  \]&lt;/p&gt;

&lt;h4&gt;Partition of Unity&lt;/h4&gt;

&lt;p&gt;\[ \sum_{i=0}^{n}B_{i,n}(t) = \sum_{i=0}^{n-1}B_{i,n-1}(t) = 1 \]&lt;/p&gt;

&lt;p&gt;证明:&lt;/p&gt;

&lt;p&gt;利用递归公式，有：&lt;/p&gt;

&lt;p&gt;\( \sum_{i=0}^{n}B_{i,n}(t) \)&lt;/p&gt;

&lt;p&gt;\( = \sum_{i=0}^{n}[(1-t)B_{i,n-1}(t) + tB_{i-1,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = \sum_{i=0}^{n}[(1-t)B_{i,n-1}(t)] + \sum_{i=0}^{n}[tB_{i-1,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)\sum_{i=0}^{n}[B_{i,n-1}(t)] + t\sum_{i=0}^{n}[B_{i-1,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)[\sum_{i=0}^{n-1}B_{i,n-1}(t) + B_{n,n-1}(t) ] + t[\sum_{i=1}^{n}B_{i-1,n-1}(t) + B_{-1,n-1}(t) ] \)&lt;/p&gt;

&lt;p&gt;因为:&lt;/p&gt;

&lt;p&gt;\[ B_{n,n-1}(t) = C_{n-1}^{n}t^{n}(1-t)^{n-1-n} = 0 \]&lt;/p&gt;

&lt;p&gt;\[ B_{-1,n-1}(t) = C_{n-1}^{-1}t^{-1}(1-t)^{(n-1)-(-1)} = 0 \]&lt;/p&gt;

&lt;p&gt;(这里利用了上文提到的组合数公式性质2)&lt;/p&gt;

&lt;p&gt;所以可简化为：&lt;/p&gt;

&lt;p&gt;\( \sum_{i=0}^{n}B_{i,n}(t) \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)[\sum_{i=0}^{n-1}B_{i,n-1}(t)] + t[\sum_{i=1}^{n}B_{i-1,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)[\sum_{i=0}^{n-1}B_{i,n-1}(t)] + t[\sum_{i=0}^{n-1}B_{i,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = (1-t+t)[\sum_{i=0}^{n-1}B_{i,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = \sum_{i=0}^{n-1}B_{i,n-1}(t) \)&lt;/p&gt;

&lt;h4&gt;对称性&lt;/h4&gt;

&lt;p&gt;\[ B_{i,n}(1 - t) = B_{n-i,n}(t) \]&lt;/p&gt;

&lt;p&gt;证明：&lt;/p&gt;

&lt;p&gt;由定义：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(t) = C_{n}^{i}t^{i}(1-t)^{n-i} \]&lt;/p&gt;

&lt;p&gt;有：&lt;/p&gt;

&lt;p&gt;\( B_{n-i,n}(t) = C_{n}^{n-i}t^{n-i}(1-t)^{n-(n-i)}  \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{n-i}t^{n-i}(1-t)^{i}  \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{i}t^{n-i}(1-t)^{i} \)&lt;/p&gt;

&lt;p&gt;\( B_{i,n}(1 - t) =  C_{n}^{i}(1 - t)^{i}(1-(1 - t))^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{i}(1 - t)^{i}t^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{i}t^{n-i}(1-t)^{i} \)&lt;/p&gt;

&lt;p&gt;得证。&lt;/p&gt;

&lt;h4&gt;非负性&lt;/h4&gt;

&lt;p&gt;当 t = 0 时：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(0) = 0 , 【i &amp;gt; 0】\]&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(0) = 1 , 【i = 0】\]&lt;/p&gt;

&lt;p&gt;当 t = 1 时：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(0) = 0 , 【i &amp;gt; 0】\]&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(0) = 1 , 【i = 0】\]&lt;/p&gt;

&lt;p&gt;当 t= (0,1) 时：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(t) &amp;gt; 0 , 【i =0,1,2,\cdots ,n-1】\]&lt;/p&gt;

&lt;p&gt;证明：把数值代入定义公式就可以了。&lt;/p&gt;

&lt;h2&gt;Bernstein基(Bernstein Basis)到幂基(Power Basis)的转换&lt;/h2&gt;

&lt;p&gt;由二项式定理：&lt;/p&gt;

&lt;p&gt;\[ (a+b)^{n} = \sum_{r=0}^{n}C_{n}^{r}a^{n-r}b^{r} \]&lt;/p&gt;

&lt;p&gt;得到：&lt;/p&gt;

&lt;p&gt;\[ (1-t)^{n} = \sum_{r=0}^{n}C_{n}^{r}1^{n-r}(-t)^{r} = \sum_{r=0}^{n}C_{n}^{r}(-t)^{r}\]&lt;/p&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(t) = C_{n}^{i}t^{i}(1-t)^{n-i} \]&lt;/p&gt;

&lt;p&gt;\[ = C_{n}^{i}t^{i}\sum _{k=0}^{n-i}C_{n-i}^{k}(-t)^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = C_{n}^{i}t^{i}\sum _{k=0}^{n-i}C_{n-i}^{k}(-1)^{k}t^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=0}^{n-i}C_{n}^{i}t^{i}C_{n-i}^{k}(-1)^{k}t^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=0}^{n-i}C_{n}^{i}C_{n-i}^{k}(-1)^{k}t^{k+i} \]&lt;/p&gt;

&lt;p&gt;这时设g = k + i ，则有 k = g - i，i = g - k，上式变成：&lt;/p&gt;

&lt;p&gt;\[ = \sum _{g - i=0}^{n-(g-k)}C_{n}^{i}C_{n-i}^{g - i}(-1)^{g - i}t^{g} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{g=i}^{n-g+k}C_{n}^{i}C_{n-i}^{g - i}(-1)^{g - i}t^{g}\]&lt;/p&gt;

&lt;p&gt;把g换成k，上式变成：&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=i}^{n-k+k}C_{n}^{i}C_{n-i}^{k - i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=i}^{n}C_{n}^{i}C_{n-i}^{k - i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;其中\(C_{n}^{i}C_{n-i}^{k - i}\)可以进一步简化：&lt;/p&gt;

&lt;p&gt;\( C_{n}^{i} C_{n-i}^{k - i} \)
\( = \frac {n!}{i!(n-i)!} \frac {(n-i)!}{(k-i)!((n-i)-(k-i))!}  \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{i!(n-i)!} \frac {(n-i)!}{(k-i)!((n-k)!}  \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!(n-i)!}{i!(n-i)!(k-i)!((n-k)!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{i!(k-i)!((n-k)!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!k!}{i!(k-i)!((n-k)!k!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{k!(n-k)!} \frac {k!}{i!((k-i)!} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{k} C_{k}^{i} \)&lt;/p&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=i}^{n}C_{n}^{i}C_{n-i}^{k - i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=i}^{n}C_{n}^{k} C_{k}^{i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;综上:&lt;/p&gt;

&lt;p&gt;\[  B_{i,n}(t) = \sum _{k=i}^{n}C_{n}^{k} C_{k}^{i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;设\( b_{k,i} = C_{n}^{k} C_{k}^{i}(-1)^{k - i} \)&lt;/p&gt;

&lt;p&gt;则上式变成：&lt;/p&gt;

&lt;p&gt;\[  B_{i,n}(t) = \sum _{k=i}^{n}b_{k,i}t^{k} \]&lt;/p&gt;

&lt;p&gt;展开后：&lt;/p&gt;

&lt;p&gt;\[  B_{i,n}(t) = b_{i,i}t^{i} + b_{i+1,i}t^{i+1} + \cdots + b_{n,i}t^{n} \]&lt;/p&gt;

&lt;h1&gt;Bézier曲线的递推形式(de Casteljau算法)&lt;/h1&gt;

&lt;p&gt;前面讲的是Bézier曲线的曲线方程定义，现在介绍一个简单实用的算法:de Casteljau&amp;#39;s Algorithm。&lt;/p&gt;

&lt;p&gt;先分享我找到的一些演示程序：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://myst729.github.io/bezier-curve/&quot;&gt;http://myst729.github.io/bezier-curve/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jasondavies.com/animated-bezier/&quot;&gt;https://www.jasondavies.com/animated-bezier/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;以及油管上的:&lt;a href=&quot;https://www.youtube.com/watch?v=YATikPP2q70&quot;&gt;https://www.youtube.com/watch?v=YATikPP2q70&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;递推公式如下：&lt;/p&gt;

&lt;p&gt;\[ P_{i}^{k} =\begin {cases} P_{i}  【k=0】 \\  (1-t)P_{i}^{k-1}+tP_{i+1}^{k-1} 【k=1,2,\cdots ,n,i=0,1,\cdots ,n-k】 \end {cases}  \]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.12/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;以上图为例演示下这条公式：&lt;/p&gt;

&lt;p&gt;因为有\( P_{0},P_{1},P_{2},P_{3} \)4个控制点，所以n的值是3(要减1)。&lt;/p&gt;

&lt;p&gt;然后求该贝塞尔曲线在 t = 1/2时的坐标点B(1/2)的步骤如下：&lt;/p&gt;

&lt;p&gt;k = 0时，\(i = 0,1,\cdots ,n-k = 0,1,2,3 \)，所以有:&lt;/p&gt;

&lt;p&gt;\( P_{i}^{k=0} = P_{i} \) &lt;/p&gt;

&lt;p&gt;\( P_{0}^{k=0} = P_{0} \)&lt;/p&gt;

&lt;p&gt;\( P_{1}^{k=0} = P_{1} \)&lt;/p&gt;

&lt;p&gt;\( P_{2}^{k=0} = P_{2} \)&lt;/p&gt;

&lt;p&gt;\( P_{3}^{k=0} = P_{3} \)&lt;/p&gt;

&lt;p&gt;k = 1时，\(i = 0,1,\cdots ,n-k = 0,1,2 \)，所以有:&lt;/p&gt;

&lt;p&gt;\( P_{i}^{k=1} = (1-t)P_{i}^{1-1}+tP_{i+1}^{1-1}  = (1-t)P_{i}^{0}+tP_{i+1}^{0} \)&lt;/p&gt;

&lt;p&gt;\( P_{0}^{k=1} = (1-t)P_{0}^{0}+tP_{1}^{0} = 0.5P_{0} + 0.5P_{1} = m_{0} \)&lt;/p&gt;

&lt;p&gt;\( P_{1}^{k=1} = (1-t)P_{1}^{0}+tP_{2}^{0} = 0.5P_{1} + 0.5P_{2} = m_{1} \)&lt;/p&gt;

&lt;p&gt;\( P_{2}^{k=1} = (1-t)P_{2}^{0}+tP_{3}^{0} = 0.5P_{2} + 0.5P_{3} = m_{2} \)&lt;/p&gt;

&lt;p&gt;k = 2时，\(i = 0,1,\cdots ,n-k = 0,1\)，所以有:&lt;/p&gt;

&lt;p&gt;\( P_{i}^{k=2} = (1-t)P_{i}^{1}+tP_{i+1}^{1} \)&lt;/p&gt;

&lt;p&gt;\( P_{0}^{k=2} = (1-t)P_{0}^{1}+tP_{1}^{1} = 0.5m_{0} + 0.5m_{1} = q_{0} \)&lt;/p&gt;

&lt;p&gt;\( P_{1}^{k=2} = (1-t)P_{1}^{1}+tP_{2}^{1} = 0.5m_{1} + 0.5m_{2} = q_{1} \)&lt;/p&gt;

&lt;p&gt;k = 3时，\(i = 0,1,\cdots ,n-k = 0\)，所以有:&lt;/p&gt;

&lt;p&gt;\( P_{i}^{k=3} = (1-t)P_{i}^{2}+tP_{i+1}^{2} \)&lt;/p&gt;

&lt;p&gt;\( P_{0}^{k=3} = (1-t)P_{0}^{2}+tP_{1}^{2} = 0.5q_{0} + 0.5q_{1} = B(1/2) \)&lt;/p&gt;

&lt;h1&gt;Bézier曲线的矩阵形式&lt;/h1&gt;

&lt;p&gt;由上上一节推导出来的2条式子：&lt;/p&gt;

&lt;p&gt;\[ b_{k,i} = C_{n}^{k} C_{k}^{i}(-1)^{k - i} \]&lt;/p&gt;

&lt;p&gt;\[  B_{i,n}(t) = \sum _{k=i}^{n}b_{k,i}t^{k} = b_{i,i}t^{i} + b_{i+1,i}t^{i+1} + \cdots + b_{n,i}t^{n} \]&lt;/p&gt;

&lt;p&gt;可以推导出矩阵：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} B_{0,n}(t)&amp;amp;B_{1,n}(t)&amp;amp;\cdots &amp;amp;B_{n,n}(t)\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} \sum _{k=0}^{n}b_{k,0}t^{k}&amp;amp;\sum _{k=1}^{n}b_{k,1}t^{k}&amp;amp;\cdots &amp;amp;\sum _{k=n}^{n}b_{k,n}t^{k}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} t^{0}&amp;amp;t^{1}&amp;amp;t^{2}&amp;amp;\cdots &amp;amp;t^{n}\\ \end{matrix} \right] \left[ \begin{matrix} b_{0,0}&amp;amp;0&amp;amp;0&amp;amp;\cdots &amp;amp;0\\  b_{1,0}&amp;amp;b_{1,1}&amp;amp;0&amp;amp;\cdots &amp;amp;0\\  b_{2,0}&amp;amp;b_{2,1}&amp;amp;b_{2,2}&amp;amp;\cdots &amp;amp;0\\  \vdots &amp;amp;\vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots \\  b_{n,0}&amp;amp;b_{n,1}&amp;amp;b_{n,2}&amp;amp;\cdots &amp;amp;b_{n,n}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;再由Bézier曲线的公式：&lt;/p&gt;

&lt;p&gt;\[ P(t) = \sum_{i=0}^{n}P_{i}B_{i,n}(t) , t\in [0,1] \]&lt;/p&gt;

&lt;p&gt;有：&lt;/p&gt;

&lt;p&gt;\[ P(t) =  \left[ \begin{matrix} t^{0}&amp;amp;t^{1}&amp;amp;t^{2}&amp;amp;\cdots &amp;amp;t^{n}\\ \end{matrix} \right] \left[ \begin{matrix} b_{0,0}&amp;amp;0&amp;amp;0&amp;amp;\cdots &amp;amp;0\\  b_{1,0}&amp;amp;b_{1,1}&amp;amp;0&amp;amp;\cdots &amp;amp;0\\  b_{2,0}&amp;amp;b_{2,1}&amp;amp;b_{2,2}&amp;amp;\cdots &amp;amp;0\\  \vdots &amp;amp;\vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots \\  b_{n,0}&amp;amp;b_{n,1}&amp;amp;b_{n,2}&amp;amp;\cdots &amp;amp;b_{n,n}\\ \end{matrix} \right]  \left[ \begin{matrix} P^{0}\\ P^{1}\\ P^{2}\\ \vdots \\ P^{n}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;注意，中间的矩阵B是常量(取决于阶数):&lt;/p&gt;

&lt;p&gt;n = 2时：&lt;/p&gt;

&lt;p&gt;\( b_{k,i} = C_{2}^{k} C_{k}^{i}(-1)^{k - i} \)&lt;/p&gt;

&lt;p&gt;\( b_{0,0} = C_{2}^{0} C_{0}^{0}(-1)^{0 - 0} =  1*1=1 \)&lt;/p&gt;

&lt;p&gt;\( b_{1,0} = C_{2}^{1} C_{1}^{0}(-1)^{1 - 0} =  2*1*(-1)=-2 \)&lt;/p&gt;

&lt;p&gt;\( b_{2,0} = C_{2}^{2} C_{2}^{0}(-1)^{2 - 0} =  1*1=1 \)&lt;/p&gt;

&lt;p&gt;\( b_{1,1} = C_{2}^{1} C_{1}^{1}(-1)^{1 - 1} =  2*1=2 \)&lt;/p&gt;

&lt;p&gt;\( b_{2,1} = C_{2}^{2} C_{2}^{1}(-1)^{2 - 1} =  1*2*(-1)=-2 \)&lt;/p&gt;

&lt;p&gt;\( b_{2,2} = C_{2}^{2} C_{2}^{2}(-1)^{2 - 2} =  1*1=1 \)&lt;/p&gt;

&lt;p&gt;\[ B =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ -2&amp;amp;2&amp;amp;0\\ 1&amp;amp;-2&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;n = 3时：&lt;/p&gt;

&lt;p&gt;\[ B =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\ -3&amp;amp;3&amp;amp;0&amp;amp;0\\ 3&amp;amp;-6&amp;amp;3&amp;amp;0\\ -1&amp;amp;3&amp;amp;-3&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h2&gt;测试一下正确性&lt;/h2&gt;

&lt;p&gt;测试代码基于我正在开发中的&lt;a href=&quot;https://github.com/voyagingmk/renderer&quot;&gt;renderer&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;quot;transform.hpp&amp;quot;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;quot;geometry.hpp&amp;quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix3x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;mf&quot;&gt;20.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;20.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//P0&lt;/span&gt;
        &lt;span class=&quot;mf&quot;&gt;770.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;30.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//P1&lt;/span&gt;
        &lt;span class=&quot;mf&quot;&gt;400.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;780.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//P2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Matrix3x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Matrix3x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MxN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix1x3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CImg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atXYZC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atXYZC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atXYZC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0001f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Matrix1x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Matrix1x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TBP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TBP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TBP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atXYZC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;../images/2015.12/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/bezier-1/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/bezier-1/</guid>
      </item>
    
      <item>
        <title>线性代数之Cholesky分解</title>
        <description>&lt;p&gt;又到了矩阵分解时间。这次介绍的是&lt;strong&gt;Cholesky分解&lt;/strong&gt;。这个方法只适用于符合厄米特矩阵、正定矩阵定义的矩阵。&lt;/p&gt;

&lt;h2&gt;算法原理&lt;/h2&gt;

&lt;p&gt;设A是一个n阶厄米特正定矩阵(Hermitian positive-definite matrix)。&lt;/p&gt;

&lt;p&gt;Cholesky分解的目标是把A变成:&lt;/p&gt;

&lt;p&gt;\[ A = LL^{T} \]&lt;/p&gt;

&lt;p&gt;L是下三角矩阵。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;推导过程&lt;/h2&gt;

&lt;p&gt;因为A是对称的矩阵，所以设A为：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} a_{11}&amp;amp;A_{21}^{T}\\ A_{21}&amp;amp;A_{22}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;(注意：细心观察此式子可以发现\(A_{21}\)是一个列向量，\(A_{22}\)是一个n-1阶的方阵)&lt;/p&gt;

&lt;p&gt;设L：&lt;/p&gt;

&lt;p&gt;\[ L =  \left[ \begin{matrix} l_{11}&amp;amp;0\\ L_{21}&amp;amp;L_{22}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;则有:&lt;/p&gt;

&lt;p&gt;\[ L^{T} =  \left[ \begin{matrix} l_{11}&amp;amp;L_{21}^{T}\\ 0&amp;amp;L_{22}^{T}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;设\( A = LL^{T} \)，得到：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} a_{11}&amp;amp;A_{21}^{T}\\ A_{21}&amp;amp;A_{22}\\ \end{matrix} \right] =  \left[ \begin{matrix} l_{11}&amp;amp;0\\ L_{21}&amp;amp;L_{22}\\ \end{matrix} \right] \left[ \begin{matrix} l_{11}&amp;amp;L_{21}^{T}\\ 0&amp;amp;L_{22}^{T}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} l_{11}^{2}&amp;amp;l_{11}L_{21}^{T}\\ l_{11}L_{21}&amp;amp;L_{21}L_{21}^{T}+L_{22}L_{22}^{T}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;其中，未知量是\( l_{11},L_{21},L_{22} \)，这3个未知量的求解公式是：&lt;/p&gt;

&lt;p&gt;\[ l_{11} = \sqrt {a_{11}} \]&lt;/p&gt;

&lt;p&gt;\[ L_{21} = \frac {1}{l_{11}}A_{21} \]&lt;/p&gt;

&lt;p&gt;\[ L_{22}L_{22}^{T} =  A_{22} - L_{21}L_{21}^{T} \]&lt;/p&gt;

&lt;p&gt;显然，\( l_{11},L_{21} \)是易求的，而\( L_{22} \)的求解救有意思了。&lt;/p&gt;

&lt;p&gt;观察可以发现，\( A_{22} - L_{21}L_{21}^{T} \)也很好求，\( A_{22} \)已知，\( L_{21}L_{21}^{T} \)是一个对角线矩阵，对角线上的元素只是一个平方，好求。&lt;/p&gt;

&lt;p&gt;那么设\(A_{22}&amp;#39; = A_{22} - L_{21}L_{21}^{T} \)，则剩下的问题就是求:&lt;/p&gt;

&lt;p&gt;\[ A_{22}&amp;#39; = L_{22}L_{22}^{T} \]&lt;/p&gt;

&lt;p&gt;啊，这不也是Cholesky分解！被分解的矩阵是A的右下角的n-1阶子方阵！&lt;/p&gt;

&lt;p&gt;所以这个算法具有递归性质。&lt;/p&gt;

&lt;p&gt;附上一个实例：&lt;/p&gt;

&lt;p&gt;设:&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} 25&amp;amp;15&amp;amp;-5\\ 15&amp;amp;18&amp;amp;0\\ -5&amp;amp;0&amp;amp;11\\ \end{matrix} \right] =  \left[ \begin{matrix} l_{11}&amp;amp;0&amp;amp;0\\ l_{21}&amp;amp;l_{22}&amp;amp;0\\ l_{31}&amp;amp;l_{32}&amp;amp;l_{33}\\ \end{matrix} \right] \left[ \begin{matrix} l_{11}&amp;amp;l_{21}&amp;amp;l_{31}\\ 0&amp;amp;l_{22}&amp;amp;l_{32}\\ 0&amp;amp;0&amp;amp;l_{33}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;根据上文的公式，有：&lt;/p&gt;

&lt;p&gt;\[ l_{11} = \sqrt { a_{11} } = 5 \]
\[ L_{21} = \frac {1}{l_{11}}A_{21} = \frac {1}{5} \left[ \begin{matrix} 15\\ -5\\ \end{matrix} \right] =  \left[ \begin{matrix} 3\\ -1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ A_{22} - L_{21}L_{21}^{T}  =  L_{22}L_{22}^{T} \]&lt;/p&gt;

&lt;p&gt;\[ A_{22} - L_{21}L_{21}^{T}  =  L_{22}L_{22}^{T} \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} 18&amp;amp;0\\ 0&amp;amp;11\\ \end{matrix} \right] -  \left[ \begin{matrix} 3\\ -1\\ \end{matrix} \right] \left[ \begin{matrix} 3&amp;amp;-1\\ \end{matrix} \right] =   \left[ \begin{matrix} l_{22}&amp;amp;0\\ l_{32}&amp;amp;l_{33}\\ \end{matrix} \right]   \left[ \begin{matrix} l_{22}&amp;amp;l_{32}\\ 0&amp;amp;l_{33}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} 9&amp;amp;3\\ 3&amp;amp;10\\ \end{matrix} \right] =  \left[ \begin{matrix} l_{22}&amp;amp;0\\ l_{32}&amp;amp;l_{33}\\ \end{matrix} \right]   \left[ \begin{matrix} l_{22}&amp;amp;l_{32}\\ 0&amp;amp;l_{33}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;(注意，这里已经是n-1阶的Cholesky分解)&lt;/p&gt;

&lt;p&gt;\[ l_{22} = \sqrt { 9 } = 3 \]
\[ l_{32} = \frac {1}{3}3 = 1 \]
\[ 10 = l_{32}^{2} + l_{33}^{2} = 1 + l_{33}^{2} \]
\[ l_{33} = \sqrt {10 - 1} = 3 \]&lt;/p&gt;

&lt;p&gt;综上：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} 25&amp;amp;15&amp;amp;-5\\ 15&amp;amp;18&amp;amp;0\\ -5&amp;amp;0&amp;amp;11\\ \end{matrix} \right] =  \left[ \begin{matrix} 5&amp;amp;0&amp;amp;0\\ 3&amp;amp;3&amp;amp;0\\ -1&amp;amp;1&amp;amp;3\\ \end{matrix} \right] \left[ \begin{matrix} 5&amp;amp;3&amp;amp;-1\\ 0&amp;amp;3&amp;amp;1\\ 0&amp;amp;0&amp;amp;3\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;
</description>
        <pubDate>Sat, 19 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-11/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-11/</guid>
      </item>
    
      <item>
        <title>线性代数之逆矩阵</title>
        <description>&lt;p&gt;逆矩阵是一个很基本的概念，这里就不说定义了。本文只介绍求解方法。&lt;/p&gt;

&lt;h2&gt;初等变换求逆法——高斯消元法(Gauss-Jordan elimination)&lt;/h2&gt;

&lt;p&gt;先在要求解逆矩阵的A的右边增加一个临时的单位矩阵（阶数显然和A一致）。那么A就变成了一个n行、2n列的矩阵A&amp;#39;。
然后对A&amp;#39;进行高斯消元，也就是通过row operation不断对A&amp;#39;做变换，直到A&amp;#39;的左边的A变成单位矩阵时，A&amp;#39;的右边部分就是A的逆矩阵了。
要注意的是，A不一定有逆矩阵，当A没有逆矩阵时，这个高斯消元过程中肯定会出现A的某row全是0的情况。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;举例说明：&lt;/p&gt;

&lt;p&gt;设A：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3\\ 2&amp;amp;5&amp;amp;3\\ 1&amp;amp;0&amp;amp;8\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;扩展A，在A的右边增加(Adjoin)一个单位矩阵：&lt;/p&gt;

&lt;p&gt;\[ A&amp;#39; =  \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3&amp;amp;1&amp;amp;0&amp;amp;0\\ 2&amp;amp;5&amp;amp;3&amp;amp;0&amp;amp;1&amp;amp;0\\ 1&amp;amp;0&amp;amp;8&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;开始变换：&lt;/p&gt;

&lt;p&gt;\(  \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3&amp;amp;1&amp;amp;0&amp;amp;0\\ 2&amp;amp;5&amp;amp;3&amp;amp;0&amp;amp;1&amp;amp;0\\ 1&amp;amp;0&amp;amp;8&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \xrightarrow{ R_{2}=R_{2}-2R_{1}, R_{3}=R_{3}-R_{1} }   \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3&amp;amp;1&amp;amp;0&amp;amp;0\\ 2-2*1&amp;amp;5-2*2&amp;amp;3-2*3&amp;amp;0-2*1&amp;amp;1-2*0&amp;amp;0-2*0\\ 1-1&amp;amp;0-2&amp;amp;8-3&amp;amp;0-1&amp;amp;0-0&amp;amp;1-0\\ \end{matrix} \right]\)&lt;/p&gt;

&lt;p&gt;\(  \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3&amp;amp;1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;-3&amp;amp;-2&amp;amp;1&amp;amp;0\\ 0&amp;amp;-2&amp;amp;5&amp;amp;-1&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \xrightarrow{ R_{3}=R_{3}+2R_{2} }   \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3&amp;amp;1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;-3&amp;amp;-2&amp;amp;1&amp;amp;0\\ 0+2*0&amp;amp;-2+2*1&amp;amp;5+2*(-3)&amp;amp;-1+2*(-2)&amp;amp;0+2*1&amp;amp;1+2*0\\ \end{matrix} \right]\)&lt;/p&gt;

&lt;p&gt;\(  \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3&amp;amp;1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;-3&amp;amp;-2&amp;amp;1&amp;amp;0\\ 0&amp;amp;-0&amp;amp;-1&amp;amp;-5&amp;amp;2&amp;amp;1\\ \end{matrix} \right] \xrightarrow{ R_{3}=-R_{3} }   \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3&amp;amp;1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;-3&amp;amp;-2&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1&amp;amp;5&amp;amp;-2&amp;amp;-1\\ \end{matrix} \right]\)&lt;/p&gt;

&lt;p&gt;\(  \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3&amp;amp;1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;-3&amp;amp;-2&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1&amp;amp;5&amp;amp;-2&amp;amp;-1\\ \end{matrix} \right] \xrightarrow{ R_{1}=R_{1}-3R_{3},R_{2}=R_{2}+3R_{3} }   \left[ \begin{matrix} 1&amp;amp;2&amp;amp;0&amp;amp;-14&amp;amp;6&amp;amp;3\\ 0&amp;amp;1&amp;amp;0&amp;amp;13&amp;amp;-5&amp;amp;-3\\ 0&amp;amp;0&amp;amp;1&amp;amp;5&amp;amp;-2&amp;amp;-1\\ \end{matrix} \right]\)&lt;/p&gt;

&lt;p&gt;\(  \left[ \begin{matrix} 1&amp;amp;2&amp;amp;0&amp;amp;-14&amp;amp;6&amp;amp;3\\ 0&amp;amp;1&amp;amp;0&amp;amp;13&amp;amp;-5&amp;amp;-3\\ 0&amp;amp;0&amp;amp;1&amp;amp;5&amp;amp;-2&amp;amp;-1\\ \end{matrix} \right] \xrightarrow{ R_{1}=R_{1}-2R_{2} }   \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;-40&amp;amp;16&amp;amp;9\\ 0&amp;amp;1&amp;amp;0&amp;amp;13&amp;amp;-5&amp;amp;-3\\ 0&amp;amp;0&amp;amp;1&amp;amp;5&amp;amp;-2&amp;amp;-1\\ \end{matrix} \right]\)&lt;/p&gt;

&lt;p&gt;所以A的逆矩阵为：&lt;/p&gt;

&lt;p&gt;\[  A^{-1} =  \left[ \begin{matrix} -40&amp;amp;16&amp;amp;9\\ 13&amp;amp;-5&amp;amp;-3\\ 5&amp;amp;-2&amp;amp;-1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h2&gt;伴随矩阵求逆法&lt;/h2&gt;

&lt;p&gt;先回顾下2个定理：&lt;/p&gt;

&lt;p&gt;1.n阶行列式\(D=det(a_{ij}) \)等于它的任一行(列)的各元素与其代数余子式乘积之和，即：&lt;/p&gt;

&lt;p&gt;\[ D = a_{i1}A_{i1}+a_{i2}A_{i2}+\cdots + a_{in}A_{in} , i = 1,2,\cdots ,n \]
\[ D = a_{1j}A_{1j}+a_{2j}A_{2j}+\cdots + a_{nj}A_{nj} , j = 1,2,\cdots ,n \]&lt;/p&gt;

&lt;p&gt;2.n阶行列式\(D=det(a_{ij}) \)的某一行(列)的元素与另一行(列)对应元素的代数余子式乘积之和等于零，即：&lt;/p&gt;

&lt;p&gt;\[ D = a_{i1}A_{s1}+a_{i2}A_{s2}+\cdots + a_{in}A_{sn} , i \neq s \]
\[ D = a_{1j}A_{1t}+a_{2j}A_{2t}+\cdots + a_{nj}A_{nt} , j \neq t \]&lt;/p&gt;

&lt;p&gt;以及伴随矩阵的定义：&lt;/p&gt;

&lt;p&gt;设\(A=(a_{ij})_{nXm}\)，\(A_{ij}\)是A的行列式\( |A|=det(a_{ij}) \)的元素\( a_{ij} \)的代数余子式\( (i,j=1,2,\cdots,n)\), 则有：&lt;/p&gt;

&lt;p&gt;\[ (adj(A)) ^{T} =  \left[ \begin{matrix} A_{11}&amp;amp;A_{12}&amp;amp;\ldots&amp;amp;A_{1n}\\ A_{21}&amp;amp;A_{22}&amp;amp;\ldots&amp;amp;A_{2n}\\ \vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ \\ A_{n1}&amp;amp;A_{n2}&amp;amp;\ldots &amp;amp;A_{nn}\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;\[ adj(A) =  \left[ \begin{matrix} A_{11}&amp;amp;A_{21}&amp;amp;\ldots&amp;amp;A_{n1}\\ A_{12}&amp;amp;A_{22}&amp;amp;\ldots &amp;amp;A_{n2}\\ \vdots \ \ \ \ &amp;amp;\vdots  \ \ \ \ &amp;amp;\vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ \\ A_{1n}&amp;amp;A_{2n}&amp;amp;\ldots &amp;amp;A_{nn}\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;adj(A)称为伴随矩阵。&lt;/p&gt;

&lt;p&gt;利用上面2条定理，计算\(Aadj(A)\):&lt;/p&gt;

&lt;p&gt;\[ Aadj(A) =  \left[ \begin{matrix} a_{11}&amp;amp;a_{12}&amp;amp;\ldots&amp;amp;a_{1n}\\ a_{21}&amp;amp;a_{22}&amp;amp;\ldots&amp;amp;a_{2n}\\ \vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ \\ a_{n1}&amp;amp;a_{n2}&amp;amp;\ldots &amp;amp;a_{nn}\\ \end{matrix} \right] \left[ \begin{matrix} A_{11}&amp;amp;A_{21}&amp;amp;\ldots&amp;amp;A_{n1}\\ A_{12}&amp;amp;A_{22}&amp;amp;\ldots &amp;amp;A_{n2}\\ \vdots \ \ \ \ &amp;amp;\vdots  \ \ \ \ &amp;amp;\vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ \\ A_{1n}&amp;amp;A_{2n}&amp;amp;\ldots &amp;amp;A_{nn}\\ \end{matrix} \right]\]&lt;/p&gt;

&lt;p&gt;\[  =  \left[ \begin{matrix} |A|&amp;amp;0&amp;amp;\ldots&amp;amp;0\\ 0&amp;amp;|A|&amp;amp;\ldots&amp;amp;0\\ \vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ &amp;amp;\vdots \ \ \ \ \\ 0&amp;amp;0&amp;amp;\ldots &amp;amp;|A|\\ \end{matrix} \right]  = |A|E \]&lt;/p&gt;

&lt;p&gt;即:
\[ Aadj(A)  = |A|E \]&lt;/p&gt;

&lt;p&gt;从而有：&lt;/p&gt;

&lt;p&gt;\[ A^{-1}  = \frac {1}{|A|}adj(A) \]&lt;/p&gt;

&lt;p&gt;因为用这条公式求逆矩阵要计算adj(A)和|A|，这个计算太慢了。所以可以认为这个解法对阶数&amp;lt;=3的矩阵才实用。&lt;/p&gt;

&lt;p&gt;现在用伴随矩阵求逆法来求第一节中的A的逆矩阵：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} 1&amp;amp;2&amp;amp;3\\ 2&amp;amp;5&amp;amp;3\\ 1&amp;amp;0&amp;amp;8\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\( A_{11} = (-1)^{1+1}   \left| \begin{matrix} 5\ 3\\ 0\ 8\\ \end{matrix} \right| = 40 \)&lt;/p&gt;

&lt;p&gt;\( A_{12} = (-1)^{1+2}   \left| \begin{matrix} 2\ 3\\ 1\ 8\\ \end{matrix} \right| = -13\)&lt;/p&gt;

&lt;p&gt;\( A_{13} = (-1)^{1+3}   \left| \begin{matrix} 2\ 5\\ 1\ 0\\ \end{matrix} \right| = -5 \)&lt;/p&gt;

&lt;p&gt;\( A_{21} = (-1)^{2+1}   \left| \begin{matrix} 2\ 3\\ 0\ 8\\ \end{matrix} \right| = -16 \)&lt;/p&gt;

&lt;p&gt;\( A_{22} = (-1)^{2+2}   \left| \begin{matrix} 1\ 3\\ 1\ 8\\ \end{matrix} \right| = 5  \)&lt;/p&gt;

&lt;p&gt;\( A_{23} = (-1)^{2+3}   \left| \begin{matrix} 1\ 2\\ 1\ 0\\ \end{matrix} \right| = 2  \)&lt;/p&gt;

&lt;p&gt;\( A_{31} = (-1)^{3+1}   \left| \begin{matrix} 2\ 3\\ 5\ 3\\ \end{matrix} \right| = -9  \)&lt;/p&gt;

&lt;p&gt;\( A_{32} = (-1)^{3+2}   \left| \begin{matrix} 1\ 3\\ 2\ 3\\ \end{matrix} \right| = 3  \)&lt;/p&gt;

&lt;p&gt;\( A_{33} = (-1)^{3+3}   \left| \begin{matrix} 1\ 2\\ 2\ 5\\ \end{matrix} \right| = 1  \)&lt;/p&gt;

&lt;p&gt;于是:&lt;/p&gt;

&lt;p&gt;\[ adj(A) =  \left[ \begin{matrix} A_{11}&amp;amp;A_{21}&amp;amp;A_{31}\\ A_{12}&amp;amp;A_{22}&amp;amp;A_{32}\\ A_{13}&amp;amp;A_{23}&amp;amp;A_{33}\\ \end{matrix} \right] =  \left[ \begin{matrix} 40&amp;amp;-16&amp;amp;-9\\ -13&amp;amp;5&amp;amp;3\\ -5&amp;amp;2&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ |A| =  a_{31}A_{31} + a_{32}A_{32} + a_{33}A_{33} = 1*(-9) + 0*3 + 8*1 = -1 \]&lt;/p&gt;

&lt;p&gt;\[ A^{-1}  = \frac {1}{|A|}adj(A) =  \left[ \begin{matrix} -40&amp;amp;16&amp;amp;9\\ 13&amp;amp;-5&amp;amp;-3\\ 5&amp;amp;-2&amp;amp;-1\\ \end{matrix} \right]   \]&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.mathportal.org/linear-algebra/matrices/gauss-jordan.php&quot;&gt;Inverse of a matrix by Gauss-Jordan elimination&lt;/a&gt;
&lt;a href=&quot;http://www.sosmath.com/matrix/inverse/inverse.html&quot;&gt;Determinant and Inverse of Matrices&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-10/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-10/</guid>
      </item>
    
      <item>
        <title>《Effective Modern C++》读书笔记</title>
        <description>&lt;p&gt;Note：为避免各种侵权问题，本文并没有复制原书任意文字(代码除外，作者已经声明代码可以被使用)。需要原书完整中文翻译的读者请等待官方译本的发布。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;正文&lt;/h1&gt;

&lt;p&gt;为了让本文更加清晰，依然还是用&lt;strong&gt;条款&lt;/strong&gt;的形式来介绍知识点。(但不能保证我写的&lt;strong&gt;条款&lt;/strong&gt;就是原书的条款)&lt;/p&gt;

&lt;h2&gt;条款7：考虑用新的变量初始化语法{}代替旧的()吧&lt;/h2&gt;

&lt;h3&gt;优点：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用{}来初始化变量，可以避免程序员不期望的隐式类型转换(更具体地说应该是narrowing conversions，收缩转换)；&lt;/li&gt;
&lt;li&gt;用{}替代()，可以避免A a()被编译器解析(parsed)成函数声明的问题；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;缺点：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;和auto结合得不友好，auto遇到{}，auto推导成了std::initializer_list，这不是所期望的；&lt;/li&gt;
&lt;li&gt;当类的多个构造函数里，有一个是用std::initializer_list时，要注意其他构造函数不能用{}语法；&lt;/li&gt;
&lt;li&gt;当类有类型转换函数时，第二个缺点会变得更严重：复制构造函数可能不会被调用；&lt;/li&gt;
&lt;li&gt;当存在std::initializer_list构造函数时，即使构造代码不正确，编译器也不会转而使用其他构造函数来构造(即使其他构造函数更加match)，而是报错。(一种例外情况是当{...}里的元素不能被转换成std::initializer_list的T时，编译器才会转而使用其他构造函数)；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;编写类构造函数的最佳实践&lt;/h3&gt;

&lt;p&gt;当你要给自定义的类加上std::initializer_list构造函数时，要细心考虑这个类被使用时，用{}和()是否一致，是否会有反直觉的结果。也就是说，为了避免上面所说的缺点，为了不坑自己或你的代码的用户，你需要在编写一个class时保持警惕。如无必要，应尽可能不添加td::initializer_list构造函数。&lt;/p&gt;

&lt;h3&gt;c++11创造了2个阵营&lt;/h3&gt;

&lt;p&gt;用()构造亦或用{}构造对象。只使用()的话，是传统派；只使用{}的话，是革新派。革新派追求{}的那2个优点，对{}的缺点保持乐观面对的态度；传统派更重视避免std::initializer_list构造函数带来的问题。选择哪一个阵营，看自己喜好了。&lt;/p&gt;

&lt;h3&gt;对于库的编写者，并不是立场的问题&lt;/h3&gt;

&lt;p&gt;编写template function，可能会需要构造局部变量，当局部变量的类型未知时，怎么知道要用{}还是()？万一T是一个革新派写的class，而你又用了{}来构造对象，那么你的template function的执行情况，可能和T的构造函数重载情况大有关系。也即是说，你的template function是不稳定的。究竟在template function里用{}还是()，是一个复杂的问题。&lt;/p&gt;

&lt;h2&gt;条款8：不用考虑了，就用nullptr代替0和NULL&lt;/h2&gt;

&lt;p&gt;nullptr的好处在哪，请阅读书中的例子。这个条款十分简单：不要再用0和NULL来表示空指针，而是用c++11的nullptr，只有好处，没有坏处。&lt;/p&gt;

&lt;h2&gt;条款9：用using代替typedef&lt;/h2&gt;

&lt;p&gt;同条款8，大部分情况下都可以用using代替typedef。&lt;/p&gt;

&lt;h2&gt;条款10：具有作用域的enum&lt;/h2&gt;

&lt;p&gt;写法如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;red&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// black, white, red&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// are scoped to Color&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;white&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// fine, no othe&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// error! no enumerator named&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// &amp;quot;white&amp;quot; is in this scope&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// fine&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// also fine (and in accord&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// with Item 5&amp;#39;s advice)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我觉得主要好处是避免名空间污染。&lt;/p&gt;

&lt;p&gt;c++11还允许给enum指定underlying type：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// underlying type for&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Status is std::uint32_t&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// (from &amp;lt;cstdint&amp;gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意思是，Status的每一个元素都是std::uint32_t类型。缺省类型是int。&lt;/p&gt;

&lt;p&gt;还有就是，c++11 enum支持前置声明(类似class的前置声明)。&lt;/p&gt;

&lt;h2&gt;条款11：新功能：在成员函数声明后面加 = delete&lt;/h2&gt;

&lt;p&gt;这样子写:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;想比c++98的做法(把函数声明为private，并不定义实现)：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用 = delete会更好，因为被声明 = delete的函数，编译器保证什么代码都不能调用它们(会编译报错)，如果是c++98，有可能是链接时才报错。&lt;/p&gt;

&lt;p&gt;注意到 = delete声明的函数，是public的，其实是为了让报错内容更准确。想一下，如果 = delete的函数是private，然后这个函数被外部调用，编译器可能只是给出&amp;quot;不能调用private函数&amp;quot;的错误信息。这可能会误导调用者。&lt;/p&gt;

&lt;p&gt;= delete的另一个特性是，它并不是只能用在类成员函数，而是任意函数。看这段代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isLucky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// original function&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isLucky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// reject chars&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isLucky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// reject bools&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isLucky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// reject doubles and floats&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isLucky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// error! call to deleted function&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isLucky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// error!&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isLucky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;3.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// error!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把后3个函数重载给delete掉，保证了那3种调用方式不能被编译！也就是说，=delete可以用来阻止隐式转换陷阱。&lt;/p&gt;

&lt;p&gt;用= delete还有一个高端的好处：在class内部的函数模板，它的访问类型只能是public、protected、private其中一种，不能又有public又有private的实例化，所以c++98的&amp;quot;delete&amp;quot;方案对函数模板没辙。还好，C++11解决了这个问题，用= delete即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// still public, but deleted&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再引用下作者的一段话:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;the C++98 approach is not as good as the real thing. It doesn’t work outside classes, it doesn’t always work inside classes, and when it does work, it may not work until link-time. So stick to deleted functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;条款12-1：新功能：引用限定符 reference qualifiers&lt;/h3&gt;

&lt;p&gt;这样子玩:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this version of doWork applies&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// only when *this is an lvalue&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this version of doWork applies&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// only when *this is an rvalue&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;makeA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// factory function (returns rvalue)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// normal object (an lvalue)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// calls A::doWork for lvalues&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// (i.e., A::doWork &amp;amp;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;makeA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// calls A::doWork for rvalues&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// (i.e., A::doWork &amp;amp;&amp;amp;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;条款12-2：新功能：覆盖限定符 override qualifiers&lt;/h3&gt;

&lt;p&gt;这个限定符是用来防止程序员粗心写错重载的。&lt;/p&gt;

&lt;p&gt;错误例子:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Base&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Derived&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Derived的前3个函数一点没有覆盖掉基类的实现。因为派生类函数和基类对应的函数，函数签名不完全一样。&lt;/p&gt;

&lt;p&gt;c++11给出了优雅的解决办法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Derived&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mf4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Derived的mf1、mf2、mf3这3个覆盖函数无法编译通过，因为编译器在Base中找不到对应的函数。&lt;/p&gt;

&lt;h3&gt;条款13: 尽可能使用const_iterators&lt;/h3&gt;

&lt;p&gt;c++11/c++14可以这么写:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// it是const_iterators&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cbegin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1983&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1998&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，cbegin和cend是成员函数。在c++11中，有非成员函数的begin和end，但没有非成员函数的cbegin和cend(c++14才有)。&lt;/p&gt;

&lt;p&gt;所以要写泛型函数时，c++14这么写:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findAndInsert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insertVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cbegin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cbegin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insertVal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c++11则不能，但可以先定义2个函数，使得可以和c++14保持一致:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbegin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;条款14: 如果函数保证不会抛出异常，请给它加上 noexcept声明&lt;/h3&gt;

&lt;p&gt;(这个标题怎么有点像《三体》里的安全声明:如果你的文明确定没有攻击性，请给你的星球加个光速黑洞=。=)&lt;/p&gt;

&lt;p&gt;在c++98中，允许声明一个函数会抛出什么样的异常，客户端可以根据异常声明去安排自己的代码。然并卵，因为这产生了耦合性：如果一个函数的异常声明被改动了，客户端代码也得跟着改了。所以最终大家都不用这个特性。&lt;/p&gt;

&lt;p&gt;在modern c++中，把这个东西废掉了，并加入noexcept关键字。从而只需要声明一个函数&lt;strong&gt;是否抛出异常&lt;/strong&gt;即可。&lt;/p&gt;

&lt;p&gt;noexcept的威力在于，它告诉编译器的优化器可以多大程度地优化函数代码生成。当noexcept被声明时，运行时栈不需要保存一个可解状态(可解状态是指，这函数里的局部变量可以按照构造顺序的反序去析构)。即干掉这个函数的不必要信息，让它更轻量。&lt;/p&gt;

&lt;p&gt;noexcept在标准库里部有很重要的应用，具体请阅读原书。&lt;/p&gt;

&lt;p&gt;noexcept还是支持表达式计算的。可以这样子玩:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                                  &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释下第二个swap：一个pair对象和另一个pair对象进行swap，当前仅当swap(first, p.first)和swap(second, p.second)都是noexcept时，pair::swap才是noexcept。&lt;/p&gt;

&lt;p&gt;虽然noexcept很强大，但是乱用是不好的。譬如如果你声明一个函数是noexcept，但有一天你反悔了，你可能想去掉noexcept声明，但这对客户端代码的影响不小，或者你不管noexcept声明了，硬是在函数里抛出异常！Oh，那当这个异常抛出来的时候，程序就强制终止了。&lt;/p&gt;

&lt;p&gt;解决上述问题的唯一办法就是&lt;strong&gt;谨慎&lt;/strong&gt;，只对关键的、底层的、频繁调用的函数考虑加上noexcept声明。一来，函数是底层函数，函数内部很可能没有调用其他函数，或者调用的函数也都是noexcept的，于是这个函数可以妥妥地加上noexcept。&lt;/p&gt;

&lt;p&gt;在modern c++中，用户定义的析构函数亦或是编译器生成的析构函数，都隐式声明了noexcept。&lt;/p&gt;

&lt;h3&gt;条款15: 尽可能地使用constexpr&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;所有的constexpr对象都是常量，但不是所有的const对象都是constexpr。如果确定需要一个编译时期的常量，那么得用constexpr。&lt;/li&gt;
&lt;li&gt;当你着手的代码需要用到编译时期常量时，可以使用constexpr函数，如果你给constexpr函数传递一些编译时期可知的参数(这些参数来源于上下文)，那么这个constexpr函数&lt;strong&gt;很可能&lt;/strong&gt;会在编译时期被执行。然而，如果其中一个参数是编译时期不可知的，这个函数&lt;strong&gt;肯定&lt;/strong&gt;不会在编译时期就执行。这个自动处理是自动的、隐式的，也就是说不要求程序员写2个函数，一个runtime用，一个compiling用。&lt;/li&gt;
&lt;li&gt;从第二点可以反推，如果一个函数不是constexpr，那么即使你传递给它的参数都是编译时期已知的，这个函数也不一定就会在编译时期执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体怎么玩？看下面的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// C++11&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// C++14&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c++11的递归版本很容易爆栈，而c++14对constexpr做了改进，允许写成迭代的形式。&lt;/p&gt;

&lt;p&gt;注释掉c++11的版本，然后试试c++14的版本吧，执行指令：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;time gcc test.cpp -o test.out -std=gnu++14 -lstdc++&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指令执行耗时：&lt;/p&gt;

&lt;p&gt;real    0m1.190s&lt;/p&gt;

&lt;p&gt;user    0m1.108s&lt;/p&gt;

&lt;p&gt;sys     0m0.052s&lt;/p&gt;

&lt;p&gt;哇，用了1秒多，这1秒多花在哪了呢？其实就是gcc编译器在编译时期就把constexpr int result = times(a, b);计算了。（然而有些诡异的是，times仅仅循环100W，就花了一秒。）&lt;/p&gt;

&lt;p&gt;不过这也值得高兴了，这个特性可以让程序性能有了进一步提高，譬如可以把复杂的静态class常量变成constexpr，使得在编译器就把变量生成了，而不是等到运行期(即使你说运行期只创建一次)。&lt;/p&gt;

&lt;p&gt;总的来说就是，constexpr使得本来在运行期执行的工作，可以提前到编译期，只要你加上constexpr声明即可。&lt;/p&gt;

&lt;h3&gt;条款16: 关于编译器自动生成的成员函数&lt;/h3&gt;

&lt;p&gt;移动构造函数(move constructor)和移动赋值操作符(move assignment operator)，是modern c++新补充的generated member function。&lt;/p&gt;

&lt;p&gt;对于这2个函数的任意一个，当前仅当满足下面的条件时，编译器才会自动生成它们：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有地方需要用到它&lt;/li&gt;
&lt;li&gt;用户没有自定义复制操作函数(copy operations)，即复制构造函数(copy constructor)和赋值操作符(copy assignment operator)&lt;/li&gt;
&lt;li&gt;用户没有自定义移动操作函数(move operations)&lt;/li&gt;
&lt;li&gt;用户没有自定义析构函数&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/cpp-6/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/cpp-6/</guid>
      </item>
    
  </channel>
</rss>