<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>写作主题覆盖：游戏开发技术、图形学、机器学习。QQ：234707482</description>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>漫谈网络通讯加密（3）HKDF</title>
        <description>&lt;p&gt;本文将简单介绍&lt;a href=&quot;https://tools.ietf.org/html/rfc5869&quot;&gt;rfc5869&lt;/a&gt;提出的HKDF。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;HKDF = HMAC + KDF&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/HMAC&quot;&gt;HMAC&lt;/a&gt;，基于Hash的MAC算法&lt;/h2&gt;

&lt;p&gt;HMAC是指Hash-based的MAC算法，hash函数是可选的，例如存在这些HMAC实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HMAC_MD5&lt;/li&gt;
&lt;li&gt;HMAC_SHA1&lt;/li&gt;
&lt;li&gt;HMAC_SHA256&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然hash函数可选，但HMAC是有严格的定义的：&lt;/p&gt;

&lt;p&gt;\[ HMAC(k, m) = H ( (k \oplus opad) || H( (k \oplus ipad) || m) ) \]&lt;/p&gt;

&lt;p&gt;伪代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hmac&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;opad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x5c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;blocksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Where blocksize is that of the underlying hash function&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ipad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x36&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;blocksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;blocksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Where &amp;#39;hash&amp;#39; is the underlying hash function&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;ipad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ipad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;XOR&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;opad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;opad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;XOR&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;opad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ipad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Where || is concatenation&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码逻辑和上面的公式是一致的，一共调用了2次hash函数，2次异或操作，2次concat操作。&lt;/p&gt;

&lt;p&gt;唯一特别的是多了一个if的判断：如果key的长度比要求的blocksize还长，那么需要缩短，方法是用hash函数hash一下这个key，从而变成blocksize长度。&lt;/p&gt;

&lt;p&gt;HMAC的图解如下(from wiki)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/8.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/HKDF&quot;&gt;KDF&lt;/a&gt;， key derivation function, 密钥导出函数&lt;/h2&gt;

&lt;p&gt;KDF是加密系统中十分基本和必要的组件。KDF的任务是，&lt;strong&gt;给定某初始密钥材料(IKM，initial keying material)，以及可选的salt，导出1或多个密码级强度的密钥&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;HKDF&lt;/h2&gt;

&lt;p&gt;HKDF是基于HMAC的KDF，功能上和其他KDF没什么区别。&lt;/p&gt;

&lt;p&gt;HKDF分两个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;extract&lt;/li&gt;
&lt;li&gt;expand&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;extract&lt;/h3&gt;

&lt;p&gt;接口定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HKDF_Extract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IKM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Options:
      Hash     a hash function; HashLen denotes the length of the
               hash function output in octets&lt;/p&gt;

&lt;p&gt;输入：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;salt: 可选的“盐”，如果不提供，则默认为0串&lt;/li&gt;
&lt;li&gt;IKM: 初始密钥材料&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PRK: 定长的伪随机密钥&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用HMAC_Hash(key, message)实现HKDF_Extract：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HMAC_Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IKM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;expand&lt;/h3&gt;

&lt;p&gt;接口定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HKDF_Expand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OKM&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PRK：HKDF_Extract的输出&lt;/li&gt;
&lt;li&gt;info：可选的上下文信息，默认是空字符串“”，当IKM被用于多种业务时，就可以用info来保证导出不一样的OKM&lt;/li&gt;
&lt;li&gt;L：指定输出的OKM的字节长度，不能超过255*HashLen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OKM: 输出密钥材料&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HKDF_Expand的伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HashLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 向上取整，保证T的长度大于等于L&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;OKM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;octets&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 裁剪成L个字节&lt;/span&gt;

   &lt;span class=&quot;nl&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zero&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HMAC_Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HMAC_Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HMAC_Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x03&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

   &lt;span class=&quot;c1&quot;&gt;// 0x01 0x02 0x03是递增的单字节常量&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;python实现HKDF&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;#!/usr/bin/env python3&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;hashlib&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;hmac&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;math&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;hash_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hmac_sha256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hmac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashlib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sha256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;digest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hkdf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ikm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;prk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hmac_sha256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ikm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;okm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hmac_sha256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;okm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;okm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Tue, 17 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/crypto-3/</link>
        <guid isPermaLink="true">http://localhost:4000/crypto-3/</guid>
      </item>
    
      <item>
        <title>分布式杂谈</title>
        <description>&lt;!--more--&gt;

&lt;h3&gt;分布式中心化/去中心化&lt;/h3&gt;

&lt;p&gt;既然分布式了为什么还有中心化？其中关键是简化了中心节点的任务，中心节点是作为任务派发者、网络管理者存在的，类似领导和员工的关系。&lt;/p&gt;

&lt;p&gt;领导节点可能是所有节点一起选举出来的，而不是固定的。从而避免领导节点故障导致整个网络崩溃。&lt;/p&gt;

&lt;p&gt;例子是raft算法。&lt;/p&gt;

&lt;h3&gt;分布式一致性&lt;/h3&gt;

&lt;p&gt;一致性是指所有节点的数据状态一致。一般是用来做大型数据库的多机备份和海量服务。多机备份使得单个数据库节点坏了，还有别的数据库可用，数据不易丢失；海量服务是指，既然可以保证多个数据库节点是一致的，那么数据库节点越多，能服务于用户的能力越强，因为用户可以任意选择一个节点存取数据。&lt;/p&gt;

&lt;p&gt;一致性算法：paxos、raft。&lt;/p&gt;

&lt;p&gt;因为节点之间的同步存在网络延迟，故一致性要分强弱：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;强一致：强调读操作读到的肯定是最新的值，即写操作同步到整个网络前，读操作是要阻塞的。&lt;/li&gt;
&lt;li&gt;弱一致：单机写入后，不保证其他节点可以立即读到最新的值，也不保证多久之后数据能够达到一致，只是尽可能保证某个时间级别后（秒），能够一致。&lt;/li&gt;
&lt;li&gt;最终一致：弱一致的特例，保证会在一定时间内，能够达到一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;分布式缓存&lt;/h3&gt;

&lt;h4&gt;LFU&lt;/h4&gt;

&lt;p&gt;Least Frequently Used（LFU），如果一个数据在最近一段时间内使用&lt;strong&gt;次数&lt;/strong&gt;很少，那么在将来一段时间内被使用的可能性也很小。&lt;/p&gt;

&lt;h4&gt;LRU&lt;/h4&gt;

&lt;p&gt;Least Recently Used（LRU），如果一个数据在最近一段时间&lt;strong&gt;没有被访问到&lt;/strong&gt;，那么在将来它被访问的可能性也很小。&lt;/p&gt;

&lt;h3&gt;分布式锁&lt;/h3&gt;

&lt;h3&gt;节点互访：RPC&lt;/h3&gt;

&lt;p&gt;功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;远程调用&lt;/li&gt;
&lt;li&gt;服务注册&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;服务监控&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最基础的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;稳定&lt;/li&gt;
&lt;li&gt;高性能&lt;/li&gt;
&lt;li&gt;多语言&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;微服务&lt;/h3&gt;

&lt;h3&gt;对象序列化技术&lt;/h3&gt;

&lt;p&gt;最普通的：JSON&lt;/p&gt;

&lt;p&gt;更高级的：MessagePack、Protocol Buffers、FlatBuffers。&lt;/p&gt;

&lt;h3&gt;消息队列&lt;/h3&gt;

&lt;h3&gt;分布式数据库拆分&lt;/h3&gt;

&lt;p&gt;先垂直拆分：不同服务的数据(库)要相互隔离，不要放一起。&lt;/p&gt;

&lt;p&gt;后水平拆分：隔离后，单机数据库如果遇到瓶颈，就拆成多机（分片）。&lt;/p&gt;

&lt;p&gt;水平拆分会遇到问题：没有一个唯一的入口，来操作数据库。&lt;/p&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端来实现数据路由：客户端自己决定连接哪个数据库节点，存什么数据。缺点是&lt;/li&gt;
&lt;li&gt;中间件：把多机数据库封装成单机的使用方法，客户端操作起来和单机一样，简单很多&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 13 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/distributed-1/</link>
        <guid isPermaLink="true">http://localhost:4000/distributed-1/</guid>
      </item>
    
      <item>
        <title>《现代操作系统》17年第四版 阅读笔记</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;系统调用&lt;/h2&gt;

&lt;h3&gt;fork&lt;/h3&gt;

&lt;p&gt;创建一个原有进程的精确副本。&lt;/p&gt;

&lt;p&gt;被复制的东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有的文件描述符&lt;/li&gt;
&lt;li&gt;所有的寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没被复制的东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;程序正文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在fork后，原有的进程和其副本（父与子）就分开了。&lt;/p&gt;

&lt;p&gt;返回值，用来在进程里区分谁是父谁是子：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在子进程中该值为0&lt;/li&gt;
&lt;li&gt;在父进程中等于子进程的PID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;shell为例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;while(true) {
    type_prompt();
    read_command(cmd, params);
    if(fork()!=0) {
        // 父
        waitpid(-1, &amp;amp;status, 0);
    } else {
        // 子
        execve(command, params, 0);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;waitpid&lt;/h3&gt;

&lt;p&gt;参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;子进程PID，填-1就是任意一个子进程PID&lt;/li&gt;
&lt;li&gt;status（statloc）子进程的返回状态码&lt;/li&gt;
&lt;li&gt;一般为0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;exec&lt;/h3&gt;

&lt;p&gt;使得整个核心映像（core image）被一个文件所替代。&lt;/p&gt;

&lt;p&gt;参数：将要执行的文件名、一个指向变量数组的指针、一个指向环境数组的指针（通常为0）&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;p&gt;cp file1 file2&lt;/p&gt;

&lt;p&gt;execve(cp, [file1, file2], 0)&lt;/p&gt;

&lt;p&gt;main(argc, argv, envp)&lt;/p&gt;

&lt;p&gt;argc为3，argv[0]为cp，argv[1]为file1，argv[2]为file2；没有envp。&lt;/p&gt;

&lt;h3&gt;exit(status)&lt;/h3&gt;

&lt;p&gt;status是用户指定的，status其实就是waitpid的staloc，子进程设定的status最终可以告诉父进程。&lt;/p&gt;

&lt;h3&gt;link&lt;/h3&gt;

&lt;p&gt;在unix中，每个文件都有唯一的编号（i-node）。&lt;/p&gt;

&lt;p&gt;每个目录有一个i-node到文件名的表。&lt;/p&gt;

&lt;p&gt;link时，是在指向目录里面创建一个新条目，i-node为原文件的i-node，文件名都link参数里指定的文件名。&lt;/p&gt;

&lt;p&gt;目录和i-node是双向指向的，i-node也存有一个表，记录了指向该i-node的目录项。&lt;/p&gt;

&lt;h1&gt;进程和线程&lt;/h1&gt;

&lt;h2&gt;进程模型&lt;/h2&gt;

&lt;h3&gt;CPU利用率&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;t1, 一个进程等待I/O操作的时间&lt;/li&gt;
&lt;li&gt;t, 一个进程停留在内存中时间&lt;/li&gt;
&lt;li&gt;p, 一个进程等待I/O操作的时间与其停留在内存中时间的比。&lt;/li&gt;
&lt;li&gt;n为同时存在的进程数量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用率 = \( 1 - p^{n}\)&lt;/p&gt;

&lt;p&gt;这是简单模型，只适用于进程之间互相独立。例如对于单CPU，即使进程就绪，但已有一个进程正在被CPU处理，那么还是会等待。&lt;/p&gt;

&lt;h3&gt;用户空间线程&lt;/h3&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;h3&gt;内核空间线程&lt;/h3&gt;

&lt;h3&gt;调度程序激活机制 和 上行调用（upcall)&lt;/h3&gt;

&lt;h3&gt;IPC：信号量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;创建信号量：sem_t *sem_open(const char *name, int oflag, 权限, 初始值)。返回值：返回一个信号量对象，若失败，则返回SEM_FAILED，并设置errno。&lt;a href=&quot;https://linux.die.net/man/3/sem_open&quot;&gt;man page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;P(down)操作，即int sem_wait(sem_t *sem)，检查信号量的值是不是大于0，若大于0，则减1并返回；若等于0，则进程睡眠，sem_wait阻塞不返回；非阻塞版本是sem_trywait，用返回值EAGAIN代替阻塞；限时的down操作是sem_timedwait，使得阻塞不是永久的。返回值：0代表成功，-1代表失败，并设置errno。&lt;/li&gt;
&lt;li&gt;V(up)操作，即int sem_post(sem_t *sem),对信号量加1，若是从0变1，那么那些阻塞在这个信号量的进程或线程会被唤醒。返回值同P。V操作是怎么都不会阻塞的。&lt;/li&gt;
&lt;li&gt;本进程关闭信号量：int sem_close(sem_t *sem)。没什么特别的。&lt;/li&gt;
&lt;li&gt;真·销毁信号量：sem_unlink，前提是open了信号量的进程已经调用了close或者已经结束了进程（调用了exit或者main函数返回），如果还没close就调用，那么没效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tomasbruckner/minimalSemaphoreDemo/blob/master/semaphore_synchronization/semaphore_synchronization.c&quot;&gt;github代码实例&lt;/a&gt;，双信号量实现父进程和子进程的同步。&lt;/p&gt;

&lt;p&gt;信号量2个能力：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现互斥量&lt;/li&gt;
&lt;li&gt;实现计数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;IPC：futex 快速用户空间互斥&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;linux特有&lt;/li&gt;
&lt;li&gt;实现了基本的锁（很像互斥锁），但避免了陷入内核&lt;/li&gt;
&lt;li&gt;内核服务：提供一个等待队列，它允许多个进程在一个锁上等待。把进程放到等待队列代价很大（系统调用）。&lt;/li&gt;
&lt;li&gt;避免锁争用：没有争用时，futex完全在用户空间工作；加锁时，如果锁没有被锁，那么直接加锁成功，不需要陷入内核；如果已经被锁了，执行系统调用把线程放到等待队列（不自旋）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;IPC：管程 montior&lt;/h3&gt;

&lt;p&gt;原因：为了更易于编写正确的程序。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;管程是编程语言的组成部分，能不能用管程得看是什么语言，例如java&lt;/li&gt;
&lt;li&gt;任一时刻管程中只能有一个活跃进程&lt;/li&gt;
&lt;li&gt;进程可在任何需要的时候调用管程中的过程（procdeure)&lt;/li&gt;
&lt;li&gt;进入管程是的互斥由编译器负责，出错的可能性要小得多&lt;/li&gt;
&lt;li&gt;写管程的人无需关心编译器是如何实现互斥的，只需知道将所有临界区转换成管程即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;IPC：消息传递&lt;/h3&gt;

&lt;p&gt;其实就是用socket来实现IPC。&lt;/p&gt;

&lt;h3&gt;IPC：屏障 barrier&lt;/h3&gt;

&lt;p&gt;概念上像是gpu渲染一帧，n个gpu核都在计算它负责的像素点，有的快有的慢，但必须全部核的任务都处理完毕，才能进入下一个阶段。&lt;/p&gt;

&lt;h3&gt;IPC：无锁化，RCU（读取-复制-更新）&lt;/h3&gt;

&lt;h2&gt;调度&lt;/h2&gt;

&lt;h3&gt;何时进行调度&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;创建一个新进程后，需要决定是运行父进程还是运行子进程。可以任意决定。&lt;/li&gt;
&lt;li&gt;一个进程退出时必须做出调度决策。必须从就绪进程集合选择另外某个进程。&lt;/li&gt;
&lt;li&gt;当一个进程阻塞在I/O和信号量上或由于其他原因阻塞是，必须选择其他进程运行。&lt;strong&gt;阻塞原因会成为选择的因素，然而调度程序并不拥有做出这种相关考虑的必要信息&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在一个I/O中断发生时，必须做出调度决策。可能等待I/O的进程变成就绪了，有三种可能，让新就绪进程运行；继续当前进程的运行；让别的进程运行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据如何处理时钟中断，可以把调度算法分2类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非抢占式：进程自己释放CPU时/阻塞时，才会切换到别的进程。即时钟中断不会进行调度。&lt;/li&gt;
&lt;li&gt;抢占式：让进程运行某个固定时段的最大值，然后挂起它，调度别的进程继续运行。前提是有时钟，不然就得用非抢占式的调度算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据环境选择算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;批处理。适合用非抢占式调度。一个进程需要运行长时间。也就减少了进程切换，优化了性能。&lt;/li&gt;
&lt;li&gt;交互式。适合抢占式。&lt;/li&gt;
&lt;li&gt;服务器。适合抢占式。&lt;/li&gt;
&lt;li&gt;实时系统。一般是非抢占式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;调度算法目标&lt;/h3&gt;

&lt;p&gt;适用所有环境的目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;公平&lt;/li&gt;
&lt;li&gt;策略强制执行。即调度进程有一些优先级策略&lt;/li&gt;
&lt;li&gt;平衡。保证系统的所有部分都忙碌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;批处理系统的测量指标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;吞吐量：每小时完成的作业数量&lt;/li&gt;
&lt;li&gt;周转时间：一个作业从提交到完成的统计平均时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;能够使吞吐量最大化的调度算法不一定就有最小的周转时间。例如，系统优先处理大量小作业导致长作业无法被处理，这样有做大的吞吐量但平均周转时间无限长。&lt;/p&gt;

&lt;p&gt;交互式系统：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最小响应时间。能够让所有的交互式请求首先运行的则是好服务。&lt;/li&gt;
&lt;li&gt;均衡性。满足用户的期望（这个概念比较模糊）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;交互式系统的调度&lt;/h3&gt;

&lt;h4&gt;轮转调度(round robin)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;每个进程被分配一个时间片（quantum)。注意，进程可在时间片花完前提前结束运行，例如阻塞了。&lt;/li&gt;
&lt;li&gt;时间片过小，容易发生抢占，过多的切换进程，降低CPU效率；&lt;/li&gt;
&lt;li&gt;时间片太长，则引起对短的交互请求的响应时间变长。&lt;/li&gt;
&lt;li&gt;一般为20~50ms&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;优先级调度&lt;/h4&gt;

&lt;p&gt;每个进程加一个优先级属性，优先级大的先执行完，再执行次优先的。&lt;/p&gt;

&lt;p&gt;问题：只按优先级来执行进程的话，低优先级进程可能永远都不会被执行。&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;被执行的进程的优先级每个时钟滴答减1，直到低于次优先级进程时切换。&lt;/li&gt;
&lt;li&gt;最大时间片法，用完时间片就轮到次优先的进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优先级的赋予：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;静态：人工分配，例如商业计算中心，高优先级的任务价格高&lt;/li&gt;
&lt;li&gt;动态：根据 1/f公式分配优先级。例如在50ms的时间片中只使用2ms就挂起的进程，优先级为1/(2/50) = 25。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变种：按优先级分类，然后用轮转调度，高优先级的进程组里的进程集合轮转调度，优先执行，都执行完时切换到次优先级组。&lt;/p&gt;

&lt;h4&gt;多级队列&lt;/h4&gt;

&lt;p&gt;基于上面的优先级分类，设计了多级队列调度。&lt;/p&gt;

&lt;p&gt;原理是：属于最高优先级类的进程运行一个时间片，属于次高优先级类的进程运行2个时间片，再次一级运行4个时间片；当进程用完分配的时间片后，它被移送到下一类。&lt;/p&gt;

&lt;p&gt;例子：假设一个进程要完成计算任务总共需要100个时间片。一开始被分配1个时间片，然后就被换出，下次到它时获得2个时间片，又被换出。总共经历了1、2、4、8、16、32、64个优先级类。在64优先级类的第37个时间片就完成了工作。总共用了7次进程上下文切换。要比轮转算法轮转100次要高效。&lt;/p&gt;

&lt;h4&gt;最短进程优先&lt;/h4&gt;

&lt;p&gt;最短路程含义是进入运行到挂起的时间间隔最短，这种进程优先处理，对实时系统挺友好。例如交互式进程，每条用户命令相当于一次短作业。&lt;/p&gt;

&lt;p&gt;但如何知道这个作业将执行多久呢？方法是用过去的数据来做预测，\( T = aT_{0} + (1 - a)T_{1} \)。&lt;/p&gt;

&lt;h4&gt;保证调度&lt;/h4&gt;

&lt;p&gt;也是绝对公平的调度。有两种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多用户同时登录工作。每个用户可获得CPU的1/n的处理能力。&lt;/li&gt;
&lt;li&gt;n个进程在运行的单用户系统。每个进程获得CPU的1/n的处理能力。不过这种情况需要记录每个进程从创建以来已累积获得的CPU时间。因为没有时间片的概念，所以进程实际获得的运行时间和理应获得的时间可能会不一致，此时可以算一个比值（优先级），使得较亏的进程可以先运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;彩票调度&lt;/h4&gt;

&lt;p&gt;即给每个进程发一些彩票。调度时，随机抽一张彩票，哪个进程持有这张彩票就被执行。&lt;/p&gt;

&lt;p&gt;可以给某个进程赋予比别人多的彩票数量，来提高优先级(中奖几率)。&lt;/p&gt;

&lt;h4&gt;公平分享调度&lt;/h4&gt;

&lt;p&gt;这个是对于多用户环境而言的。每个用户的所有进程占x%的时间。有点像上面的保证调度。&lt;/p&gt;

&lt;h3&gt;调度策略参数化&lt;/h3&gt;

&lt;p&gt;例如一个数据库父进程下面有多个子进程，父进程才知道怎么调度子进程才是最优。那么就可以设计一种参数化调度机制，让父进程向内核设置参数，如子进程优先级，更好地做调度。&lt;/p&gt;

&lt;h3&gt;线程调度&lt;/h3&gt;

&lt;p&gt;要分用户级线程和内核级线程两种情况。&lt;/p&gt;

&lt;h3&gt;经典IPC问题&lt;/h3&gt;

&lt;h3&gt;页面置换算法&lt;/h3&gt;

&lt;h4&gt;最优页面置换算法&lt;/h4&gt;

&lt;p&gt;基于2点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当缺页中断(page fault)发生时，有些页面在内存中，其中有一个页面（包含紧接着的下一条指令的那个页面）将很快被访问，其他页面则可能要10、100、1000条指令后才会访问，这个指令数就是标记&lt;/li&gt;
&lt;li&gt;最优页面置换，就是置换掉标记最大的页面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而无法实现，因为操作系统无法知道各个页面下一次将在什么时候被访问。&lt;/p&gt;

&lt;p&gt;不过可以作为性能对比工具，例如弄个仿真程序，先跟踪一遍所有页面的访问情况，然后第二次运行则可以用第一次的数据来跑出最优页面置换算法。之后再用其他算法也跑一下，从而做对比。不过此方案问题在于是针对某个特定程序而言的。&lt;/p&gt;

&lt;h4&gt;最近未使用页面置换算法（NRU，not recently used）&lt;/h4&gt;

&lt;p&gt;首先每个页面设置2个状态位:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;R位，被访问时设置&lt;/li&gt;
&lt;li&gt;W位，被写入时设置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法：&lt;/p&gt;

&lt;p&gt;当启动一个进程时，它的所有页面的两个位都由操作系统设置成0，R位被定期地清零（比如每次时钟中断时）以区别最近没有被访问的页面和被访问的页面。&lt;/p&gt;

&lt;p&gt;当发生缺页中断时，操作系统检查所有的页面并根据它们当前的R位和M位的值，把它们分为4类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;没有被访问，没有被修改&lt;/li&gt;
&lt;li&gt;没有被访问，被修改&lt;/li&gt;
&lt;li&gt;被访问，没有被修改&lt;/li&gt;
&lt;li&gt;被访问，被修改&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本算法随机地从类编号最小的非空类中挑选一个页面淘汰。&lt;/p&gt;

&lt;h4&gt;先进先出置换算法 FIFO&lt;/h4&gt;

&lt;p&gt;页面按照访问时间顺序组成链表，每次发生缺页中断时直接从表头的页面干掉，并把新页面放到表尾。&lt;/p&gt;

&lt;p&gt;问题在于常用页面也可能会被淘汰，&lt;/p&gt;

&lt;h4&gt;第二次机会页面置换算法&lt;/h4&gt;

&lt;p&gt;这个是 FIFO的改进：要淘汰时，检查最老页面的R位，如果是0，那么可以置换掉；如果是1，那么就是最近访问过的，把R位设0，并移动到链表末端。&lt;/p&gt;

&lt;p&gt;如果所有页面都被访问过了，那么退化为普通的FIFO。&lt;/p&gt;

&lt;h4&gt;时钟页面置换算法&lt;/h4&gt;

&lt;p&gt;上面的算法的问题在于要经常在链表移动页面。改进方法：改成环形链表，一个指针指向最老的页面。&lt;/p&gt;

&lt;p&gt;当发生缺页中断时：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查指针指向的页面，若R位为0，则淘汰该页面，把新页面放入这个位置，指针移动到下一个位置；&lt;/li&gt;
&lt;li&gt;若R为1，则清除R位，指针还是++，重复这个过程直到找到一个R为0的页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;最近最少使用算法（LRU）&lt;/h4&gt;

&lt;p&gt;在缺页中断发生时，置换未使用时间最长的页面。&lt;/p&gt;

&lt;p&gt;假设还是用链表，要达到LRU，需要每次访问内存都更新链表：在链表中找到这个页面，删除它，然后把它移动到表头。&lt;/p&gt;

&lt;p&gt;不用链表，有别的方案：&lt;/p&gt;

&lt;p&gt;每个页表存一个属性：指令计数器，每条指令执行完后加1；当发生缺页中断时，检查所有页表项的计数器值，找到值最小的页面，就是最近最少使用的页面了。这是基于硬件的方案。&lt;/p&gt;

&lt;h4&gt;软件实现的LRU&lt;/h4&gt;

&lt;p&gt;NFU（Not Frequently Used，最不常用）算法：&lt;/p&gt;

&lt;p&gt;内存里做一个表，把每个页面和一个软件计数器相关联，初值为0，每次时钟中断时，操作系统扫描内存中&lt;strong&gt;所有的页面&lt;/strong&gt;，把每个页面的R位的值加到计数器上，这个计数器大体跟踪了各个页面被访问的频繁程度。发生缺页中断时，淘汰计数器值最小的页面。&lt;/p&gt;

&lt;p&gt;改进的NFU——Aging老化算法：&lt;/p&gt;

&lt;p&gt;因为NFU对旧状态记忆得太深，不能应对快速变化的程序状态，有可能根据计数器淘汰了最经常访问的页面。可以修改一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在R位被加进计数器前，计数器右移一位（除2）；&lt;/li&gt;
&lt;li&gt;将R位加到计数器最左端的位而不是最右端的位；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发生缺页中断还是淘汰计数器值最小的页面。老化算法的问题在于计数器只有有限位，限制了它对过往状态的记忆能力。&lt;/p&gt;

&lt;h4&gt;基本工作集页面置换算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;工作集：一个进程当前正在使用的页面的集合称为它的工作集。&lt;/li&gt;
&lt;li&gt;颠簸：如果内存太小不足以容纳整个工作集，那么每执行几条指令就会发生一次缺页中断&lt;/li&gt;
&lt;li&gt;预先调页：在进程运行前预先装入其工作集页面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;工作集的严格定义：在任一时刻t，都存在一个集合，它包含所有最近k次内存访问所访问过的页面，称为w(k,t)&lt;/p&gt;

&lt;p&gt;w是k的单调非递减函数，且会收敛到一个稳定的范围。预先调页原理就是基于以下推测：程序上次结束时w有一个稳定范围，可预先装下这个范围的工作集。&lt;/p&gt;

&lt;p&gt;实现条件：操作系统必须跟踪哪些页面在工作集中。&lt;/p&gt;

&lt;p&gt;基于工作集的页面置换算法：当发生缺页中断时，淘汰一个不在工作集的页面。精确地统计工作集，就是确定一个k值。&lt;/p&gt;

&lt;p&gt;问题：工作集的计算不容易。2种方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按使用频率计。成本比较高。k还是按次数的k。&lt;/li&gt;
&lt;li&gt;按执行时间计。k变成秒数r，工作集变成在过去的r秒实际运行时间(使用了CPU的时间)中进程所访问页面的集合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺页中断时，需要扫描整个页表，找出适合的页面来淘汰。&lt;/p&gt;

&lt;h4&gt;工作集时钟页面置换算法&lt;/h4&gt;

&lt;p&gt;上面的算法问题在于需要扫描整个页表来淘汰页面。&lt;/p&gt;

&lt;p&gt;改进（类似前面的时钟页面置换算法）:&lt;/p&gt;

&lt;p&gt;建立一个以页框为元素的循环表。每次缺页中断时，首先检查指针指向的页面，如果R为1，则把R改为0，并把指针++，重复这个逻辑；R为0时，如果指针当前页面的生存时间大于r，并且页面是干净的（M=0），它就不在工作集中且磁盘上有一个有效的副本，置换替换掉此页框即可，如果M为1，为了避免写磁盘操作引起进程切换，指针继续++，检查下一个页。&lt;/p&gt;

&lt;h4&gt;总结&lt;/h4&gt;

&lt;p&gt;最好的算法是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;老化算法（LRU）&lt;/li&gt;
&lt;li&gt;工作集时钟算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;分页系统的设计问题&lt;/h3&gt;

&lt;h4&gt;进程之间的内存竞争&lt;/h4&gt;

&lt;p&gt;考虑多个进程的页面置换算法称为全局算法，反之就是局部算法。&lt;/p&gt;

&lt;p&gt;全局算法一般是基于&lt;strong&gt;PFF&lt;/strong&gt;，page fault frequency，缺页中断率，它指出了&lt;strong&gt;何时增加或减少分配给一个进程的页面&lt;/strong&gt;，但却完全没有说明在发生缺页中断时应该替换掉哪一个页面。仅控制分配集的大小。&lt;/p&gt;

&lt;p&gt;PFF的测量：PFFF = (当前1秒的PFF + 旧PFF）/ 2&lt;/p&gt;

&lt;h4&gt;负载控制&lt;/h4&gt;

&lt;p&gt;问题：即使是使用最优页面置换算法，也可能会发生颠簸，如内存不足的时候。&lt;/p&gt;

&lt;p&gt;解决方案：将一部分进程交换到磁盘，释放他们所占有的所有页面。&lt;/p&gt;

&lt;h4&gt;页面大小&lt;/h4&gt;

&lt;p&gt;有公式可以算页面大小，对于平均进程大小为1MB，每个页表项为8B的系统，最优页面是4KB。一般范围是到64KB。&lt;/p&gt;

&lt;h4&gt;分离指令空间和数据空间&lt;/h4&gt;

&lt;p&gt;地址空间太小时，拆成2个空间就会改善情况。不过现在64位系统的地址空间很大，拆2个空间是因为别的原因了。&lt;/p&gt;

&lt;h4&gt;共享页面&amp;amp;共享库&amp;amp;内存映射文件&lt;/h4&gt;

&lt;p&gt;原因：避免在内存中有一个页面的两个副本。&lt;/p&gt;

&lt;p&gt;策略：共享I空间。&lt;/p&gt;

&lt;p&gt;还有问题：释放页面要考虑有没别的进程在使用这个页面。所以共享页面要有特殊的数据结构来记录。&lt;/p&gt;

&lt;p&gt;其他问题：fork调用，理应拷贝数据段，但就会产生大量副本。解决方法是写时复制COW。&lt;/p&gt;

&lt;p&gt;共享库就是DLL了，不过有个问题是地址。共享库要用相对地址，办法是编译时设置参数。&lt;/p&gt;

&lt;p&gt;内存映射文件，应该就是共享内存了。&lt;/p&gt;

&lt;h4&gt;清除策略&lt;/h4&gt;

&lt;p&gt;弄个分页守护进程（paging daemon），定时被唤醒检查内存、看是不是要置换掉页面，如果已修改，那么要写硬盘，如果未修改且硬盘有副本，则直接清除。&lt;/p&gt;

&lt;h3&gt;有关实现&lt;/h3&gt;

&lt;h4&gt;缺页中断处理流程&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;硬件陷入内核，在堆栈中保存程序计数器。大多数机器将当前指令的各种状态信息保存在特殊的CPU寄存器中。&lt;/li&gt;
&lt;li&gt;启动一个汇编代码例程保存通用寄存器和其他易失的信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。&lt;/li&gt;
&lt;li&gt;当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么。&lt;/li&gt;
&lt;li&gt;一旦知道了发生缺页中断的虚拟地址，操作系统检査这个地址是否有效，并检査存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程(&lt;strong&gt;segment fault！&lt;/strong&gt;)。如果地址有效且没有保护错误发生，系统则检査是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。&lt;/li&gt;
&lt;li&gt;如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，&lt;strong&gt;让其他进程运行直至磁盘传输结束&lt;/strong&gt;。无论如何，该页框被&lt;strong&gt;标记为忙&lt;/strong&gt;，以免因为其他原因而&lt;strong&gt;被其他进程占用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;—旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统査找所需页面在磁盘上的地址，通过磁盘播作将其装入，该页面正在被装入时，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行„&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;磁盘中断&lt;/strong&gt;发生时，表明该页已经被装人，页表已经更新并可以反映它的位置，页框也被标记为正常状态。&lt;/li&gt;
&lt;li&gt;恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。&lt;/li&gt;
&lt;li&gt;调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。&lt;/li&gt;
&lt;li&gt;该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;指令备份&lt;/h4&gt;

&lt;p&gt;即怎么记忆发生中断的指令位置，以及怎么恢复。方法是在执行一条指令前用一个寄存器备份这条指令。&lt;/p&gt;

&lt;h4&gt;锁页面&lt;/h4&gt;

&lt;p&gt;例如缺页中断时把别的进程的缓冲区的页面置换掉了，别的进程如果用DMA传输数据中，就会覆盖掉了刚被装入的页面，全乱了。解决方法是对页面加锁。&lt;/p&gt;

&lt;h4&gt;后备存储&lt;/h4&gt;

&lt;p&gt;即置换页面，把页面放到硬盘哪里的问题。&lt;/p&gt;

&lt;p&gt;方法：设立一个交换分区，专门来做这个事情。具体而言要3个区：正文、堆栈、数据。&lt;/p&gt;

&lt;h4&gt;分段&lt;/h4&gt;

&lt;p&gt;现在x86-64都去掉分段机制了，目测没有学习的必要。&lt;/p&gt;

&lt;h2&gt;文件系统&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;主引导记录：磁盘的0号扇区（Master Bot Record, MBR)，用来引导计算机&lt;/li&gt;
&lt;li&gt;分区表：在MBR的末尾，给出了每个分区的起始和结束地址&lt;/li&gt;
&lt;li&gt;活动分区：分区表的某一个分区被定为活动分区&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;启动流程：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;计算机被引导&lt;/li&gt;
&lt;li&gt;BIOS读入并执行MBR&lt;/li&gt;
&lt;li&gt;MBR确定活动分区&lt;/li&gt;
&lt;li&gt;MBR读入活动分区的第一个块（引导块）&lt;/li&gt;
&lt;li&gt;引导块中的程序将装在该分区中的操作系统&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note：为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统&lt;/p&gt;

&lt;h4&gt;文件的实现&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;连续分配。读取速度快，但容易产生碎片。存储时就需要知道文件大小。&lt;/li&gt;
&lt;li&gt;链表分配。随机读取速度慢。指针占用一些字节，导致一些效率问题。&lt;/li&gt;
&lt;li&gt;文件分配表FAT。在内存中弄一张表，用来获取磁盘块链表信息，从而避免了在磁盘块头存节点信息。随机读取速度变快。问题是如果块大小才1KB，但是磁盘空间1T，内存分配表就需要10亿个项，假设每项3个字节，就需要3GB内存。&lt;/li&gt;
&lt;li&gt;i节点。是对FAT的改进，把链表信息存到磁盘上形成一个i节点文件，打开某个文件时把i节点文件信息载入到内存。i节点的唯一问题是定长大小的话，怎么动态扩容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;目录的实现&lt;/h4&gt;

&lt;p&gt;目录系统主要功能：把文件名映射成定位文件数据所需的信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;目录：一堆目录项，kv对&lt;/li&gt;
&lt;li&gt;目录项：k是文件名，v可以随意，一般是i节点号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;问题：文件名不定长。定长的话容易浪费空间。&lt;/p&gt;

&lt;p&gt;解决方案:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;让目录项大小不一致。问题一是如果移走一个文件会导致出现大小不定的空隙，二是目录项可能会跨页面，在读取文件名时可能会发生缺页中断。&lt;/li&gt;
&lt;li&gt;目录项大小一致，但把文件名移出目录项，放到目录最后的堆里。但就要对堆进行管理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;共享文件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;硬链接：创建直接与目标文件关联的i节点。删除文件操作会变得复杂。&lt;/li&gt;
&lt;li&gt;符号链接：创建一个符号文件（类型link），文件中只包含&lt;strong&gt;所链接的文件的路径&lt;/strong&gt;。删除文件没什么大问题。额外开销时是要通过路径找到目标文件的i节点，以及符号文件本身还是要有一个i节点和一个磁盘块放路径，毕竟还是个文件。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 10 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/os-1/</link>
        <guid isPermaLink="true">http://localhost:4000/os-1/</guid>
      </item>
    
      <item>
        <title>漫谈网络通讯加密（2）流程设计</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;加密通讯的基础&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonce&lt;/a&gt;（不重数）&lt;/h2&gt;

&lt;p&gt;在进入正文前，先介绍一个关键的东西：nonce，以及几个粗糙的例子，以说明nonce的作用。&lt;/p&gt;

&lt;p&gt;nonce本质就是一段随机码，因为不一定是数字，可能是字符，所以不能叫随机数。因此取了个名字叫nonce。&lt;/p&gt;

&lt;p&gt;nonce的存在是为了对付&lt;strong&gt;彩虹表(raintable)&lt;/strong&gt;、&lt;strong&gt;重放攻击(replay attack)&lt;/strong&gt;，或者说为了制造&lt;strong&gt;请求唯一性(request unique)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;nonce有server nonce、client nonce之分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要client nonce的原因：阻止邪恶的客户端做重放攻击。&lt;/li&gt;
&lt;li&gt;需要server nonce的原因：阻止中间人攻击。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nonce的生成策略有讲究：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以是时间相关变量&lt;/li&gt;
&lt;li&gt;可以是一个通过强随机算法生成的足够长的bits&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;例子：登录与登录密码&lt;/h3&gt;

&lt;h4&gt;方案1&lt;/h4&gt;

&lt;p&gt;直接经过无加密的tcp或者http，发password到服务器进行登录。&lt;/p&gt;

&lt;p&gt;问题：登录包一被截取，密码就泄露了，攻击者想怎么搞就怎么搞了。&lt;/p&gt;

&lt;h4&gt;方案2&lt;/h4&gt;

&lt;p&gt;对password做一个经典的hash：&lt;/p&gt;

&lt;p&gt;secret = Hash(password);&lt;/p&gt;

&lt;p&gt;客户端只发secret给服务器，服务器执行（这里假设存了密码原文）：&lt;/p&gt;

&lt;p&gt;secrect_server = Hash(password_server)；&lt;/p&gt;

&lt;p&gt;得到secret_server即可做校验。&lt;/p&gt;

&lt;p&gt;问题：攻击者还是截包，就获得了secret，因为每次登录都是发一样的secret，所使攻击者首先可以做&lt;strong&gt;重放攻击&lt;/strong&gt;，直接copy用户的登录包，发给服务器，就可以登录了；其次，因为Hash函数无非md5、SHA256这些，完全可以用raintable暴力查表，获得password。&lt;/p&gt;

&lt;h4&gt;方案3&lt;/h4&gt;

&lt;p&gt;改进：客户端每次登录前，服务器会生成一个nonce并发给客户端，客户端计算：&lt;/p&gt;

&lt;p&gt;secret = Hash(nonce_server, password);&lt;/p&gt;

&lt;p&gt;客户端只发secret给服务器，服务器执行：&lt;/p&gt;

&lt;p&gt;secrect_server = Hash(nonce_server, password_server)；&lt;/p&gt;

&lt;p&gt;然后比较secret和secret_server是否一致即可。&lt;/p&gt;

&lt;p&gt;优点：每次登录hash出来的secret都不一样，用户密码比较安全了，要破解密码，得根据secret、nonce_server、Hash，逆向出password，可行，但耗时。&lt;/p&gt;

&lt;p&gt;问题：服务端发送的nonce可以被攻击者篡改成固定的nonce，从而导致nonce特性还是被消去了，攻击者就还是可以弄raintable，暴力破解密码。
拿到密码后，就可以骗过服务器了，实现中间人攻击。&lt;/p&gt;

&lt;h4&gt;基于方案3的方案4&lt;/h4&gt;

&lt;p&gt;既然方案3中，客户端接收了攻击者篡改出来的固定nonce，并发送了符合攻击者raintable预期的secret，导致密码容易被破解，那么客户端是否可以做一些保护措施，使得发到网络中的secret是随机的呢？&lt;/p&gt;

&lt;p&gt;方法是有的，就是客户端也生成nonce， 称之为nonce_client，secret的计算变成：&lt;/p&gt;

&lt;p&gt;secret = nonce_client || Hash(nonce_client, nonce_server, password)&lt;/p&gt;

&lt;p&gt;（Note：||表示concat操作）&lt;/p&gt;

&lt;p&gt;服务器收到secret后拆出nonce_client和hash值，本地也执行一遍这条公式，就能做登录校验。&lt;/p&gt;

&lt;p&gt;这样处理后，攻击者即使篡改了nonce_server，攻击者收到的客户端secret依然是随机的。并不能直接查raintable获得password，而必须根据客户端的nonce_client，即时算出一份新的raintable表（计算量巨大），才能破解密码。&lt;/p&gt;

&lt;p&gt;问题：在登录过程中，本质上还是发送了password，就依然有被猜出密码的可能。如果这个密码是用户的常用密码，例如生日，那后果还是很可怕的。&lt;/p&gt;

&lt;p&gt;进一步的思路：既然发送加密的密码不妥，那就是用DH密钥交换了，就不会有密钥在网络中传输的问题。当然对于用户输入密码登录的场景，DH应该是用不了了。&lt;/p&gt;

&lt;h1&gt;简单版本的加密通讯&lt;/h1&gt;

&lt;p&gt;首先以一个较为简单的例子来说明：某客户端想和某服务器建立tcp加密通讯。&lt;/p&gt;

&lt;p&gt;首先需要一个工具：公钥私钥对（非对称加密技术）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务器在本地或数据库中存放了用于和任意客户端建立通讯的公钥私钥对。&lt;/li&gt;
&lt;li&gt;客户端想和服务器通讯时，服务器发送公钥给客户端。客户端确信用这个公钥加密的数据只有这个服务器能解密。（暂时不考虑中间人攻击问题）&lt;/li&gt;
&lt;li&gt;客户端计算一个key（其实是pre-master key和master key，下文会介绍），这个key可能真的是本地算出来的，也可能用DH算法和服务器交换出来的。如果是本地算出来的，那就必须用刚刚的非对称加密通讯信道，发给服务器。总之，key是客户端服务器都得持有。&lt;/li&gt;
&lt;li&gt;客户端服务器各自生成nonce，互发给对方。此时双方都持有key、cnonce、snonce。&lt;/li&gt;
&lt;li&gt;客户端服务器各自本地计算Hash(key，cnonce，snonce)获得真正用于通讯的对称密钥encrypt key。&lt;/li&gt;
&lt;li&gt;另外的，客户端服务器还可以计算Hash2(key，cnonce，snonce)，获得用于别的用途的key，例如integrity protection key，验证消息用的key。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;仔细看，第三步传递key之后的步骤其实不是必须的，因为key是用安全的非对称加密信道协商了，没有泄露key的问题。&lt;/p&gt;

&lt;p&gt;然而，如果每次建立通讯都要走1-3步骤的话，开销会比较大，所以key其实是要复用的。例如客户端可以缓存在本机，服务器就缓存到数据库，设个过期时间。&lt;/p&gt;

&lt;p&gt;之后如果客户端想再次发起通讯，那么就可以跳过1-3步，直接执行4-6步，算出用于本次通讯的加密密钥。&lt;/p&gt;

&lt;h1&gt;完整版本的加密通讯&lt;/h1&gt;

&lt;h2&gt;一，公钥证书&lt;/h2&gt;

&lt;p&gt;首先，上一篇文章说的CA那套公钥证书的东西，是必要的。因为在互联网中通讯，只有依靠公钥证书这个机制，才能确认正在握手的对端是不是你所预期的对端。简要地回顾下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务器向客户端出示由某CA签发的公钥证书，即CA用&lt;strong&gt;CA私钥&lt;/strong&gt;加密了服务器公钥，导出来的东西，称之为公钥证书&lt;/li&gt;
&lt;li&gt;在握手前，用户的浏览器已经安装了该CA的证书，该证书里面有CA的公钥&lt;/li&gt;
&lt;li&gt;客户端用本地CA公钥，&lt;strong&gt;解密&lt;/strong&gt;收到的公钥证书得到服务器公钥。解得出来，那就说明这个服务器公钥（证书）确实是这个CA曾经用私钥加密过的。&lt;/li&gt;
&lt;li&gt;当然，公钥证书是有过期问题的，例如服务器把私钥泄露了，那相应的公钥证书就得从CA里删掉，这就涉及到了&lt;strong&gt;证书撤销列表CRL&lt;/strong&gt;。CRL就是一个数据库，这个数据库显然得支持分布式，否则全世界的用户都涌到中心化的服务器去验证证书是否已被撤销，那是做不到的。而分布式数据库，显然就有个更新同步延迟问题，中心数据库更新了CRL，什么时候本地能更新CRL缓存，就决定了安全度有多高。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第4步骤先不说，前3步骤才是最关键的。这些流程，完全是为了&lt;strong&gt;确认正在握手的服务器是不是自己所信任的CA签名了的服务器&lt;/strong&gt;。信任的根基是CA，客户端只相信CA，CA说什么就是什么。&lt;/p&gt;

&lt;p&gt;值得思考的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端会不会装了不可靠的CA证书。如果是，那后面的所有流程都是白搭了。&lt;/li&gt;
&lt;li&gt;通讯双端没有CA基础设施怎么办？例如手机游戏，没有什么浏览器CA，只有tcp udp可用。答案是直接把服务器公钥硬编码到客户端安装包里，只要用户确保是从正规途径下载的安装包，那么就可以保证客户端里的公钥是真实服务器的公钥。例如从app store下载游戏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;二，都是为了加密性能&lt;/h2&gt;

&lt;p&gt;第一步中，客户端和服务器已经建立了可靠的&lt;strong&gt;非对称加密通讯&lt;/strong&gt;，客户端持有服务器的公钥，客户端用公钥加密自己数据，只有服务器才能解密，不就万事大吉了吗？&lt;/p&gt;

&lt;p&gt;然而很可惜的是，非对称加密算法，性能一般都差强人意，远不如&lt;strong&gt;对称加密算法&lt;/strong&gt;。所以如果用户要发送大量隐私数据给服务器，且只用非对称加密的话，先不说客户端耗能，服务器的CPU首先就炸了。&lt;/p&gt;

&lt;p&gt;用指令openssl speed xxx，可以认识到各种算法的性能：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;                        sign        verify          sign/s    verify/s
rsa 2048 bits 0.000738s 0.000022s   1354.2  45918.7

因为rsa是按次的，这里得换算成k bytes才能和aes比较，即乘以256再除以1000：
rsa 2048 bits 0.000738s 0.000022s   346.7k 11755.2k


type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
aes-128 cbc      99115.02k   115128.04k   122790.06k   126412.46k   126915.93k

                              op      op/s
 256 bit ecdh (nistp256)   0.0001s  14937.4
 384 bit ecdh (nistp384)   0.0008s   1265.2
 521 bit ecdh (nistp521)   0.0009s   1148.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然可以看出rsa和aes根本不是同个数量级的，rsa私钥运算大约比aes慢1000倍。&lt;/p&gt;

&lt;p&gt;性能是关键，接下来的步骤，都得归咎于非对称加密算法的性能。&lt;/p&gt;

&lt;h2&gt;三，前主密钥和主密钥：pre-master key和master key&lt;/h2&gt;

&lt;p&gt;因为性能问题，我们希望尽可能不使用非对称加密通讯信道，甚至不去建立非对称加密通讯。&lt;/p&gt;

&lt;p&gt;最终的，非对称加密通讯所要负责的事情，被精简成一件事：协商一个master key。&lt;/p&gt;

&lt;p&gt;在说master key时，需要搞清楚pre-master key和master key分别是什么，有什么区别：&lt;/p&gt;

&lt;p&gt;pre-master key：是服务器和客户端&lt;strong&gt;直接协商&lt;/strong&gt;出来的产物（key exchange）。例如用ECDH密钥协商算法算出来的东西。唯一要提的点是，pre-master key是&lt;strong&gt;不定长&lt;/strong&gt;的，取决于选择了什么样的密钥协商算法，一般算法越强，长度越长。&lt;/p&gt;

&lt;p&gt;master key：正因为pre-master key不定长的问题，导致出现了master key这个东西，master key是&lt;strong&gt;定长&lt;/strong&gt;的。master key从pre-master key派生，是它的亲儿子。&lt;/p&gt;

&lt;p&gt;这个&lt;a href=&quot;https://tools.ietf.org/html/rfc5246#section-8.1&quot;&gt;RFC&lt;/a&gt;里有提及如何算master key:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master_secret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre_master_secret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;master secret&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;ClientHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServerHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                          &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0..47&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用本文的术语来表达的就是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master_key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre_master_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;master key&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;nonce_client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonce_server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                          &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0..47&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PRF（Pseudo-random function），是&lt;strong&gt;伪随机导出函数&lt;/strong&gt;。这段代码意思是，根据pre-master key、nonce_client、nonce_server三个参数，伪随机地，导出了一个master key，定长48字节。&lt;/p&gt;

&lt;p&gt;PRF的简单实现是hash(key || msg)或hash(msg || key)或hash(key || msg || key)，三种情况的问题不太一样，但都是naive的，例如可能会遇到&lt;a href=&quot;https://en.wikipedia.org/wiki/Length_extension_attack&quot;&gt;Length extension attack&lt;/a&gt;。严格的PRF实现是HKDF，下篇文章再介绍。&lt;/p&gt;

&lt;p&gt;RFC里补充说，一旦得到了master key，即可从内存干掉pre-master key。对待生父是如此的残忍啊，不过也是必要的，免得给恶意程序可乘之机。（nonce_client、nonce_server并不能删除，之后还要用到）&lt;/p&gt;

&lt;p&gt;pre-master key在master key出来后消失了，生命期非常短暂，所以本节重点显然是master key。&lt;/p&gt;

&lt;p&gt;这节不说master key的作用，先说master key的管理问题。&lt;/p&gt;

&lt;p&gt;在常规的https通讯中，每次tcp连接都意味着计算一个新的master key，成本挺高，当然安全性也高。&lt;/p&gt;

&lt;p&gt;但有的时候想要节约掉这个成本，例如连续不断地对同个服务器发起多次https请求（短连接），于是就有人发明了缓存机制。&lt;/p&gt;

&lt;p&gt;缓存，就是指长时间地妥当地把master key存起来，随时拿出来用。但并不能直接存取，会有安全问题。&lt;/p&gt;

&lt;p&gt;有2种套路，一个是session id，本质是服务器做缓存；另一个是session ticket，是客户端做缓存。&lt;/p&gt;

&lt;h3&gt;session id&lt;/h3&gt;

&lt;p&gt;在之前的密钥协商后，服务器会分配一个session id，并在数据库中存入以session id为键的会话信息如master key。下次做密钥协商时，客户端发现已经缓存了一个session id，那么发id给服务器，如果服务器能在数据库找出这个id对应的master key，那么就不需要去协商master key了。不过缺点是很难维护一个这样子的数据库。&lt;/p&gt;

&lt;h3&gt;session ticket&lt;/h3&gt;

&lt;p&gt;新的会话建立时，服务器用一个只有自己知道的密钥（ticket key）对master key做加密，把密文ticket发给客户端，客户端单纯地只把ticket缓存起来。下次要建立会话时，把缓存的ticket发给服务器，服务器解密，就拿到之前的master key。因为ticket key必须所有服务器一致，且不可变，也有一定安全风险，现在一般是采用轮转的方式，定时地渐进式地淘汰旧的ticket key（新的会话用旧的ticket key尝试解密，用新的ticket key加密）。&lt;/p&gt;

&lt;p&gt;这两种方案中，共同点都是客户端依然得自己缓存好master key。&lt;/p&gt;

&lt;p&gt;关于master key还有它自身的时效性问题。是否缓存一次，永久使用？答案是不可以，这不安全。&lt;/p&gt;

&lt;p&gt;一般master key要设个过期时间，一天、一个星期、一个月，加了限时，就保证了要定期更换，一定程度降低了master key泄露的风险。过期时间服务器决定，客户端如果缓存的是过期的master key，那服务器应有反馈，并重新协商新的master key。&lt;/p&gt;

&lt;h2&gt;四，基于master key，得到对称加密密钥，建立对称加密通讯&lt;/h2&gt;

&lt;p&gt;刚才的简化例子有一点没有说清楚的，就是nonce怎么发送。&lt;/p&gt;

&lt;p&gt;实际上，nonce_client, nonce_server，都可以不经过加密通讯信道直接发送，泄露了也没关系。&lt;/p&gt;

&lt;p&gt;因为需要的对称加密密钥基于三个参数：&lt;/p&gt;

&lt;p&gt;encrypt key = Hash(master key，nonce_client, nonce_server)&lt;/p&gt;

&lt;p&gt;我们不怕泄露后2个，因为第一个master key已经保证保密了。这样子hash出来的encrypt key也依然是保密的。&lt;/p&gt;

&lt;p&gt;有了双方一致的encrypt key，就可以拿出各种对称加密算法，来建立加密通讯了。&lt;/p&gt;

&lt;p&gt;要注意的点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nonce_client, nonce_server存在的意义前文也说过了，主要是防止重放攻击、中间人攻击，所以每次想要用master key建立加密通讯，都是即时地重新协商nonce。&lt;/li&gt;
&lt;li&gt;encrypt key实际上要2个，因为tcp是全双工连接，有2个数据流方向，2个方向的encrypt key如果一样，安全系数就降低了，详情不表。最好就是一个方向一个encrypt key。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;五，加密数据的完整性保证&lt;/h2&gt;

&lt;p&gt;前四步骤已经几乎建立了绝对可靠的性能不错的加密通讯，但还有一个问题：建立加密通讯后，客户端发出去的包，依然还是有被截包篡改的可能。&lt;/p&gt;

&lt;p&gt;例如A用encrypt key加密了原文a得到密文b，用tcp把b发出去，b被攻击者截取，攻击者可能用各种奇奇怪怪的方法尝试篡改这个密文b变成密文c，亦或者替换了b变成密文d（很可能是通讯早期截获的包！），然后继续发向服务器，那么就还是不安全，因为客户端想要发给服务器的密文b并没有真正送到，服务器还处理了别的密文！&lt;/p&gt;

&lt;p&gt;还有一种情况是，客户端和服务器的对称密钥因为某种原因不同步了，这样会导致服务器用错误的对称密钥解密数据得到了“乱码”，但服务器是完全感知不到用了错误的密钥，服务器无法知道乱码是不是乱码。&lt;/p&gt;

&lt;p&gt;即使是加密通讯的建立过程本身，都有完整性安全漏洞，即下一节会说到的&lt;strong&gt;算法选取&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;那怎么办呢？答案是再给密文b加一层&lt;strong&gt;认证&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;简单理解就是，客户端给密文b做个hash，得到消息验证码MAC（上一篇文章介绍过的)，把密文b和MAC一起发给服务器，服务器也对收到的密文做一样的hash，如果服务器得到的MAC值和客户端的MAC值不一致，那就说明数据不是客户端发来的。&lt;/p&gt;

&lt;p&gt;hash函数刚才也提到过了，需要一个integrity key，也是基于master key的。攻击者没有办法获得一样的hash函数。&lt;/p&gt;

&lt;p&gt;MAC的安全隐患上一篇文章也说到过了。最经典的是重放攻击，就是攻击者并不篡改密文和MAC，而只是原样地保存下来，并伺机重复发送给服务器。这个问题的解决办法就是对每条消息加一个递增的序号。同样的消息就不可能收到两次。&lt;/p&gt;

&lt;p&gt;P.S. 用一个额外的MAC（其实应该叫做MtE，EtM，E&amp;amp;M）来保证完整性已经是一种过时的思路，有安全缺陷。其中只有EtM(encrypt then MAC)是安全的，是一个大坑。让程序员搞懂这三者区别也是痛苦。所以现在并不提倡EtM之类的做法了。&lt;/p&gt;

&lt;p&gt;取而代之的是AEAD。所谓AEAD，含义是在对称加密算法里添加了完整性验证的功能，例如AES-128-GCM、ChaCha20-IETF-Poly1305。所以AEAD并不是一种算法，而只是方案的代名词。在即将到来的TLSv1.3中，已经彻底干掉MAC，而统一用AEAD了。&lt;/p&gt;

&lt;p&gt;然后剩下就是&lt;strong&gt;算法选取步骤&lt;/strong&gt;的认证问题。&lt;/p&gt;

&lt;p&gt;这个问题很有意思，因为我们的加密通讯已经建立了，认证机制也有了。&lt;strong&gt;这时候反而可以回过头来认证下算法选取过程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;客户端和服务器在tcp三次握手后直到建立SSL连接，中间n次交流的内容（有对称性），都记录下来，然后在连接建立完成后，互相在本地对这些内容做一次HMAC计算，并把MAC值发给对方校验，如果不一致，说明有中间人篡改了某次交流，那么关闭本次连接。&lt;/p&gt;

&lt;h2&gt;六，加密算法选取&lt;/h2&gt;

&lt;p&gt;上面的五大步骤，其实都没有限定具体用什么算法。据我了解，如果不用openSSL之类的库，而是自己手动组合，那么可以这么弄：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;master key：ECDH&lt;/li&gt;
&lt;li&gt;对称加密：AES&lt;/li&gt;
&lt;li&gt;生成encrypt key：SHA256&lt;/li&gt;
&lt;li&gt;生成integrity key：SHA256 with salt&lt;/li&gt;
&lt;li&gt;生成消息验证码：HMAC with integrity key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这对程序员的要求比较高，需要了解各种算法的优缺点和如何组合，是否适合配对。&lt;/p&gt;

&lt;p&gt;所以算法选取这个事情，已经被建立起规范，关键词叫做cipherSuite，例如openSSL就支持，可以执行openssl ciphers -V | column -t，看到系统的openSSL支持的cipherSuites：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/4.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;（注意，SSLv3已经过时了，现在都是TLSv1.2，即将出现TLSv1.3）&lt;/p&gt;

&lt;p&gt;第一列2个十六进制值相当于ID。&lt;/p&gt;

&lt;p&gt;以其中最常见的0xC0,0x2F为例：&lt;/p&gt;

&lt;p&gt;0xC0,0x2F  -  ECDHE-RSA-AES128-GCM-SHA256    TLSv1.2  Kx=ECDH        Au=RSA    Enc=AESGCM(128)    Mac=AEAD&lt;/p&gt;

&lt;p&gt;含义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用于TLSv1.2版本&lt;/li&gt;
&lt;li&gt;kx = key exchange，使用ECDHE做秘钥交换。就是上一篇文章说的DH基于椭圆曲线EC算法的变种。最后的E代表ephemeral，表示转瞬即逝性。&lt;/li&gt;
&lt;li&gt;Au = authenticity，使用RSA做认证&lt;/li&gt;
&lt;li&gt;Enc = encryption，使用AES-128-GCM做对称加密。GCM意味着加密算法支持认证功能。&lt;/li&gt;
&lt;li&gt;MAC = AEAD（authenticated encryption with associated data），一种同时具备保密性(confidentiality)，完整性(integrity)和可认证性(authenticity assurances)的加密形式。 MAC=AEAD意思是说“把这些认证问题交给对称加密算法就行了，不需要MAC”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以撇除掉融合到加密算法里的MAC，那么CipherSuite其实只有3个东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1个key exchange 密钥交换算法&lt;/li&gt;
&lt;li&gt;1个authentication 认证算法&lt;/li&gt;
&lt;li&gt;1个encryption 对称加密算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;引入CipherSuite，说明算法的选取不是完全定死的，而是可以根据需要协商的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;协商过程会发生在tcp三次握手后的第一个包里&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这就要注意1个问题：&lt;strong&gt;算法选取过程是无加密的&lt;/strong&gt;，发生什么攻击都可能。&lt;/p&gt;

&lt;p&gt;例如中间人攻击，中间人篡改了算法协商的内容，使得通讯双方用了安全度较低的、符合中间人预期的加密算法，那么这次通讯就不那么安全了。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;h2&gt;概括一下加密通讯标准过程&lt;/h2&gt;

&lt;p&gt;从tcp握手到算法协商完成，步骤大致如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;tcp完成三次握手&lt;/li&gt;
&lt;li&gt;客户端发送它支持的CipherSuite列表和client nonce（所谓的ClientHello）&lt;/li&gt;
&lt;li&gt;服务器从该列表中，选择一套合适的算法，然后连同自己的&lt;strong&gt;公钥证书&lt;/strong&gt;、server nonce 发给客户端（ServerHello）&lt;/li&gt;
&lt;li&gt;客户端验证证书，得到服务器公钥，基于公钥协商pre-master key，导出master key。&lt;/li&gt;
&lt;li&gt;客户端服务器各自本地计算各个对称密钥。&lt;/li&gt;
&lt;li&gt;用MAC算法认证本次连接握手信息，防止中间人攻击。认证通过后，即建立了加密通讯。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;0-rtt，1-rtt？&lt;/h2&gt;

&lt;p&gt;搞通讯偶尔会看到什么0-rtt，1-rtt，其实都指的是基于TLS连接，和tcp的三次握手没关系。&lt;/p&gt;

&lt;p&gt;TLS连接握手，是发生tcp三次握手后的事情，即三次握手后，还要经过多少个rtt回合，才能建立TLS连接？&lt;/p&gt;

&lt;p&gt;用1-rtt搞定TLS连接，那么这一个rtt必然是用来协商对称加密密钥的。比如说，你的程序可以强制客户端和服务端只用DH算法协商密钥，并且这个rtt里也发送各自的nonce，那么1-rtt后，通讯两端就都拥有了master key、cnonce、snonce。&lt;/p&gt;

&lt;p&gt;至于0-rtt，必然是有损安全性的。0-rtt意味着第一个数据包就得支持发送用户数据，那必然是用某种缓存的key来加密用户数据。这个key叫做半静态ECDH公钥。原理有点像前面说的，游戏客户端硬编码了服务器公钥。&lt;/p&gt;

&lt;p&gt;缺陷在于：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;0-RTT发送的应用数据没有前向安全性&lt;/li&gt;
&lt;li&gt;跨连接可以重放0-RTT里的应用数据（任何服务器端无共享状态的协议，都无法做到跨连接防重放）&lt;/li&gt;
&lt;li&gt;如果服务器端 半静态 ECDH公钥对应的私钥泄露了，攻击者就可以伪装成客户端随意篡改数据了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这简直就是性能和安全的博弈。google的QUIC就很好地实现了0-rtt。&lt;/p&gt;

&lt;h1&gt;微信mmtls对比&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.52im.net/thread-310-1-1.html&quot;&gt;mmtls介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;mmtls是微信自己设计的&amp;quot;TLS1.3&amp;quot;协议。&lt;/p&gt;

&lt;p&gt;mmtls分为3个部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;handshake协议：tcp连接建立后的密钥协商。&lt;/li&gt;
&lt;li&gt;alert协议：handshake失败时需要显式告诉对端。微信是服务端告诉客户端，让客户端来关闭连接，避免服务端过多的TIME_WAIT状态。&lt;/li&gt;
&lt;li&gt;record协议：负责上层数据的加密传输&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法组成：ECDH + ECDSA + AES-GCM（AEAD）&lt;/p&gt;

&lt;p&gt;几个关键点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;去掉了CA公钥证书这个环节，取而代之的是把认证公钥（verify_key）直接嵌入到客户端里，只要保证客户端来自官方渠道，就保证了verify_key不是中间人伪造的。&lt;/li&gt;
&lt;li&gt;把verify_key固定在客户端后，如果认证私钥（sign_key）泄露，怎么撤掉verify_key。方法是强制更新客户端，同时服务端加强对认证私钥的存放管理，怎么管理原文没有细说。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mmtls是对TLS1.3草案的精简，觉得与其分析mmtls还不如先好好看一遍TLS1.3，而且openSSL1.1.1已经发布了，支持TLS1.3。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/&quot;&gt;https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.helong.info/blog/2015/01/23/ssl_tls_ciphersuite_intro/&quot;&gt;https://blog.helong.info/blog/2015/01/23/ssl_tls_ciphersuite_intro/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cryptologie.net/article/340/tls-pre-master-secrets-and-master-secrets/&quot;&gt;https://www.cryptologie.net/article/340/tls-pre-master-secrets-and-master-secrets/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/crypto-2/</link>
        <guid isPermaLink="true">http://localhost:4000/crypto-2/</guid>
      </item>
    
      <item>
        <title>《计算机网络-自顶向下方法》笔记</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;网络层&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;是否对ip包分片，取决于输出链路的mtu，如果包大小大于mtu（可能500多到1500字节），那么就会自动分片&lt;/li&gt;
&lt;li&gt;分片有3个不可或缺字段：ip包的唯一标识（ID)、字节偏移offset、结束标志（0或1，1表示还没结束，0表示当前已是最后一个片）&lt;/li&gt;
&lt;li&gt;分片是ipv4的机制，且有安全问题，ipv6没有分片，杜绝了安全隐患&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分片重组是在目的地端主机上进行的，路由器只可能做分片，而不会做重组&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主机和物理链路之间的边界叫做接口&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个接口有自己的ip地址，所以ip地址技术是与接口关联，而不是和主机或路由器&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子网：直接互联并与其他网络岛隔离的主机接口+路由器接口组成子网&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子网掩码：例如223.1.1.0/24，/24就是子网掩码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络层有三个主要组件：IP协议、路由选择协议(RIP、OSPF、BGP）、因特网控制报文协议ICMP&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看和修改系统的mtu值：&lt;/p&gt;

&lt;p&gt;查看：&lt;/p&gt;

&lt;p&gt;ifconfig eth0&lt;/p&gt;

&lt;p&gt;修改：&lt;/p&gt;

&lt;p&gt;ifconfig eth0 mtu 1460&lt;/p&gt;

&lt;h2&gt;DHCP动态主机配置协议&lt;/h2&gt;

&lt;p&gt;四大步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DHCP发现报文，用UDP，端口67，src ip为0.0.0.0，dst ip为255.255.255.255，广播一个发现报文，报文里包含一个事物ID。&lt;/li&gt;
&lt;li&gt;DHCP提供报文，DHCP服务器收到广播而来的发现报文后，用一个提供报文做响应，src ip为自己的ip，dst ip为255.255.255.255，也是广播。因为DHCP服务器不一定唯一，所以客户机有选择权。提供报文包含，收到的发现报文的事物ID、向客户推荐的IP地址、IP地址的掩码、IP地址租用期（address lease time），租用期一般为几小时到几天。&lt;/li&gt;
&lt;li&gt;DHCP请求报文，客户机从1到多个提供报文中选择一个，并向该服务器发送DHCP请求报文。&lt;/li&gt;
&lt;li&gt;DHCP ACK报文，就是第三步的响应报文，告诉客户配置参数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第四步完成后，客户就可以在租用期里使用这个ip。另外，DHCP也有延长租用期的办法。&lt;/p&gt;

&lt;h2&gt;NAT网络地址转换&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;NAT是用来解决ipv4的ip地址不够用问题的&lt;/li&gt;
&lt;li&gt;NAT会使得外部主机不能直接访问内网主机（内网主机不可见），因为内网主机没有自己的全球唯一ip地址&lt;/li&gt;
&lt;li&gt;NAT用一张转换表来双向转发数据包&lt;/li&gt;
&lt;li&gt;内网主机可以主动访问外网，反过来就不行&lt;/li&gt;
&lt;li&gt;NAT的存在对实现p2p应用很不好&lt;/li&gt;
&lt;li&gt;应用NAT穿越技术，可以改善p2p应用的通讯问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NAT穿越：&lt;a href=&quot;https://www.jianshu.com/p/84e8c78ca61d&quot;&gt;https://www.jianshu.com/p/84e8c78ca61d&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;ICMP控制报文协议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;常用于差错报告，例如目的地不可达时，中间路由器就会返回类型3的ICMP报文&lt;/li&gt;
&lt;li&gt;ICMP协议是建立在IP协议上面的，因为是用IP分组承载的。类似TCP、UDP。但一般认为ICMP是属于网络层的协议。&lt;/li&gt;
&lt;li&gt;ICMP报文组成：类型、编码。编码可理解为大类型里的子类型。&lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol&quot;&gt;wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ping程序： 发一个ICMP[8,0]报文，目的主机发回一个ICMP[0,0]的报文。&lt;/p&gt;

&lt;p&gt;源抑制报文：从wiki可以看到已经deprecated了，最初是用来做拥塞控制的，不过tcp自己有拥塞控制，所以没卵用。&lt;/p&gt;

&lt;p&gt;traceroute：原理就是发送一系列IP数据报，每个数据报携带UDP报文，目的地ip为目标主机，端口号设置为不可达的端口号。关键的，第一个数据报的TTL设为1，第二个的TTL为2，以此类推。当第n个数据报到达第n台路由器时，第n台路由器发现这个数据报的TTL正好过期，然后就会发给源主机一个ICMP[11,0]，携带了该路由器的ip地址。然后每个数据报都设置了定时器，收到回复时就可以算出往返延迟RTT。&lt;/p&gt;

&lt;p&gt;traceroute还有个问题是何时停止发送udp报文，这是通过ICMP的类型和编码字段判断的，因为如果目的地主机在线，那么最终会返回一个ICMP[3,3]，表示目的主机端口不可达。&lt;/p&gt;

&lt;h2&gt;ipv6&lt;/h2&gt;

&lt;p&gt;改进：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;去掉了分片功能，因为分片功能是耗时操作，去掉后能提高路由器性能&lt;/li&gt;
&lt;li&gt;没有分片后，如果包太大，就无法发进链路层，只能丢弃，并返回ICMP差错报文，让发送方重新发一个小的&lt;/li&gt;
&lt;li&gt;去掉了首部校验和，因为传输层协议、链路层协议也会做校验和，所以多余了。另外，因为IP头部有个动态的跳数，会导致每次修改跳数都得重新计算校验和，影响性能。&lt;/li&gt;
&lt;li&gt;选项字段从IP首部去掉，但依然可以存在选项，方法是用“下一个头部”字段来实现，就是说选项信息是一个可选的头部。&lt;/li&gt;
&lt;li&gt;去掉了选项后，ipv6的头部就是定长的40字节，非常高效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2个ipv6主机之间通讯，可能会经过一段由仅支持ipv4的主机组成的路径，这时可以用隧道技术，把ipv6分组，放到ipv4分组的有效载荷里。&lt;/p&gt;

&lt;h2&gt;路由选择算法&lt;/h2&gt;

&lt;p&gt;全局式算法：路由器拥有网络拓扑信息、连通信息、链路费用信息，从而算出最优路径。也称为链路状态算法。链路费用一般取决于链路承载流量。&lt;/p&gt;

&lt;p&gt;分散式算法：路由器没有网络链路信息，而只需要拥有和路由器直接相连链路的费用信息就可开始工作。通过迭代、和邻居交换信息，就能逐渐计算出到达某目的地结点的最低费用路径。&lt;/p&gt;

&lt;p&gt;静态算法：依靠人工。&lt;/p&gt;

&lt;p&gt;动态算法：拓扑或负载变化时更新。不过容易受&lt;strong&gt;路由选择循环、路由震荡&lt;/strong&gt;影响。&lt;/p&gt;

&lt;p&gt;负载敏感算法：链路费用会动态地变化，以反映链路拥塞情况。&lt;/p&gt;

&lt;p&gt;负载迟钝算法：相反的，对拥塞不敏感，费用固定。更普遍可行的方法。&lt;/p&gt;

&lt;p&gt;路由震荡：用随机化的链路通告时间，可以改善震荡。&lt;/p&gt;

&lt;p&gt;LS链路状态算法：基于无向图最短路算法。最坏情况n平方。&lt;/p&gt;

&lt;p&gt;DV距离向量算法：是一种迭代、异步、分布式的算法。&lt;/p&gt;

&lt;h2&gt;互联网当前的路由算法&lt;/h2&gt;

&lt;h3&gt;RIP，&lt;strong&gt;路由选择信息协议&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;路由选择表（routing table），也叫RIP表，包含该路由器的距离向量、转发表。&lt;/li&gt;
&lt;li&gt;目的子网，就是把目的地路由器当成一个子网网络&lt;/li&gt;
&lt;li&gt;跳数，理解为到目的子网的链接边数即可&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;转发表的结构：目的子网，下一台路由器，到目的子网的跳数。每个子网占一行。&lt;/p&gt;

&lt;p&gt;转发表的状态是迭代的，不可能是实时获得整个网络的状态信息。&lt;/p&gt;

&lt;p&gt;邻居路由器之间会互相通告最新的转发表信息。大概30秒一次。&lt;/p&gt;

&lt;p&gt;如果邻居超过180秒没有发来报文，认为不可达，更新自己的路由表，并向其他存活的邻居发公告。&lt;/p&gt;

&lt;p&gt;每次收到转发表信息，都可能导致当前路由器的所知的到达某个子网的跳数、下一跳路由器信息，产生更新，因为新的路径（跳数）可能会更短。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/2.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/3.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/4.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;路由器可以主动询问邻居&lt;strong&gt;到指定目的地的费用&lt;/strong&gt;（RIP请求报文）。基于UDP 520端口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RIP是一个基于传输层UDP协议的应用层进程（叫routed），用UDP来控制IP路由。&lt;/strong&gt;这也是一个特殊进程，因为它可以操作系统内核的转发表。&lt;/p&gt;

&lt;p&gt;routed会和邻居路由器的routed进程相互联系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;OSPF&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;被设想为RIP的后继者，因为有许多先进特性&lt;/li&gt;
&lt;li&gt;洪泛链路状态信息的链路状态协议 + Dijkstra最低费用路径算法&lt;/li&gt;
&lt;li&gt;是基于完整信息状态的算法&lt;/li&gt;
&lt;li&gt;各条链路费用可用网络管理员配置，如果都设为1，则退化成&lt;strong&gt;最少跳数路由选择（RIP）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;管理员可以根据带宽大小来设置链路费用，反比，带宽越大，费用越低。&lt;/li&gt;
&lt;li&gt;路由选择信息是广播到整个网络的，而不仅仅是邻居&lt;/li&gt;
&lt;li&gt;当一跳链路状态（费用、连接/中断）变化时，更新并广播&lt;/li&gt;
&lt;li&gt;即使无变化，也要定期广播&lt;/li&gt;
&lt;li&gt;OSPF报文直接承载于IP层，所以OSPF要自行实现可靠传输，链路状态广播功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安全，对网络成员有身份鉴别功能，从而鉴别假冒的OSPF协议包。但这是可选的功能。鉴别方法是在每台路由器上配置一样的共享密钥，发包时，把密钥添加到分组里然后算一个MD5，再把MD5放到发包分组里，接收端收到分组后，对内容段添加自己的密钥并算一个MD5，并和收到的MD5进行比较鉴别。另外还有个序号，用来针对重放攻击。&lt;/li&gt;
&lt;li&gt;负载均衡，如果去某个目的地存在多条费用一样的路径，OSPF允许同时使用多条路径，而不是只用其中一条。&lt;/li&gt;
&lt;li&gt;层次结构&lt;/li&gt;
&lt;li&gt;对多播的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OSPF可按区域划分（大区分小区），区域和区域外的联系要经过&lt;strong&gt;区域边界路由器&lt;/strong&gt;，边界路由器都连到主干路由，从而实现区域之间的连通。&lt;/p&gt;

&lt;h3&gt;BGP 边界网关协议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;BGP确保了因特网中所有AS知道该子网以及如何到达那里。&lt;/li&gt;
&lt;li&gt;没有BGP，那么每个子网将是隔离的，不为互联网其他部分所知。&lt;/li&gt;
&lt;li&gt;是BGP这个协议将所有东西粘合在一起&lt;/li&gt;
&lt;li&gt;BGP基于TCP端口179，半永久TCP连接&lt;/li&gt;
&lt;li&gt;BGP作用：使得每个AS知道经过其相邻AS可达哪些目的地。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关键词定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BGP对等方，BGP peers，即一条BG TCP连接的两端&lt;/li&gt;
&lt;li&gt;沿着该连接发送所有BGP报文的TCP连接称为BGP会话&lt;/li&gt;
&lt;li&gt;跨越2个AS的BGP会话称为外部BGP，eBGP；同理，内部的叫iBGP。&lt;/li&gt;
&lt;li&gt;目的地：不是主机IP，而是CDIR化的前缀，表示一个子网或子网的集合，如：138.16.64/24。&lt;/li&gt;
&lt;li&gt;前缀聚合：如果AS连接了4个子网，138.16.64/24，138.16.65/24，138.16.66/24，138.16.67/24，可以聚合成138.16.64/22&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;链路层&lt;/h1&gt;

&lt;h2&gt;交换局域网-ARP协议&lt;/h2&gt;

&lt;h3&gt;ARP表&lt;/h3&gt;

&lt;p&gt;每个主机维护一张ARP表，key是IP地址（所在子网的其他主机的局域网地址），value是MAC地址，并且有一个ttl，指明这key到value的映射关系什么时候过期。&lt;/p&gt;

&lt;h3&gt;适配器、接口、ARP模块、MAC地址&lt;/h3&gt;

&lt;p&gt;一个接口对应一个适配器、一个ARP模块、一个MAC地址&lt;/p&gt;

&lt;h3&gt;例子：同子网下的ARP&lt;/h3&gt;

&lt;p&gt;主机10.10.10.1要发送一个数据报，给本子网上的另一台主机10.10.10.2或路由器&lt;/p&gt;

&lt;p&gt;分2种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发送主机的ARP表有目的主机ip的MAC地址：直接可以发。&lt;/li&gt;
&lt;li&gt;发送主机没有目的主机的MAC地址：发送方用ARP协议来解析这个目的ip地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ARP解析过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;发送主机构造一个ARP分组（ARP packet），发送IP地址、接收IP地址、MAC地址。ARP分组细分为&lt;strong&gt;查询分组&lt;/strong&gt;和&lt;strong&gt;响应分组&lt;/strong&gt;，格式一样。&lt;/li&gt;
&lt;li&gt;发送方把ARP查询分组送到适配器，并且指示适配器&lt;strong&gt;用MAC广播地址FF-FF-FF-FF-FF-FF&lt;/strong&gt;发送它&lt;/li&gt;
&lt;li&gt;适配器在链路层帧中封装这个查询分组，用广播地址作为帧的目的地址，并把该帧传输进子网（广播）&lt;/li&gt;
&lt;li&gt;同子网上的所有其他适配器都会收到这个ARP查询，因为地址是广播地址，所以适配器底层不能直接判断是否丢弃分组，而是向上传递给&lt;strong&gt;ARP模块&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;ARP模块检查自己的IP地址是否和分组的目的IP地址相匹配。&lt;/li&gt;
&lt;li&gt;最终只有一个ARP模块会匹配，此时回发给最开始的发送主机一个响应分组（响应分组的目的MAC地址是已知的，不需要广播）。&lt;/li&gt;
&lt;li&gt;发送主机收到响应分组，更新ARP表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由此可见，ARP协议是一个同时跨越链路层和网络层边界的协议&lt;/p&gt;

&lt;h3&gt;例子：跨子网ARP&lt;/h3&gt;

&lt;p&gt;背景：1个路由器打通了2个子网，子网1的主机A想要发数据报给子网2的主机B&lt;/p&gt;

&lt;p&gt;问题：目的地主机不在同一子网上，意味着即使已知目的主机的MAC地址，也不可能让链路帧直接送达&lt;/p&gt;

&lt;p&gt;流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;发送主机把数据帧发送到路由器接口1&lt;/li&gt;
&lt;li&gt;路由器会看到该帧的目的地址是自己的接口1，于是解析链路帧，把数据报传递到路由器的网络层&lt;/li&gt;
&lt;li&gt;路由器网络层观察数据报的ip目的地址，发现转发表里有这个子网（最长前缀匹配），并且知道得通过接口2转发这个数据报&lt;/li&gt;
&lt;li&gt;接口2的适配器把该数据报封装到一个新的帧中，帧的目的MAC地址就是主机B的MAC地址（路由器从自己的ARP表获得），并且将帧发送进子网2中&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;交换局域网-以太网&lt;/h2&gt;

&lt;p&gt;以太网是高速局域网。&lt;/p&gt;

&lt;p&gt;21世纪早期，集线器（hub）换成了交换机（switch）。&lt;/p&gt;

&lt;p&gt;交换机特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无碰撞&lt;/li&gt;
&lt;li&gt;存储转发分组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交换机和路由器区别：交换机仅工作在2层，而路由器是3层。&lt;/p&gt;

&lt;p&gt;以太网帧结构：&lt;/p&gt;

&lt;p&gt;前同步码(Preamble) | 帧开始符（Start of frame delimiter, SFD）| 目的MAC地址 | 源MAC地址 | tag (optional) | 类型（或长度）| 数据 | FCS，Frame check sequence（即CRC） | IPG(interpacket gap)&lt;/p&gt;

&lt;p&gt;各字段占用字节数：&lt;/p&gt;

&lt;p&gt;7 | 1 | 6 | 6 | 4(optional) | 2 | 46~1500 | 4 | 12&lt;/p&gt;

&lt;p&gt;一帧里面要分为两部分，一部分是2层链路层的，一部分是1层物理层的。&lt;/p&gt;

&lt;p&gt;物理层的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preamble （用于链路2端的时钟同步，10101010····，且有唤醒接收适配器的作用）&lt;/li&gt;
&lt;li&gt;SFD（标明下一个字节为目的MAC字段，10101011，最后2位突然变成2个1，警告接收适配器重要的内容要来了）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpacket_gap&quot;&gt;IPG&lt;/a&gt; (一个pause段，让接收者有时间准备接收下一个分组)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;占7 + 1 + 12 = 20字节。&lt;/p&gt;

&lt;p&gt;链路层的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;目的MAC地址&lt;/li&gt;
&lt;li&gt;源MAC地址&lt;/li&gt;
&lt;li&gt;tag (optional) &lt;/li&gt;
&lt;li&gt;类型（或长度）&lt;/li&gt;
&lt;li&gt;数据 (3层协议数据)&lt;/li&gt;
&lt;li&gt;FCS (对接收网卡提供判断是否传输错误的一种方法，如果发现错误，丢弃此帧)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;min：6 + 6 + 2 + 46 + 4 = 64字节，max：6 + 6 + 4 + 2 + 1500 + 4 = 1522字节&lt;/p&gt;

&lt;p&gt;注意，数据字段是有填充需求的，即要让以太网帧至少有64字节。&lt;/p&gt;

&lt;p&gt;另外，如果上下文是物理层，那么以太网帧应该叫以太网分组（Ethernet packet），以太网分组包括上面整个帧结构。&lt;/p&gt;

&lt;p&gt;以太网技术特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;向网络层提供无连接服务，类似3层数据报、4层UDP&lt;/li&gt;
&lt;li&gt;向网络层提供不可靠服务，接收端无论是否正确接收，都不会做任何反馈，错帧直接丢弃。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;交换局域网-链路层交换机&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;交换机的任务：接收&lt;strong&gt;入链路层帧&lt;/strong&gt;，并将它们转发到&lt;strong&gt;出链路&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;交换的是链路层帧，工作在2层&lt;/li&gt;
&lt;li&gt;对子网中的主机和路由器&lt;strong&gt;透明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;交换机有缓存，因为转发输出速率可能会超过输出接口的链路容量&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;转发&amp;amp;过滤&lt;/h3&gt;

&lt;p&gt;过滤和转发的实现，依赖于&lt;strong&gt;交换机表（switch table）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;交换机表包含局域网上&lt;strong&gt;某些主机和路由器&lt;/strong&gt;的表项：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/2.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;例子：假设有一个目的地地址为DD-DD-DD-DD-DD-DD的帧从交换机接口x到达，交换机用该MAC地址索引交换机表。有3种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;表中没有对于DD-DD-DD-DD-DD-DD的表项。交换机向除了接口x外的所有接口广播该帧。广播前，实际是把帧放到接口的缓冲区。&lt;/li&gt;
&lt;li&gt;表中有一个表项将DD-DD-DD-DD-DD-DD与接口x联系起来。交换机丢失该帧。&lt;/li&gt;
&lt;li&gt;表中有一个表项将DD-DD-DD-DD-DD-DD与接口y（y!=x）联系起来。该帧被转发到与接口y相连的局域网网段，交换机通过将该帧放到接口y的输出缓冲区完成转发功能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;自学习&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;交换机表初始为空&lt;/li&gt;
&lt;li&gt;对于在每个接口接收到的每个入帧，该交换机在其表中存储：

&lt;ol&gt;
&lt;li&gt;帧里的源MAC地址&lt;/li&gt;
&lt;li&gt;该帧到达的接口&lt;/li&gt;
&lt;li&gt;当前时间&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;因为每条记录有时间戳，所以过期的记录会删除&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自学习性质使得交换机变成即插即用设备，不需要做配置。&lt;/p&gt;

&lt;h3&gt;交换机和路由器的区别&lt;/h3&gt;

&lt;p&gt;共同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;都是存储转发分组交换机&lt;/li&gt;
&lt;li&gt;有时候相互可替代&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;路由器使用网络层IP地址转发分组；交换机用MAC地址转发分组&lt;/li&gt;
&lt;li&gt;路由器是3层设备；交换机是2层设备&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各自特点优缺点：&lt;/p&gt;

&lt;p&gt;交换机特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MAC地址寻址扁平&lt;/li&gt;
&lt;li&gt;为了防止广播帧的循环，交换网络的活跃拓扑限制为一颗&lt;strong&gt;生成树&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交换机优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;即插即用&lt;/li&gt;
&lt;li&gt;具有相对高的分组过滤和转发速率（只需要处理高到2层的帧，而路由器高至3层）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交换机缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;交换机对于广播风暴并不提供任何保护措施，即某主机故障并传输无尽的以太网广播帧，交换机将转发所有这些帧，导致整个以太网崩溃&lt;/li&gt;
&lt;li&gt;所以如果没有生成树，会循环。而生成树限制了转发路径唯一。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;路由器优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;即使存在冗余路径，分组也不会循环&lt;/li&gt;
&lt;li&gt;没有生成树限制。允许以丰富的拓扑结构构建因特网，例如：欧洲与北美之间的多条活跃链路。&lt;/li&gt;
&lt;li&gt;对2层的广播风暴提供了防火墙保护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;路由器缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不是即插即用（但DHCP使得路由器可以自动分配IP）&lt;/li&gt;
&lt;li&gt;对每个分组的处理时间比交换机更长&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择策略：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通常，由几百台主机组成的小网络有几个局域网网段。对于这些小网络，交换机就足够了，&lt;strong&gt;因为它们不要求IP地址的任何配置就能使流量局部化并增加总计吞吐量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果是几千台主机，则需要路由器，因为&lt;strong&gt;路由器提供了更健壮的流量隔离方式和对广播风暴的控制，并在网络的主机之间使用更智能的路由&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/3.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/4.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;实例：web页面请求的历程&lt;/h2&gt;

&lt;p&gt;背景：Bob用以太网电缆将他的电脑连到学校的以太网交换机，交换机又与学校的路由器相连，路由器和一个ISP（comcast）相连；comcast为学校提供DNS服务，所以DNS服务器在comcast网络里；DHCP服务器运行在路由器中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/5.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;第1步：Bob电脑连接网络&lt;/h3&gt;

&lt;p&gt;刚连接时，Bob电脑没有本机IP，所以第一步是获得IP。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Bob电脑运行DHCP协议，生成&lt;strong&gt;DHCP请求报文&lt;/strong&gt;，并将这个报文放入一个&lt;strong&gt;UDP报文段&lt;/strong&gt;，UDP报文段的的目的地端口为67、源端口为68&lt;/li&gt;
&lt;li&gt;该UDP报文段进而被放置在一个&lt;strong&gt;IP数据报&lt;/strong&gt;中，数据报的目的地IP地址为255.255.255.255（广播地址）、源IP地址为0.0.0.0&lt;/li&gt;
&lt;li&gt;包含DHCP请求报文的IP数据报则被放置在以&lt;strong&gt;太网帧&lt;/strong&gt;中，以太网帧的目的MAC地址为FF:FF:FF:FF:FF:FF，这会使该帧广播到&lt;strong&gt;与交换机连接的所有设备&lt;/strong&gt;，源MAC地址为Bob电脑的MAC地址00:16:D3:23:68:8A&lt;/li&gt;
&lt;li&gt;该以太网帧是第一个由Bob电脑发送到以太网交换机的帧，该交换机在所有的出端口广播这个入帧&lt;/li&gt;
&lt;li&gt;路由器在它的具有MAC地址00:22:6B:45:1F:1B的接口收到该广播以太网帧(该帧中包含DHCP请求)，从该以太网帧中抽取出IP数据报。因为该IP数据报的目的地IP地址为广播地址，所以该IP数据报的载荷被分解向上到达UDP模块，DHCP请求报文从该UDP报文段中抽取出来，此时路由器即DHCP服务器有了DHCP请求报文&lt;/li&gt;
&lt;li&gt;假设路由器DHCP服务器能够以CIDR块68.85.2.0/24分配IP地址，DHCP服务器因此分配地址68.85.2.101给Bob电脑。&lt;/li&gt;
&lt;li&gt;除了分配IP地址，DHCP服务器还需要将DNS服务器的IP地址（68.87.71.226）、默认网关路由器的IP地址（68.85.2.1）、子网块（68.85.2.0/24）（子网掩码），这些东西组成一个DHCP ACK报文。&lt;/li&gt;
&lt;li&gt;该DHCP ACK报文被放入一个UDP报文段，UDP报文段被放入一个IP数据报，IP数据报被放入以太网帧中，这个以太网帧的源MAC地址是00:22:6B:45:1F:1B（归属网络的接口），目的地址是Bob电脑的MAC地址&lt;/li&gt;
&lt;li&gt;包含DHCP ACK的以太网帧由路由器发给交换机，因为交换机是自学习的，并且先前从Bob电脑收到DHCP请求报文以太网帧，所以该交换机知道寻址到00:16:D3:23:68:8A的帧仅从通向Bob电脑的端口转发。&lt;/li&gt;
&lt;li&gt;Bob电脑接收到包含DHCP ACK的以太网帧，从里面抽出DHCP ACK报文，Bob电脑的DHCP客户端记录下它的IP地址和DNS服务器的IP地址，另外，它还在IP转发表中安装默认网关的IP地址68.85.2.1，Bob电脑将向该网关发送目的地址为其子网68.85.2.0/24以外的所有数据报。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第2步：DNS和ARP（1）&lt;/h3&gt;

&lt;p&gt;Bob电脑初始化好它的网络组件后，准备访问一个google的网页。&lt;/p&gt;

&lt;p&gt;首先需要知道www.google.com的地址。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Bob电脑生成一个DNS查询报文，将字符串www.google.com放入DNS报文的问题段，DNS报文被放进一个UDP报文段，UDP目的地端口为53；UDP报文进而被放入一个IP数据报， IP数据报的目的地IP地址为68.87.71.226（DNS服务器的IP地址！），源IP地址为68.85.2.101&lt;/li&gt;
&lt;li&gt;Bob电脑把这个IP数据报放入一个以太网帧，该帧将发送到Bob学校网络中的网关路由器（因为不在同子网），但Bob电脑并不知道DNS服务器的MAC地址，Bob电脑为了获得该网关路由器的MAC地址，需要使用ARP协议。&lt;/li&gt;
&lt;li&gt;Bob电脑生成一个具有目的地IP地址为68.85.2.1（默认网关）的ARP查询报文，将该ARP报文放置在一个具有广播目的地址（FF:FF:FF:FF:FF:FF）、源MAC地址为00:16:D3:23:68:8A(Bob电脑)的以太网帧中，并向交换机发送该以太网帧，交换机将该帧广播到所有连接的设备，包括网关路由器。&lt;/li&gt;
&lt;li&gt;网关路由器在通往学校网络的接口上接收到包含该ARP查询报文的帧，发现在ARP报文中目标IP地址68.85.2.1匹配自己的接口的IP地址，网关路由器因此发送一个ARP应答，指示它的MAC地址00:22:6B:45:1F:1B，对应IP地址68.85.2.1。它将ARP回答放在一个以太网帧中，其目的地址为00:16:D3:23:68:8A(Bob电脑)，并向交换机发送该帧，再由交换机将帧交付给Bob电脑。&lt;/li&gt;
&lt;li&gt;Bob电脑接收到包含ARP应答报文的以太网帧，从中拿出网关路由器的MAC地址。&lt;/li&gt;
&lt;li&gt;此时，Bob电脑能够使包含DNS查询的以太网帧寻址到网关路由器的MAC地址。这个以太网帧的目的IP地址为68.87.71.226（DNS服务器）、MAC目的地址为00:22:6B:45:1F:1B（网关）。Bob电脑向交换机发送该帧，交换机将该帧交付网关路由器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;小结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bob电脑已知DNS服务器IP，所以发送DNS请求，因为DNS服务器不在同子网，所以得先把请求发到默认网关，然而又发现没有网关的MAC地址，所以只能先发起ARP查询；&lt;/li&gt;
&lt;li&gt;ARP查询返回应答时，Bob电脑就能继续向网关发送包含DNS查询的udp包，但此时DNS请求还没有到达DNS服务器，下面继续。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;第3步：DNS（2）&lt;/h3&gt;

&lt;p&gt;此时，网关路由器收到了来自Bob电脑的包含DNS查询的IP数据报。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;网关路由器查找该数据报的目的地址68.87.71.226（DNS服务器），并根据其&lt;strong&gt;转发表&lt;/strong&gt;决定该数据报应当发送到comcast网路中最左边的路由器。&lt;/li&gt;
&lt;li&gt;这个comcast路由器收到转发来的IP数据报，也查看数据报的目的IP地址，并根据本地转发表确定出口，朝着DNS服务器继续转发。转发表由域内协议（RIP、OSPF、IS-IS）和域间协议（BGP）填写。&lt;/li&gt;
&lt;li&gt;最终的，包含DNS查询的数据报到达了DNS服务器，DNS查询抽取出DNS查询报文，在自己的DNS数据库中查找名字www.google.com，找到包含对应www.google.com的IP地址（64.233.169.105）的&lt;strong&gt;DNS源记录&lt;/strong&gt;（这里假设了该记录已缓存在本机，源于权威DNS服务器）。&lt;/li&gt;
&lt;li&gt;DNS服务器生成一条包含主机名www.google.com到IP地址（64.233.169.105）的DNS回答报文，放入UDP、UDP放入到寻址到Bob电脑的IP数据报，该数据报通过comcast网络反向转发到学校的路由器，并从这里经过以太网交换机到Bob电脑。&lt;/li&gt;
&lt;li&gt;Bob电脑收到这条DNS应答报文，从中取出www.google.com的IP地址。此时就可以真正地访问google网站了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第4步：Web客户端-服务器交互：TCP和HTTP&lt;/h3&gt;

&lt;p&gt;这一步就是传输层和应用层的事情了：tcp三次握手，tcp承载了HTTP协议。&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/network/</link>
        <guid isPermaLink="true">http://localhost:4000/network/</guid>
      </item>
    
      <item>
        <title>select和epoll多路复用用法总结</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;select&lt;/h2&gt;

&lt;p&gt;资料：&lt;a href=&quot;https://notes.shichao.io/unp/ch6/#select-function&quot;&gt;https://notes.shichao.io/unp/ch6/#select-function&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;struct fd_set，fd的集合&lt;/li&gt;
&lt;li&gt;FD_ZERO(fd_set *)， 清零一个fd_set，传fd_set的地址&lt;/li&gt;
&lt;li&gt;FD_SET(int fd, fdset *)，把fd添加到这个fd_set&lt;/li&gt;
&lt;li&gt;FD_CLR(int fd, fdset *)，把fd移出这个fd_set&lt;/li&gt;
&lt;li&gt;int FD_ISSET(int fd, fd_set *fdset); 查询fd是否在这个fd_set&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;核心函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;返回值：&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;&amp;lt;0：出错&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;0：select超时返回了，没有读、写事件&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;&amp;gt;0：有事件发生的fd数量&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;maxfdp：是最大的fd再加1！&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;readfds、writefds、errorfds是值-结果参数，调用的时候作为值语义参数，函数返回的时候作为结果，所以没有const修饰&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;readfds：   要监听读事件的fd集合   /    有读事件的fd集合&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;writefds：  要监听写事件的fd集合   /    有写事件的fd集合&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;errorfds：  错误事件，一般传null即可&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxfdp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writefds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errorfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用法要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按读、写声明2个fd_set：rfds、wfds&lt;/li&gt;
&lt;li&gt;需要再声明2个读、写fd_set，用于存放第一步的fd_set的拷贝，用于select：_rfds、_wfds&lt;/li&gt;
&lt;li&gt;用FD_SET和FD_CLR控制要监听哪个fd的读、写事件&lt;/li&gt;
&lt;li&gt;调用select前，要先复制一份fd_set，用memcpy即可&lt;/li&gt;
&lt;li&gt;调用select：retval = select(eventLoop-&amp;gt;getMaxFd() + 1, &amp;amp;_rfds, &amp;amp;_wfds, NULL, tvp);&lt;/li&gt;
&lt;li&gt;如果retval&amp;gt;0，就遍历所有fd（[0, maxfd]），用FD_ISSET(fd, _rfds)，判断这个fd是否可读，写事件同理&lt;/li&gt;
&lt;li&gt;到此就完成一次循环，做完其他逻辑后，回到第4步&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;select是基于位掩码的设计，所以fd_set有固定长度。长度由FD_SETSIZE确定，FD_SETSIZE可以用户自己定。默认只有1024。&lt;/p&gt;

&lt;h2&gt;epoll&lt;/h2&gt;

&lt;h3&gt;创建epfd&lt;/h3&gt;

&lt;p&gt;epoll_create1(0)，创建一个epfd，epoll所有接口都会用到它，它也是个文件描述符，持有资源&lt;/p&gt;

&lt;h3&gt;添加监听事件&lt;/h3&gt;

&lt;p&gt;需要区分是首次添加还是修改操作（用户自己要做记录），op = EPOLL_CTL_ADD或者EPOLL_CTL_MOD。&lt;/p&gt;

&lt;p&gt;然后创建一个epoll_event ee，如果需要监听读事件就执行ee.events |= EPOLLIN，写事件就 ee.events |= EPOLLOUT；然后要登记目标fd到ee里，ee.data.fd = fd。&lt;/p&gt;

&lt;p&gt;ee准备好后，就可以调用epoll_ctl(epfd, op, fd, &amp;amp;ee)。&lt;/p&gt;

&lt;p&gt;epoll_ctl返回值：0是成功；-1失败，errno记录错误类型。&lt;/p&gt;

&lt;h3&gt;删除监听事件&lt;/h3&gt;

&lt;p&gt;和添加监听事件类似，也是构造ee，也要设置ee.data.fd，最终调用epoll_ctl。&lt;/p&gt;

&lt;p&gt;op的就有点不一样，如果已经没有任何要监听的事件了，那么op是EPOLL_CTL_DEL；如果至少有监听某种事件，那么用EPOLL_CTL_MOD。&lt;/p&gt;

&lt;p&gt;需要注意的是，即使是删除监听事件，epoll_ctl一个参数都不能少。&lt;/p&gt;

&lt;h3&gt;轮询&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;epoll_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;timeout：-1，永久阻塞；0，立即返回，不阻塞； &amp;gt;0，阻塞多少毫秒后返回
events和maxevents：就是指定一块数组用来存epoll_wait的返回结果，maxevents就是这个数组的长度。&lt;/p&gt;

&lt;p&gt;如果返回值（numevents）大于0，那么就可以遍历events，遍历上限为numevents，逐个epoll_event访问它的events变量，看含有什么事件。也就是说，epoll_wait只返回了有事件的fd集合，比select要高效。&lt;/p&gt;

&lt;h3&gt;底层特点&lt;/h3&gt;

&lt;p&gt;epfd被创建时，会相应地创建一个eventpoll结构体：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;struct eventpoll {  
    /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/  
    struct rb_root  rbr;  
    /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/  
    struct list_head rdlist;    
};  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;eventpoll可理解为存了2个数据结构的头部指针，一个指向一个红黑树的根，一个指向双向链表的头。&lt;/p&gt;

&lt;p&gt;只要某个fd的某个事件被监听中，就会存在和这个fd关联的一个epitem:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epitem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rb_node&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;rbn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//红黑树节点  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;rdllink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//双向链表节点  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_filefd&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ffd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//事件句柄信息  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eventpoll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//指向其所属的eventpoll对象  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//期待发生的事件类型  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;红黑树中的每个节点都等同于某个epitem的rbn对象指针；双向链表的每个节点都等同于某个epitem的rdllink指针。&lt;/p&gt;

&lt;p&gt;所以epitem应该是一个内存连接的数组，而红黑树和双向链表用指针的方式和这个数组产生联系。&lt;/p&gt;

&lt;p&gt;为什么高效：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当监听的事件发生时，会回调ep_poll_callback，把事件信息添加到双向链表rdlist&lt;/li&gt;
&lt;li&gt;当调用epoll_wait检查是否有事件发生时，只需检查eventpoll的rdlist链表中是否有epitem元素即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1、2点已经凸显了epoll_wait的高效，这是一种基于驱动回调的技术，epoll_wait的成本只是获取这个rdlist而已。&lt;/p&gt;

&lt;p&gt;另外，为了保证不会重复添加同个fd的epitem，只能遍历内核的epitem数组，但这是个O(n)的操作，所以就需要红黑树，可以快速找出某个fd是否已被监听，并且也用于快速找到epitem从而修改fd的监听事件。这可是log(n)的复杂度，性能大大提高。&lt;/p&gt;

&lt;h3&gt;总结：&lt;/h3&gt;

&lt;p&gt;epoll是在内核维护复杂数据结构的设计，用户态的接口就相对复杂一些，但可控制性高一点；另外利用了回调技术，就不需要主动去查询每个fd是否有事件，效率自然就高了。&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/multiplexing/</link>
        <guid isPermaLink="true">http://localhost:4000/multiplexing/</guid>
      </item>
    
      <item>
        <title>C++ STL的一些笔记</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;set和multiset&lt;/h2&gt;

&lt;p&gt;set有去重；multiset无去重。&lt;/p&gt;

&lt;p&gt;multiset可以用来做计时器容器，因为计时器需要按时间排序，而时间戳可能会出现相同的，即同一时刻添加了2个定时任务。&lt;/p&gt;

&lt;p&gt;使用set和multiset的易错点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;存储的元素需要是const含义的，即添加到容器后，原则上是不能修改的。原因是排序需要。如果添加到容器后用户还能修改容器元素，那么应触发某种全排序，否则容器有序性就丢失了。&lt;/li&gt;
&lt;li&gt;然而容器没有办法保证用户不可修改元素，所以容易用错。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个易错点，只能好好记住了，不然迟早酿成bug。如果一定要在添加元素后，对这个元素做修改，那么需要先erase然后再insert回去。&lt;/p&gt;

&lt;p&gt;另外的问题是，容器和智能指针结合使用时的易错点。&lt;/p&gt;

&lt;p&gt;当元素为shared_ptr&lt;T&gt;包装的类实例时，直接放进(multi)set就有2个潜在问题，一是容器排序的依据是shared_ptr，而不是T，这是很容易误解的，解决这个问题的办法是声明容器时添加一个Comparator参数，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Compare&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;multiset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样子写才会真正地按照T的定义去排序。&lt;/p&gt;

&lt;p&gt;然而还有个细节问题：用于容器的Compare或者说operator&amp;lt;，必须满足&lt;strong&gt;strict weak ordering&lt;/strong&gt;。这个概念会贯穿整个STL。&lt;/p&gt;

&lt;p&gt;这个东西简单理解就是说，类T必须实现operator&amp;lt;，从而容器sort元素的时候，可以用这个operator&amp;lt;实现==、&amp;gt;比较。&lt;/p&gt;

&lt;p&gt;为什么一个&amp;lt;就能实现==呢？这是用了一个有趣的技巧： a==b 可认为等价于 !(a &amp;lt; b) &amp;amp;&amp;amp; !(b &amp;lt; a)。&lt;/p&gt;

&lt;p&gt;对于只有单个属性的T来说，实现strict weak ordering很简单，只要operator&amp;lt;里写一行a.x &amp;lt; a.x就行了。&lt;/p&gt;

&lt;p&gt;对于一个有复合属性的类T，operator&amp;lt;需要小心一点，但也是大同小异。例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;逆序排序的话，&amp;lt;的结果取反即可。所以总之遇到(multi)set排序，重载operator&amp;lt;就对了。&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/cpp-8/</link>
        <guid isPermaLink="true">http://localhost:4000/cpp-8/</guid>
      </item>
    
      <item>
        <title>漫谈网络通讯加密（1）算法基础</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;常见加密算法&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/RSA_(cryptosystem)&quot;&gt;RSA&lt;/a&gt; （Rivest–Shamir–Adleman)（1977年）&lt;/h2&gt;

&lt;p&gt;基于大数（1024bits以上)的质因数分解问题。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic-curve_cryptography&quot;&gt;ECC&lt;/a&gt;（Elliptic-curve cryptography） （1985年）&lt;/h2&gt;

&lt;p&gt;基于在椭圆曲线上的离散对数的求取问题。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES（Rijndael）&lt;/a&gt; （2001年）&lt;/h2&gt;

&lt;p&gt;AES的意思是高级加密标准（Advanced Encryption Standard），使用的算法是Rijndael，Rijndael是当时加密算法竞赛的top 1。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;DH&lt;/a&gt;（Diffie-Hellman key exchange）（1976年）&lt;/h2&gt;

&lt;p&gt;密钥交换算法。&lt;/p&gt;

&lt;p&gt;基于离散对数问题。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman&quot;&gt;ECDH&lt;/a&gt; (21世纪)&lt;/h2&gt;

&lt;p&gt;DH标准算法的变种，是基于椭圆曲线算法的DH密钥交换算法。&lt;/p&gt;

&lt;h1&gt;ECC算法&lt;/h1&gt;

&lt;h2&gt;直观认识什么是椭圆曲线&lt;/h2&gt;

&lt;p&gt;椭圆曲线，指的是满足这个&lt;strong&gt;维尔斯特拉斯通用式&lt;/strong&gt;的曲线：&lt;/p&gt;

&lt;p&gt;\[ y^{2} = x^{3} + ax + b , 且 4a^{3} + 27 b^{2} ≠ 0 \]&lt;/p&gt;

&lt;p&gt;判别式(&lt;a href=&quot;https://en.wikipedia.org/wiki/Discriminant&quot;&gt;discriminant&lt;/a&gt; )不为0时，曲线才没有奇异点，才能用于加密。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/6.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;到这里就能发现椭圆曲线第一个特点：&lt;strong&gt;整个曲线是关于x轴对称的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;各类加密货币使用的椭圆曲线代号是secp256k1，长这样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;用这个&lt;a href=&quot;https://hub.mybinder.org/user/ipython-ipython-in-depth-qhl9ondm/notebooks/binder/Untitled1.ipynb?kernel_name=python3&quot;&gt;在线工具&lt;/a&gt;可以打印椭圆曲线：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;np&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pylab&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pl&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 替换掉这个方程，然后重新run&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mgrid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;levels&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;../images/2018.4/7.png&quot; alt=&quot;7.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;ECC算法细节&lt;/h2&gt;

&lt;h3&gt;曲线基本特点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果一条（不垂直于x轴的）直线与椭圆曲线相交（有2个相交点），那么必然存在第三个相交点。（证明过程？）&lt;/li&gt;
&lt;li&gt;第三个点相当于公钥&lt;/li&gt;
&lt;li&gt;椭圆曲线关于x轴镜像对称&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;无穷远点0 &lt;a href=&quot;https://en.wikipedia.org/wiki/Point_at_infinity&quot;&gt;Point at infinity&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;无穷远点，或理想点，指理想化地认为一条直线在无穷远处有一个终点，一般以0表示。&lt;/p&gt;

&lt;h3&gt;椭圆曲线上的点的取反操作&lt;/h3&gt;

&lt;p&gt;因为椭圆曲线关于x轴对称，所以可定义：&lt;/p&gt;

&lt;p&gt;对于任意椭圆曲线上的点P，对P取反后得到-P，-P为P关于x轴镜像对称点。&lt;/p&gt;

&lt;h3&gt;P + Q = R&lt;/h3&gt;

&lt;p&gt;前面已经提到，任意直线与椭圆曲线如果相交，那么必然有3个相交点。（记得相交线不能和x轴垂直）&lt;/p&gt;

&lt;p&gt;在椭圆曲线加密算法中，定义了一个阿贝尔群，该群的的加法操作定义如下：&lt;/p&gt;

&lt;p&gt;对于任意相交点P、Q、-R（这里取反是有意义的），若P!=-Q，有等式 P + Q + (-R) = 0 成立，即 P + Q = R。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先要注意，这个加法并不是欧氏几何加法，例如看下图， P + Q在欧氏几何中的结果是（-2.45，-1.024），而不是（3.89，5.62）&lt;/li&gt;
&lt;li&gt;该定义中，要求P!=-Q，也是有深意的：如果P=-Q，说明P和Q是关于x轴对称的2个点，那么P和Q应是R和-R，所以P!=-Q这个前提条件保证了P和Q不是那个特殊的R&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;base point P&lt;/h3&gt;

&lt;p&gt;在椭圆曲线加密算法中，第一步是定一个基准点P。&lt;/p&gt;

&lt;p&gt;第二步是，找出从P到P的直线方程。此时会疑惑2个一样的点怎么构成直线，当然是可以的，这个直线是&lt;strong&gt;经过P点的和椭圆曲线相切的切线&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/9.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;根据前面小节的说明，这条切线必然会与椭圆曲线相交于另外一点-R，又因为P + Q = R（-R的镜像点），所以有 P + P = 2P = R：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/10.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这一个过程还可以迭代下去：因此此时已有P和2P两个点，如果让它们相加，即 P + 2P，那么又会得到新的一个镜像点3P：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/11.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;继续迭代这个过程，就能得到4P、5P、6P······&lt;/p&gt;

&lt;h3&gt;nP + rP = (n+r)P&lt;/h3&gt;

&lt;p&gt;假设现在要求出10P，那么按上一节的迭代算法，就需要计算：&lt;/p&gt;

&lt;p&gt;\[ P+P+P+P+P+P+P+P+P+P \]&lt;/p&gt;

&lt;p&gt;这是很慢的过程，不过可以用群加法其中一个性质来加速：&lt;/p&gt;

&lt;p&gt;\[ nP + rP = (n+r)P \]&lt;/p&gt;

&lt;p&gt;当然还是不能一步到位，而是从9次加法变成了4次加法：&lt;/p&gt;

&lt;p&gt;\[ P + P = 2P \]&lt;/p&gt;

&lt;p&gt;\[ 2P + 2P = 4P \]&lt;/p&gt;

&lt;p&gt;\[ 4P + 4P = 8P \]&lt;/p&gt;

&lt;p&gt;\[ 2P + 8P = 10P \]&lt;/p&gt;

&lt;h3&gt;x为大数时，xP的计算问题&lt;/h3&gt;

&lt;p&gt;假设x是一个超大正整数，例如有256bits，32个字节这么大。那么要得到xP，得做多少次群加法呢？&lt;/p&gt;

&lt;p&gt;这是个二进制的问题。首先假设x等于十进制的246（值很小，只用一个字节就能表示，是为了讨论方便），并把x二进制展开（binary expansion，是叫二进制展开吧？）：&lt;/p&gt;

&lt;p&gt;\[ 2^{7} + 2^{6} + 2^{5} + 2^{4} + 2^{2}  + 2^{1}  = 128 + 64 + 32 + 16 + 4 + 2 = 246 \]&lt;/p&gt;

&lt;p&gt;等式两边都乘以P：&lt;/p&gt;

&lt;p&gt;\[ 2^{7}P + 2^{6}P + 2^{5}P + 2^{4}P + 2^{2}P  + 2^{1}P  = 246 P \]&lt;/p&gt;

&lt;p&gt;此时x=246的xP问题就解决了：先算出一系列\(2^{n} P\)，n从0到255（255次群加法），然后用5次群加法就得到了246P，总共需要260次群加法。&lt;/p&gt;

&lt;p&gt;当x的256bits都为1，即x取最大值时，也只需要做255+255=510次群加法。&lt;/p&gt;

&lt;h3&gt;逆向求xP的x&lt;/h3&gt;

&lt;p&gt;假设Bob和Alice玩一个椭圆曲线的游戏：Bob先保密地随机取一个256bits的x，并算出X = xP，把X点坐标告诉Alice；Alice也知道这个椭圆曲线方程以及P点，那么Alice是否可以求出x的值？&lt;/p&gt;

&lt;p&gt;再复述下Alice掌握的信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;椭圆曲线方程，如：\(y^{2} = x^{3} - 7x \)&lt;/li&gt;
&lt;li&gt;P点坐标，如：（-2.35, -1.86）&lt;/li&gt;
&lt;li&gt;X点坐标，如：（123.456，789.123）（瞎写的）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Alice是否可以知道X是做了多少次对P的群加法得到的？如果能，需要多久？&lt;/p&gt;

&lt;p&gt;答案是，现在世界上并没有一个快速算法求出x。唯一可行的笨办法是，遍历整个256bits范围的整数集，从1P开始，不断+P，直到发现nP=X，此时的n就是要求的x。&lt;/p&gt;

&lt;p&gt;也有同样复杂度的逆算法：不断对X减P，直到减完时刚好就是P，此时统计减的次数，就是x了。&lt;/p&gt;

&lt;p&gt;x落在\( [0, 2^{256} - 1] \)，平均值为\( 2^{128} \)。因此平均需要暴力地做2&lt;sup&gt;128次群加法。&lt;/sup&gt;&lt;/p&gt;

&lt;h3&gt;公钥私钥&lt;/h3&gt;

&lt;p&gt;基于上一节的讨论，x和X适合用来做非对称加密的私钥公钥：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;私钥：大数x&lt;/li&gt;
&lt;li&gt;公钥：椭圆曲线上的坐标X&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;非对称加密的公钥私钥必然要满足一个性质：给定一个公钥，很难去推导出它对应私钥。可见，x和X满足这个性质。&lt;/p&gt;

&lt;p&gt;但X、x公钥私钥对并不能直接用于加密数据。这个事情后面再说。&lt;/p&gt;

&lt;h3&gt;谁才是主人公？持有私钥证明 part1&lt;/h3&gt;

&lt;p&gt;Bob持有私钥x，是事实，但Bob怎么向别人证明自己持有X对应的私钥x呢？&lt;/p&gt;

&lt;p&gt;这个事情有点复杂，首先要改进下椭圆曲线的模型。&lt;/p&gt;

&lt;p&gt;上面的椭圆曲线模型有个问题：xP这个点的坐标x、y可能会超大，x和y加起来可能大过一个公钥的存储极限，例如512bits。&lt;/p&gt;

&lt;p&gt;解决方案是：在有限域上定义一个椭圆曲线。为此有2个新的限制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;坐标点的分量限制为整数&lt;/li&gt;
&lt;li&gt;坐标点的分量取值范围不是无穷远&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;公式上的改变如下：&lt;/p&gt;

&lt;p&gt;把 \( y^{2} = x^{3} + ax + b\) 改成：&lt;/p&gt;

&lt;p&gt;\[ ( y^{2} ) \% p = ( x^{3} + ax + b ) \% p\]&lt;/p&gt;

&lt;p&gt;p是一个大质数，例如在secp256k1椭圆曲线中，p的取值是【0, \( 2^{256} \) 】范围内的最大质数。&lt;/p&gt;

&lt;p&gt;这么一转换后，椭圆曲线就变成大概这样子的东西：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/12.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;离散的点集，但仍然有关于x轴的对称性。&lt;/p&gt;

&lt;p&gt;而且，前面讨论的东西仍然是有效的。&lt;/p&gt;

&lt;h3&gt;谁才是主人公？持有私钥证明 part2&lt;/h3&gt;

&lt;p&gt;如何才能在不暴露x的前提下告诉别人“我”持有私钥呢？&lt;/p&gt;

&lt;p&gt;首先拿出前面提到的加法结合律：&lt;/p&gt;

&lt;p&gt;\[ n \cdot P + r \cdot P = ( n + r ) \cdot P \]&lt;/p&gt;

&lt;p&gt;然后把n替换为这个东西：&lt;/p&gt;

&lt;p&gt;\[ hash(m, \ r \cdot P) \cdot n \]&lt;/p&gt;

&lt;p&gt;得到：&lt;/p&gt;

&lt;p&gt;\[ hash(m, r \cdot P) \cdot n \cdot P + r \cdot P = ( hash(m, r \cdot P) \cdot n + r ) \cdot P \]&lt;/p&gt;

&lt;p&gt;引入了一个新的m，以及关于m和rP的hash函数。&lt;/p&gt;

&lt;p&gt;假设\(n \cdot P = X \)（X就是公钥X），代入上式，得到：&lt;/p&gt;

&lt;p&gt;\[ hash(m, r \cdot P) \cdot X + r \cdot P = ( hash(m, r \cdot P) \cdot n + r ) \cdot P \]&lt;/p&gt;

&lt;p&gt;又因为\(n \cdot P = X \)，所以有n = x（x就是私钥x），继续代入，得到：&lt;/p&gt;

&lt;p&gt;\[ hash(m, r \cdot P) \cdot X + r \cdot P = ( hash(m, r \cdot P) \cdot x + r ) \cdot P \]&lt;/p&gt;

&lt;p&gt;此时再设2个新的对象R和s：&lt;/p&gt;

&lt;p&gt;\[ R = r\cdot P \]&lt;/p&gt;

&lt;p&gt;\[ s = hash(m, R)\cdot x + r \]&lt;/p&gt;

&lt;p&gt;把R代入上面的方程，变成：&lt;/p&gt;

&lt;p&gt;\[ hash(m, R) \cdot X + R = ( hash(m, R) \cdot x + r ) \cdot P \]&lt;/p&gt;

&lt;p&gt;然后再代入s，最终得到：&lt;/p&gt;

&lt;p&gt;\[ hash(m, R) \cdot X + R = s \cdot P （持有私钥证明方程）\] &lt;/p&gt;

&lt;p&gt;这条方程就是&lt;strong&gt;持有私钥证明&lt;/strong&gt;了：谁能够给出任意m、R、s，使得m、R、s代入上述方程使得等式成立，那么这个人就必然持有私钥x。&lt;/p&gt;

&lt;p&gt;那么对持有人来说，怎么得到m、R、s呢？很简单：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;随机生成m&lt;/li&gt;
&lt;li&gt;随机生成r&lt;/li&gt;
&lt;li&gt;计算\( R = r\cdot P \)&lt;/li&gt;
&lt;li&gt;计算\( s = hash(m, R)\cdot x + r \)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里提2个问题。一个是私钥安全问题：&lt;/p&gt;

&lt;p&gt;对第三者来说，未知数是r和x，假设r泄露了给第三者，那么第三者就可以根据第4步的式子的变换，导出私钥x：&lt;/p&gt;

&lt;p&gt;\[ x =  \frac { s - r } { hash(m, R) } \]&lt;/p&gt;

&lt;p&gt;所以r必须是用完就丢的。因为持有者只需要给出R就足够用予持有私钥证明。&lt;/p&gt;

&lt;p&gt;另一个是暴力破解问题：&lt;/p&gt;

&lt;p&gt;第三者是否可以暴力地找到合适的m、R、s代入持有私钥证明方程，使得方程成立？&lt;/p&gt;

&lt;p&gt;假设可行，那么第一步应是先任意找出一组合适的参数：h( h = hash(m, R) )、R、s，使得\( hash(m, R) \cdot X + R = s \cdot P \) 成立，这肯定是办得到的。&lt;/p&gt;

&lt;p&gt;然后下一步是，解出一个m，使得hash(m, R) = h成立。然而，如果选择了一个优质的&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_hash_function&quot;&gt;cryptographic hash functions&lt;/a&gt;，是很难办到的。这也被称为原像攻击（&lt;a href=&quot;https://en.wikipedia.org/wiki/Preimage_attack&quot;&gt;Preimage attack&lt;/a&gt; )，即给定hash值，找出能hash出这个值得输入。&lt;/p&gt;

&lt;h3&gt;ECC的应用：数字签名（ECDSA）&lt;/h3&gt;

&lt;p&gt;前面已经论证了只有私钥持有者能给出m、R、s三元组，那么当m是一段有意义的消息(依然是一段字节序），而与这个m匹配的R、s，就成为这个消息m的&lt;strong&gt;签名&lt;/strong&gt;了。&lt;/p&gt;

&lt;p&gt;因为攻击者理论上并不能用自己随意篡改的m&amp;#39;，使得m&amp;#39;、R、s能成功代入持有私钥证明方程。&lt;/p&gt;

&lt;h3&gt;ECC的应用：比特币&lt;/h3&gt;

&lt;p&gt;简单来说，要生成一个新的比特币钱包，需要先随机生成一个256bits的私钥x，然后根据比特币所用的椭圆曲线参数（secp256k1），计算X = xP，X就是这个钱包的公钥。&lt;/p&gt;

&lt;p&gt;然后呢，X大有所为，X可以随便公开，X相当于钱包的银行账号，例如比特币转入这个钱包，就需要用到X。&lt;/p&gt;

&lt;p&gt;转入问题是解决了，但怎么证明你是这个钱包的主人，并转出（消费）比特币呢？答案就是用上一节的方法，做一个持有私钥声明（即数字签名），转出事务广播开后，每个人都可以简单地验证这个持有声明的真伪性。&lt;/p&gt;

&lt;p&gt;如果去观察比特币的事务消息，就会发现他它的数字签名部分就是一个椭圆曲线上的某坐标R和一个随机的256bits的s的组合。&lt;/p&gt;

&lt;h3&gt;ECC的参数集合（Elliptic Curve Domain Parameters）&lt;/h3&gt;

&lt;p&gt;纠正下前面介绍ECC相关参数的命名。&lt;/p&gt;

&lt;p&gt;椭圆曲线算法有很多参数，被称为Elliptic Curve Domain Parameters：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a：椭圆曲线方程\( y^{2}  = x^{3} + ax + b \) 里的a&lt;/li&gt;
&lt;li&gt;b：椭圆曲线方程\( y^{2}  = x^{3} + ax + b \) 里的b&lt;/li&gt;
&lt;li&gt;G：即上文说的P，椭圆曲线上任意取得基准点坐标&lt;/li&gt;
&lt;li&gt;p：质数p，用来控制值域范围的&lt;/li&gt;
&lt;li&gt;n：基准点G的阶(order)，即使得nG=0(无穷远点)的最小正整数。&lt;/li&gt;
&lt;li&gt;h：辅因子(cofactor)，h等于\( \frac {1}{n} | E(F_{p}) | \)。当h为最理想的1时，整个点群#E都可以被使用，否则，可用的点群大小只有#E/h。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以这样理解n：nP = iP + jP = 0, 即椭圆曲线上某2个点iP、jP，它们的和nP为无穷远点，即经过iP、jP的直线垂直于x轴，当i+j=n取到最小值时，即为G点的阶。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/13.jpg&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;（观察此图，发现5P + P = 6P = 0，P点的阶为6。&lt;a href=&quot;https://math.stackexchange.com/questions/704202/order-of-a-point-on-an-elliptic-curve&quot;&gt;进一步阅读&lt;/a&gt; ）&lt;/p&gt;

&lt;p&gt;当阶数n和#E一样大时，h取到最佳值1。h的计算，必然要先理解透彻群论的知识，这里不做展开，可以阅读这2个链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://math.stackexchange.com/questions/1394251/calculating-elliptic-curve-cofactor-h&quot;&gt;https://math.stackexchange.com/questions/1394251/calculating-elliptic-curve-cofactor-h&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hasse%27s_theorem_on_elliptic_curves&quot;&gt;https://en.wikipedia.org/wiki/Hasse%27s_theorem_on_elliptic_curves&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;ECC的应用：加密通讯 &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman&quot;&gt;ECDH&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;要仅仅用ECC来加密数据，那么就要用到&lt;a href=&quot;https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme&quot;&gt;ECIES&lt;/a&gt;这个。&lt;/p&gt;

&lt;p&gt;ECIES，即基于椭圆曲线的整合加密方案，与其类似的还有基于离散对数的整合加密方案 (DLIES)。&lt;/p&gt;

&lt;p&gt;ECIES，也被称为Elliptic Curve Augmented Encryption Scheme（基于椭圆曲线的增强加密方案） 或简单地叫 Elliptic Curve Encryption Scheme（基于椭圆曲线的加密方案）。&lt;/p&gt;

&lt;p&gt;Anyway，先以一个例子介绍下ECIES：Alice和Bob进行加密通讯。&lt;/p&gt;

&lt;p&gt;通讯前准备：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个椭圆曲线和参数集合(p,a,b,G,n,h)&lt;/li&gt;
&lt;li&gt;Bob的公钥\( K_{B} \)。\( K_{B} = k_{B}G , k_{B} \in [1, n - 1] \), \( k_{B} \)是Bob自己随机生成的私钥。注意，\( k_{B} \)是值, 而\( K_{B} \)是一个椭圆曲线上的点。&lt;/li&gt;
&lt;li&gt;双方共享信息： \( S_{1} ，S_{2}\) （nonce）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;加密流程；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成随机数r，计算R = rG&lt;/li&gt;
&lt;li&gt;计算\(P = (P_{x}, P_{y}) = rK_{B} \)，取P的x分量\(P_{x}\)作为共享密钥S。&lt;/li&gt;
&lt;li&gt;用KDF密钥导出函数，导出定长的对称加密密钥\(k_{E} \)和MAC密钥\(k_{M} \)，\( k_{E} || k_{M} = KDF(S || S_{1}) \)&lt;/li&gt;
&lt;li&gt;加密消息：\( c = E( k_{E}, m) \)，E代表Encrypt函数。&lt;/li&gt;
&lt;li&gt;计算MAC：\( d = MAC(k_{M}, c|| S_{2}) \)&lt;/li&gt;
&lt;li&gt;输出\(R || c || d\)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;解密流程： （ Bob已收到\(R || c || d\) ）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Bob先求出Alice也在使用的共享密钥\(P_{x}\), \(P = (P_{x}, P_{y}) = rK_{B} = rk_{B}G = k_{B}R \)，R是Alice发来的，\( k_{B} \)是本地的。&lt;/li&gt;
&lt;li&gt;Bob也用一样的方法求出2个密钥，\( k_{E} || k_{M} = KDF(S || S_{1}) \)&lt;/li&gt;
&lt;li&gt;检查收到的d和自己算的d‘是否一致，不一致的话说明c被中间人篡改了：\( d&amp;#39; = MAC(k_{M}, c|| S_{2}) \) &lt;/li&gt;
&lt;li&gt;此时就可以用对称加密密钥，解出消息m：\( m = E^{-1}(k_{E}, c) \) ，\(E^{-1}\)代表Decrypt函数（一般等同于Encrypt函数）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实这个流程就是非常著名的&lt;strong&gt;ECDH算法&lt;/strong&gt;了。Alice和Bob利用ECC算法，进行了&lt;strong&gt;密钥交换&lt;/strong&gt;，得到了\( P_{x} \)。&lt;/p&gt;

&lt;p&gt;资料： &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://crypto.stackexchange.com/questions/31602/how-does-encryption-work-in-elliptic-curve-cryptography&quot;&gt;https://crypto.stackexchange.com/questions/31602/how-does-encryption-work-in-elliptic-curve-cryptography&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;补充：已知P、Q，怎么求R&lt;/h3&gt;

&lt;p&gt;这个问题其实是解方程组问题，一个是直线的方程: \(y = kx + c\)，一个是椭圆曲线的方程：\( y^{2} = x^{3} + ax + b  \)。&lt;/p&gt;

&lt;p&gt;（推荐一个在线解方程组的工具：&lt;a href=&quot;http://www.wolframalpha.com/&quot;&gt;wolframalpha&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;以这幅图为例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;假设已知的只有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;椭圆曲线方程：\( y^{2} = x^{3} - 7x \)&lt;/li&gt;
&lt;li&gt;P(-2.35089, -1.86107)&lt;/li&gt;
&lt;li&gt;Q(-0.0999884, 0.836014)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在目标是求，直线与曲线的第三个交点R(应该叫-R）的坐标。&lt;/p&gt;

&lt;p&gt;第一步，化解方程组:&lt;/p&gt;

&lt;p&gt;\[ y = kx + m， y^{2} = ax^{3} + bx^{2} + cx + d \]&lt;/p&gt;

&lt;p&gt;\[ (kx + m)^{2} = ax^{3} + bx^{2} + cx + d \]&lt;/p&gt;

&lt;p&gt;\[ 0 = ax^{3} + (b - k^{2}) x^{2} + (c - 2km)x + d -  m^{2}\]&lt;/p&gt;

&lt;p&gt;本例的椭圆方程的系数为：&lt;/p&gt;

&lt;p&gt;\[ a = 1, b = 0, c = -7, d = 0\]&lt;/p&gt;

&lt;p&gt;代入上式，得到：&lt;/p&gt;

&lt;p&gt;\[ 0 = x^{3} - k^{2}x^{2} - (7 + 2km)x - m^{2}\]&lt;/p&gt;

&lt;p&gt;第二步，搬出&lt;a href=&quot;https://en.wikipedia.org/wiki/Vieta%27s_formulas&quot;&gt;韦达公式&lt;/a&gt;，对于一元三次方程，它的根之间有如下关系式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/14.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;用到我们这里，就是：&lt;/p&gt;

&lt;p&gt;\[ x_{1} + x_{2} + x_{3} = -\frac {b}{a} =  -\frac { -k^{2} }{1} = k^{2} \]&lt;/p&gt;

&lt;p&gt;\[ x_{1} * x_{2} * x_{3} = -\frac {d}{a}  = -\frac { -m^{2} }{1} = m^{2} \]&lt;/p&gt;

&lt;p&gt;\[ x_{1}x_{2} + x_{2}x_{3} + x_{1}x_{3} = \frac {c}{a} = \frac {- (7 + 2km)}{1} = - (7 + 2km) \]&lt;/p&gt;

&lt;p&gt;又因为\(x_{1}、x_{2}、x_{3}\)其实就是\( P_{x}、Q_{x}、R_{x} \) ，所以有：&lt;/p&gt;

&lt;p&gt;\[ R_{x} =  k^{2} - (P_{x} + Q_{x}) \]&lt;/p&gt;

&lt;p&gt;这样就求出了\(R_{x} \)。而R的y分量可以用斜率公式推出：&lt;/p&gt;

&lt;p&gt;\[ \frac { R_{y} - P_{y} } {  R_{x} - P_{x} } = k \]&lt;/p&gt;

&lt;p&gt;\[ R_{y} = k (R_{x} - P_{x} ) + P_{y} \]&lt;/p&gt;

&lt;p&gt;这里面还有个未知数斜率k，也是用斜率公式求出：&lt;/p&gt;

&lt;p&gt;\[ k = \frac { Q_{y} - P_{y} } {  Q_{x} - P_{x} } = 1.19822222 \]&lt;/p&gt;

&lt;p&gt;最终的：&lt;/p&gt;

&lt;p&gt;\[ R_{x} =  (1.19822222)^{2} - ((-2.35089) + (-0.0999884)) = 3.8866148938271605 \approx 3.89 \]&lt;/p&gt;

&lt;p&gt;\[ R_{y} = (1.19822222) (3.8866148938271605 - (-2.35089) ) + (-1.86107) = 5.6128469750035 \approx 5.61 \]&lt;/p&gt;

&lt;p&gt;\[ -R = (3.89, 5.61)，R = (3.89, -5.61) \]&lt;/p&gt;

&lt;p&gt;和图片里的数值一样。&lt;/p&gt;

&lt;h1&gt;DH算法&lt;/h1&gt;

&lt;h2&gt;key exchange例子（ &lt;a href=&quot;https://scotthelme.co.uk/perfect-forward-secrecy/&quot;&gt;from here&lt;/a&gt; )：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Alice和Bob首先线下商量好，使用&lt;strong&gt;p (prime, 质数) = 23、g (generator, 生成器) = 5&lt;/strong&gt;作为通讯基础（p和g不需要绝对的保密，泄露了也没事）&lt;/li&gt;
&lt;li&gt;每次Alice和Bob想要建立通讯(连接)时，Alice自己随机生成一个在范围[1, p - 1]的数：a = 6&lt;/li&gt;
&lt;li&gt;同样，Bob自己也随机一个：b = 15&lt;/li&gt;
&lt;li&gt;Alice计算： \( A =  g^{a}  \% p =  5^{6}  \% 23 =  15625 \% 23 = 8 \)，把A发给Bob&lt;/li&gt;
&lt;li&gt;Bob计算： \( B =  g^{b}  \% p =  5^{15}  \% 23 =  30517578125 \% 23 = 19 \)，把B发给Alice&lt;/li&gt;
&lt;li&gt;Alice收到B后，可计算出&lt;strong&gt;对称密钥&lt;/strong&gt;：\( s_{Alice} =  B^{a}  \% p =  19^{6}  \% 23 = 47045881 \% 23 = 2 \)&lt;/li&gt;
&lt;li&gt;Bob收到A后，可计算出&lt;strong&gt;对称密钥&lt;/strong&gt;：\( s_{Bob} =  A^{b}  \% p =  8^{15}  \% 23 = 35184372088832 \% 23 = 2 \)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;数学原理&lt;/h2&gt;

&lt;p&gt;其中，用到了&lt;strong&gt;模幂运算&lt;/strong&gt;的基本定理，对于任意自然数a、b、n，有：&lt;/p&gt;

&lt;p&gt;\[ ab\  \%\  n =  ( ab\ \%\  n) \  \%\  n =  ( (a\ \%\  n)  (b\ \%\  n) ) \ \%\  n \]&lt;/p&gt;

&lt;p&gt;应用到幂运算：&lt;/p&gt;

&lt;p&gt;\[ a^{b}\  \%\  n =  ( a \cdots  a ) \  \%\  n =  ( (a\ \%\  n) \cdots  (a\ \%\  n) ) \  \%\  n =  ( \ (a\ \%\  n)  ^{b}\  ) \ \%\  n \]&lt;/p&gt;

&lt;p&gt;\[ a^{b}\  \%\  n =  ( a^{b}\ \%\  n) \  \%\  n \]&lt;/p&gt;

&lt;p&gt;观察这2个式子最右边，发现b的位置是可以移动的：&lt;/p&gt;

&lt;p&gt;\[ ( \ (a\ \%\  n)  ^{b}\  ) \ \%\  n  =  ( a^{b}\ \%\  n) \  \%\  n \]&lt;/p&gt;

&lt;p&gt;套进上一节的例子里的推导公式，得到：&lt;/p&gt;

&lt;p&gt;\[ s_{Alice} = B^{a} \% p = (\  (\  g^{b} \% p\  ) ^{a}\   ) \% p = (  \ g^{ab} \% p\  \  ) \% p =  \ g ^{ab} \% p \]&lt;/p&gt;

&lt;p&gt;同理：&lt;/p&gt;

&lt;p&gt;\[ s_{Bob} = A^{b} \% p = (\  (\  g^{a}  \% p\  ) ^{b}\   ) \% p = (  \ g^{ab} \% p\  \  ) \% p  =  \ g ^{ab} \% p \]&lt;/p&gt;

&lt;p&gt;显然有：&lt;/p&gt;

&lt;p&gt;\[  s_{Alice} = s_{Bob}  \]&lt;/p&gt;

&lt;p&gt;这样就协商出了对称的密钥，密钥实质等于：&lt;/p&gt;

&lt;p&gt;\[ g ^{ab} \% p \]&lt;/p&gt;

&lt;p&gt;其中，g、p可公开、a、b保密。&lt;/p&gt;

&lt;h2&gt;为什么可行&lt;/h2&gt;

&lt;p&gt;从攻击者角度看，攻击者最多只能获得以下信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;p：23&lt;/li&gt;
&lt;li&gt;g：5&lt;/li&gt;
&lt;li&gt;A：8&lt;/li&gt;
&lt;li&gt;B：19&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;攻击者目标是获得s（serect）。要计算s，就是算2条式子：&lt;/p&gt;

&lt;p&gt;\[ s = ( B^{a} ) \% p \]&lt;/p&gt;

&lt;p&gt;\[ s = ( A^{b} ) \% p \]&lt;/p&gt;

&lt;p&gt;显然，攻击者只需要破解出a或b，就能得到s。&lt;/p&gt;

&lt;p&gt;又因为有：&lt;/p&gt;

&lt;p&gt;\[ A = ( g^{a} ) \% p \]&lt;/p&gt;

&lt;p&gt;\[ B = ( g^{b} ) \% p \]&lt;/p&gt;

&lt;p&gt;所以破解a或b的方法是：&lt;/p&gt;

&lt;p&gt;\[ a = log_{g}^{A} \% p \]&lt;/p&gt;

&lt;p&gt;\[ b = log_{g}^{B} \% p \]&lt;/p&gt;

&lt;p&gt;这看似很简单的算术（对数运算和取模运算），其实是很难算的。目前为止没有找到一个快速计算对数的算法。&lt;/p&gt;

&lt;p&gt;关键在于&lt;strong&gt;p这个素数要足够大&lt;/strong&gt;，那么以现在的计算机计算速度，就很难通过A（或B）、g、p这3个参数算出a，这被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_logarithm&quot;&gt;离散对数难题&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这里需要注意，难的是&lt;strong&gt;离散对数&lt;/strong&gt;，即有log和mod运算并且参数是整数；若单单只有log运算，是不难的。&lt;/p&gt;

&lt;h2&gt;p、g的选取问题&lt;/h2&gt;

&lt;p&gt;涉及到了一些数论的概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Greatest_common_divisor&quot;&gt;最大公约数gcd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiplicative_order&quot;&gt;数论阶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Primitive_root_modulo_n&quot;&gt;原根&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先明确下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;p必须是素数，且必须是大数(1024-2048bits)，算法才安全&lt;/li&gt;
&lt;li&gt;g不需要是素数，且不需要很大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;p、g不需要自己挑选，可以直接用&lt;a href=&quot;https://tools.ietf.org/html/rfc5114&quot;&gt;rfc5114&lt;/a&gt;给定的值。&lt;/p&gt;

&lt;p&gt;例如&lt;a href=&quot;https://tools.ietf.org/html/rfc5114#section-2.1&quot;&gt;1024-bit MODP Group with 160-bit Prime Order Subgroup&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;再讲下去就是深入密码学、数论了，按住不表。&lt;/p&gt;

&lt;h1&gt;分组加密算法的模式&lt;/h1&gt;

&lt;p&gt;分组加密算法，都需要考虑wrap模式（【Block Cipher Modes（&lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation%EF%BC%89%EF%BC%89%E3%80%82&quot;&gt;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation））。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;模式多种多样，也很容易查到介绍资料。选择模式时主要考察几个点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;并发性：

&lt;ul&gt;
&lt;li&gt;如CTR、GCM计数器模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;安全性：

&lt;ul&gt;
&lt;li&gt;如ECB模式对重复出现的明文分组加密后结果是一样的，容易被猜出&lt;/li&gt;
&lt;li&gt;如CBC模式，会遇到&lt;a href=&quot;https://en.wikipedia.org/wiki/Padding_oracle_attack&quot;&gt;padding oracle attacks&lt;/a&gt;，这篇写得很详细：&lt;a href=&quot;https://blog.csdn.net/qq_35078631/article/details/78484980&quot;&gt;https://blog.csdn.net/qq_35078631/article/details/78484980&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;完整性(integrity)和可验证性(authenticity)：

&lt;ul&gt;
&lt;li&gt;其实就是指消息验证码MAC。加了MAC后，解密时，验证MAC，防止密文被篡改（tamper），保持完整。&lt;/li&gt;
&lt;li&gt;CCM模式，等于CTR加上CBC-MAC，不过做了2重加密，速度慢。&lt;/li&gt;
&lt;li&gt;OCB，有版权问题据说。&lt;/li&gt;
&lt;li&gt;GCM，等于CTR加上GHASH。这个是NIST官方标准了，绝对靠谱，性能据说很可以，openssl里面有一堆GASH的汇编代码，硬件级别上也有相应支持。&lt;/li&gt;
&lt;li&gt;这2个性质不一定要由分组加密完成。也可以外部套一个非对称加密，用数字签名来保证完整性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AES各种模式的选择问题，参考:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1220751/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb&quot;&gt;https://stackoverflow.com/questions/1220751/how-to-choose-an-aes-encryption-mode-cbc-ecb-ctr-ocb-cfb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此回答近300赞，在stackoverflow上算很多了。&lt;/p&gt;

&lt;p&gt;如果没耐心看，就看作者的最后总结：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果数据已经在外部做了非对称加密数字签名以支持验证，那么用CBC即可，否则用GCM&lt;/strong&gt;。&lt;/p&gt;

&lt;h1&gt;&lt;strong&gt;完全前向保密&lt;/strong&gt; PFS(Perfect Forward Secrecy)&lt;/h1&gt;

&lt;h2&gt;没有PFS之前：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果攻击者曾经窥探并保存了用户和服务器的加密数据流，且包括被公钥加密的对称密钥&lt;/li&gt;
&lt;li&gt;如果有一天攻击者通过某种办法获得了服务器私钥&lt;/li&gt;
&lt;li&gt;攻击者同时拥有了：“用公钥加密的对称密钥”、“私钥”&lt;/li&gt;
&lt;li&gt;攻击者用“私钥”对“用公钥加密的对称密钥”解密，获得了对称密钥&lt;/li&gt;
&lt;li&gt;攻击者此时就可以用破解出来的对称密钥对已存的历史加密数据做解密&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;基于DH的PFS：&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不再使用公钥加密对称密钥的方案&lt;/li&gt;
&lt;li&gt;改为用DH密钥交换算法（key exchange），协商对称密钥，可以直接明文传输协商时需要的信息（并不怕这些信息被窃取）&lt;/li&gt;
&lt;li&gt;每次会话都协商新的对称密钥&lt;/li&gt;
&lt;li&gt;因为公钥私钥没有用来加密对称密钥了，所以即使服务器私钥被盗了也不会导致历史对称密钥被破解&lt;/li&gt;
&lt;li&gt;即使单次会话的对称密钥被破解了，也不会影响到别的会话&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;为什么可行&lt;/h2&gt;

&lt;p&gt;关键在于，用于生成会话密钥的“数据”，根本就没通过网络发送出去。而用公钥加密的密钥，本身就是通过网络传输的。&lt;/p&gt;

&lt;p&gt;后者显然更容易被攻击，主要获得私钥并记录了整个会话的数据流，就可以破解了。&lt;/p&gt;

&lt;p&gt;而前者，对称密钥的协商，根本没有用到公钥私钥，经过网络的也不是什么被加密后的密钥，而只是协商信息。攻击者要想破解某次会话的内容，只能从该次会话的加密数据流入手，没有他法。&lt;/p&gt;

&lt;h2&gt;问题&lt;/h2&gt;

&lt;p&gt;要做到perfect，意味着每次会话都要协商密钥，意味着增加了计算开销，不然不能保证密钥的转瞬即逝性质（ephemeral）。&lt;/p&gt;

&lt;h1&gt;通讯的认证&lt;/h1&gt;

&lt;p&gt;认证问题是指，如何确定和自己通讯的对方不是其他假冒者？&lt;/p&gt;

&lt;p&gt;目前有2个主要的解决方案：消息验证码（message authentication code，MAC）和数字签名（digital signature）。&lt;/p&gt;

&lt;h2&gt;消息验证码&lt;/h2&gt;

&lt;p&gt;前提：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通讯双方需要先约定好一个密钥，称为&lt;strong&gt;共享密钥&lt;/strong&gt;，双方都把它安全地存起来&lt;/li&gt;
&lt;li&gt;对任意长度的消息数据，用共享密钥可以计算出对应的固定长度的MAC&lt;/li&gt;
&lt;li&gt;计算MAC必须用到共享密钥，除非密钥泄露，否则第三者无法计算出MAC值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;协商密钥&lt;/li&gt;
&lt;li&gt;发送方对消息计算MAC值&lt;/li&gt;
&lt;li&gt;发送方把消息和MAC值都发给对方&lt;/li&gt;
&lt;li&gt;对方收到消息后，也用共享密钥计算MAC值，并与收到的MAC值比对&lt;/li&gt;
&lt;li&gt;如果2个MAC值一致，那么消息确实来自于发送方&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;各种问题：&lt;/h3&gt;

&lt;p&gt;一，密钥协商问题（上面已提过）。&lt;/p&gt;

&lt;p&gt;二，重放攻击(replay attack)：攻击者窃听通讯双方（例如2个银行）的数据，把汇款消息保存了下来（带有MAC值），然后重复发送这个汇款消息，接收方就会重复地向发送方发起汇款。其中，攻击者并不需要破解消息。&lt;/p&gt;

&lt;p&gt;解决方法：每条消息都加序号，序号必须保证递增，从而每条消息的序号唯一；消息加时间戳，但时钟同步和时钟精度又是新的问题；每个消息加nonce，一个只能用一次的随机数。&lt;/p&gt;

&lt;p&gt;三，密钥推测攻击：应确保攻击者不能通过MAC值逆向出共享密钥，否则攻击者就可以伪造发包了。&lt;/p&gt;

&lt;p&gt;四，对第三方证明问题：共享密钥只能保证2个人之间的通讯认证，但是如果多于2个人时，理论上共享密钥无法解决认证问题。&lt;/p&gt;

&lt;p&gt;例子：用户A向银行B用共享密钥传输了一个取款消息，如果B取款前需要告知C“A申请取款”，C是否可以相信A真的发出了取款消息，还是说消息是B杜撰的？答案是C没有办法知道。&lt;/p&gt;

&lt;p&gt;五，防止否认问题：就上面的取款例子，如果A真的发起了取款消息，但是事后又矢口否认，A认为是B杜撰了这个消息，此时事实就说不清了，A和B都有共享密钥，无法知道消息是A说的还是B说的。&lt;/p&gt;

&lt;h2&gt;数字签名&lt;/h2&gt;

&lt;p&gt;简单来说，数字签名是公钥加密的逆向过程。&lt;/p&gt;

&lt;p&gt;对比一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;公钥加密&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;公钥：发送者加密时使用&lt;/li&gt;
&lt;li&gt;私钥：接收者解密时使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数字签名&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;公钥：验证者验证签名时使用&lt;/li&gt;
&lt;li&gt;私钥：签名者生成签名时使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里面的公钥私钥是一样的东西，只是用法不一样。私钥依然需要保密地持有，而公钥依然可以任意地公开。&lt;/p&gt;

&lt;p&gt;为什么公钥加密反过来就是数字签名，而不是反方向的加密呢？用心琢磨下就知道了：用私钥去加密消息，而谁都能拿到公钥去解密，有什么保密意义可言？&lt;/p&gt;

&lt;p&gt;其中还有一个关键点是由公钥的数学原理保证的：用私钥加密的消息，只能用配套的公钥才能解密。&lt;/p&gt;

&lt;h3&gt;数字签名使用方法：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;发送方计算消息的摘要（MD5，SHA-1）&lt;/li&gt;
&lt;li&gt;发送方对摘要用自己的私钥加密，生成数字签名&lt;/li&gt;
&lt;li&gt;发送方把消息和数字签名同时发出&lt;/li&gt;
&lt;li&gt;任何人都可以用发送方公布的公钥对数字签名解密&lt;/li&gt;
&lt;li&gt;通过对比解出来的摘要和自己算出来的摘要，就可以知道消息是不是来自发送方（识别修改）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，上面说的消息，可以是明文也可以是密文，也就是说数字签名支持对明文做签名。&lt;/p&gt;

&lt;h3&gt;公钥证书：&lt;/h3&gt;

&lt;p&gt;对签名用到的公钥私钥对中的公钥也进行签名，就得到了公钥证书。（是不是有一种递归的感觉。）&lt;/p&gt;

&lt;p&gt;公钥证书可以用来判断收到的公钥是不是发送方的公钥。因为有可能收到假的公钥（中间人攻击）。&lt;/p&gt;

&lt;p&gt;签名公钥时，用到的公钥密钥对，本身又要认证。这就产生了CA的概念。&lt;/p&gt;

&lt;p&gt;一般公钥证书会简称证书。&lt;/p&gt;

&lt;h3&gt;数字签名的主要问题：&lt;/h3&gt;

&lt;p&gt;抛开一些攻击问题不讲，最主要的问题就是上面刚提到的中间人攻击。&lt;/p&gt;

&lt;p&gt;因为要正确地使用数字签名，有一个大前提：&lt;strong&gt;用于验证签名的公钥必须属于真正的发送者&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这就陷入了死循环：数字签名是用来&lt;strong&gt;防止伪冒&lt;/strong&gt;，但同时又必须从非伪冒的发送者拿到没有被篡改的公钥。&lt;/p&gt;

&lt;p&gt;所以就得用上刚刚提过的&lt;strong&gt;公钥证书&lt;/strong&gt;，给公钥附加一个第三方的签名，这样就把问题转移到了第三方。&lt;/p&gt;

&lt;p&gt;第三方的背后也可以存在别的第三方，于是需要构造一个&lt;strong&gt;数字签名链条&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;链条的末端，就是所谓的根证书了。&lt;/p&gt;

&lt;h3&gt;公钥基础设施：PKI（Public-Key Infrasture）&lt;/h3&gt;

&lt;p&gt;PKI的组成结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户，使用PKI的人&lt;/li&gt;
&lt;li&gt;认证机构（CA，Certification Authority），颁发证书的实体&lt;/li&gt;
&lt;li&gt;仓库（Repo），也叫证书目录，保存证书的数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PKI可以有无数个。&lt;/p&gt;

&lt;p&gt;重点要理解CA是怎么回事。&lt;/p&gt;

&lt;p&gt;CA主要做三件事：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;生成公钥密钥对。其实是可选的，如果由CA生成，那么需要安全地把私钥发给用户；如果是PKI用户生成，就简单多了。&lt;/li&gt;
&lt;li&gt;生成颁发证书。需要用到CA自己的私钥来对第一步的公钥进行数字签名，&lt;strong&gt;同时还需要对用户身份进行认证&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;作废（revoke）证书。作废比较复杂，因为用户会在本地缓存证书副本。于是就有了CRL，证书作废清单，（Certification Revocation List）。相当于是一个作废证书的公示榜单。其中每个证书有一个序列号可以作为id对应。用户通过查看CRL就可以知道证书有没作废。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CA可以形成层级关系，最顶层的叫根CA。验证某个公钥证书时，需要从根CA开始，一层层往下验证，确保整条链上的证书都是合法的。&lt;/p&gt;

&lt;h3&gt;对证书的攻击&lt;/h3&gt;

&lt;p&gt;有社会学的攻击也有非社会学的，具体建议看《图解密码技术》的第十章。&lt;/p&gt;

&lt;h3&gt;为什么要搞得这么复杂&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果用户有办法能够取得可信的公钥，则不需要CA&lt;/li&gt;
&lt;li&gt;当持有可信的CA公钥，并相信这个CA，则可以相信该CA颁发的证书，从而获得可信的公钥。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我的理解是，目前的技术瓶颈导致只能如此，没有更靠谱的方法。&lt;/p&gt;

&lt;p&gt;不过存在替代CA模式的其他解决方案：信任网络（web of trust），这个概念来源于PGP。&lt;/p&gt;

&lt;p&gt;信任网络就好像人与人之间的关系网（六度分隔理论），通过&lt;strong&gt;熟人推荐&lt;/strong&gt;，就可以建立起信任链，从而解决公钥认证问题。&lt;/p&gt;

&lt;p&gt;PGP就是建立在信任网络的协议和软件。鉴于PGP的设计，PGP特别适合用于电子邮件传输，当然电子邮件又不仅限用PGP，还可以用基于CA的S/MIME。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38920372&quot;&gt;https://zhuanlan.zhihu.com/p/38920372&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://scotthelme.co.uk/perfect-forward-secrecy/&quot;&gt;https://scotthelme.co.uk/perfect-forward-secrecy/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hackernoon.com/eliptic-curve-crypto-the-basics-e8eb1e934dc5&quot;&gt;Elliptic Curve Crypto , The Basics&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3&quot;&gt;What is the math behind elliptic curve cryptography?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.certicom.com/content/certicom/en/21-elliptic-curve-addition-a-geometric-approach.html&quot;&gt;https://www.certicom.com/content/certicom/en/21-elliptic-curve-addition-a-geometric-approach.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/block2016/p/5623902.html&quot;&gt;https://www.cnblogs.com/block2016/p/5623902.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/crypto-1/</link>
        <guid isPermaLink="true">http://localhost:4000/crypto-1/</guid>
      </item>
    
      <item>
        <title>无损压缩算法：deflate</title>
        <description>&lt;p&gt;本文目标是搞清楚zlib库的deflate算法实现。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;名词解释&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/DEFLATE&quot;&gt;deflate&lt;/a&gt;：最常见的无损压缩算法，非常关键。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;.zip&lt;/a&gt;：archive format，使用了deflate压缩算法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Gzip&quot;&gt;.gz&lt;/a&gt;(或gzip格式）: single file compress format，也是使用了deflate压缩算法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Tar_(computing)&quot;&gt;.tar.gz&lt;/a&gt;或.tgz：archive format，可认为.gz文件的集合，但又不止是多个.gz的集合，因为tgz利用了文件之间的关联信息，提升了压缩率。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zlib.net/&quot;&gt;zlib&lt;/a&gt;：一个通用库，只有源代码，不提供可执行文件，支持gzip。linux内核、libpng、git等等都用了它。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/gzip/manual/gzip.html&quot;&gt;gzip&lt;/a&gt;：GNU Gzip，开源，提供了gzip和gunzip可执行文件，直接可以用来压缩、解压缩。内部也是实现了deflate算法。&lt;/p&gt;

&lt;p&gt;7-Zip：类似gzip，也是工具。&lt;/p&gt;

&lt;p&gt;经过了解，gzip的源码相对&lt;/p&gt;

&lt;h2&gt;Huffman Coding 和 LZ77&lt;/h2&gt;

&lt;h3&gt;LZ77（Lempel–Ziv Coding）&lt;/h3&gt;

&lt;p&gt;LZ77是基于&lt;strong&gt;字典&lt;/strong&gt;的算法。思路是，把数据中的重复（冗余）部分，用更短的metadata元信息代替。&lt;/p&gt;

&lt;p&gt;wiki：&lt;a href=&quot;https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;LZ77 and LZ78&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根据wiki所说，作者是发明了2个算法LZ77和LZ78。这2个算法是其他LZ算法变种的基础（LZW、LZSS、LZMA）。&lt;/p&gt;

&lt;p&gt;下面重点介绍LZ77。&lt;/p&gt;

&lt;h4&gt;LZ77关键词：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;input stream：待压缩的字节序列串&lt;/li&gt;
&lt;li&gt;byte：字节，是input stream的基本元素&lt;/li&gt;
&lt;li&gt;coding position：相当于一个指针，指向当前编码位置；也是lookahead buffer的起始位置&lt;/li&gt;
&lt;li&gt;lookahead buffer：就是指coding position为起点，input stream末端为终点的这段字节序列&lt;/li&gt;
&lt;li&gt;window：最大长度为W的滑动窗口，也是以coding position为起点，但是窗口方向是&lt;strong&gt;反向往左&lt;/strong&gt;；窗口初始长度为0，随着编码的进行，长度会增长到W，然后就开始往右滑动&lt;/li&gt;
&lt;li&gt;match：当前匹配串&lt;/li&gt;
&lt;li&gt;pointer：当前匹配串的信息，一般用（B，L）表示，B表示Go &lt;strong&gt;B&lt;/strong&gt;ack多少个字节（从coding position往左），因为也叫starting offset；L指匹配串从starting offset往右延伸的长度。 pointer为（0，0）时，表示匹配失败。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;LZ77要注意的点：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;pointer的L是可能比B还大的，即匹配串从window区域，延伸进了lookahead buffer区域，又因为匹配串的起点就是lookahead buffer的起点，所以此时出现了&lt;strong&gt;repeat&lt;/strong&gt;现象。这个repeat是没问题的，甚至是有用的，可以对不断重复的数据大大压缩。&lt;/li&gt;
&lt;li&gt;pointer有匹配成功和匹配失败2种情况，所以把pointer信息输出时，还得在pointer前用一个bit表示是哪种pointer。&lt;/li&gt;
&lt;li&gt;pointer里2个信息：B和L，它们的位数一般是固定的。位数大小可以是任意的N bits，但显然，位数太少的话，说明最大匹配长度就受限，即对于超长串是无法高度压缩的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重点&lt;/strong&gt;：有的文章会把pointer表示成（B，L，C）。C就是一个byte数据，这是因为任意一个byte第一次出现时，肯定是找不到匹配串的，所以会输出（0，0，byte）；并且，为了输出缓冲区的结构一致性，当匹配成功时，也得输出（B，L，C），C相当于一个空的占位符，有点浪费，所以有的LZ77算法会再成功匹配后，把下一个byte存到占位符里，因此encoding position要移动L+1。（注意下文讲解的实例占位符是留空的）&lt;/li&gt;
&lt;li&gt;B和L耗用的位数不需要一样。&lt;/li&gt;
&lt;li&gt;既然固定了B和L的位数大小，那么最大窗口大小W也是可以固定的，例如当W为32KB时，那么15 bits就可以表达32KB的任意一个值。&lt;/li&gt;
&lt;li&gt;window的最大长度W影响到压缩比率和压缩效率。显然W越大，匹配得越充分，但也越慢。&lt;/li&gt;
&lt;li&gt;需要定一个&lt;strong&gt;最小匹配长度&lt;/strong&gt;，只有当当前匹配串大于最小匹配长度时，这个匹配才成立。例如B用15位，L用8位，差不多就用了3个字节，如果当前匹配串不足3个字节，例如1个字节，那就导致encoding后长度反而更长了。&lt;/li&gt;
&lt;li&gt;显然LZ77的compress做的工作量要比decompress多得多，因为做了大量的匹配查找。所以LZ77特别适合于&lt;strong&gt;一次压缩，多次解压缩&lt;/strong&gt;的情景。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;实例：&lt;/h4&gt;

&lt;p&gt;这种算法用实例来理解是最快的。微软&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ee916854.aspx&quot;&gt;这篇文章&lt;/a&gt;就给出了一个例子，这里拿来用一下。&lt;/p&gt;

&lt;p&gt;（&lt;a href=&quot;https://www.cnblogs.com/junyuhuang/p/4138376.html&quot;&gt;另外这篇文章&lt;/a&gt;给出了这个例子的示意图，建议同时参照下，本文就不做图了）&lt;/p&gt;

&lt;p&gt;待压缩字节串（流）：AABCBBABC&lt;/p&gt;

&lt;p&gt;字节串中每个字节记一个位置标记position（上面的encoding position也是指这个），从1开始数，不是从0哦：&lt;/p&gt;

&lt;pre&gt;

Position    1    2    3    4    5    6    7    8    9

Byte        A    A    B    C    B    B    A    B    C

&lt;/pre&gt;

&lt;p&gt;开始LZ77编码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;LZ77编码后，就输出了最右边一列，注意，这里只是方便理解，实际上不会存成文本形式，没有（ ），这些字符。&lt;/p&gt;

&lt;p&gt;这里重点要搞懂output这一列是怎么来的，用人话来描述下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始时，滑动窗口window是空的：【】&lt;/li&gt;
&lt;li&gt;第1次遇到A，然后在window里match一下，必然找不到A，match失败，于是输出(0,0)A。window更新为【A】&lt;/li&gt;
&lt;li&gt;第2次遇到A，window里match一下，此时要注意，match的方向是右到左（反向）。在window右起第1个位置就找到了A，所以输出(1, 1)，window更新为【AA】&lt;/li&gt;
&lt;li&gt;第1次遇到B，同步骤1，输出(0,0)B，window更新为【AAB】&lt;/li&gt;
&lt;li&gt;同步骤3，输出(0,0)C，window更新为【AABC】&lt;/li&gt;
&lt;li&gt;第2次遇到B，在window第2个位置找到B，于是starting position为2，同时发现下一个字节不匹配（左C和右B），所以长度为1，输出（2，1），window更新为【AABCB】&lt;/li&gt;
&lt;li&gt;第3次遇到B，在window第1个位置就找到B，同时发现下一个字节不匹配（左B和右C），所以长度为1，输出（1，1），window更新为【AABCBB】&lt;/li&gt;
&lt;li&gt;第3次遇到A，在window第5个位置找到A，然后迭代匹配，发现后面的BC也匹配上，所以长度为3，输出（5，3），window更新为【AABCBBABC】&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来，看看如何把这一列output再解码回原文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;输入(0,0)A，表示直接往输出缓冲区push一个A字符。 【A】&lt;/li&gt;
&lt;li&gt;输入(1,1)，只有meta信息，(1,1)意思是它的位置等于1，长度为1，&lt;strong&gt;注意，位置是反向数，长度是正向数&lt;/strong&gt;。显然，(1,1)等于缓冲区的字符A，于是push了一个一样的A。【AA】&lt;/li&gt;
&lt;li&gt;(0,0)B，和步骤1一样，直接push一个B。【AAB】&lt;/li&gt;
&lt;li&gt;(0,0)C，同上。【AABC】&lt;/li&gt;
&lt;li&gt;(2,1)，又是meta信息，位置为2，长度为1，倒着数当前缓冲区，发现起点是B字符，长度为1，所以push一个B。【AABCB】&lt;/li&gt;
&lt;li&gt;(1,1)，参考步骤5，也是push一个B。【AABCBB】&lt;/li&gt;
&lt;li&gt;(5,3)，长度终于不为1了，首先在缓冲区倒着数5下，发现是左起第二个A，然后长度3，于是往右再获取2个字符，得到ABC，push到缓冲区，得到【AABCBBABC】&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的内容搞得懂的话，就差不多了，要继续深入就是看源码。但不急，先看完Huffman Coding。&lt;/p&gt;

&lt;h3&gt;Huffman Coding&lt;/h3&gt;

&lt;p&gt;待续。&lt;/p&gt;

&lt;h2&gt;zlib 和 deflate&lt;/h2&gt;

&lt;h3&gt;zlib&lt;/h3&gt;

&lt;p&gt;zlib自带CMakeLists.txt，在Mac上可以直接生成一个Xcode project，不仅可以方便地编译zlib，还可以用来学习zlib（本文的重心）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;cd build/
cmake .. -G &amp;#39;Xcode&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后打开zlib.xcodeproj，构建All，并选择运行example。能运行成功的话打开example.c，会发现有完整的zlib使用教程。&lt;/p&gt;

&lt;p&gt;我们重点放在deflate的最简单的使用实例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_deflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;test_inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncomprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第1行压缩，第2行解压。看懂了这两个函数代码，是理解deflate算法的第一步。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 该函数用到的外部代码片段，我搬运到这里，方便浏览&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 压缩强度级别&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define Z_NO_COMPRESSION         0&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define Z_BEST_SPEED             1&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define Z_BEST_COMPRESSION       9&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define Z_DEFAULT_COMPRESSION  (-1)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 这个结构大概相当于一个压缩控制器&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z_stream_s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z_const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bytef&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* 指向待压缩数据的第一个字节 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uInt&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 待压缩数据next_in的长度 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;total_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 当前已读取多少输入字节 */&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Bytef&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 指向输出缓冲区，只需要在一开始赋值一次 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uInt&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 输出缓冲区next_out的剩余空间 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;total_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 当前已输出多少输入字节*/&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;z_const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 错误信息 */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internal_state&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FAR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 暂时不用管这个 */&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;alloc_func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 压缩过程会分配新内存（internal state），用户可以设置自己的alloc函数给z_stream */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;free_func&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;cm&quot;&gt;/* 释放内存 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;voidpf&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;opaque&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* zalloc、zfree的第一个参数，默认设0即可 */&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;data_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 数据的类型的猜测：Z_BINARY 或者 Z_TEXT，即保存了detect_data_type的返回值 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;adler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* 未压缩数据的检验和 （Adler-32 or CRC-32) */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;reserved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//待压缩的字节串&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z_const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;hello, hello!&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_deflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z_stream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 待压缩数据大小&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opaque&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voidpf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deflateInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_DEFAULT_COMPRESSION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;deflateInit&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_in&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z_const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 如果不使用1字节buffer模式的话，要执行这2行&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// c_stream.avail_in = len;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// c_stream.avail_out = comprLen;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 开始压缩&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 每次只处理1个字节，故意的*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_NO_FLUSH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;deflate&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 压缩末端的处理&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 依然每次只输出一个字节&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_FINISH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_STREAM_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 结束标记&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;deflate&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deflateEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;deflateEnd&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;纵观整个压缩流程，其实就是1个变量和3个函数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义z_stream局部变量c_stream&lt;/li&gt;
&lt;li&gt;deflateInit(&amp;amp;c_stream, Z_DEFAULT_COMPRESSION)，初始化c_stream&lt;/li&gt;
&lt;li&gt;deflate(&amp;amp;c_stream, Z_NO_FLUSH)和deflate(&amp;amp;c_stream, Z_FINISH)，压缩数据&lt;/li&gt;
&lt;li&gt;deflateEnd(&amp;amp;c_stream)，结束&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个example故意让缓冲区每次迭代都只有1个字节可用，可以去掉那2行代码，并在开始压缩之前执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是解压缩：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncomprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Byte&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uLong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncomprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z_stream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;garbage&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opaque&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;voidpf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_in&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 如果不使用1字节buffer模式的话，要执行这2行&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// d_stream.avail_in = (uInt)comprLen;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// d_stream.avail_out = (uInt)uncomprLen;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflateInit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;inflateInit&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uncomprLen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comprLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avail_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_NO_FLUSH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Z_STREAM_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;inflate&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflateEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CHECK_ERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;inflateEnd&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strcmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;bad inflate&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;inflate(): %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncompr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;deflate和inflate函数的源码，非常恐怖，单个函数几百行。这里就不贴出来分析了。&lt;/p&gt;

&lt;h3&gt;deflate&lt;/h3&gt;

&lt;p&gt;待续。&lt;/p&gt;

&lt;h2&gt;adler32 和 CRC32&lt;/h2&gt;

&lt;p&gt;待续。&lt;/p&gt;

&lt;h2&gt;历史&lt;/h2&gt;

&lt;p&gt;一位答主写了压缩算法的演变史，很值得一看：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they&quot;&gt;https://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单来说，就是早期unix系统上面只有compress指令，compress使用了一个有版权的LZW算法，作者Phil Katz对LZW的免费使用有所争议。&lt;/p&gt;

&lt;p&gt;并且，zip format也是这个作者设计的，但庆幸zip format是无版权的，于是就有个叫Info-ZIP group的组织开发了同样可以压缩&amp;amp;解压缩zip的程序，开源免费跨平台，这个东西导致zip format被大范围使用。&lt;/p&gt;

&lt;p&gt;然后到了90年代早期，出现了新的压缩格式：gzip format（或.gz）以及对应的程序gzip。gzip的代码继承自Info-ZIP，gzip是打算用来取代unix的compress的。&lt;/p&gt;

&lt;p&gt;gzip单个文件时，会给该文件加上.gz后缀。&lt;/p&gt;

&lt;p&gt;然后又到了90年代中期，又遇到了版权问题，这次是关于gif格式的，gif用了带版权的LZW算法。于是又有人站出来开发了替代品：png。这是一种无损压缩图片的技术，同样使用了deflate作为内部格式。为了扩大png的使用范围，就弄出了libpng和zlib两个网站。libpng是用来处理png有关的所有事情，而zlib是作为libpng背后的支撑：提供了压缩和解压缩算法（当然现在也被用于别的软件）。注意，zlib的代码继承自gzip。&lt;/p&gt;

&lt;p&gt;小结2点：&lt;strong&gt;gzip是zlib之父；以上说的版权问题现在都已过期了&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;zlib兼容gzip，且提供了比gzip更多的功能选项。一是wrapping模式可选：无wrapping、zlib wrapping、gzip wrapping。无wrapping就是仅使用deflate内部格式；png使用的就是zlib wrapping。&lt;/p&gt;

&lt;p&gt;zlib wrapping和gzip wrapping的主要区别是：zlib wrapping更紧凑并且新增了Adler-32算法，比gzip用的CRC32更快。&lt;/p&gt;

&lt;p&gt;所以zlib源码会显得比较复杂，需要兼容gzip格式和CRC32，且新增了zlib格式和Adler32；gzip就显得比较原始，只有deflate和CRC32代码。&lt;/p&gt;

&lt;p&gt;zlib是目前最广泛使用的压缩库。&lt;/p&gt;

&lt;p&gt;再后来，就出现了新的基于deflate压缩库：7-Zip和google的zopfli。zopfli的压缩率比zlib的最高压缩率还高，压榨了最后的一些空间，但也花费了更多的CPU时间。当然这个最高压缩level是可选的。注意，zopfli只提供了压缩功能，解压缩依然得用zlib或gzip（大概是因为解压缩本来就足够优秀了）；zopfli虽然有3-8%的压缩率提升，但耗时增长得更厉害，觉得zopfli还是显得鸡肋。&lt;/p&gt;

&lt;p&gt;以上说的都是基于deflate算法的压缩库。实际上还存在别的算法：bzip2、LZMA等，他们有的甚至是完胜deflate。但很可惜，在互联网中要更替一种标准是非常困难的。deflate已经广泛运用到web的方方面面，难以取代。&lt;/p&gt;

&lt;p&gt;所以还是学习deflate先吧。并且，阅读zlib库最佳。&lt;/p&gt;

&lt;h2&gt;资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951 : DEFLATE Compressed Data Format Specification version 1.3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://qianwenjie.net/?p=17&quot;&gt;http://qianwenjie.net/?p=17&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://marknelson.us/1997/01/01/zlib-engine/&quot;&gt;http://marknelson.us/1997/01/01/zlib-engine/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zlib.net/feldspar.html&quot;&gt;http://www.zlib.net/feldspar.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/zlib-1/</link>
        <guid isPermaLink="true">http://localhost:4000/zlib-1/</guid>
      </item>
    
      <item>
        <title>多线程网络库开发笔记</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;收到EPOLLOUT事件，但write时返回了EAGAIN？&lt;/h2&gt;

&lt;p&gt;这是因为EAGAIN不止是在发送缓冲区满时返回，还可能是&lt;strong&gt;未ACK的包数量已经达到了拥塞窗口的大小&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而EPOLLOUT并不会检查拥塞窗口的情况，只要发送缓冲区不满，就返回EPOLLOUT了。&lt;/p&gt;

&lt;p&gt;用并发压力测试可以测出这种情况：在epoll_wait返回后，检测可写事件的fd是否发送缓冲区不满，不满的话尝试写入一个字节，然后通过write的返回值和错误码就可以知道有没出现&lt;strong&gt;缓冲区不满的EAGAIN&lt;/strong&gt;。同时打印出拥塞窗口信息，就可以看出EAGAIN原因：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.3/22.png&quot; alt=&quot;22.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;a href=&quot;https://stackoverflow.com/questions/3070127/will-eagain-return-on-send-for-anything-other-than-buffer-full&quot;&gt;https://stackoverflow.com/questions/3070127/will-eagain-return-on-send-for-anything-other-than-buffer-full&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://linuxgazette.net/136/pfeiffer.html&quot;&gt;https://linuxgazette.net/136/pfeiffer.html&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;EAGAIN/EWOULDBLOCK can also be returned (for TCP sockets) when the number of unacknowledged packets has reached the congestion window.&lt;/p&gt;

&lt;p&gt;To check the status of the socket w.r.t. the congestion window, then try this:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;netinet/tcp.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_tcp_cwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcp_info_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getsockopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOL_TCP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TCP_INFO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_info_length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;tcpi_snd_cwnd: %u, tcpi_unacked: %u&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcpi_snd_cwnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tcp_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcpi_unacked&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;If tcpi_unacked == tcpi_snd_cwnd then send() will return EAGAIN/EWOULDBLOCK for a non-blocking socket.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;write无限返回EAGAIN导致的cpu超载和FIN_WAIT1卡死&lt;/h2&gt;

&lt;p&gt;这是只会出现在非阻塞socket的问题。&lt;/p&gt;

&lt;p&gt;解决思路：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检查是不是意外调用了onWritable接口，即还没有监听可写事件，却调用了可写回调接口&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尝试用while循环来调用send data，直到send发完数据，或返回-1（EAGAIN）并添加可写监听。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，收到可写事件时，尝试write剩余字节，如果write能把所有字节都写进发送队列，那么就可以删除EPOLLOUT监听了。&lt;/p&gt;

&lt;h2&gt;atomic变量也会segment fault?&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#0  0x00000000004cb56b in std::atomic&amp;lt;wynet::TcpConnection::State&amp;gt;::load (this=0x58, &lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;4.8.2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;209&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#1  0x00000000004c9a6d in std::atomic&amp;lt;wynet::TcpConnection::State&amp;gt;::operator wynet::TcpConnection::State&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x58&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++/&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;4.8.2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;176&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#2  0x00000000004f0fa1 in wynet::TcpConnection::shutdown (this=0x0)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;github&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wynet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;74&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gdb查core文件，发现日志很奇怪，在atomic的load里crash了。&lt;/p&gt;

&lt;p&gt;最终发现是访问了一个null的shared_ptr的atomic变量。加if判断即可。&lt;/p&gt;

&lt;h2&gt;10k和10k+连接问题&lt;/h2&gt;

&lt;p&gt;10k数量级的网络连接，是非常容易暴露出自己写的网络代码的问题的。&lt;/p&gt;

&lt;p&gt;局域网下有2种测试方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;server和clients同主机（走回环，不需要经过网卡）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;server和clients不同主机，clients可以分散到多台主机（需要经过网卡）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我现在做的第一种，本地开2个进程，一个进程跑server，另一个进程发起10k+个客户端连接，pingpong发消息，可以测吞吐量并且也可以测下承载能力。&lt;/p&gt;

&lt;p&gt;目前遇到很多问题，逐个列举下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开文件描述符数量限制。可以用ulimit -n修改。Mac下有些特殊。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端的port不够用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先查看系统上限：cat /proc/sys/net/ipv4/ip_local_port_range，可能会输出32768   60999，只有28231个端口可用。
但由于port是双字节，理论上撑死只有3万个port可以用。改大这个范围的意义不大。此时要考虑多主机来测试30k+连接了。&lt;/p&gt;

&lt;h2&gt;多线程：wait morphing&lt;/h2&gt;

&lt;p&gt;以pthread为例，在C++中使用pthread的pthread_mutex_xxx和pthread_cond_xxx，实现RAII的mutex guard类以及阻塞队列(BlockingQueue)时，会遇到wait morphing的需求。&lt;/p&gt;

&lt;p&gt;例如，一般会先实现2个类：MutexLock，和MutexLockGuard：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutexLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutexLockGuard&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MutexLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MutexLockGuard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MutexLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MutexLockGuard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是BlockingQueue：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BlockingQueue&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MutexLockGuard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_notEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// wait morphing&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 注意，lock是在退出本函数时才销毁，所以顺序是：cond signal -&amp;gt; unlock&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MutexLockGuard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m_notEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop_front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用BlockingQueue的put函数，做了几个事情：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;lock了mutex&lt;/li&gt;
&lt;li&gt;put一个对象到队列&lt;/li&gt;
&lt;li&gt;发射条件变量信号&lt;/li&gt;
&lt;li&gt;函数退出，unlock了mutex&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;MutexLockGuard对mutex lock/unlock的封装，是非常符合RAII的，只需要在函数开头声明一个栈变量，就可以保证成对的lock、unlock。&lt;/p&gt;

&lt;p&gt;然而，这个特性遇到条件变量时，就不是很好了。首先，因为unlock和notify是2个单独的操作，谁先谁后，效果并不一样。以上面的put函数为例，put完一个对象后，做2种情景假设。&lt;/p&gt;

&lt;p&gt;情景1：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;线程1先unlock了mutex&lt;/li&gt;
&lt;li&gt;线程1调用notify，唤醒等待线程2&lt;/li&gt;
&lt;li&gt;等待线程2被唤醒，因为mutex已经unlock，于是立即就lock到了mutex&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;情景2：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;线程1先调用notify，唤醒等待线程2&lt;/li&gt;
&lt;li&gt;等待线程2被唤醒，试图锁住mutex，但mutex还未解锁，于是又进入睡眠。&lt;/li&gt;
&lt;li&gt;线程1unlock了mutex&lt;/li&gt;
&lt;li&gt;线程2因为在第2步中试图锁住mutex，所以会被第3步的unlock唤醒，尝试第2次加锁，lock到了mutex&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分析可见，情景2中，线程2被唤醒了2次才锁到了mutex，有多余的性能开销。&lt;/p&gt;

&lt;p&gt;而我们的C++ RAII MutexLockGuard和BlockingQueue就是情景2.&lt;/p&gt;

&lt;p&gt;linux系统有专门针对这个问题的优化技术：wait morphing。&lt;/p&gt;

&lt;p&gt;wait morphing含义是，&lt;strong&gt;系统可以知道情景2的第2步的该次唤醒并不能锁住mutex，那么把挂在该condvar的所有等待线程，转移(morphing)到mutex的等待线程队列，并不去唤醒它们，从而免去多余的上下文切换&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当然这个优化是内核的，需要先了解你的linux有没实现这个优化。&lt;/p&gt;

&lt;h2&gt;tcp连接管理问题&lt;/h2&gt;

&lt;h3&gt;Mac下意外的RST：&lt;/h3&gt;

&lt;p&gt;出现情景：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端发送了一些数据包后，调用close或者shutdown(SHUT_WR)，此时客户端会发送FIN&lt;/li&gt;
&lt;li&gt;服务端收到FIN，如果没有待发送的数据，那么返回FIN+ACK，如果还有数据要发送，那么只返回ACK&lt;/li&gt;
&lt;li&gt;客户端收到自己发出的FIN的ACK&lt;/li&gt;
&lt;li&gt;服务端如果仅返回了对客户端FIN的ACK，然后继续发送剩下的数据，并会在最后发一个FIN&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重点&lt;/strong&gt;，如果客户端没有接收完服务端剩下的数据，就结束进程（会彻底关闭socket），那么客户端协议栈收到服务端余下的数据包时，只能返回RST，因为socket已经不见了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结论：在Mac下，客户端进程需要稍微延时关闭，例如在main最后一行加sleep(1)。&lt;/p&gt;

&lt;h2&gt;shared_ptr与多线程安全&lt;/h2&gt;

&lt;p&gt;线程安全要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;因为shared_ptr内部维护了2个指针，1个指向真实的对象，一个指向control block，所以修改shared_ptr时需要两步操作，于是就有了race condition问题。&lt;/li&gt;
&lt;li&gt;在两步操作中，shared_ptr修改control block是保证线程安全的，即ref count不会出问题，但修改对象指针则不是。&lt;/li&gt;
&lt;li&gt;多线程&lt;strong&gt;只读&lt;/strong&gt;shared_ptr仍然是安全的。&lt;/li&gt;
&lt;li&gt;多线程&lt;strong&gt;读写&lt;/strong&gt;shared_ptr不安全，其中不安全表现之一是出现&lt;strong&gt;空悬指针&lt;/strong&gt;。在这种情况下， 读写shared_ptr必须用mutex保护。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;shared_ptr细节特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;shared_ptr有ptr指针，control block里还有一个ptr指针：这是为了让shared_ptr无需虚析构函数(virtual destructor)，第一次构造shared_ptr时，就把目标对象的指针放进了control block的ptr里，从而记住类型，而shared_ptr的ptr则可以是对象类型也可以是父类型，并不影响计数降为0时的自动析构。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于特点1，于是可以实现更粗暴的多态，即任意shared_ptr&lt;T&gt;都可以转成shared_ptr&lt;void&gt;。可以用来防止对象过早析构，或者做泛型编程。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应尽量用make_shared，可以节约一次new操作，不过需要看构造函数的访问性，不一定可以替代new T。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;weak_ptr：weak_ptr可以提升为shared_ptr，提升操作lock()据说是线程安全的。&lt;/p&gt;

&lt;h2&gt;self connect 自连接问题&lt;/h2&gt;

&lt;p&gt;资料：&lt;a href=&quot;http://sgros.blogspot.jp/2013/08/tcp-client-self-connect.html&quot;&gt;http://sgros.blogspot.jp/2013/08/tcp-client-self-connect.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;就是客户端socket连接成功后，发现两端ip和port一模一样。&lt;/p&gt;

&lt;p&gt;解释：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端发起连接时，只知道对端的ip和port，以及自己的ip（localhost），但自己的port是操作系统随机分配的。&lt;/li&gt;
&lt;li&gt;每一个tcp连接都是由四元组(source IP, source port, destination IP, destination port)唯一标识的。&lt;/li&gt;
&lt;li&gt;source port可以认为是随机分配，但linux可能会先顺序地分配用户有方法自己决定port，用bind，但一般很少这样做。&lt;/li&gt;
&lt;li&gt;这个source port也叫Ephemeral port（转瞬即逝的端口），这些port是在某个范围段里选的，linux下调用cat /proc/sys/net/ipv4/ip_local_port_range可以查这个范围，会返回2个数字，例如 32768 60999&lt;/li&gt;
&lt;li&gt;self connect只出现在本机客户端连本机服务器的情景下，这是因为source IP和destination IP要一致。&lt;/li&gt;
&lt;li&gt;复现self connect的方法是，客户端connect本机ip_local_port_range里的某个端口，因为该端口并没有socket服务器在监听，所以一般情况下会返回RST。随着不断发起这些不可能成功的连接，可能会出现操作系统分配了一个和dest port一样的source port，于是self connect出现。&lt;/li&gt;
&lt;li&gt;之所以允许这种情况，是因为tcp标准里有&lt;strong&gt;simultaneous open 同时打开&lt;/strong&gt;这个概念。&lt;/li&gt;
&lt;li&gt;self connect可以成功，意味着“两端”之间完成了三次握手，进入了ESTABLISHED状态。&lt;/li&gt;
&lt;li&gt;self connect只可能发生在握手阶段，所以对于一个已经ESTABLISHED的socket，也无法利用self connect做什么坏事的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接着，剖析下当分配了和dest port一样的source port时，tcp状态机究竟是怎么进入ESTABLISHED的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先socket是CLOSED状态&lt;/li&gt;
&lt;li&gt;调用connect，发送SYN，进入SYN SENT状态&lt;/li&gt;
&lt;li&gt;这个socket马上又收到来自自己的SYN包，于是根据tcp状态机图所示，该socket状态机会走simultaneous open路径，发送SYN+ACK，并进入SYN RECEIVED状态&lt;/li&gt;
&lt;li&gt;因为第3步里面发送了ACK的，所以这个处于SYN RECEIVED状态的socket接着会收到ACK，根据状态机图，socket就进入了ESTABLISHED&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：避免self connect是最佳做法，也就是不要选择Ephemeral port作为server端的监听端口，就没事了。&lt;/p&gt;

&lt;h2&gt;wait-free V.S. lock-free&lt;/h2&gt;

&lt;p&gt;在wiki上这2个东西都是指&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;Non-blocking algorithm&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;非阻塞&lt;/h3&gt;

&lt;p&gt;一个算法被称作非阻塞的前提是：线程的失败或挂起（failure or suspension），不会导致其他线程的失败或挂起。&lt;/p&gt;

&lt;h3&gt;lock-free：&lt;/h3&gt;

&lt;p&gt;在系统级别保证该系统（即用户程序）总是有进展的（progress）。换句话说，如果该系统的所有线程运行足够长时间，能保证至少有一个线程取得进展(make progress），就是lock-free。&lt;/p&gt;

&lt;p&gt;在lock-free中，如果一个线程被挂起，其他线程依然能取得进展。lock-free优点在于CPU是可以一直繁忙的，当当前线程被挂起，CPU可以接着处理别的线程（没有核心处于空闲状态），因此增加了系统的吞吐量。但不足之处是，还是可能存在一些线程是被延迟处理的(waiting)，也就意味着这些线程的工作有延时。&lt;/p&gt;

&lt;p&gt;在lock-free系统中优化延时的办法是，建立调度器，维护一个较好的平均延时。&lt;/p&gt;

&lt;h3&gt;wait-free：&lt;/h3&gt;

&lt;p&gt;和lock-free的区别是，wait-free是在lock-free的前提上，进一步要求该系统的线程的操作在有限步骤内能保证完成。所以wait-free必然满足lock-free。&lt;/p&gt;

&lt;p&gt;就上面说的吞吐量而言，wait-free更佳，因为保证了每个线程只要有机会被CPU载入执行，就总是能在有限步内完成，没有等待延时，no waiting。例如实时交易系统就需要wait-free。&lt;/p&gt;

&lt;h3&gt;Q&amp;amp;A&lt;/h3&gt;

&lt;p&gt;Q：为什么lock-free不等于wait-free？&lt;/p&gt;

&lt;p&gt;A：假设一个情景，系统运行在n核环境，并且有n个线程在做一个长操作，其中有m个（m&amp;lt;n）线程能在有限步内完成操作，其他的n - m线程可能会操作失败(fail)并一直不断重试（retry on failure）（失败原因可能那n个线程有关），n-m线程是不能保证在有限步骤内完成操作的（也就是需要wait），所以这种系统就只是lock-free而已。而如果换作wait-free的话，每个线程都能保证操作能在有限步以内完成，并且每个线程和其他线程相互独立，没有依赖，就是无等待，即wait-free。&lt;/p&gt;

&lt;p&gt;Q：lock-free是不是就是无锁？&lt;/p&gt;

&lt;p&gt;A：确实是要求无锁。因为如果系统内有一个线程获得了锁，然后万一线程异常了没有释放锁（无法保证progress），就会导致等待该线程的其他线程永久饥饿。如果这个锁释不释放对其他线程无所谓，那这个锁也显然无意义。综上，lock-free必然要求无锁。 &lt;/p&gt;

&lt;p&gt;wait-free也是无锁？&lt;/p&gt;

&lt;p&gt;A：wait-free是比lock-free更进一步的东西，当然也得是无锁。&lt;/p&gt;

&lt;h2&gt;ABA problem&lt;/h2&gt;

&lt;h2&gt;指令重排和thread fence&lt;/h2&gt;

&lt;h3&gt;指令重排：&lt;/h3&gt;

&lt;p&gt;（参考资料：&lt;a href=&quot;http://preshing.com/20120625/memory-ordering-at-compile-time/%EF%BC%89&quot;&gt;http://preshing.com/20120625/memory-ordering-at-compile-time/）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编译器为了优化性能，可能会按和c/c++代码不一样的顺序重新排列指令。&lt;/p&gt;

&lt;p&gt;指令重排需要打开编译优化选项。&lt;/p&gt;

&lt;p&gt;指令重排保证对单线程程序没有影响。但对多线程程序来说，就惨了。&lt;/p&gt;

&lt;p&gt;例子（Linux 3.10.0-514.26.2.el7.x86_64，gcc 4.8.5）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行 gcc -S -masm=intel test.c，得到：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    mov eax, DWORD PTR B[rip]   // 取出B值并写入eax
    add eax, 1                  // eax = eax + 1
    mov DWORD PTR A[rip], eax   // 把eax写入A
    mov DWORD PTR B[rip], 0     // B = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行 gcc -S -masm=intel -O2 test.c，得到：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;    mov eax, DWORD PTR B[rip]   // 取出B值并写入eax
    mov DWORD PTR B[rip], 0     // B = 0
    add eax, 1                  // eax = eax + 1
    mov DWORD PTR A[rip], eax   // 把eax写入A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，两者区别是第四行B=0指令被提前到第二行了，即B=0发生在对A的赋值之前，和c代码是不同的顺序。&lt;/p&gt;

&lt;p&gt;单线程程序不会感知到这个区别。但考虑在多线程环境下，就容易引发一些问题。&lt;/p&gt;

&lt;p&gt;一是影响到了lock-free代码，考虑下面的代码，用了一个共享变量IsPublished来标志Value是否有数据：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IsPublished&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sendValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IsPublished&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果编译器重排了指令，使得IsPublished=1(Store)发生在Value = x(Store)之前。如果有一个线程在这2次store之间抢占了CPU，它看到IsPublished为1，但其实Value是还未赋值的，就引发了错误。&lt;/p&gt;

&lt;p&gt;如果不想受到重排指令的危害，那就得考虑使用thread fence了。&lt;/p&gt;

&lt;h3&gt;memory_order（访存次序）和thread fence&lt;/h3&gt;

&lt;p&gt;中文：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://zh.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;http://zh.cppreference.com/w/cpp/atomic/memory_order&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;英文：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/atomic/memory_order&quot;&gt;http://en.cppreference.com/w/cpp/atomic/memory_order&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;分成三大类：&lt;/p&gt;

&lt;p&gt;一. 顺序一致性模型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;memory_order_seq_cst：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;二. relax模型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;memory_order_relaxed：没有顺序限制，仅保证该操作的原子性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三. Acquire-Release模型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;memory_order_consume：&lt;/li&gt;
&lt;li&gt;memory_order_acquire：&lt;/li&gt;
&lt;li&gt;memory_order_release：&lt;/li&gt;
&lt;li&gt;memory_order_acq_rel：&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;cache line 和 cache line bouncing&lt;/h2&gt;

&lt;h2&gt;little&amp;#39;s law 律特定律&lt;/h2&gt;

&lt;h2&gt;consistent hashing 一致性哈希&lt;/h2&gt;

&lt;p&gt;参考代码（python）：&lt;a href=&quot;https://github.com/goller/hashring&quot;&gt;https://github.com/goller/hashring&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考代码（go）：&lt;a href=&quot;https://godoc.org/stathat.com/c/consistent#example-New&quot;&gt;https://godoc.org/stathat.com/c/consistent#example-New&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ioriiod0/consistent_hash&quot;&gt;https://github.com/ioriiod0/consistent_hash&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/wynet-1/</link>
        <guid isPermaLink="true">http://localhost:4000/wynet-1/</guid>
      </item>
    
  </channel>
</rss>