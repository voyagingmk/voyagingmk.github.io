<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>博主主要学习方向：图形学、机器学习，以及各种有趣的数学。联系QQ：234707482。</description>
    <link>http://www.qiujiawei.com</link>
    <atom:link href="http://www.qiujiawei.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>蒙特·卡罗(Monte Carlo)积分详解</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;蒙特·卡罗积分公式&lt;/h2&gt;

&lt;p&gt;对于一个连续函数f，它的积分公式为：&lt;/p&gt;

&lt;p&gt;\[ F = \int _{a}^{b}f(x)dx \]&lt;/p&gt;

&lt;p&gt;对应的，f的&lt;a href=&quot;https://en.wikipedia.org/wiki/Monte_Carlo_integration&quot;&gt;蒙特·卡罗积分公式&lt;/a&gt;如下：&lt;/p&gt;

&lt;p&gt;\[ F^{N} = \frac {1}{N}\sum _{i=1}^{N}\frac {f(X_{i})}{ pdf(X_{i}) } \]&lt;/p&gt;

&lt;p&gt;蒙特卡罗最关键的就是理解这条公式了。其他延伸探讨都可以暂时忽略。那么这条公式如何理解呢？首先第一点是，虽然这条公式没有积分符号\(\int  \)，但是它认被称为&lt;strong&gt;积分&lt;/strong&gt;，这是因为这公式的作用相当于在对f(x)做积分，只不过不那么“精确”，即蒙特·卡罗积分是&lt;strong&gt;对理想积分的近似&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;那么这个近似是如何完成的？很简单，核心就是两个字：&lt;strong&gt;采样(Sampling)&lt;/strong&gt;。对一个连续函数的采样方法是在该函数的定义域中随机挑N个值，并求出对应的N个\( f(X_{i}) \)，就得到了样本集合。再对这些样本集合做一些换算，就可以得到一个近似的积分了。对于蒙特·卡罗积分，&lt;strong&gt;采样样本越多，就越逼近真实的积分结果&lt;/strong&gt;，这是蒙特·卡罗积分的最核心特性。&lt;/p&gt;

&lt;p&gt;继续观察上面的公式，里面还有一个极其重要的参数：pdf(probability distribution function，概率分布函数)。pdf还有个近亲pmf，下面小节详解pdf、pmf的由来。&lt;/p&gt;

&lt;h2&gt;pdf和pmf&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;pmf(probability mass function)，指的是&lt;strong&gt;离散的&lt;/strong&gt;随机变量的概率分布函数&lt;/li&gt;
&lt;li&gt;pdf(probability distribution function)， 指的是&lt;strong&gt;连续的&lt;/strong&gt;随机变量的概率分布函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;离散的随机变量X的数学期望为：&lt;/p&gt;

&lt;p&gt;\[E[X] = \sum _{ x_{i} }pmf(x_{i})x_{i} \]&lt;/p&gt;

&lt;p&gt;连续的随机变量X的数学期望为：&lt;/p&gt;

&lt;p&gt;\[E[X] = \int ^{\infty }_{-\infty }pdf(x)xdx \]&lt;/p&gt;

&lt;p&gt;pdf和pmf名字接近，含义也是接近。pdf、pmf函数的参数都是样本值x，返回值是概率，即表示一个样本出现的概率，所有样本的出现概率之和(概率的积分)应等于1。要注意的是，pdf、pmf的存在说明有可能每个样本的出现概率都是各不相同的。&lt;/p&gt;

&lt;h3&gt;pmf&lt;/h3&gt;

&lt;p&gt;pmf的简单例子就是&lt;strong&gt;基于均匀分布的离散的随机变量X&lt;/strong&gt;，此时\( pmf(X_{i}) \)恒等于\( \frac{1}{N} \)，含义是每个随机样本的出现概率等于\( \frac{1}{样本总数} \)。&lt;/p&gt;

&lt;p&gt;通过这个例子也印证了pmf的性质：&lt;strong&gt;pmf函数的所有结果值之和等于1&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;pdf&lt;/h3&gt;

&lt;p&gt;借用&lt;a href=&quot;http://www.scratchapixel.com/&quot;&gt;http://www.scratchapixel.com/&lt;/a&gt;的一个很好的例子来说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.8/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个例子中，目标问题是求出该函数[a,b]段曲线下方的面积(最后一幅图的黑色区域)，也就是要求该函数[a,b]段的积分。基于蒙特·卡罗积分的解法，就要用上面给出的公式：&lt;/p&gt;

&lt;p&gt;\[ F^{N} = \frac {1}{N}\sum _{i=1}^{N}\frac {f(X_{i})}{ pdf(X_{i}) } \]&lt;/p&gt;

&lt;p&gt;在此图中，做了四次随机采样，得到了四个随机样本\( x_{i} \)：\( x_{1}、x_{2}、x_{3}、x_{4} \)，并且进而得到了这四个样本的\( f(x_{i}) \)值：\( f(x_{1})、f(x_{2})、f(x_{3})、f(x_{4}) \)。（原文没有提及如何得到\( f(x_{i}) \)。函数f是奇形怪状的，不太可能有表达式存在，难道是用尺子量的？暂且忽略这个事吧。）&lt;/p&gt;

&lt;p&gt;有了这4个样本后，可以针对每一个样本求一个&lt;strong&gt;近似面积值&lt;/strong&gt;，这个面积值等于\( f(x_{i})  (b - a) \)。为什么可以这样做呢？是因为每一个单独的样本是对原函数f的近似，即在每个样本中，认为\( f(x) \)恒等于\( f(x_{i}) \)，从而让原函数曲线简化成一个矩形区域，而矩形的面积显然就是长(b-a)乘以宽\( f(x_{i}) \)。&lt;/p&gt;

&lt;p&gt;得到4个&lt;strong&gt;近似面积值&lt;/strong&gt;后，再求出它们的均值(数学期望)，就完成了蒙特·卡罗积分。把上述流程汇总得到：&lt;/p&gt;

&lt;p&gt;\[ Area = \frac {1}{4}(f(x_{1})(b - a) + f(x_{2})(b - a) + f(x_{3})(b - a) + f(x_{4})(b - a)) \]&lt;/p&gt;

&lt;p&gt;\[ = \frac {1}{4}(b - a)( f(x_{1}) + f(x_{2}) + f(x_{3}) + f(x_{4}) ) \]&lt;/p&gt;

&lt;p&gt;\[ = \frac {1}{4}(b - a)\sum _{i=1}^{4}f(x_{i}) \]&lt;/p&gt;

&lt;p&gt;此时，对比下蒙特·卡罗积分公式：&lt;/p&gt;

&lt;p&gt;\[ F^{N} = \frac {1}{N}\sum _{i=1}^{N}\frac {f(X_{i})}{ pdf(X_{i}) } \]&lt;/p&gt;

&lt;p&gt;发现两个式子非常相似，对式子做下转换得到：&lt;/p&gt;

&lt;p&gt;\[ Area =  \frac {1}{4}\sum _{i=1}^{4}\frac {f(x_{i})}{\frac {1}{b - a} } \]&lt;/p&gt;

&lt;p&gt;于是可以知道\( pdf(x_{i}) \)等于：&lt;/p&gt;

&lt;p&gt;\[ pdf(x_{i}) = \frac {1}{b - a } \]&lt;/p&gt;

&lt;p&gt;这意味着，对于连续函数f，f的每个可能取值x的出现概率等于x的取值范围[a,b]的倒数\(\frac{1}{b-a}\)。&lt;/p&gt;

&lt;p&gt;在实际应用场合，随机变量X要写成F(X)，即可能需要对X做一个转换再使用。这时候要注意F(X)的pdf不等于X的pdf。&lt;/p&gt;

&lt;h2&gt;蒙特·卡罗积分的数学期望等于理想积分？&lt;/h2&gt;

&lt;p&gt;对于下面的\(F\)和\(F^{N}\)：&lt;/p&gt;

&lt;p&gt;\[ F = \int _{a}^{b}f(x)dx \]&lt;/p&gt;

&lt;p&gt;\[ F^{N} = \frac {1}{N}\sum _{i=1}^{N}\frac {f(X_{i})}{ pdf(X_{i}) } \]&lt;/p&gt;

&lt;p&gt;是否随着N变大，\(F^{N}\)会逼近\(F\)？即\(F^{N}\)的数学期望是否等于\(F\)?&lt;a href=&quot;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration&quot;&gt;Monte Carlo Methods in Practice&lt;/a&gt;文章中给出了推导过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.8/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;第二行到第三行是最不好理解的。因为这里其实用到了新的知识点：&lt;a href=&quot;https://en.wikipedia.org/wiki/Law_of_the_unconscious_statistician&quot;&gt;Law of the unconscious statistician&lt;/a&gt;(简称：LOTUS)。LOTUS的应用情景是，已知随机变量X的概率分布，但不知道f(x)的分布，此时用LOTUS公式能计算出函数f(x)的数学期望。LOTUS的公式如下：&lt;/p&gt;

&lt;p&gt;f(x)是离散函数时:&lt;/p&gt;

&lt;p&gt;\[ E[f(X)] = \sum _{x_{i}}f(x_{i})pmf(x_{i}) \]&lt;/p&gt;

&lt;p&gt;f(x)是连续函数时:&lt;/p&gt;

&lt;p&gt;\[ E[f(X)] = \int _{-\infty }^{\infty}f(x)pdf(x)dx \]&lt;/p&gt;

&lt;p&gt;(建议对比第二小节开头的两条公式来理解)&lt;/p&gt;

&lt;p&gt;有了LOTUS公式，再来看第二行到第三行的转换，就好理解了：&lt;/p&gt;

&lt;p&gt;\[ E[ \frac {f(X_{i})}{pdf(X_{i})} ] = E[ \frac {f(x)}{pdf(x)} ] =\int _{-\infty }^{\infty}\frac {f(x)}{pdf(x)}pdf(x)dx \]&lt;/p&gt;

&lt;p&gt;\[ =\int _{-\infty }^{\infty}f(x)dx \]&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration&quot;&gt;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations/expected-value-of-the-function-of-a-random-variable&quot;&gt;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations/expected-value-of-the-function-of-a-random-variable&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/monte-carlo/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/monte-carlo/</guid>
      </item>
    
      <item>
        <title>渲染基础理论的介绍(2)——工程实现</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;从SPD到XYZ&lt;/h2&gt;

&lt;p&gt;在上一篇文章中，已经提到了SPD需要转换成XYZ值，才能进一步转换成RGB从而变成位图。这里面的工程实现还是需要学习一下的。&lt;/p&gt;

&lt;p&gt;首先，先回顾下三色XYZ三色刺激值(tristimulus vlaues)的图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/14.png&quot; alt=&quot;14.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个图怎么用到程序里呢？方法就是打表，图中有3个函数\( \hat {x}(\lambda ) 、 \hat {y}(\lambda ) 、 \hat {z}(\lambda )\)，可以建立4个数组来表示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//切片数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;471&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//存了λ值的数组，范围是从360到830，即可见光波段&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;360&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;361&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;362&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;363&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;364&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;365&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;366&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;367&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;368&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;369&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;370&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;371&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;372&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;373&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;374&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;······&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;825&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;826&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;827&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;828&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;829&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;830&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//下面三个数组的元素的取值范围是[0.0, 2.0]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//hat(x)函数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.0001299000f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.0001458470f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.0001638021f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.0001840037f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;······&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.000001439440f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.000001341977f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.000001251141f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//hat(y)函数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.000003917000f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.000004393581f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.000004929604f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.000005532136f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;······&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.0000005198080f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0000004846123f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0000004518100f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//hat(z)函数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.0006061000f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0006808792f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0007651456f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0008600124f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;······&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为\( \hat {x}(\lambda ) 、 \hat {y}(\lambda ) 、 \hat {z}(\lambda )\)是常量（和万有引力常数一样的常数）,所以上面的4个数组只需要制作一次就行了，然后可以把它们硬编码到你的程序里(pbrt就是这么干的)。&lt;/p&gt;

&lt;h2&gt;SPD数据源&lt;/h2&gt;

&lt;p&gt;SPD数据源如何获得暂且不提，这里关注的是SPD数据源的存放格式：它应该是一个序列，序列中的元素是一个tuple，tuple里存了2个元素，一是λ值，二是v值，代表眼睛-光谱敏感度(spectral sensitivity)，后者一般是一个单位化的值(0.0到1.0之间):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//n由数据提供方给出&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;···&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;从SPD转换到XYZ到RGB&lt;/h2&gt;

&lt;p&gt;先贴上pbrt的实现代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//pbrt-v2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RGBSpectrum&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FromSampled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//part I&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InterpolateSpectrumSamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                               &lt;span class=&quot;n&quot;&gt;CIE_lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//part II&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//part III&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FromXYZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数的参数分别是SPD曲线的λ值、v值、λ-v对数(即采样次数)，这3者确定了一条离散的SPD曲线；该函数的返回值就是一个RGB值。&lt;/p&gt;

&lt;p&gt;可以把这个函数分成3部分来阅读理解。&lt;/p&gt;

&lt;p&gt;part I是其中最关键的，这个for循环计算出了xyz各个分量的值，循环次数和nCIESamples一致，每次循环需要执行一个InterpolateSpectrumSamples函数得到一个val值(这个val是波长!)，再把这个val值分别和CIE_X、CIE_Y、CIE_Z相乘，并累加到xyz数组里。这个步骤其实就是下面的公式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/15.png&quot; alt=&quot;15.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;的离散版本:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/16.png&quot; alt=&quot;16.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;InterpolateSpectrumSamples做的事情也不复杂。因为SPD的n值和nCIESamples不一定一样，也就是说不可能SPD和XYZ表的切片刚好一致，所以必然要做线性插值，从而把SPD切片数据转换成可用数据。具体转换过程看pbrt源码即可。&lt;/p&gt;

&lt;p&gt;part II是把xyz规范化(Normalize)的过程。part I 加上 part II总的公式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/24.png&quot; alt=&quot;24.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;part III做的事情就是把XYZ转换成RGB，公式在上一篇文章已经给出了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/17.png&quot; alt=&quot;17.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;对应的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;XYZToRGB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.240479f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.537150f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.498535f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.969256f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.875991f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.041556f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.055648f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.204043f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.057311f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，这里得到的RGB是线性空间的RGB，并没有做gamma校正。gamma校正的公式如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/21.png&quot; alt=&quot;21.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;gamma校正应放在【线性空间】到【非线性空间】的转换时做，也就是最后输出时。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//gamma校正&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GammaCorrect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0031308f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12.92f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.055f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.4f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.055f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;//Clamp函数&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;//RGB_linear转成sRGB&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GammaCorrect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GammaCorrect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GammaCorrect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;pbrt源码&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/rendering-equation2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/rendering-equation2/</guid>
      </item>
    
      <item>
        <title>记录c++一些神奇的报错</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;Heap Corruption Deteched&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/10.png&quot; alt=&quot;10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个报错发生在main函数返回时。出错原因是在堆数组的赋值上。&lt;/p&gt;

&lt;p&gt;先是初始化一个数组指针：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后循环赋值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，这个循环溢出了，这个循环对array[100]进行了赋值，即数组的第101个元素，而数组长度只有100。&lt;/p&gt;

&lt;p&gt;然后再执行delete[] array就会出上面截图那个报错了。&lt;/p&gt;

&lt;p&gt;修了那个循环次数就没事了，就酱。&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/c++-error-solved/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/c++-error-solved/</guid>
      </item>
    
      <item>
        <title>渲染基础理论的介绍(1)</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;基础概念&lt;/h1&gt;

&lt;h2&gt;辐射度学 Radiometry&lt;/h2&gt;

&lt;p&gt;辐射度学是指测量电磁辐射(包括可见光)的一系列技术，它是和观察者无关的。而近似的光度学(photometric)，是观察者相关的。这里我所说的观察者无关，是指测量值和人眼并无关系，是绝对值。&lt;/p&gt;

&lt;p&gt;基于辐射度学来做渲染，需要了解下面这些东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;光谱 Spectrum&lt;/li&gt;
&lt;li&gt;光谱功率分布(SPD, spectral power distribution)&lt;/li&gt;
&lt;li&gt;XYZ 和 RGB 两种CIE颜色系统以及它们之间、它们和SPD之间的转换&lt;/li&gt;
&lt;li&gt;辐射通量(Flux)&lt;/li&gt;
&lt;li&gt;立体角(Solid Angle)&lt;/li&gt;
&lt;li&gt;辐射密度(Irradiance)&lt;/li&gt;
&lt;li&gt;辐射亮度(Radiance)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;光谱 Spectrum&lt;/h2&gt;

&lt;p&gt;现实中大部分光源（非直接光源也算），发射出的光都是复合光，即是由不同波长的色光混合而成的。 光谱就是指所有光波的&lt;strong&gt;分布&lt;/strong&gt;。光谱图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/11.png&quot; alt=&quot;11.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;其中波长在 390 nm 到700 nm之间的光波称为可见光。&lt;/p&gt;

&lt;h2&gt;光谱功率分布&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectral_power_distribution&quot;&gt;spectral power distribution&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;光谱功率分布描述的是这样一件事情：对于一个直接或间接光源物体，它发射出的复合光中各个波长的色光分别有多少能量，或者说，这个光源的能量是如何分布到各个波长的光波的？&lt;/p&gt;

&lt;p&gt;譬如，水银灯的光主成分是波长为404.7, 407.8, 435.8, 546.1, 577.0, 579.0纳米的光波（见下图）。这意味着能量分布非常不平衡，主要集中在这几个波长上了，相当于离散了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/12.png&quot; alt=&quot;12.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图就是水银灯的SPD曲线了。&lt;/p&gt;

&lt;p&gt;而白炽灯的SPD曲线是这样子的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/13.png&quot; alt=&quot;13.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;注意上面两个图中，横轴是指波长，纵轴是指每单位纳米(10纳米一个单位)的波长的功率（能量）。&lt;/p&gt;

&lt;p&gt;SPD曲线都是用&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectroradiometer&quot;&gt;Spectroradiometers&lt;/a&gt; 这种专门仪器测量的。&lt;/p&gt;

&lt;p&gt;SPD一般用符号P(λ)表示。&lt;/p&gt;

&lt;h2&gt;XYZ 三色刺激值(tristimulus vlaues)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/14.png&quot; alt=&quot;14.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(CIE标准观察者颜色匹配函数)(The CIE standard observer color matching functions)&lt;/p&gt;

&lt;p&gt;当看到CIE standard observer字眼时，其实指的就是上面这个图。这个图是通过测量获得的，好处是这个图相当于一个数据表，当需要把SPD曲线转换成XYZ三刺激值时，就可以用这个图做，坏处是它不是数学描述出来的，那么应用起来就有一定限制性。&lt;/p&gt;

&lt;p&gt;那么SPD如何转换到XYZ呢？公式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/15.png&quot; alt=&quot;15.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这里面用到了积分，但因为匹配函数是非数学描述的（上面的图的3条曲线），所以这个公式不可用，然而我们可以另辟蹊径，用采样和线性叠加的方法计算XYZ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/16.png&quot; alt=&quot;16.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这里的下标i代表第几个刻度的采样。采样间隔(spacing)一般是1到20纳米，采样空间(span)是整个可见光波段（这个波段的具体范围取决于实际需求和SPD曲线）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.brucelindbloom.com/index.html?Eqn_Spect_to_XYZ.html&quot;&gt;通过SPD计算XYZ：Computing XYZ From Spectral Data&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;XYZ和RGB之间的互相转换&lt;/h2&gt;

&lt;h3&gt;XYZ到RGB&lt;/h3&gt;

&lt;p&gt;公式是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/17.png&quot; alt=&quot;17.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(此矩阵只适用于 &lt;a href=&quot;https://en.wikipedia.org/wiki/SRGB&quot;&gt;sRGB&lt;/a&gt; 定义中的RGB)&lt;/p&gt;

&lt;p&gt;(对于右边的输入值XYZ，也是有要求的，这是因为左边的\(RGB_{linear} \)的取值范围是[0,1]，所以右边的XYZ也需要做规范化。在我的下一篇文章中会介绍这部分。)&lt;/p&gt;

&lt;p&gt;得到的\(RGB_{linear} \)是线性空间的，有什么意义呢？因为一般渲染器都是在线性空间下进行光照计算的，所以这个\(RGB_{linear} \)可直接用到光照等计算中。但是当要把最终的渲染结果输出时，例如写入到位图文件或显示到屏幕上，就需要对每个像素的\(RGB_{linear} \)做gamma校正，校正成sRGB，公式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/21.png&quot; alt=&quot;21.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;校正后的sRGB是单位化的，各个分量的取值范围是[0.0, 1.0]，输出时需要乘以255并取整。&lt;/p&gt;

&lt;h3&gt;RGB到XYZ&lt;/h3&gt;

&lt;p&gt;当输入的RGB是sRGB时，需要做逆gamma校正，公式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/22.png&quot; alt=&quot;22.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;得到线性空间的RGB值后，就可以用下面的公式转换到XYZ空间：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/23.png&quot; alt=&quot;23.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;辐射通量(Flux)&lt;/h2&gt;

&lt;p&gt;辐射通量(Radiant Flux)，指的是单位时间到达一块平面(或一个局部空间区域)的能量总和。单位是焦耳每秒(joules/second,，J/s)，或瓦特(watts，W)。符号是\(\Phi \)。&lt;/p&gt;

&lt;p&gt;一个点光源发射出去的能量大小可以用Flux来描述。其中要注意的是，Flux描述的是单位时间的能量，那么对于点光源来说，Flux只和光源的强弱有关，所以下图的2个圆圈的Flux值是一样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;辐射密度(Irradiance)  (或称辐射照度(Radiant Exitence))&lt;/h2&gt;

&lt;p&gt;辐射密度也叫辐射照度。定义了辐射通量后，就可以定义辐射照度了，辐射照度指的是单位面积&lt;strong&gt;进入&lt;/strong&gt;的辐射通量，单位是\(W/m^{2}\)。根据这个定义用符号E表示。&lt;/p&gt;

&lt;p&gt;辐射照度和辐射密度是近似的东西，辐射照度指的是单位面积&lt;strong&gt;离开&lt;/strong&gt;的辐射通量，单位也是\(W/m^{2}\)。用符号M表示。&lt;/p&gt;

&lt;p&gt;以上面的点光源来分析，可以知道上图中内圆圈的辐射照度比外圆圈的辐射照度大，这是因为内圆圈的面积更小而点光源的Flux值恒定，所以内圆圈的E值就大。&lt;/p&gt;

&lt;p&gt;用公式表示：&lt;/p&gt;

&lt;p&gt;\[ E = \frac { 点光源辐射通量 }{ 球的表面积 } =  \frac {\Phi}{4\pi r^{2} } \]&lt;/p&gt;

&lt;p&gt;可见，W恒定，半径r越小，那么辐射照度E越大。&lt;/p&gt;

&lt;p&gt;当假设光源在无限远处时，可把光源认为是一块平面（这种光源叫方向光）。此时，光源平面与被照射平面存在2种情形：光源平面与被照射平面平行（下图中的A）、光源平面与被照射平面不平行（下图中的B）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图中的平面附近的A指的是面积Area)&lt;/p&gt;

&lt;p&gt;当光源平面与被照射平面平行时，有：&lt;/p&gt;

&lt;p&gt;\[ E_{1} = \frac {\Phi}{ A } \]&lt;/p&gt;

&lt;p&gt;当光源平面与被照射平面不平行时，需要根据平面的法向量和光线方向的夹角θ，先求出\( A^{&amp;#39;} \)：&lt;/p&gt;

&lt;p&gt;\[ cos\theta = \frac { A }{ A^{&amp;#39;} }  \]&lt;/p&gt;

&lt;p&gt;\[ A^{&amp;#39;}= \frac { A }{ cos\theta }  \]&lt;/p&gt;

&lt;p&gt;于是得到：&lt;/p&gt;

&lt;p&gt;\[ E_{2} = \frac {\Phi}{ A^{&amp;#39;} } =  \frac {\Phi}{ \frac { A }{ cos\theta }  } =  \frac {  \Phi  cos\theta  }{ A } \]&lt;/p&gt;

&lt;p&gt;也可以记为&lt;/p&gt;

&lt;p&gt;\[ E = \frac { \Phi  cos\theta  }{ A^{\perp } }  \]&lt;/p&gt;

&lt;p&gt;( \(  A^{\perp } \) 指A&amp;#39;在光线的方向的正交平面上的投影)&lt;/p&gt;

&lt;p&gt;微分形式：&lt;/p&gt;

&lt;p&gt;\[ dE = \frac {  d\Phi  cos\theta  }{ dA^{\perp }  } \]&lt;/p&gt;

&lt;p&gt;根据这个式子，可以想到，当θ逼近0度时，cosθ等于1，法向量和光线方向平行（上图中的A）；当θ逼近90度时，cosθ等于0，辐射照度E为0（光线垂直于法向量了）。&lt;/p&gt;

&lt;h2&gt;立体角(Solid Angle)&lt;/h2&gt;

&lt;p&gt;立体角的介绍请访问：&lt;a href=&quot;http://www.qiujiawei.com/solid-angle/&quot;&gt;立体角(Solid Angle)详解&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;辐射亮度(Radiance)&lt;/h2&gt;

&lt;p&gt;辐射亮度是指辐射通量与单位面积(注意，是与光线方向正交的那块)单位立体角的比值。符号为L。定义式如下：&lt;/p&gt;

&lt;p&gt;\[ L = \frac { d\Phi }{ d\omega dA^{\perp } } = \frac { d\Phi }{ d\omega dA cos\theta  } \]&lt;/p&gt;

&lt;p&gt;或：&lt;/p&gt;

&lt;p&gt;\[ L = \frac { \Phi }{ \omega A^{\perp } } \]&lt;/p&gt;

&lt;p&gt;物理含义如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/7.png&quot; alt=&quot;7.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;辐射密度E和辐射亮度L的关系是&amp;quot;总体&amp;quot;和&amp;quot;个体&amp;quot;的区别，可以对比下两者的公式来理解：&lt;/p&gt;

&lt;p&gt;\[ E = \frac { \Phi }{ A }  \]&lt;/p&gt;

&lt;p&gt;\[ L = \frac { \Phi }{ \omega A^{\perp } } \]&lt;/p&gt;

&lt;p&gt;E是指进入目标区域的总辐射通量与目标区域总面积的比值；而L是指进入目标区域的总辐射通量与目标区域总面积、&lt;strong&gt;总的入射立体角&lt;/strong&gt;的比值，也就是说L是比E多除了立体角。直观图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/19.png&quot; alt=&quot;19.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;也就是说其实E和L可以认为是同一个东西，只是L描述的是E的局部。用一句话记住两者的区别：有特定方向时是L，无特定方向时是E。这个区别相当重要，因为它体现在了渲染方程中。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意：在计算机图形学中，辐射亮度比起上面其他物理量，都重要地得多。&lt;/p&gt;

&lt;p&gt;如果要求平面上某点p的某方向\(\omega \)的辐射亮度L(Radiance)，可用下面的符号表示：&lt;/p&gt;

&lt;p&gt;\[ L(p,\omega ) \]&lt;/p&gt;

&lt;p&gt;其中，\(\omega \)的方向需要注意，因为它是一个立体角，立体角的圆心是p，\(\omega \)的朝向必然是从圆心p往外（向量起点是p）。&lt;/p&gt;

&lt;p&gt;实际上，需要区分成入射(input)和出射(output)2种辐射亮度L，用下面2个符号表示：&lt;/p&gt;

&lt;p&gt;\[ L_{i}(p,\omega ) \]&lt;/p&gt;

&lt;p&gt;\[ L_{o}(p,\omega ) \]&lt;/p&gt;

&lt;p&gt;且在现实世界中有：&lt;/p&gt;

&lt;p&gt;\[ L_{i}(p,\omega ) \neq L_{o}(p,\omega ) \]&lt;/p&gt;

&lt;p&gt;还有，上面的这个p不能简单认为真的是一个无体积的点，它也可能是一个无限小的平面块，即它是一个有面积A、有法向量n的“点”。对于这样一个“点”，我们可以求出它的上半球(沿着n的方向)的辐射密度值\( E(p, n) \)：&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = \int _{\Omega } L_{i} (p,\omega ) |cos\theta |d\omega \]&lt;/p&gt;

&lt;p&gt;分析下这个式子的由来。首先搬出上文给出的L和E的公式：&lt;/p&gt;

&lt;p&gt;\[ L = \frac { d\Phi }{ d\omega dA^{\perp } } \]&lt;/p&gt;

&lt;p&gt;\[ dE = \frac {  d\Phi  cos\theta  }{ dA^{\perp }  } \]&lt;/p&gt;

&lt;p&gt;所以有：&lt;/p&gt;

&lt;p&gt;\[ d\Phi = L d\omega dA^{\perp } \]&lt;/p&gt;

&lt;p&gt;\[ 
dE = \frac {  d\Phi  cos\theta  }{ dA^{\perp }  }
= \frac {  L d\omega dA^{\perp }  cos\theta  }{ dA^{\perp }  }&lt;br&gt;
= L d\omega cos\theta \]&lt;/p&gt;

&lt;p&gt;对上式做整个半球的积分，就得到了：&lt;/p&gt;

&lt;p&gt;\[ E = \int _{\Omega }L|cos\theta |d\omega \]&lt;/p&gt;

&lt;p&gt;也就是：&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = \int _{\Omega } L_{i} (p,\omega ) |cos\theta |d\omega \]&lt;/p&gt;

&lt;p&gt;其中的\( cos\theta \)加绝对值是因为我们求的是半球的积分，立体角\(\omega \)和法向量的夹角必然是锐角，锐角的余弦值必然大于等于0。&lt;/p&gt;

&lt;p&gt;如果把式子中的\(d\omega \)替换成球形角(Sphere Angle)，则得到：&lt;/p&gt;

&lt;p&gt;\[ d\omega = sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = \int _{\Omega } L_{i} (p,\omega ) |cos\theta |sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;这个式子是不对的，因为积分那里用了立体角，需要将其转换成对\(\theta 和 \phi \)的积分。因为这里积分的是半球，那么\(\theta \)的取值范围是\( [0,\frac {π}{2}] \)、\(\phi \)的取值范围是\( [0,2π] \)：&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = \int _{0 }^{ 2π } \int _{0 }^{ \frac {π}{2} }  L_{i} (p,\theta ,\phi ) cos\theta sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;（因为已经明确限定了\(\theta \)的取值范围，所以\( cos\theta \)必然大于等于0，可去掉绝对值符号）&lt;/p&gt;

&lt;p&gt;如果\(L_{i} (p,\theta ,\phi ) \)是一个常量值，那么就意味着任意方向的Radiance都是相等的，于是上式可以求出积分：&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = L_{i} (p,\theta ,\phi ) \int _{0 }^{ 2π } \int _{0 }^{ \frac {π}{2} }  cos\theta sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) \int _{0 }^{ 2π } (\frac {1}{2}sin^{2}\theta )\rvert ^{\frac {π}{2}}_{0} d\phi \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) \int _{0 }^{ 2π } (\frac {1}{2}sin^{2}\frac {π}{2} - \frac {1}{2}sin^{2}0  ) d\phi \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) \int _{0 }^{ 2π } \frac {1}{2} d\phi \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) \frac {1}{2}( 2π - 0) \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) π  \]&lt;/p&gt;

&lt;p&gt;注意，这个简化公式在渲染中很重要。因为当计算一个点到摄像机的Radiance，第一步就是先求这个点的入射E（求E的过程可以很复杂），当求出E之后，就可以认为这个点对任意方向的出射Radiance是均等的，也就是\( L = \frac {E}{\pi } \)。&lt;/p&gt;

&lt;h1&gt;渲染方程 Rendering Equation&lt;/h1&gt;

&lt;p&gt;把wiki的渲染方程贴进来：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/18.png&quot; alt=&quot;18.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Rendering_equation&quot;&gt;https://en.wikipedia.org/wiki/Rendering_equation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;各个组成元素的解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;λ&lt;/strong&gt; 指代波长为λ的光&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;t&lt;/strong&gt; 某一时间点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;x&lt;/strong&gt; 指空间上的某个点，也即被渲染的点(微分平面) (其实应该写成p吧)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;n&lt;/strong&gt; 被渲染的点(平面)的法向量，可以人为指定也可以根据一定规则自动生成&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( \omega _{o} \)  出射光线的方向（是一个立体角)，起点在x(被渲染的点)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( \omega _{i} \)  入射光线的反方向（是一个立体角)，起点也在x，所以才叫反方向&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( L_{o}(x, \omega _{o}, λ, t) \)   在t时刻、从x点往\( \omega _{o} \)方向的光(λ)的总辐射亮度(Radiance)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( L_{e}(x, \omega _{o}, λ, t) \)  指x点自身发射出的辐射亮度(Radiance)，其他参数含义同\( L_{o}(x, \omega _{o}, λ, t) \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\(\Omega \)是以x为圆心的单位半球，半球的朝向和法向量&lt;strong&gt;n&lt;/strong&gt;一致&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\(\int _{ \Omega } \cdots d\omega _{i} \) 指对这个半球做积分&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\(f_{r}(x, \omega _{i}, \omega _{o}, λ, t) \) BRDF函数，函数的返回值是一个比值(ratio scalar)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( L_{i}(x, \omega _{i}, λ, t) \)  在t时刻、沿着\( \omega _{i} \)方向进入x点的光(λ)的辐射亮度(Radiance)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\(\omega _{i} \cdot n \) 是一个衰减比值(一般是0到1)，指入射光的方向和法向量的夹角\( \theta _{i} \)，这个夹角导致产生的衰减。原因请参考上面的&lt;strong&gt;辐射通量&lt;/strong&gt;小节。这个参数也可以写成\( \cos \theta _{i} \)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的可能太教科书了，下面展示一个简化的渲染方程：&lt;/p&gt;

&lt;p&gt;\[ L_{o}(p, \omega _{o}) = L_{e}(p, \omega _{o})  + \int _{\Omega }f(p, \omega _{o}, \omega _{i}) L_{i}(p, \omega _{i}) |cos \theta _{i}|d\omega _{i} \]&lt;/p&gt;

&lt;p&gt;能简化成这个式子的原因是，在做渲染器的时候，本来就是把t值固定的，即做动画渲染的话，也是把动画离散成一帧帧来渲染，对每一帧来说t值是常量值；而另外的λ值蕴含在颜色空间(XYZ RGB)中。&lt;/p&gt;

&lt;p&gt;还有一个要说清楚的，就是这个方程3个部分的含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/20.png&quot; alt=&quot;20.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;为什么右边那坨是E？上文已经说过了:&amp;quot;有特定方向时是L，无特定方向时是E&amp;quot;,因为它是对L做整个半球的积分（注意，积分的是入射角度），也就是无特定方向，所以它是E。而另外2个分部都是指定了朝向了\(\omega _{o} \)（出射方向）的，所以是L。&lt;/p&gt;

&lt;p&gt;整个渲染方程可以说就是在求出射方向到底有多少辐射通量（为什么不是L？因为被渲染区域的面积一般都限定为单位面积，即等于1，所以L相当于\(\Phi \) )，辐射通量一旦确定就可以知道这个被渲染区域的颜色。&lt;/p&gt;

&lt;p&gt;基于光线追踪的离线渲染中，是可以直接基于上面的渲染方程去做工程实现的。（相比而言，实时渲染更多的是用各种trick技术来近似渲染方程。）&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/candycat1992/article/details/46228771&quot;&gt;http://blog.csdn.net/candycat1992/article/details/46228771&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.poynton.com/GammaFAQ.html&quot;&gt;http://www.poynton.com/GammaFAQ.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.poynton.com/PDFs/GammaFAQ.pdf&quot;&gt;http://www.poynton.com/PDFs/GammaFAQ.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.brucelindbloom.com/index.html?Equations.html&quot;&gt;Useful Color Equations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html&quot;&gt;RGB/XYZ Matrices&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/rendering-equation/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/rendering-equation/</guid>
      </item>
    
      <item>
        <title>立体角(Solid Angle)详解</title>
        <description>&lt;p&gt;理解立体角之前要先理解圆心角。在二维平面上，一个圆的圆弧的微分记为ds(也叫弧微分)，半径为r，则圆心角指的是弧微分与半径的比值:&lt;/p&gt;

&lt;p&gt;\[ d\theta = \frac {ds}{r} \]&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;对这个式子做0到2π的积分的话，显然右边的分子变成了圆周长2πr，圆心角为\( \frac { 2πr }{r} = 2π \)。&lt;/p&gt;

&lt;p&gt;立体角与圆心角非常类似。立体角的ds的含义是球面上的面积微分(下文用dA表示)，而分母需要变成半径r的平方（1&lt;a href=&quot;https://en.wikipedia.org/wiki/Steradian&quot;&gt;球面度&lt;/a&gt;所对应的立体角所对应的球面表面积为\(r^{2}\) ）：&lt;/p&gt;

&lt;p&gt;\[ d\omega = \frac {dA}{r^{2}} \]&lt;/p&gt;

&lt;p&gt;因为球体表面积等于\( 4πr^{2} \)，所以上面的式子积分到整个球体的话，立体角等于4π。&lt;/p&gt;

&lt;p&gt;再换个角度分析。在宏观上看，立体角的定义是：&lt;/p&gt;

&lt;p&gt;\[ \Omega = \frac {A}{r^{2} } sr \]&lt;/p&gt;

&lt;p&gt;其中，sr是单位，叫做球面度；A是这个立体角所对应的球表面积，A被叫做&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Spherical_cap&quot;&gt;spherical cap&lt;/a&gt;&lt;/strong&gt;(球帽?)。&lt;/p&gt;

&lt;p&gt;spherical cap的几何表示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(from wiki)&lt;/p&gt;

&lt;p&gt;spherical cap面积等于\(2\pi rh \)，所以上式可变成：&lt;/p&gt;

&lt;p&gt;\[ \Omega = \frac {2\pi rh}{r^{2} } sr \]&lt;/p&gt;

&lt;p&gt;当h等于r时，得到：&lt;/p&gt;

&lt;p&gt;\[ \Omega = \frac {2\pi rr}{r^{2} } sr = 2\pi \ sr \]&lt;/p&gt;

&lt;p&gt;此时得到的是半球的立体角，那么就可以知道整个球的立体角为\(4\pi  \)，和上述结论一致。&lt;/p&gt;

&lt;h2&gt;立体角(Solid Angle)转换到球形角(Sphere Angle)&lt;/h2&gt;

&lt;p&gt;Spherical Coordinates坐标系下的单位球，可用2个&lt;strong&gt;弧度变量&lt;/strong&gt;来定位球面上一个点：\(\theta 和 \phi \)。和三维坐标系的对应关系如下：&lt;/p&gt;

&lt;p&gt;\[ x = sin\theta cos\phi \]&lt;/p&gt;

&lt;p&gt;\[ y = sin\theta sin\phi \]&lt;/p&gt;

&lt;p&gt;\[ x = cos\theta \]&lt;/p&gt;

&lt;p&gt;简单验证下。把上面3个式子代入单位球公式:\(x^{2}+y^{2}+z^{2} = 1\)，可得：&lt;/p&gt;

&lt;p&gt;\[ (sin\theta cos\phi)^{2} + (sin\theta sin\phi )^{2} + cos^{2}\theta = 1 \]&lt;/p&gt;

&lt;p&gt;\[ sin^{2}\theta (cos^{2}\phi  + sin^{2}\phi ) + cos^{2}\theta = 1 \]&lt;/p&gt;

&lt;p&gt;\[ sin^{2}\theta  + cos^{2}\theta = 1 \]&lt;/p&gt;

&lt;p&gt;那么，立体角\(\omega \)和\(\theta 、 \phi \)是什么关系呢？先给出答案：&lt;/p&gt;

&lt;p&gt;\[ d\omega = sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;似乎有点莫名其妙，这里我详细解释吧。首先先搞懂\(  d\theta 和  d\phi \)的几何意义。&lt;/p&gt;

&lt;p&gt;弧度变量的单位是&lt;strong&gt;弧度&lt;/strong&gt;，1弧度的定义是：弧长s等于半径r的弧对应的圆心角为1弧度。因此可以知道整个圆的弧度为周长\(2\pi r\)除以半径\(r\)等于\(2\pi \)。&lt;/p&gt;

&lt;p&gt;因此，如果已知弧度和半径，就可以求出弧长s，那么上面的\(\theta 、 \phi \)对应的弧长就是：&lt;/p&gt;

&lt;p&gt;\[ s_{ \theta } = r_{ \theta }\theta  \]&lt;/p&gt;

&lt;p&gt;\[ s_{ \phi } = r_{ \phi }\phi  \]&lt;/p&gt;

&lt;p&gt;微分形式：&lt;/p&gt;

&lt;p&gt;\[ ds_{ \theta } = r_{ \theta } d\theta  \]&lt;/p&gt;

&lt;p&gt;\[ ds_{ \phi } = r_{ \phi } d\phi  \]&lt;/p&gt;

&lt;p&gt;\( r_{ \theta }、r_{ \phi }\)的值并不是相等的，需要接着分析。&lt;/p&gt;

&lt;p&gt;在球坐标系下，\(\theta 、 \phi \)指的是这2个角：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/9.png&quot; alt=&quot;9.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;\(\theta\)是目标点p与z轴的夹角；而\(\phi\)是目标点p在xy平面上的投影与y轴的夹角。&lt;/p&gt;

&lt;p&gt;从图可知，\( r_{ \theta } \)与圆的半径r相等；而\( r_{ \phi } \)是小于等于r的(注意看上面的小圆)，且有：&lt;/p&gt;

&lt;p&gt;\[ sin\theta = \frac { r_{ \phi } } {r_{ \theta } }\]&lt;/p&gt;

&lt;p&gt;当球是单位球时，球的半径为1，所以有：&lt;/p&gt;

&lt;p&gt;\[ r_{ \theta } = 1\]&lt;/p&gt;

&lt;p&gt;\[ r_{ \phi } = sin\theta  r_{ \theta } = sin\theta \]&lt;/p&gt;

&lt;p&gt;又因为在微观下，立体角对应的曲面(或者叫球帽)面积可以当做一个小矩形看，这个小矩形dA的面积等于2个弧长\( ds_{ \theta } \)和\( ds_{ \phi } \)的积：&lt;/p&gt;

&lt;p&gt;\[ dA = ds_{ \theta }ds_{ \phi } = r_{ \theta } r_{ \phi }d\theta d\phi = sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;再因为立体角的微分其实也就是这个小矩形的面积，那么就有：&lt;/p&gt;

&lt;p&gt;\[ d\omega = dA = sin\theta d\theta d\phi \]&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/solid-angle/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/solid-angle/</guid>
      </item>
    
      <item>
        <title>直线与平面相交算法</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;平面的方程&lt;/h1&gt;

&lt;p&gt;设位于平面P上的某个点为\( \vec p_{0} \)(已知量)，平面P的法向量为\( \vec n \)(已知量)，该平面P的任意一点设为\( \vec p \)，则平面P的方程为：&lt;/p&gt;

&lt;p&gt;\[ (\vec p -  \vec p_{0} )\cdot \vec n = 0 \]&lt;/p&gt;

&lt;p&gt;使得这个方程成立的原理是，位于平面P上的任意一个向量\( (\vec p -  \vec p_{0} ) \)，必然和平面P的法向量垂直，互相垂直的向量的点积必然为0。&lt;/p&gt;

&lt;h1&gt;直线的方程&lt;/h1&gt;

&lt;p&gt;设位于直线上的某个点为\( \vec o \)(已知量)，直线的方向向量为\( \vec d \)(已知量)，直线上的任意一点为\( \vec p \)，则直线的方程为:&lt;/p&gt;

&lt;p&gt;\[ \vec p = \vec o + t\vec d, t\in R \]&lt;/p&gt;

&lt;p&gt;注意，式子右边的t是一个Scalar（一个实数），这个t决定了\(\vec p\)的位置。&lt;/p&gt;

&lt;h1&gt;直线与平面的相交&lt;/h1&gt;

&lt;p&gt;直线与平面的相交，必然是一个点。将上面的直线方程代入平面方程，得到：&lt;/p&gt;

&lt;p&gt;\[ ( \vec o + t\vec d -  \vec p_{0} )\cdot \vec n = 0  \]&lt;/p&gt;

&lt;p&gt;其中，\( \vec o 、\vec d 、\vec p_{0} 、\vec n \)都是已知量，只有t是未知量，&lt;strong&gt;所以求直线与平面的相交点等同于求t的值&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;化简这个式子，得到：&lt;/p&gt;

&lt;p&gt;\[ t\vec d \cdot \vec n + (\vec o -  \vec p_{0} )\cdot \vec n = 0  \]&lt;/p&gt;

&lt;p&gt;\[ t\vec d \cdot \vec n = ( \vec p_{0} - \vec o )\cdot \vec n  \]&lt;/p&gt;

&lt;p&gt;\[ t = \frac { ( \vec p_{0} - \vec o )\cdot \vec n }{ \vec d \cdot \vec n }  \]&lt;/p&gt;

&lt;h1&gt;实例 (基于三维坐标系)&lt;/h1&gt;

&lt;p&gt;本小节的实例是结合实际需求设计的。在3D图形学中，直线与平面相交算法一般是应用到了光线与包围盒的相交判定问题中。&lt;/p&gt;

&lt;p&gt;那么下面就设直线为任意直线(光线都是任意方向的)，而平面设为某几种特定的特殊平面，来展示上面的算法的流程。&lt;/p&gt;

&lt;h2&gt;1. 法向量为\( (1,0,0) \)并且经过点\( (x_{0},0,0) \)的平面&lt;/h2&gt;

&lt;p&gt;根据上面的定义，可以知道：&lt;/p&gt;

&lt;p&gt;\[ \vec n =  (1,0,0)  \]&lt;/p&gt;

&lt;p&gt;\[ \vec p_{0} =  (x_{0},0,0)  \]&lt;/p&gt;

&lt;p&gt;代入上面的方程，得到：&lt;/p&gt;

&lt;p&gt;\[ t = \frac { ( (x_{0},0,0) - \vec o )\cdot (1,0,0) }{ \vec d \cdot (1,0,0) }  \]&lt;/p&gt;

&lt;p&gt;化简得到：&lt;/p&gt;

&lt;p&gt;\[ t = \frac { x_{0} -  o_{x} }{ d_{x} }  \]&lt;/p&gt;

&lt;h2&gt;2. 法向量为\( (0,1,0) \)并且经过点\( (0,y_{0},0) \)的平面&lt;/h2&gt;

&lt;p&gt;同上，可以得到：&lt;/p&gt;

&lt;p&gt;\[ t = \frac { y_{0} -  o_{y} }{ d_{y} }  \]&lt;/p&gt;

&lt;h2&gt;3. 法向量为\( (0,0,1) \)并且经过点\( (0,0,z_{0}) \)的平面&lt;/h2&gt;

&lt;p&gt;同上，可以得到：&lt;/p&gt;

&lt;p&gt;\[ t = \frac { z_{0} -  o_{z} }{ d_{z} }  \]&lt;/p&gt;

&lt;h1&gt;应用，判定直线与BBox是否相交&lt;/h1&gt;

&lt;p&gt;BBox是一个分别和x、y、z轴平行的长方体。在判定直线与BBox是否相交的问题中，要把BBox想象成6个无限大的平面，每个平面称为一个slab。然后就可以应用上面的公式，计算直线与6个slab的相交点(即，算出t值)，根据t值，就可以知道直线是不是和BBox相交了。&lt;/p&gt;

&lt;h2&gt;2维的情况&lt;/h2&gt;

&lt;p&gt;以此图为例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中的红色区域是一个BBox，一般定义一个BBox只需要记录它的2个对角顶点的坐标值即可。图中BBox的左下顶点坐标为(3,1)，右上顶点坐标为(6,3)；&lt;/p&gt;

&lt;p&gt;图中绿色直线的方程为 y = x - 1。&lt;/p&gt;

&lt;p&gt;BBox的4个slab分别为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;法向量为\( (1,0) \)并且经过点\( (3,0) \)的直线a&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;法向量为\( (1,0) \)并且经过点\( (6,0) \)的直线b&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;法向量为\( (0,1) \)并且经过点\( (0,1) \)的直线c&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;法向量为\( (0,1) \)并且经过点\( (0,3) \)的直线d&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;绿色直线的o和d分别为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;o = (1,0)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;d = (1,1)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据上面的交点公式，可以知道绿色直线与4个slab的相交点A、B、C、D，它们的t值分别为：&lt;/p&gt;

&lt;p&gt;\[ t_{A} = \frac { x_{0} -  o_{x} }{ d_{x} }  = \frac { 3 - 1 }{ 1 } = 2  \]&lt;/p&gt;

&lt;p&gt;\[ t_{B} = \frac { x_{1} -  o_{x} }{ d_{x} }  = \frac { 6 - 1 }{ 1 } = 5  \]&lt;/p&gt;

&lt;p&gt;\[ t_{C} = \frac { y_{0} -  o_{y} }{ d_{y} }  = \frac { 1 - 0 }{ 1 } = 1  \]&lt;/p&gt;

&lt;p&gt;\[ t_{D} = \frac { y_{1} -  o_{y} }{ d_{y} }  = \frac { 3 - 0 }{ 1 } = 3  \]&lt;/p&gt;

&lt;p&gt;得到这4个t值之后，怎么知道相交还是不相交呢？这需要分析一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;\( t_{A} \)、\( t_{B} \)的意义是：对于在BBox内的任意一个点P，它的分量x关于直线的t值，必然在\( [ t_{A} ,  t_{B} ] \)之间；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( t_{C} \)、\( t_{D} \)的意义是：对于在BBox内的任意一个点P，它的分量y关于直线的t值，必然在\( [ t_{C} ,  t_{D} ] \)之间；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结合例子来说就是：若BBox内存在一个点P，它的x、y分量的t值分别满足\( 2 \leq t_{x} \leq 5 \)、\( 1 \leq t_{y} \leq 3 \)时，这个BBox就必然与直线y = x - 1相交。&lt;/p&gt;

&lt;p&gt;但是这个方案并不是最佳方案。&lt;/p&gt;

&lt;p&gt;接着分析下。&lt;/p&gt;

&lt;p&gt;因为我们给直线定义了o和d，所以直线的另一个表达式是 \(\vec o + t\vec d\)。根据这个表达式，\( t_{A} \)、\( t_{B} \) 和  \( t_{C} \)、\( t_{D} \)有了新的意义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;\( t_{A} \)、\( t_{B} \)限定了一条在直线上的有限长度线段\( \overline {AB} \)，起点是\(\vec o + t_{A}\vec d \)，终点是\(\vec o + t_{B}\vec d \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( t_{C} \)、\( t_{D} \)限定了一条在直线上的有限长度线段\( \overline {CD} \)，起点是\(\vec o + t_{C}\vec d \)，终点是\(\vec o + t_{D}\vec d \)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是，判定直线与BBox是否相交的充分必要条件呼之欲出：&lt;strong&gt;s1和s2两个线段存在重叠&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中的黑色线段即为\( \overline {AB} \)、\( \overline {CD} \)的重叠部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;对于直线y = x + 1来说，就不存在重叠部分了。&lt;/p&gt;

&lt;h2&gt;3维的情况&lt;/h2&gt;

&lt;p&gt;理解了2维的情况，3维（甚至更高维）的情况类推就可以了。完整的算法流程是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BBox&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsIntersectWithRay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//x y z&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invRayDir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tNear&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pMin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invRayDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tFar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pMax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invRayDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tNear&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tFar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tNear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tFar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tNear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tFar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Fri, 01 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/line-plane-intersection/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/line-plane-intersection/</guid>
      </item>
    
      <item>
        <title>Global Gamejam 2016 和 IndieAce Gamejam 2016 作品</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;Global Gamejam&lt;/h1&gt;

&lt;p&gt;本次主题，一个词：&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;Ritual&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;我们根据题目做出来的游戏：《阴阳合》&lt;/p&gt;

&lt;p&gt;游戏截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.6/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;试玩地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://yinyang.qiujiawei.com/&quot;&gt;http://yinyang.qiujiawei.com/&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;IndieACE Gamejam&lt;/h1&gt;

&lt;p&gt;本次主题，一幅画：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.6/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们根据题目做出来的游戏：《人，造人》&lt;/p&gt;

&lt;p&gt;游戏截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.6/3.jpg&quot; alt=&quot;3.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;试玩地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://voyagingmk.github.io/IndieACEGamejam2016/&quot;&gt;https://voyagingmk.github.io/IndieACEGamejam2016/&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;后记&lt;/h1&gt;

&lt;p&gt;GGJ一般是年初的时候举办，IndieACE的GJ一般是年中的时候举办。目前国内搞得好的、一般人能接触到的只有这2个GJ吧。&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/gamejam/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/gamejam/</guid>
      </item>
    
      <item>
        <title>学习增强学习</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;马尔可夫决策过程&lt;/h1&gt;

&lt;p&gt;马尔可夫决策过程(&lt;a href=&quot;https://en.wikipedia.org/wiki/Markov_decision_process&quot;&gt;Markov decision process&lt;/a&gt;，下文简称MDP)，可用来处理一些最优化问题，譬如非常出名的&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_programming&quot;&gt;动态规划&lt;/a&gt;问题，以及本文的核心——&lt;a href=&quot;https://en.wikipedia.org/wiki/Reinforcement_learning&quot;&gt;增强学习&lt;/a&gt;问题。&lt;/p&gt;

&lt;h2&gt;MDP的定义&lt;/h2&gt;

&lt;p&gt;MDP包含5个东西：\(S、A、P、R、\gamma \)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;S(State)，指的是目标系统的所有状态的集合&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A(Action)，状态之间的转换行为。可以把状态S想象成一堆节点，而A就是各个节点之间的有向连线集合&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;P(probability)，\(P_{a}(s,s&amp;#39;)\)，某状态\(s\)通过某行为a进入另一个状态\(s&amp;#39;\)的概率&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;R(Rewawrd)，\(R_{a}(s,s&amp;#39;)\)，某状态\(s\)通过某行为a进入另一个状态\(s&amp;#39;\)能获得的奖励值&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\(\gamma \) (Discount Factor)，用于奖励值计算的一个系数，表示非立即奖励(future rewards)相对于立即奖励(present rewards)的重要程度，当为1时表示同等重要，小于1时表示非立即奖励要打个折，等于0时表示只考虑立即奖励。因此有\( 0 \leq \gamma \leq 1 \)。注意，\(\gamma \) 是一个常数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为一般来说，状态之间是有时间先后顺序的（拓扑结构），所以每个状态s有它自己的固有属性t，表示这个s处于时间轴上的位置。&lt;/p&gt;

&lt;p&gt;在MDP的定义中没有指出S、A是不是有限集合(finite)，但在实际应用MDP时，必然是有限的。&lt;/p&gt;

&lt;p&gt;MDP的直观表示是一个有向图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/2/21/Markov_Decision_Process_example.png&quot; alt=&quot;1.png&quot;&gt;
(from wiki)&lt;/p&gt;

&lt;h2&gt;MDP的核心问题&lt;/h2&gt;

&lt;p&gt;MDP的核心核心是找出一个最理想的策略函数\(\pi ^{*} (s)\)给做决策的人，这个\(\pi ^{*}(s)\)决定了当处于状态s时，应采取哪个行为a，即\( a_{t} = \pi ^{*} (s_{t})\)。&lt;/p&gt;

&lt;p&gt;这个问题的解决方案是：求出一个叫做&lt;strong&gt;折算累积奖励(discounted cumulative reward)&lt;/strong&gt;多项式的最大值，此时的\(\pi (s)\)就是最优解\(\pi ^{*}(s)\)。公式化表示就是：&lt;/p&gt;

&lt;p&gt;\[ r_{t} =  R_{ a_{t} }(s_{t}, s_{t+1} ) \]&lt;/p&gt;

&lt;p&gt;\[ V ^{\pi } (s_{t}) = r_{t} + \gamma r_{t+1} + \gamma ^{2} r_{t+2} + \cdots  =  \sum _{i=0}^{\infty }\gamma ^{i}r_{t+i} \]&lt;/p&gt;

&lt;p&gt;\[\pi ^{*} = argmax  V ^{\pi } (s) \]&lt;/p&gt;

&lt;p&gt;获得\(\pi ^{*} (s)\)后，就可以应用了，即对任意一个\(s_{t}\)，都可以算出最理想的行为\( a^{*}_{t} = \pi ^{*} (s_{t})\)。&lt;/p&gt;

&lt;p&gt;注意：\( V ^{\pi } (s_{t}) \)的实现不是唯一的，还有其他各种各样的公式可以选择，严格来说并不是MDP定义的一部分。&lt;/p&gt;

&lt;h2&gt;Q函数&lt;/h2&gt;

&lt;p&gt;评估函数Q的公式定义：&lt;/p&gt;

&lt;p&gt;\[ Q(s,a) = r_{immediate}(s,a) + \gamma V^{ \pi ^{*} }(s&amp;#39;) \]&lt;/p&gt;

&lt;p&gt;用文字解释：Q的值为从状态s执行动作a所获得的立即奖励再加上后续遵循最优策略时的V值，V用\(\gamma \)折算。&lt;/p&gt;

&lt;p&gt;并且有：&lt;/p&gt;

&lt;p&gt;\[\pi ^{*} = argmax Q(s,a)  \]&lt;/p&gt;

&lt;p&gt;V函数和Q函数的关系：&lt;/p&gt;

&lt;p&gt;\[ V^{ \pi ^{*} } = \max _{a&amp;#39;}Q(s,a&amp;#39;) \]&lt;/p&gt;

&lt;p&gt;用这个式子重写Q的定义式：&lt;/p&gt;

&lt;p&gt;\[ Q(s,a) = r_{immediate}(s,a) + \gamma \max _{a&amp;#39;}Q(s&amp;#39;,a&amp;#39;) \]&lt;/p&gt;

&lt;h2&gt;确定性MDP系统的基于Q函数的增强学习算法&lt;/h2&gt;

&lt;p&gt;在增强学习中，要学习的函数是Q函数而不是\( V^{ \pi ^{*} } \)函数。这是因为后者是关于s的一元函数，计算过程要求知道每个状态\(s_{t}\)的最佳\(a_{t}\)，否则就算不出\(r_{t}\)了；而Q函数是关于s、a的二元函数，不需要知道最佳\(a_{t}\)，而仅仅需要知道\( r_{immediate}(s,a) \)的值（右边的\(  \gamma \max _{a&amp;#39;}Q(s&amp;#39;,a&amp;#39;) \)是递归式，熟悉动态规划的童鞋就知道Q可以计算出来的，实际上Q就是一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Bellman_equation&quot;&gt;Bellman方程&lt;/a&gt;）；当算出所有Q(s,a)的值后，根据\( a_{t}  = argmax Q(s_{t},a) \)，就可以知道\( \pi ^{*} \)。&lt;/p&gt;

&lt;p&gt;Q学习算法的流程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;建一个二维表Q(s,a)，并把所有表项Q(s,a)初始化成0&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重复迭代：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;根据当前状态s，选一个动作a并执行&lt;/li&gt;
&lt;li&gt;得到立即奖励r：\( r = R_{ a }(s, s&amp;#39;)  \)&lt;/li&gt;
&lt;li&gt;更新表项：\( Q(s,a) = r + \gamma \max _{a&amp;#39;}Q(s&amp;#39;, a&amp;#39;)  \) 【向后传播(back propagation)】&lt;/li&gt;
&lt;li&gt;进入新状态s&amp;#39;：\(  s = s&amp;#39; \)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 11 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/reinforcement-learning/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/reinforcement-learning/</guid>
      </item>
    
      <item>
        <title>线性代数之主成分分析(PCA)算法</title>
        <description>&lt;p&gt;PCA(Principal Component Analysis)的主要应用场景是：在大数据集中找出关键的信息并剔除冗余的信息。根据这个特性，PCA也可以用来做信息压缩(有损)、特征提取。不过在本文中，只会对PCA的数学原理进行阐述。&lt;/p&gt;

&lt;p&gt;另外，PCA可以说是Machine Learning领域的自编码机(AutoEncoder,AE)的基础。主要区别在于，PCA是线性算法，而AE则不一定。所以在学习AutoEncoder之前，有必要先将PCA搞清楚。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;Part I&lt;/h1&gt;

&lt;p&gt;设向量\( \vec x \)表示对某个特征的n次采样(测量), 那么如果有m个不同的特征，就组成了一个\(m\times n \)的矩阵\( X \)：&lt;/p&gt;

&lt;p&gt;\[ X =  \left[ \begin{matrix} \vec x_{1}\\   \vec x_{2}\\   \vdots \\  \vec x_{m}\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;然后问题来了：每个特征之间是否是&lt;strong&gt;相互独立(independant)&lt;/strong&gt;的？如果是，那么说明这m个特征是良好的，可以直接拿去应用到任务中(譬如基于这些特征做一个分类器)；如果不是，那么就说明有特征是多余的，譬如\(  \vec x_{a} \)、\(  \vec x_{b} \)分别用米和英尺记录了同一个特征，虽然数值不一样，然而并没有什么卵用。&lt;/p&gt;

&lt;p&gt;量化特征与特征之间的关系的最好办法是用&lt;strong&gt;方差&lt;/strong&gt;(&lt;a href=&quot;https://en.wikipedia.org/wiki/Variance&quot;&gt;Variance&lt;/a&gt;)和&lt;strong&gt;协方差&lt;/strong&gt;(&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance&quot;&gt;Covariance&lt;/a&gt;)，这2者又共同涉及到了更基础的概念&lt;strong&gt;数学期望&lt;/strong&gt;(&lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;Expected Value&lt;/a&gt;)和&lt;strong&gt;均值&lt;/strong&gt;(&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;Mean&lt;/a&gt;)。先简单过一遍这4个东西的公式。&lt;/p&gt;

&lt;h3&gt;数学期望和均值&lt;/h3&gt;

&lt;p&gt;数学期望公式：&lt;/p&gt;

&lt;p&gt;\[ E[\vec x] = \sum _{i=1}^{n}x_{i}p_{i} \]&lt;/p&gt;

&lt;p&gt;当每个\( x_{i} \)的出现概率相等时(均匀分布)，有\( p_{i} = \frac {1}{n} \)，所以上式可简化成:&lt;/p&gt;

&lt;p&gt;\[ E[\vec x] = \frac {1}{n}\sum _{i=1}^{n }x_{i} \]&lt;/p&gt;

&lt;p&gt;上式其实也就是均值\( \overline {x} \)的定义，所以当\(x_{i}\)均匀分布时，有：&lt;/p&gt;

&lt;p&gt;\[  E[\vec x] =  \overline {x} \]&lt;/p&gt;

&lt;p&gt;有时候也用\( \mu \)来指代Mean。&lt;/p&gt;

&lt;h3&gt;方差和协方差&lt;/h3&gt;

&lt;p&gt;方差:&lt;/p&gt;

&lt;p&gt;\[ Var(\vec x) = E[ (\vec x - E[\vec x])^{2 } ] = E[ (\vec x - E[\vec x])(\vec x -  E[\vec x]) ]  \]&lt;/p&gt;

&lt;p&gt;协方差:&lt;/p&gt;

&lt;p&gt;\[ Cov(\vec x, \vec y) = E[ (\vec x -  E[\vec x])(\vec y -  E[\vec y]) ] \]&lt;/p&gt;

&lt;p&gt;可以发现方差是协方差的特殊情况:&lt;/p&gt;

&lt;p&gt;\[ Var(\vec x) = Cov(\vec x, \vec x) \]&lt;/p&gt;

&lt;h3&gt;协方差矩阵&lt;/h3&gt;

&lt;p&gt;在&lt;a href=&quot;http://daobiao.win:4000/linear-algebra-7/&quot;&gt;线性代数之各种各样的矩阵&lt;/a&gt;最后面已经提到了协方差矩阵(Covariance matrix):&lt;/p&gt;

&lt;p&gt;\[ C =  \left[ \begin{matrix} E[(\vec x_{1} - \mu_{1})(\vec x_{1} - \mu_{1})]&amp;amp;  E[(\vec x_{1} - \mu_{1})(\vec x_{2} - \mu_{2})]&amp;amp;  \cdots &amp;amp; E[(\vec x_{1} - \mu_{1})(\vec x_{m} - \mu_{m})]\\            E[(\vec x_{2} - \mu_{2})(\vec x_{1} - \mu_{1})]&amp;amp;  E[(\vec x_{2} - \mu_{2})(\vec x_{2} - \mu_{2})]&amp;amp;  \cdots &amp;amp; E[(\vec x_{2} - \mu_{2})(\vec x_{m} - \mu_{m})]\\   \vdots &amp;amp; \vdots &amp;amp;  \ddots &amp;amp; \vdots \\         E[(\vec x_{m} - \mu_{m})(\vec x_{1} - \mu_{1})]&amp;amp;  E[(\vec x_{m} - \mu_{m})(\vec x_{2} - \mu_{2})]&amp;amp;  \cdots &amp;amp; E[(\vec x_{m} - \mu_{m})(\vec x_{m} - \mu_{m})]\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;h3&gt;当Mean等于0时的情况&lt;/h3&gt;

&lt;p&gt;当Mean等于0时，上面的协方差矩阵变成：&lt;/p&gt;

&lt;p&gt;\[ C =  \left[ \begin{matrix} E[\vec x_{1}\vec x_{1}]&amp;amp;  E[\vec x_{1} \vec x_{2}]&amp;amp;  \cdots &amp;amp; E[\vec x_{1}\vec x_{m}]\\            E[\vec x_{2}\vec x_{1}]&amp;amp;  E[\vec x_{2}\vec x_{2}]&amp;amp;  \cdots &amp;amp; E[\vec x_{2}\vec x_{m}]\\   \vdots &amp;amp; \vdots &amp;amp;  \ddots &amp;amp; \vdots \\         E[\vec x_{m}\vec x_{1}]&amp;amp;  E[\vec x_{m}\vec x_{2}]&amp;amp;  \cdots &amp;amp; E[\vec x_{m}\vec x_{m}]\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;再假设\( \vec x \)每个分量的取值是均匀分布的，那么根据上面的定义，有：&lt;/p&gt;

&lt;p&gt;\[E[\vec x_{a}\vec x_{b}] = \frac {1}{n}\sum _{i=1}^{n} \vec x_{ai}\vec x_{bi} , 1 \leq a\leq m, 1 \leq b\leq m  \]&lt;/p&gt;

&lt;p&gt;代入上式，得到：&lt;/p&gt;

&lt;p&gt;\[ C = \frac {1}{n} \left[ \begin{matrix} \sum _{i=1}^{n} \vec x_{1}\vec x_{1}&amp;amp;  \sum _{i=1}^{n} \vec x_{1}\vec x_{2}&amp;amp;  \cdots &amp;amp; \sum _{i=1}^{n} \vec x_{1}\vec x_{m}\\            \sum _{i=1}^{n} \vec x_{2}\vec x_{1}&amp;amp;  \sum _{i=1}^{n} \vec x_{2}\vec x_{2}&amp;amp;  \cdots &amp;amp; \sum _{i=1}^{n} \vec x_{2}\vec x_{m}\\   \vdots &amp;amp; \vdots &amp;amp;  \ddots &amp;amp; \vdots \\        \sum _{i=1}^{n} \vec x_{m}\vec x_{1}&amp;amp;  \sum _{i=1}^{n} \vec x_{m}\vec x_{2}&amp;amp;  \cdots &amp;amp; \sum _{i=1}^{n} \vec x_{m}\vec x_{m}\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;再设一个矩阵X：&lt;/p&gt;

&lt;p&gt;\[ X =  \left[ \begin{matrix} \vec x_{1}\\  \vec x_{2}\\  \vdots \\  \vec x_{m}\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;\[ X^{T} =  \left[ \begin{matrix} \vec x_{1}&amp;amp; \vec x_{2}&amp;amp; \cdots &amp;amp; \vec x_{m}\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;于是有：&lt;/p&gt;

&lt;p&gt;\[ C = \frac {1}{n}XX^{T} \]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结下&lt;/strong&gt;，对符合均匀分布的、且均值等于0的\(\vec x_{i, 1\leq i \leq m}\)，它的协方差矩阵如下：&lt;/p&gt;

&lt;p&gt;\[ X^{T} =  \left[ \begin{matrix} \vec x_{1}&amp;amp; \vec x_{2}&amp;amp; \cdots &amp;amp; \vec x_{m}\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;\[ C = \frac {1}{n}XX^{T} \]&lt;/p&gt;

&lt;p&gt;为了下文能继续推导，需要把C记为\( C_{x} \)。&lt;/p&gt;

&lt;h1&gt;PART II&lt;/h1&gt;

&lt;p&gt;根据上面得到的协方差矩阵的公式，可以知道：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;\( C_{x} \)是一个对称方阵&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( C_{x} \)的对角线上的元素分别代表了对某个特征的n次测量的方差&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( C_{x} \)的非对角线上的元素代表了任意2个特征之间的协方差&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开始进入到PCA的环节。PCA的目标是提炼出\( C_{x} \)的关键信息并剔除冗余信息，这个过程用线性代数表示就是：&lt;/p&gt;

&lt;p&gt;\[ Y  = PX  \]&lt;/p&gt;

&lt;p&gt;这里面P就是我们需要的目标矩阵。而关于矩阵Y的协方差矩阵\( C_{y} \)的特性是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;\( C_{y} \)的对角线上的元素(方差)尽可能大（增大信号）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( C_{y} \)的非对角线上的元素(协方差)应该等于零，因此\( C_{y} \)还是一个对角线矩阵&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\( C_{x} \)、\( C_{y} \)、P的关系是：&lt;/p&gt;

&lt;p&gt;\[  C_{y} =  \frac {1}{n}YY^{T} \]&lt;/p&gt;

&lt;p&gt;\[  = \frac {1}{n}(PX)(PX)^{T} \]&lt;/p&gt;

&lt;p&gt;\[  = \frac {1}{n}PXX^{T}P^{T} \]&lt;/p&gt;

&lt;p&gt;\[  = P(\frac {1}{n}XX^{T})P^{T} \]&lt;/p&gt;

&lt;p&gt;\[  = PC_{x}P^{T} \]&lt;/p&gt;

&lt;p&gt;即：&lt;/p&gt;

&lt;p&gt;\[   C_{y} = PC_{x}P^{T} \]&lt;/p&gt;

&lt;p&gt;PCA的求解方法多种多样，下面展示最经典的解法——特征值分解。&lt;/p&gt;

&lt;h2&gt;基于特征值分解的PCA&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://127.0.0.1:4000/linear-algebra-6/&quot;&gt;矩阵的特征值、特征向量、特征矩阵、迹、特征值分解&lt;/a&gt;一文中提到了对称方阵的特征值分解公式：&lt;/p&gt;

&lt;p&gt;\[ A =  S\Lambda S^{-1} = S\Lambda S^{T} \]&lt;/p&gt;

&lt;p&gt;矩阵\( \Lambda \)是对角矩阵，对角线上的元素为特征值；矩阵S是一个行向量为特征向量的矩阵，\( S^{-1} = S^{T} \)。&lt;/p&gt;

&lt;p&gt;有了这个公式后，立即可以知道对称矩阵\( C_{x} \)的特征值分解(对角化)为：&lt;/p&gt;

&lt;p&gt;\[ C_{x} =  S\Lambda S^{T} \]&lt;/p&gt;

&lt;p&gt;将其代入上面的公式，有:&lt;/p&gt;

&lt;p&gt;\[C_{y} = PS\Lambda S^{T}P^{T}   \]&lt;/p&gt;

&lt;p&gt;这里可以大胆做个假设：\( P \equiv  S^{T} \)。又因为 \( S^{-1} = S^{T} \)， 则有:&lt;/p&gt;

&lt;p&gt;\[ P^{-1} =  (S^{T})^{-1} = (S^{-1})^{-1} = S = P^{T} \]&lt;/p&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;p&gt;\[ C_{y} = PS\Lambda S^{T}P^{T} = PP^{T} \Lambda PP^{T} = PP^{-1} \Lambda PP^{-1} = \Lambda   \]&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当\( P \)(主成分矩阵)是\( C_{x} \)的特征向量矩阵\( S \)时，\( C_{y} \)是特征值矩阵\( \Lambda\)&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;基于奇异值分解的PCA&lt;/h2&gt;

&lt;p&gt;关于SVD的讨论我都会追加&lt;a href=&quot;http://127.0.0.1:4000/linear-algebra-9/&quot;&gt;线性代数之奇异值(SVD)分解&lt;/a&gt;一文中，在这里不展开对SVD的详细讨论。&lt;/p&gt;

&lt;p&gt;SVD分解公式：&lt;/p&gt;

&lt;p&gt;\[ M = UΣV^{*} \]&lt;/p&gt;

&lt;p&gt;（其中各个矩阵的含义就不赘述了）&lt;/p&gt;

&lt;p&gt;和PCA最相关的SVD其中一条性质：&lt;/p&gt;

&lt;p&gt;\[ M^{*}M = V\Sigma ^{*}U^{*}U\Sigma V^{*} = V\Sigma ^{*}(U^{*}U)\Sigma V^{*} = V\Sigma ^{*}\Sigma V^{*} = V(\Sigma  ^{*}\Sigma )V^{-1}  \]&lt;/p&gt;

&lt;p&gt;当元素是实数时，有：&lt;/p&gt;

&lt;p&gt;\[ M^{T}M = V(\Sigma  ^{T}\Sigma )V^{-1}  \]&lt;/p&gt;

&lt;p&gt;注意，这个公式包含了一个事实：\( M^{T}M \)的特征值分解等于\( V(\Sigma  ^{T}\Sigma )V^{-1}  \)。&lt;/p&gt;

&lt;p&gt;现在，假设有一个矩阵Y，Y满足：&lt;/p&gt;

&lt;p&gt;\[ Y = \frac { 1 }{ \sqrt {n} }X^{T} \]&lt;/p&gt;

&lt;p&gt;那么有：&lt;/p&gt;

&lt;p&gt;\[ Y^{T}Y = (\frac { 1 }{ \sqrt {n} }X^{T})^{T}\frac { 1 }{ \sqrt {n} }X^{T} \]&lt;/p&gt;

&lt;p&gt;\[ = \frac { 1 }{ \sqrt {n} }\frac { 1 }{ \sqrt {n} } (X^{T})^{T}X^{T} \]&lt;/p&gt;

&lt;p&gt;\[ = \frac { 1 }{ n }XX^{T} \]&lt;/p&gt;

&lt;p&gt;\[ = C_{x} \]&lt;/p&gt;

&lt;p&gt;而Y的SVD分解为：&lt;/p&gt;

&lt;p&gt;\[ Y = UΣV^{*} \]&lt;/p&gt;

&lt;p&gt;所以有：&lt;/p&gt;

&lt;p&gt;\[ Y^{T}Y = V(\Sigma  ^{T}\Sigma )V^{-1} = C_{x} \] &lt;/p&gt;

&lt;p&gt;这时候事情又和特征值分解联系上了，在上一小节我们已经知道&lt;strong&gt;当\( P \)是\( C_{x} \)的特征向量矩阵\( S \)时，\( C_{y} \)是特征值矩阵\( \Lambda\)&lt;/strong&gt;，而在这个式子中，\(V\)就是\( C_{x} \)的特征向量矩阵！&lt;/p&gt;

&lt;p&gt;整理一下这个解法的思路：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先设\( Y = \frac { 1 }{ \sqrt {n} }X^{T} \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对矩阵Y做SVD分解，得到矩阵V，V就是关于X的主成分矩阵&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;A Tutorial on Principal Component Analysis, Jonathon Shlens&lt;/p&gt;
</description>
        <pubDate>Mon, 30 May 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-17/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-17/</guid>
      </item>
    
      <item>
        <title>线性代数之伪逆矩阵(pseudoinverse matrix)</title>
        <description>&lt;p&gt;众所周知只有方阵才有逆矩阵，非方阵没有逆矩阵。这个不和谐的问题已在20世纪初被数学家&lt;a href=&quot;https://en.wikipedia.org/wiki/E._H._Moore&quot;&gt;E. H. Moore&lt;/a&gt;等人解决掉了，因为他们发明了&lt;strong&gt;一般化的逆矩阵(generalized inverse)&lt;/strong&gt;，也称为&lt;strong&gt;伪逆矩阵(Moore–Penrose pseudoinverse)&lt;/strong&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;定义&lt;/h1&gt;

&lt;p&gt;对于任意一个矩阵A，A的伪逆矩阵\(A ^{+} \)必然存在，且\(A ^{+} \)必然满足以下四个条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;\( AA ^{+}A = A \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( A ^{+}AA ^{+} = A ^{+} \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( (AA ^{+})^{*} = AA ^{+} \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( (A ^{+}A)^{*} = A ^{+}A \)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这四个条件(性质)蕴含了一个事情：\(AA ^{+} \)必然是一个效果等同单位矩阵I、但又不是单位矩阵I的矩阵。&lt;/p&gt;

&lt;p&gt;伪逆矩阵\( A ^{+} \)的极限形式定义：&lt;/p&gt;

&lt;p&gt;\[ A^{+} = \lim _{\delta \searrow 0} ( A^{*}A + \delta I ) ^{-1}A^{*} \]&lt;/p&gt;

&lt;p&gt;\[  = \lim _{\delta \searrow 0}A^{*} ( A^{*}A + \delta I ) ^{-1} \]&lt;/p&gt;

&lt;p&gt;伪逆矩阵更加常用的定义（基于SVD奇异值分解）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SVD公式：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ A = UΣV^{*} \]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;伪逆矩阵公式：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ A^{+} = VΣ^{+}U^{*} \]&lt;/p&gt;

&lt;p&gt;这个公式要注意的是中间的\(Σ^{+}\)的求法。因为\(Σ_{m\times n}\)是一个对角线矩阵，但又不一定是方阵，所以计算它的伪逆矩阵的步骤是特殊又简单的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将对角线上的元素取倒数&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;再将整个矩阵转置一次&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;性质&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当A可逆时，A的伪逆矩阵等于A的逆矩阵&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;零矩阵的伪逆矩阵是它的转置矩阵&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( (A^{+})^{+} = A \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( (A^{+})^{T} = (A^{T})^{+} \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( ( \overline {A} )^{+} =  \overline { A^{+} } \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( (A^{*})^{+}  = (A^{+})^{*} \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( (\alpha A)^{+}  = \alpha ^{-1}A^{+} \)，\(\alpha \)不等于0&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;应用：最小二乘估计&lt;/h1&gt;

&lt;p&gt;在我的&lt;a href=&quot;http://www.qiujiawei.com/linear-algebra-15/&quot;&gt;最小二乘估计(Least Squares Estimator)的公式的推导&lt;/a&gt;一文中，提到了一个小问题，&lt;strong&gt;当矩阵X不是方阵时，最小二乘估计公式必须为&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;\[ \vec a = (X^{T}X)^{-1}X^{T}\vec y  \]&lt;/p&gt;

&lt;p&gt;不能进一步简化，除非X是有逆矩阵的方阵。&lt;/p&gt;

&lt;p&gt;这个事情也可以用伪逆矩阵来讨论一遍。&lt;/p&gt;

&lt;p&gt;先回到问题本源——最小二乘估计的本质是解决下面的方程：&lt;/p&gt;

&lt;p&gt;\[ \vec y = X\vec a + \vec e \]&lt;/p&gt;

&lt;p&gt;其中\(\vec y\)和\(X\)是已知量，\(\vec a\)和\(\vec e\)是要求的量，这可能有0到n个解，而我们的目标是想找使得\( ||\vec e||_{2}\)最小的\(\vec a\)。&lt;/p&gt;

&lt;p&gt;当我们求得理想的\(\vec a\)、\(\vec e\)后，可以让\(\vec e = \vec 0\)，并把\(\vec a\)、\(\vec e\)代入原方程，从而得到下面的等式：&lt;/p&gt;

&lt;p&gt;\[ \widehat {\vec y} = X\vec a \]&lt;/p&gt;

&lt;p&gt;求得的\( \widehat {\vec y} \)就是\( \vec y  \)的最佳近似。&lt;/p&gt;

&lt;p&gt;再换个角度想——如果我们一开始就默认方程\( \vec y = X\vec a  \)有解，那么这个解就是：&lt;/p&gt;

&lt;p&gt;\[ \vec a = X^{-1}\vec y \]&lt;/p&gt;

&lt;p&gt;慢着！\(  X^{-1} \)可不一定存在的，因为X不一定是方阵，所以上面这个等式是错误的。怎么办？这时候伪逆矩阵就派上用场了：&lt;/p&gt;

&lt;p&gt;\[ \vec a = X^{+}\vec y \]&lt;/p&gt;

&lt;p&gt;因为伪逆矩阵对任意矩阵都存在，所以这个等式才是合理的。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse#Singular_value_decomposition_.28SVD.29&quot;&gt;Moore–Penrose pseudoinverse&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 29 May 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-16/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-16/</guid>
      </item>
    
  </channel>
</rss>