<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>伪技术宅，兴趣点：服务器编程、游戏开发、人工智能</description>
    <link>http://www.qiujiawei.com</link>
    <atom:link href="http://www.qiujiawei.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Understanding Quaternions 中文翻译《理解四元数》</title>
        <description>&lt;p&gt;原文地址:&lt;a href=&quot;http://www.3dgep.com/understanding-quaternions/&quot;&gt;http://www.3dgep.com/understanding-quaternions/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;在这篇文章中我会尝试用简单的方式去解释四元数的概念，即用可视化的方式解释四元数以及几种对四元数的操作。我将把矩阵、欧拉角和四元数放在一起比较，并解释什么时候该用四元数、什么时候该用欧拉角或矩阵。&lt;/p&gt;

&lt;h3&gt;内容结构&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;复数
### 复数的加减
### 复数的系数缩放
### 复数的积
### 复数的平方
### 共轭复数
### 复数的绝对值
### 两复数的商&lt;/li&gt;
&lt;li&gt;i的幂&lt;/li&gt;
&lt;li&gt;复数平面
### 旋转数（Rotors)&lt;/li&gt;
&lt;li&gt;四元数
### 作为有序数的四元数
### 四元数的加减
### 四元数的积
### 实四元数
### 四元数的系数缩放
### 纯四元数
### 四元数的加法形式
### 单位四元数
### 四元数的二元形式
### 共轭四元数
### 四元数范数
### 四元数规范化
### 四元数的逆
### 四元数的点乘&lt;/li&gt;
&lt;li&gt;旋转&lt;/li&gt;
&lt;li&gt;四元数的插值
### SLERP
### 四元数的差
### 四元数求幂运算
### 四元数的分数差
### 考虑？
### SQUARD&lt;/li&gt;
&lt;li&gt;结论&lt;/li&gt;
&lt;li&gt;下载Demo&lt;/li&gt;
&lt;li&gt;引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;介绍&lt;/h3&gt;

&lt;p&gt;在计算机图形学中，我们使用转换矩阵来表示空间中的一个位置，以及朝向。一个转换矩阵还可以表示对一个目标的缩放或裁减(?)。  我们可以把转换矩阵想象成一个空间，当你用这个矩阵乘以向量、点（甚至矩阵）， 你就能把向量、点、矩阵转换进这个空间。&lt;/p&gt;

&lt;p&gt;在这篇文章中，我不会讨论这个转换函数的细节。你可以查看我前面的文章，文章中描述了转换矩阵的细节。&lt;/p&gt;

&lt;p&gt;在这篇文章中，我想要讨论一个可替代的方案，即用四元数来描述空间里的物体的朝向。&lt;/p&gt;

&lt;p&gt;四元数的概念是由爱尔兰数学家Sir William Rowan Hamilton发明的（1843年，都柏林）。Hamilton当时正和他的妻子前往爱尔兰皇家研究院，当他从Brougham桥通过皇家运河时，他领悟到了一个激动人心的东西，并立刻把它刻在桥的一个石头上：&lt;/p&gt;

&lt;p&gt;\[ i^{2} = j^{2} = k^{2} = ijk = -1 \]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/2.jpg&quot; alt=&quot;2.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;William Rowan Hamilton Plaque on Broome Bridge on the Royal Canal commemorating his discovery of the fundamental formula for quaternion multiplication.&lt;/p&gt;

&lt;h3&gt;复数&lt;/h3&gt;

&lt;p&gt;在我们能够完全理解四元数之前，我们必须先理解四元数是怎么来的。四元数的根源其实是&lt;strong&gt;复数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;除了知名的数集（自然数、整数、实数、分数）之外，复数系统引入了一个新的数集——虚数。虚数的发明是为了解决一些特定的无解的方程，例如；
\[ x^{2} + 1 = 0 \]
要解决这个等式，必须让\(x^{2} = -1 \)，在当然是不行的，因为任意数字的平方都是非负数。&lt;/p&gt;

&lt;p&gt;一般而言，数学家是不能忍受一个等式是无解的，于是一个新的术语被发明了，它就是虚数，一个可以解决上面这个等式的数。&lt;/p&gt;

&lt;p&gt;虚数有这样的形式：&lt;/p&gt;

&lt;p&gt;\[ i^{2} = -1 \]&lt;/p&gt;

&lt;p&gt;不要为这个术语较真，因为逻辑上这个数是不存在的。只要知道i是一个平方等于-1的东西即可。&lt;/p&gt;

&lt;p&gt;虚数的集合可以用\( \mathbb{I} \)来表示。&lt;/p&gt;

&lt;p&gt;复数的集合\( \mathbb{C} \)是一个实数和一个虚数的和，形式如下：&lt;/p&gt;

&lt;p&gt;\[ z = a + bi \ a,b\in R,\ i^{2} = -1 \]&lt;/p&gt;

&lt;p&gt;可以认为所有实数都是b为0的复数、所有虚数都是a=0的复数。&lt;/p&gt;

&lt;h3&gt;复数的加减&lt;/h3&gt;

&lt;p&gt;加法：&lt;/p&gt;

&lt;p&gt;\[ (a_{1} + b_{1}i) + (a_{2} + b_{2}i) = (a_{1} + a_{2}) + (b_{1} + b_{2})i \]&lt;/p&gt;

&lt;p&gt;减法：&lt;/p&gt;

&lt;p&gt;\[ (a_{1} + b_{1}i) - (a_{2} + b_{2}i) = (a_{1} - a_{2}) + (b_{1} - b_{2})i \]&lt;/p&gt;

&lt;h3&gt;复数的系数缩放&lt;/h3&gt;

&lt;p&gt;\[ \lambda (a_{1} + b_{1}i) = \lambda  a_{1} + \lambda b_{1}i \]&lt;/p&gt;

&lt;h3&gt;复数的积&lt;/h3&gt;

&lt;p&gt;\[  z_{1} = (a_{1} + b_{1}i) \]
\[  z_{2} = (a_{2} + b_{2}i) \]
\[  z_{1}z_{2} = (a_{1} + b_{1}i)(a_{2} + b_{2}i) = a_{1}a_{2} + a_{1}b_{2}i + b_{1}a_{2}i+b_{1}b_{2}i^{2} \]
\[ z_{1}z_{2} = (a_{1}a_{2} - b_{1}b_{2}) + (a_{1}b_{2} + b_{1}a_{2})i \]&lt;/p&gt;

&lt;h3&gt;复数的平方&lt;/h3&gt;

&lt;p&gt;\[ z = (a + bi) \]
\[ z^{2} = (a + bi)(a + bi) \]
\[ z^{2} = (a^{2} - b^{2}) + 2abi \]&lt;/p&gt;

&lt;h3&gt;共轭复数&lt;/h3&gt;

&lt;p&gt;复数的共轭就是指把复数的虚数部分变成负的。共轭复数的符号是\(\bar z\)或\(z^{*}\)。&lt;/p&gt;

&lt;p&gt;\[ z = (a + bi) \]&lt;/p&gt;

&lt;p&gt;\[ z^{*} = (a - bi) \]&lt;/p&gt;

&lt;p&gt;复数和它的共轭复数的乘积是：&lt;/p&gt;

&lt;p&gt;\[ zz^{*} = (a + bi)(a - bi) = a^{2}-abi+abi+b^{2} = a^{2}+b^{2} \]&lt;/p&gt;

&lt;h3&gt;复数的绝对值&lt;/h3&gt;

&lt;p&gt;我们使用共轭复数来计算复数的绝对值：&lt;/p&gt;

&lt;p&gt;\[ z = (a + bi) \]&lt;/p&gt;

&lt;p&gt;\[ |z| = \sqrt {zz^{*}} = \sqrt {(a + bi)(a - bi)} = \sqrt {a^{2} + b^{2} } \]&lt;/p&gt;

&lt;h3&gt;两复数的商&lt;/h3&gt;

&lt;p&gt;\[  z_{1} = (a_{1} + b_{1}i) \]
\[  z_{2} = (a_{2} + b_{2}i) \]
\[ \frac {z_{1}}{z_{2}} = \frac {a_{1} + b_{1}i}{a_{2} + b_{2}i} = \frac {(a_{1} + b_{1}i)(a_{2} - b_{2}i)}{(a_{2} + b_{2}i)(a_{2} - b_{2}i)} \]
\[  = \frac {a_{1}a_{2}-a_{1}b_{2}i+b_{1}a_{2}i-b_{1}b_{2}i^{2} }{a_{2}^{2} + b_{2}^{2}} \]&lt;/p&gt;

&lt;p&gt;\[ = \frac {a_{1}a_{2} + b_{1}b_{2} }{a_{2}^{2} + b_{2}^{2}}   + \frac {b_{1}a_{2} - a_{1}b_{2} }{a_{2}^{2} + b_{2}^{2}}i \]&lt;/p&gt;

&lt;h2&gt;i的幂&lt;/h2&gt;

&lt;p&gt;如果i的平方等于-1，那么i的n次幂也应该存在：&lt;/p&gt;

&lt;p&gt;\[ i^{0} = 1 \]
\[ i^{1} = i \]
\[ i^{2} = -1 \]
\[ i^{3} = ii^{2} = -i \]
\[ i^{4} = i^{2}i^{2} = 1 \]
\[ i^{5} = ii^{4} = i \]
\[ i^{6} = ii^{5} = i^{2} = -1 \]&lt;/p&gt;

&lt;p&gt;如果按照这个顺序写下去，会出现这样一个模式：
(1,i,-1,-i,1,...)&lt;/p&gt;

&lt;p&gt;一个类似的模式也出现在递增的负数幂：&lt;/p&gt;

&lt;p&gt;\[ i^{0} = 1 \]
\[ i^{-1} = -i \]
\[ i^{-2} = -1 \]
\[ i^{-3} = i \]
\[ i^{-4} = 1 \]
\[ i^{-5} = -i \]
\[ i^{-6} = -1 \]&lt;/p&gt;

&lt;p&gt;你可能已经在数学里头见过类似的模式，但是是以（x,y,-x,-y,x,...)的形式，这是在2D笛卡尔平面对一个点逆时针旋转90度时生成的；（x,-y,-x,y,x,...)则是在2D笛卡尔平面对一个点顺时针旋转90度时生成的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;复数平面&lt;/h2&gt;

&lt;p&gt;我们也能够把复数映射到一个2D网格平面——复数平面，只需要把实数映射到横轴、虚数映射到纵轴。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;如前面的序列所示，我们可以认为，对一个复数乘以i，这个复数就在复数平面上旋转了90度。&lt;/p&gt;

&lt;p&gt;让我们看看这是不是真的。我们随机地在复数平面上取一个点：&lt;/p&gt;

&lt;p&gt;\[ p = 2 + i \]&lt;/p&gt;

&lt;p&gt;p乘以i后得到q：
\[ q = pi = (2+i)i = 2i+i^{2} = -1+2i \]&lt;/p&gt;

&lt;p&gt;q乘以i后得到r：
\[ r = qi = (-1+2i)i = -i+2i^{2} = -2-i \]&lt;/p&gt;

&lt;p&gt;r乘以i后得到s：
\[ s = ri = (-2-i)i = -2i-i^{2} = 1-2i \]&lt;/p&gt;

&lt;p&gt;s乘以i后得到t：
\[ t = si = (1-2i)i = i-2i^{2} = 2+i \]&lt;/p&gt;

&lt;p&gt;t刚好是开始的p。如果我们把这些复数放到复数平面上，就得到下面的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;我们也可以按顺时针方向旋转，只需要把上面的乘数i改成-i。&lt;/p&gt;

&lt;h3&gt;旋转数（Rotors)&lt;/h3&gt;

&lt;p&gt;我们也可以在复数平面上进行任意的旋转，只需要定义下面这个复数：
\[q = cos\theta +isin\theta \]&lt;/p&gt;

&lt;p&gt;任意的复数乘以q：&lt;/p&gt;

&lt;p&gt;\[ p = a + bi \]
\[ q = cos\theta + isin\theta \]
\[ pq = (a + bi)(cos\theta + isin\theta ) \]
\[ a&amp;#39; + b&amp;#39;i = acos\theta -bsin\theta + (asin\theta +bcos\theta )i \] &lt;/p&gt;

&lt;p&gt;也可以写成矩阵的形式：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} a&amp;#39;&amp;amp;-b&amp;#39;\\ b&amp;#39;&amp;amp;a&amp;#39;\\ \end{matrix} \right] =  \left[ \begin{matrix} cos\theta &amp;amp;-sin\theta \\ sin\theta &amp;amp;cos\theta \\ \end{matrix} \right] \left[ \begin{matrix} a&amp;amp;-b\\ b&amp;amp;a\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;这也是一个在复数平面绕原点逆时针旋转任意点的方法。&lt;/p&gt;

&lt;h2&gt;四元数&lt;/h2&gt;

&lt;p&gt;了解了复数系统和复数平面后，我们可以额外增加2个虚数到我们的复数系统，从而把这些概念拓展到3维空间。&lt;/p&gt;

&lt;p&gt;四元数的一般形式：&lt;/p&gt;

&lt;p&gt;\[ q = s + xi + yj + zk s,x,y,z \in \mathbb{R} \]&lt;/p&gt;

&lt;p&gt;上面的公式是根据Hamilton的著名的表达式得到的：&lt;/p&gt;

&lt;p&gt;\[ i^{2} = j^{2} = k^{2} = ijk = -1 \]&lt;/p&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;p&gt;\[ ij = k jk = i ki = j \]
\[ ji = -k kj = -i ik = -j \]&lt;/p&gt;

&lt;p&gt;你可能已经注意到了，i、j、k之间的关系非常像笛卡尔坐标系下单位向量的叉积规则：&lt;/p&gt;

&lt;p&gt;\[ x\times y = z y\times z = x z\times x = y \]
\[ y\times x = -z z\times y = -x x\times z = -y \]&lt;/p&gt;

&lt;p&gt;Hamilton自己也发现i、j、k虚数可以被用来表达3个笛卡尔坐标系单位向量i、j、k，并且仍然保持有虚数的性质，也即\( i^{2} = j^{2} = k^{2} = -1 \)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/6.png&quot; alt=&quot;6.png&quot;&gt;
（ij, jk, ki这几个性质的可视化）&lt;/p&gt;

&lt;p&gt;上图展示了如何用i、j、k作为笛卡尔坐标系的单位向量。&lt;/p&gt;

&lt;h3&gt;作为有序数的四元数&lt;/h3&gt;

&lt;p&gt;我们可以用有序对的形式，来表示四元数：
\[s,v] s\in \mathbb{R},v\in \mathbb{R^{3}} \]&lt;/p&gt;

&lt;p&gt;其中的v，也可以用它各自独立的3个分量表示：&lt;/p&gt;

&lt;p&gt;\[ q = [s,xi + yj + zk], s,x,y,z\in \mathbb{R} \]&lt;/p&gt;

&lt;p&gt;使用这种表示法，我们可以更容易地展示四元数和复数之间的相似性。&lt;/p&gt;

&lt;h3&gt;四元数的加减&lt;/h3&gt;

&lt;p&gt;和复数类似，四元数也可以被加减：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [s_{a},a] \]
\[ q_{b} = [s_{b},b] \]
\[ q_{a} + q_{b} = [s_{a} + s_{b},a + b] \]
\[ q_{a} - q_{b} = [s_{a} - s_{b},a - b] \]&lt;/p&gt;

&lt;h3&gt;四元数的积&lt;/h3&gt;

&lt;p&gt;我们也可以表示四元数的乘积：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [s_{a},a][s_{b},b] \]
\[ = (s_{a} + x_{a}i + y_{a}j +z_{a}k)(s_{b} + x_{b}i + y_{b}j +z_{b}k) \]
\[ = (s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}) \]
\[ + (s_{a}x_{b} + s_{b}x_{a} + y_{a}z_{b} - y_{b}z_{a})i \]
\[ + (s_{a}y_{b}+s_{b}y_{a}+z_{a}x_{b}-z_{b}x_{a})j \]
\[ + (s_{a}z_{b}+s_{b}z_{a}+x_{a}y_{b}-x_{b}y_{a})k \]&lt;/p&gt;

&lt;p&gt;四元数的乘积依然还是一个四元数。如果我们把虚数i、j、k替换成有序对：&lt;/p&gt;

&lt;p&gt;\[ i = [0,i] j = [0,j] k = [0,k] \]&lt;/p&gt;

&lt;p&gt;以及还有[1,0] = 1，将它们代入前面的表达式，就得到了：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = (s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b})[1,0] \]
\[ + (s_{a}x_{b} + s_{b}x_{a} + y_{a}z_{b} - y_{b}z_{a})[0,i] \]
\[ + (s_{a}y_{b}+s_{b}y_{a}+z_{a}x_{b}-z_{b}x_{a})[0,j] \]
\[ + (s_{a}z_{b}+s_{b}z_{a}+x_{a}y_{b}-x_{b}y_{a})[0,k] \]&lt;/p&gt;

&lt;p&gt;再把这个表达式扩展成多个有序对的和：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [(s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}),0] \]
\[ + [0,(s_{a}x_{b} + s_{b}x_{a} + y_{a}z_{b} - y_{b}z_{a})i] \]
\[ + [0,(s_{a}y_{b}+s_{b}y_{a}+z_{a}x_{b}-z_{b}x_{a})j] \]
\[ + [0,(s_{a}z_{b}+s_{b}z_{a}+x_{a}y_{b}-x_{b}y_{a})k] \]&lt;/p&gt;

&lt;p&gt;如果把上面的式子再乘以单位四元数，并提取公共部分，就可以把等式改写成：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [(s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}),0] \]
\[ + [0,s_{a}(x_{b}i + y_{b}j+z_{b}k) + s_{b}(x_{a}i+y_{a}j+z_{a}k)\]
\[+(y_{a}z_{b}-y_{b}z_{a})i+(z_{a}x_{b}-z_{b}x_{a})j+(x_{a}y_{b}-x_{b}y_{a})k] \]&lt;/p&gt;

&lt;p&gt;这个等式是2个有序对的和。第1个有序对是一个&lt;strong&gt;实&lt;/strong&gt;四元数，第2个是一个&lt;strong&gt;纯&lt;/strong&gt;四元数。这两个四元数也可以合并成一个：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [(s_{a}s_{b} - x_{a}x_{b} - y_{a}y_{b} - z_{a}z_{b}), \]
\[ s_{a}(x_{b}i + y_{b}j+z_{b}k) + s_{b}(x_{a}i+y_{a}j+z_{a}k)\]
\[+(y_{a}z_{b}-y_{b}z_{a})i+(z_{a}x_{b}-z_{b}x_{a})j+(x_{a}y_{b}-x_{b}y_{a})k] \]&lt;/p&gt;

&lt;p&gt;如果把下面的表达式代入上面的等式：&lt;/p&gt;

&lt;p&gt;\[ a = x_{a}i + y_{a}j + z_{a}k\]
\[ b = x_{b}i + y_{b}j + z_{b}k\]
\[ a\cdot b = x_{a}x_{b}i^{2}+y_{a}y_{b}j^{2}+z_{a}z_{b}k^{2} \]
\[ a\times b = (y_{a}z_{b}-y_{b}z_{a})i + (z_{a}x_{b} - z_{b}x_{a})j + (x_{a}y_{b} - x_{b}y_{a})k  \]&lt;/p&gt;

&lt;p&gt;我们就得到了：&lt;/p&gt;

&lt;p&gt;\[ q_{a}q_{b} = [s_{a}s_{b} - a\cdot b, s_{a}b+s_{b}a+a\times b] \]&lt;/p&gt;

&lt;p&gt;这就是四元数乘积的一般式。&lt;/p&gt;

&lt;h3&gt;实四元数&lt;/h3&gt;

&lt;p&gt;一个实四元数是一个虚部向量为零向量的四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [s,0] \]&lt;/p&gt;

&lt;p&gt;两个实四元数的乘积是另一个实四元数：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [s_{a},0] \]
\[ q_{b} = [s_{b},0] \]
\[ q_{a}q_{b} = [s_{a},0] [s_{b},0] = [s_{a}s_{b},0]  \]&lt;/p&gt;

&lt;p&gt;这和2个虚部为0的复数的乘积几乎一样：&lt;/p&gt;

&lt;p&gt;\[ z_{1} = a_{1} + 0i \]
\[ z_{2} = a_{2} + 0i \]
\[ z_{1}z_{2} = (a_{1} + 0i)(a_{2} + 0i) = a_{1}a_{2} \] &lt;/p&gt;

&lt;h3&gt;四元数的系数缩放&lt;/h3&gt;

&lt;p&gt;我们也可以用一个系数（实数）去乘四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ \lambda q = \lambda [s,v] = [\lambda s,\lambda v] \]&lt;/p&gt;

&lt;p&gt;我们可以用实四元数与普通四元数的乘积，来确认这个等式是否正确：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ \lambda = [\lambda ,0] \]
\[ \lambda q = [\lambda ,0][s,v] = [\lambda s,\lambda v] \]&lt;/p&gt;

&lt;h3&gt;纯四元数&lt;/h3&gt;

&lt;p&gt;和实四元数相似，Hamilton也定义了纯四元数。纯四元数是s=0的四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [0,v] \]&lt;/p&gt;

&lt;p&gt;也可以写成下面的形式：&lt;/p&gt;

&lt;p&gt;\[ q = xi + yj + zk \]&lt;/p&gt;

&lt;p&gt;然后是2个纯四元数的乘积：&lt;/p&gt;

&lt;p&gt;\[ q_{a} = [0,a] \]
\[ q_{b} = [0,b] \]
\[ q_{a}q_{b} = [0,a] [0,b] = [-a\cdot b, a\times b]  \]&lt;/p&gt;

&lt;h3&gt;四元数的加法形式&lt;/h3&gt;

&lt;p&gt;我们可以把四元数写成实四元数和纯四元数的和：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ = [s,0] + [0,v] \]&lt;/p&gt;

&lt;h3&gt;单位四元数&lt;/h3&gt;

&lt;p&gt;给定任意的向量v，我们可以把这个向量写成一个系数和一个单位方向向量的乘积：&lt;/p&gt;

&lt;p&gt;\[ v = \upsilon \hat {v}\ \ v=|v|,|\hat {v}|=1\]&lt;/p&gt;

&lt;p&gt;将这个定义和纯四元数的定义结合，就得到了：&lt;/p&gt;

&lt;p&gt;\[ q = [0,v] \]
\[ = [0,\upsilon \hat {v}] \]
\[ = \upsilon [0,\hat {v}] \]&lt;/p&gt;

&lt;p&gt;然后，我们可以定义单位四元数了，它是一个s=0、v为单位向量的四元数：&lt;/p&gt;

&lt;p&gt;\[ \hat {q} = [0, \hat {v}] \]&lt;/p&gt;

&lt;h3&gt;四元数的二元形式&lt;/h3&gt;

&lt;p&gt;我们现在可以把单位四元数的定义和四元数的加法形式结合到一起，就创造了一种新的四元数的表示法，这种表示法和复数的表示法形似：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ = [s,0] + [0,v] \]
\[ = [s,0] + \upsilon [0,\hat {v}] \]
\[ = s + \upsilon \hat {q} \]&lt;/p&gt;

&lt;p&gt;这就给了我们一种和复数非常相似的四元数表示法：&lt;/p&gt;

&lt;p&gt;\[ z = a + bi \]
\[ q = s + v\hat {q} \]&lt;/p&gt;

&lt;h3&gt;共轭四元数&lt;/h3&gt;

&lt;p&gt;共轭四元数的计算，就是将四元数的虚向量取反：&lt;/p&gt;

&lt;p&gt;\[  q = [s,v] \]
\[  q^{*} = [s,-v] \]&lt;/p&gt;

&lt;p&gt;四元数和它的共轭四元数的乘积：&lt;/p&gt;

&lt;p&gt;\[  qq^{*} = [s,v][s,-v] \]
\[ = [s^{2} - v\cdot -v,-sv+sv+v\times -v] \]
\[ = [s^{2} + v\cdot v,0] \]
\[ = [s^{2} + v^{2},0] \]&lt;/p&gt;

&lt;h3&gt;四元数范数&lt;/h3&gt;

&lt;p&gt;回忆下复数范数的定义：&lt;/p&gt;

&lt;p&gt;\[ |z| = \sqrt {a^{2}+b^{2}} \]
\[ zz^{*} = |z|^{2} \]&lt;/p&gt;

&lt;p&gt;类似的，四元数的范数可以这样定义：&lt;/p&gt;

&lt;p&gt;\[ q = [s,v] \]
\[ |q| = \sqrt {s^{2} + v^{2}} \]&lt;/p&gt;

&lt;p&gt;这也让我们可以这样表达四元数范数：&lt;/p&gt;

&lt;p&gt;\[ qq^{*} = |q|^{2} \]&lt;/p&gt;

&lt;h3&gt;四元数规范化&lt;/h3&gt;

&lt;p&gt;利用四元数范数的定义，就可以对四元数进行规范化。要让一个四元数规范化，只需要让这个四元数去除以它的范数：&lt;/p&gt;

&lt;p&gt;\[ q&amp;#39; = \frac {q}{\sqrt {s^{2}+v^{2}}} \]&lt;/p&gt;

&lt;p&gt;举一个例子，让我们规范化下面这个四元数：&lt;/p&gt;

&lt;p&gt;\[ q = [1, 4i + 4j - 4k] \]&lt;/p&gt;

&lt;p&gt;第一步，先计算q的范数：&lt;/p&gt;

&lt;p&gt;\[ |q| = \sqrt {1^{2}+4^{2}+4^{2}+(-4)^{2}} \]
\[ = \sqrt {49} = 7 \]&lt;/p&gt;

&lt;h3&gt;四元数的逆&lt;/h3&gt;

&lt;h3&gt;四元数的点乘&lt;/h3&gt;
</description>
        <pubDate>Wed, 30 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/understanding-quaternions/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/understanding-quaternions/</guid>
      </item>
    
      <item>
        <title>PBRT《章2》阅读笔记</title>
        <description>&lt;p&gt;最近在看线代的公开课，顺便也把PBRT这个坑开了，合在一起学。&lt;/p&gt;

&lt;p&gt;本文的cpp代码均来自&lt;a href=&quot;https://github.com/mmp/pbrt-v2&quot;&gt;https://github.com/mmp/pbrt-v2&lt;/a&gt;，木有修改。只为方便读者阅读。&lt;/p&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;一个基本的渲染器，需要实现2点：输入场景数据、输出渲染图像。&lt;/p&gt;

&lt;p&gt;输入场景数据这一步，就需要对3D世界各种东西进行抽象、并设计各种数据结构，比如比较fundamental的：3D空间向量、3D坐标系系统、光线，或者visible的：各种2D/3D几何体、纹理系统等。大概就是，这个渲染器要渲染的东西，程序上都会有一些对应的代码。渲染器不可能对未知的东西进行渲染。比如毛发、布这种高端的东西，一个基本的渲染器是无法渲染的，除非你写了一些代码来完成这个事情。&lt;/p&gt;

&lt;p&gt;《PBRT》第二章就讲了这些基础的东西。&lt;/p&gt;

&lt;p&gt;在前面的线代的文章中，提到了矩阵的基(basis)的概念。矩阵的基是一组线性无关的列向量，这个矩阵的列空间的任意一点，可以通过对矩阵的基的线性组合得到。&lt;/p&gt;

&lt;p&gt;那么n维的情况下，定义一个向量的公式是：&lt;/p&gt;

&lt;p&gt;\[ v = s_{1}v_{1} + \cdots + s_{n}v_{n} \]&lt;/p&gt;

&lt;p&gt;定义一个点的位置的公式是：&lt;/p&gt;

&lt;p&gt;\[ p = p_{0} + s_{1}v_{1} + \cdots + s_{n}v_{n} \]&lt;/p&gt;

&lt;p&gt;对于渲染器的3维空间，要简化成：&lt;/p&gt;

&lt;p&gt;\[ p_{0} = (0,0,0) \]
\[ basis = (1,0,0) (0,1,0) (0,0,1) \]&lt;/p&gt;

&lt;p&gt;这3个标准基向量对应的空间被称为世界空间(world space)。&lt;/p&gt;

&lt;h3&gt;向量(vector)、点(point)的区别&lt;/h3&gt;

&lt;p&gt;向量和点，区别在于点没有长度的概念，也就是说点是零维的，点代表空间里的一个&lt;strong&gt;位置&lt;/strong&gt;（pbrt的Point和Vector的差异是没有LengthSquared、Length函数)，而向量没有起点的概念，向量只是指明了一个&lt;strong&gt;方向&lt;/strong&gt;并且有长度。&lt;/p&gt;

&lt;h3&gt;3维空间下，如何从一个向量出发，构造出一组标准正交基&lt;/h3&gt;

&lt;p&gt;注意，这个问题是有重要意义的，因为一组标准正交基相当于一个坐标系。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设\( v_{1}=(x_{1},y_{1},z_{1}) \)，并且v1已经单位化&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随便选择v1的某一个分量，并将它变成0，再交换剩余的2个分量的位置，并对其中一个分量取反，就能得到和v1正交的v2。这是因为这样构造出来的v2，必然使得\(  v_{1}\cdot v_{2}=0 \)。比如当\( v_{2}=(-z_{1},0,x_{1}) \)时，有\( v_{1}\cdot v_{2}=(x_{1},y_{1},z_{1})\cdot (-z_{1},0,x_{1}) = 0\)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面的v2还有不足，因它不是单位化的。单位化的v2应该是\[v_{2}=\dfrac { (-z_{1},0,x_{1}) }{ \sqrt {z_{1}^{1}+x_{1}^{1}}} \]&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有了v1、v2后，v3就等于v1和v2的叉积(cross product): \( v_{3} =v_{1} \times v_{2} \)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;法向量Normal&lt;/h3&gt;

&lt;p&gt;(突然意识到，pbrt把向量、点、法向量写成3个没有继承关系的类，意义在于，防止程序员乱用并搞砸代码=。=)&lt;/p&gt;

&lt;p&gt;** A surface normal is a vector that is perpendicular to a surface at a particular position.It can be defined as the cross product of any two nonparallel vectors
that are tangent to the surface at a point. **&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;法向量是与某个平面垂直，并经过平面上某个特殊位置的向量。可以用平面上2个互不平行、与平面正切的向量的叉积来表示。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;法向量应该说是一种特殊的向量。pbrt也实现了一个以Vector为参数的Normal构造函数（但有explicit标志），允许通过向量构造出法向量。&lt;/p&gt;

&lt;h3&gt;光线Ray&lt;/h3&gt;

&lt;p&gt;光线是一条半无限长的线，用一个原点和一个方向向量来表示。&lt;/p&gt;

&lt;p&gt;参数形式的光线表示：&lt;/p&gt;

&lt;p&gt;\[ r(t) = o + td   \ \ \ 0\leq t\geq \infty \]&lt;/p&gt;

&lt;p&gt;光线还有其他成员变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mint maxt，用来限定t的范围&lt;/li&gt;
&lt;li&gt;time 用于构建动画，当构建静态场景时不需要&lt;/li&gt;
&lt;li&gt;depth 光线弹射深度。限制光线只能bounce多少次&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;微分光线Differential Ray&lt;/h3&gt;

&lt;p&gt;先跳过&lt;/p&gt;

&lt;h3&gt;包围盒&lt;/h3&gt;

&lt;p&gt;包围盒的主要作用，是用来优化程序性能的，更具体的说，就是让复杂场景物件简化成简单的球形、方盒，使得光线快速剔除不相交的对象，计算得更快。&lt;/p&gt;

&lt;p&gt;BBox&lt;/p&gt;

&lt;p&gt;这玩意神奇的地方，我觉得是它的构造函数。输入是2个Point，就能构造一个盒子，并且也仅仅是花了2个Point来存储。这2个新的Point和输入的Point不同，被称为pMin和pMax:&lt;/p&gt;

&lt;p&gt;\[ pMin = (min(p_{1}.x,p_{2}.x), min(p_{1}.y,p_{2}.y), min(p_{1}.z,p_{2}.z)) \]&lt;/p&gt;

&lt;p&gt;\[ pMax = (max(p_{1}.x,p_{2}.x), max(p_{1}.y,p_{2}.y), max(p_{1}.z,p_{2}.z)) \]&lt;/p&gt;

&lt;p&gt;需要注意的是，根据这个转换公式，要使得pMin和pMax足够定义一个BBox，那么他们必然是BBox的2个对角顶点。且因为BBox平行于x、y、z轴，那么pMin和pMax的任意一个分量都不能相等。（否则，pMin、pMax就只能是BBox的一对邻接顶点）&lt;/p&gt;

&lt;p&gt;p1、p2和pMin、pMax是什么关系呢？其实，p1、p2也是这个BBox的某一组对角顶点。计算出来的pMin、pMax也只是这4组对角顶点的特定的一组，只不过pMin必然是BBox8个顶点中最靠近坐标系原点的顶点、pMax必然是最远离坐标系原点的顶点。&lt;/p&gt;

&lt;h3&gt;转换Transformation&lt;/h3&gt;

&lt;p&gt;** In general, a transformation T is a mapping from points to points and from vectors to
vectors:**&lt;/p&gt;

&lt;p&gt;\[ p^{\prime } = T(p) \]
\[ v^{\prime } = T(v) \]&lt;/p&gt;

&lt;p&gt;回想下线代的知识，就可以知道，这个T必然是一个方阵，阶数等于p(或v)的维数，T对p(或v)的转换，其实只是一次矩阵乘法。&lt;/p&gt;

&lt;p&gt;T有很多种，大部分是无特殊转换意义的，但有小部分是有特定意义且能用在图形学里的。譬如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Translation，我称之为位置转换&lt;/li&gt;
&lt;li&gt;Scaling，缩放转换&lt;/li&gt;
&lt;li&gt;Rotation，旋转转换&lt;/li&gt;
&lt;li&gt;LookAt，视角转换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Translation的一般形式：&lt;/p&gt;

&lt;p&gt;\[ T(\vartriangle x,\vartriangle y,\vartriangle z) =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;\vartriangle x\\ 0&amp;amp;1&amp;amp;0&amp;amp;\vartriangle y\\ 0&amp;amp;0&amp;amp;1&amp;amp;\vartriangle z\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;Scaling的一般形式：&lt;/p&gt;

&lt;p&gt;\[ T(\vartriangle x,\vartriangle y,\vartriangle z) =  \left[ \begin{matrix} x&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;y&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;z&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;Rotation的一般形式，比较复杂，先分成3种情况考虑。所谓的旋转，都要有一个轴线，对任意一个3维坐标系来说，有3条轴，所以就有以3条轴为轴线的3个Rotation：&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta ) =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;cos\theta &amp;amp;-sin\theta &amp;amp;0\\ 0&amp;amp;sin\theta &amp;amp;cos\theta &amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ R_{y}(\theta ) =  \left[ \begin{matrix} cos\theta &amp;amp;0&amp;amp;sin\theta &amp;amp;0\\ 0&amp;amp;1&amp;amp;0&amp;amp;0\\ -sin\theta &amp;amp;0&amp;amp;cos\theta &amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ R_{z}(\theta ) =  \left[ \begin{matrix} cos\theta &amp;amp;-sin\theta &amp;amp;0&amp;amp;0\\ sin\theta &amp;amp;cos\theta &amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;以x轴的旋转分析一下：&lt;/p&gt;

&lt;p&gt;因为：&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta )[x,y,z,w]^{T} = [x,cos\theta \cdot y - sin\theta \cdot z,sin\theta \cdot y + cos\theta \cdot z, w]^{T} \]&lt;/p&gt;

&lt;p&gt;所以有：&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta )[1,0,0,0]^{T} = [1,0,0,0]^{T} \]&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta )[0,1,0,0]^{T} = [0,cos\theta ,sin\theta ,0]^{T} \]&lt;/p&gt;

&lt;p&gt;\[ R_{x}(\theta )[0,0,1,0]^{T} = [0,-sin\theta ,cos\theta ,0]^{T} \]&lt;/p&gt;

&lt;p&gt;可以看出，用Rx旋转x轴,x轴不变,旋转y、z轴，y、z轴会被顺时针旋转\(\theta \)度（左手坐标系时）。&lt;/p&gt;

&lt;p&gt;Rotation有一些特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( R_{\alpha }(0) = I \) 这个0是指\(\theta=0\)，不是向量0&lt;/li&gt;
&lt;li&gt;\( R_{\alpha }(\theta _{1})R_{\alpha }(\theta _{2}) = R_{\alpha }(\theta _{1} + \theta _{2}) \)&lt;/li&gt;
&lt;li&gt;\( R_{\alpha }(\theta _{1})R_{\alpha }(\theta _{2}) = R_{\alpha }(\theta _{2})R_{\alpha }(\theta _{1}) \)&lt;/li&gt;
&lt;li&gt;\( R_{\alpha }^{-1}(\theta ) = R_{\alpha }(-\theta ) = R_{\alpha }^{T}(\theta ) \)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回想下正交矩阵的定义：&lt;strong&gt;如果实数域上的方阵A满足 \( A^{T}A = I \)，则称A为正交矩阵&lt;/strong&gt;，根据上面的第四条性质，R显然也是一个正交矩阵。正交矩阵的好处是，它的逆矩阵很简单，等于它的转置矩阵。&lt;/p&gt;

&lt;p&gt;当需要围绕任意一个向量做旋转时，可以这样想：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设轴向量为a，要被旋转的向量为v&lt;/li&gt;
&lt;li&gt;把a向量当做一个x轴（y or z轴也行）；把v到a的error向量（如果不知道什么是error向量，请看我之前的文章）当做y轴&lt;/li&gt;
&lt;li&gt;以x、y轴向量去计算正交的z轴向量（用叉积即可）&lt;/li&gt;
&lt;li&gt;就得到了一个以a向量为x轴的xyz坐标系了&lt;/li&gt;
&lt;li&gt;所以原问题就变成了，绕这个虚拟坐标系的x轴旋转&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( v_{c} = a\parallel v\parallel cos\alpha = a(v\cdot a) \)&lt;/li&gt;
&lt;li&gt;\( v_{1} = v - v_{c} \)&lt;/li&gt;
&lt;li&gt;\( v_{2} = v_{1}\times a \)&lt;/li&gt;
&lt;li&gt;\( v_{1}^{\prime } =  v_{1}cos\theta + v_{2}sin\theta \) &lt;/li&gt;
&lt;li&gt;\( v^{\prime } = v_{c} + v_{1}^{\prime } \) &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.9/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(书里没有标出来\( v_{c} \) ,红色的那段就是)&lt;/p&gt;

&lt;p&gt;书里也没有解释上面第三个式子是怎么得到的。我的理解是，因为\( v_{1}^{\prime } \)和\( v_{1} \)等长，所以\( v_{1}^{\prime } \)在\( v_{1} \)上的投影(向量)等于\(v_{1}cos\theta \)，又因为\( v_{1} \)是一个坐标系的轴，所以这个投影就是\( v_{1}^{\prime } \)对应这个轴的分量；同理，\(v_{2}sin\theta \)，是\( v_{1}^{\prime } \)在\( v_{2} \)上的投影。这两个投影向量的和，就是\( v_{1}^{\prime } \)。&lt;/p&gt;

&lt;p&gt;不过这个任意轴旋转的矩阵就不那么简单了，先设：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( c = cos\theta  \)&lt;/li&gt;
&lt;li&gt;\( s = sin\theta  \)&lt;/li&gt;
&lt;li&gt;\( x,y,z = normalize(x,y,z) \)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ R_{(x,y,z)}(\theta ) =  \left[ \begin{matrix} x^{2}+(1-x^{2})c&amp;amp;xy(1-c) -zs&amp;amp;xz(1-c)+ys&amp;amp;0\\ xy(1-c)+zs&amp;amp;y^{2}+(1-y^{2})c&amp;amp;yz(1-c)-xs&amp;amp;0\\ xz(1-c)-ys&amp;amp;yz(1-c)+xs&amp;amp;z^{2}+(1-z^{2})c&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;(好可怕的矩阵=。=，不过这世界上还有个东西叫四元数旋转。有空再写一篇四元数的文章）&lt;/p&gt;

&lt;p&gt;LookAt转换&lt;/p&gt;

&lt;p&gt;LookAt矩阵的第4列是摄像机在世界坐标系的坐标；第3列是单位化的视点朝向向量（摄像机的前方），即视点坐标减去第4列的坐标;第2列是单位化的up向量（摄像机的上方），以世界坐标系表示；第1列是摄像机坐标系的x向量在世界坐标系对应的向量。&lt;/p&gt;

&lt;p&gt;第1列的x向量，是用第2列的up向量和第3列的朝向向量进行叉积得到。&lt;/p&gt;

&lt;p&gt;设：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pos是摄像机坐标（世界坐标）&lt;/li&gt;
&lt;li&gt;up是用户提供的摄像机朝向上方的向量（世界坐标）&lt;/li&gt;
&lt;li&gt;look是用户提供的摄像机视点的向量（世界坐标）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dir = Normalize(look - pos)，摄像机的朝向向量（世界坐标）&lt;/li&gt;
&lt;li&gt;xaxis = Normalize(Cross(Normalize(up), dir))，摄像机的x轴单位向量（世界坐标）&lt;/li&gt;
&lt;li&gt;newUp = Cross(Normalize(dir), xaxis)，新的单位化的up向量（世界坐标）。这里不太明白为什么不直接newUp = Normalize(up)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[  \left[ \begin{matrix} xaxis.x&amp;amp;newUp.x&amp;amp;dir.x&amp;amp;pos.x\\ xaxis.y&amp;amp;newUp.y&amp;amp;dir.y&amp;amp;pos.y\\ xaxis.z&amp;amp;newUp.z&amp;amp;dir.z&amp;amp;pos.z\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h3&gt;Tranform的应用原理&lt;/h3&gt;

&lt;p&gt;Tranform对Vector和Point的作用过程，上面已经提到了，就是简单的矩阵相乘。&lt;/p&gt;

&lt;p&gt;对Ray和BBox的转换，也不难，就是对Ray的o和d分量分别左乘T、对BBox的8个顶点分别左乘T。&lt;/p&gt;

&lt;p&gt;这里要提一下法向量的Tranform。法向量是不能直接T(n)的，这是错误的。&lt;/p&gt;

&lt;p&gt;直接贴公式：&lt;/p&gt;

&lt;p&gt;\[ n\cdot t = n^{T}t = 0 \]
\[ (n^{\prime })^{T}t^{\prime }= 0 \]
\[ (Sn)^{T}Mt = 0 \]
\[ n^{T}S^{T}Mt = 0 \]
\[ S^{T}M = I \]
\[ n^{\prime } = Sn = (M^{-1})^{T}n \]&lt;/p&gt;

&lt;p&gt;M是某种转换，当M对一个面作用时，这个面的法向量要用上面最后那条公式转换。注意到公式里面有一个逆矩阵，所以这就是为什么Transform要存一个逆矩阵。&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/pbrt-chapter2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/pbrt-chapter2/</guid>
      </item>
    
      <item>
        <title>&lt;复习向&gt;线性代数之矩阵的特征值、特征向量、特征矩阵、迹</title>
        <description>&lt;h2&gt;定义&lt;/h2&gt;

&lt;p&gt;设A是数域F上的n阶矩阵，如果存在数域F中的一个数\(\lambda \)与数域上F的非零向量\(\alpha \)，使得：
\[ A\alpha = \lambda \alpha \]
则称\(\lambda \)为A的一个&lt;strong&gt;特征值(根)&lt;/strong&gt;(eigenvalue)，称\(\alpha \)为A的属于特征值\(\lambda \)的&lt;strong&gt;特征向量&lt;/strong&gt;(eigenvector)。&lt;/p&gt;

&lt;p&gt;\( A\alpha \)和\(\alpha \)平行（即在同一个直线上。&lt;/p&gt;

&lt;p&gt;\(\lambda E - A\)为A的&lt;strong&gt;特征矩阵&lt;/strong&gt;，行列式\(f(\lambda ) = |\lambda E - A|\)为A的&lt;strong&gt;特征多项式&lt;/strong&gt;，\(|\lambda E - A| = 0\)为A的&lt;strong&gt;特征方程&lt;/strong&gt;,\((\lambda E - A)X=0\)是A关于该\(\lambda \)的&lt;strong&gt;齐次线性方程组&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;A的主对角线上元素之和称为A的&lt;strong&gt;迹&lt;/strong&gt;(trace)，记为tr(A)，即&lt;/p&gt;

&lt;p&gt;\[ tr(A) = a_{11} + a_{11} + \cdots + a_{nn} \]&lt;/p&gt;

&lt;p&gt;迹和特征值有很重要的联系：&lt;/p&gt;

&lt;p&gt;\[ tr(A) = \lambda _{1} + \lambda _{2} + \cdots + \lambda _{n} \]&lt;/p&gt;

&lt;p&gt;迹还和A的行列式有关系：&lt;/p&gt;

&lt;p&gt;\[ |A| = \lambda _{1}\lambda _{2}\cdots \lambda _{n} \]&lt;/p&gt;

&lt;h2&gt;A的全部特征值和特征向量的求法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;计算A的特征多项式&lt;/li&gt;
&lt;li&gt;求特征方程的全部根，即矩阵A的全部特征值&lt;/li&gt;
&lt;li&gt;对于A的每一个特征值\(\lambda \)，求其相应的齐次线性方程组的一个基础解系\(\eta _{1},\eta _{2},\cdots \eta _{n-r}\)，其中\(r=r(\lambda E - A)\)，即r为矩阵A的特征矩阵的秩，A的属于该\(\lambda \)的全部特征向量为:
\[ k_{1}\eta _{1} + k_{2}\eta _{2} + \cdots + k_{n-r}\eta _{n-r} \]
其中\(k_{1},k_{2},\cdots ,k_{n-r}\)是数域F上的一组不全为零的任意常数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;特征值的性质&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;\(\lambda _{n} \)为矩阵\(A_{n} \)的特征值（n为正整数）&lt;/li&gt;
&lt;li&gt;A可逆时，\(1/\lambda \)为\(A^{-1}\)的特征值&lt;/li&gt;
&lt;li&gt;矩阵A与其转置矩阵\(A^{T}\)有相同的特征值&lt;/li&gt;
&lt;li&gt;\(k\lambda \)是矩阵kA的特征值(k是任意常数)。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;迹的性质&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;\( tr(A + B) = tr(A) + tr(B) \)&lt;/li&gt;
&lt;li&gt;\( tr(kA) = k\cdot tr(A) \)&lt;/li&gt;
&lt;li&gt;\( tr(A^{T}) = tr(A) \)&lt;/li&gt;
&lt;li&gt;\( tr(AB) = tr(BA) \)&lt;/li&gt;
&lt;li&gt;\( tr(ABC) = tr(BCA) = tr(CAB) \)&lt;/li&gt;
&lt;li&gt;设A、B为n阶方阵，P为n阶可逆矩阵，且\(P^{-1}AP = B \)，则有\(tr(A) = tr(B)\)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;当A为投影矩阵P时&lt;/h2&gt;

&lt;p&gt;因为投影矩阵P可以把一个向量b投影到一个空间的某一个向量，也就是\(Pb = p\)，这个式子和\( A\alpha = \lambda \alpha \)有一致的地方。&lt;/p&gt;

&lt;p&gt;那么P的特征向量是什么呢？前面已经说到，\( A\alpha \)和\( \alpha \)是平行关系，那么就是说，如果b在P的列空间之外，b就不是P的特征向量，当b在P的列空间内时，b是P的特征向量。&lt;/p&gt;

&lt;p&gt;比如当P对应一个平面时，这个平面内的任意一个向量x都是特征向量（因为\(Px = x\)，P作用于x后还是得到x)&lt;/p&gt;

&lt;p&gt;又因为\(Px = x = 1\cdot x\)，所以P的一个特征值是1。&lt;/p&gt;

&lt;p&gt;但是，P还有其他的特征值。当向量x正交于P的列空间时，有\(Px = 0 \)。所以P的另一个特征值为0。&lt;/p&gt;

&lt;h2&gt;当A为旋转矩阵Q时&lt;/h2&gt;

&lt;p&gt;因为旋转矩阵可以改变一个向量的方向，那么这个矩阵是否有特征值？事实是有的，但是是复数。&lt;/p&gt;

&lt;p&gt;\[ Q =  \left[ \begin{matrix} cos(90)&amp;amp;-sin(90)\\ sin(90)&amp;amp;cos(90)\\ \end{matrix} \right] =  \left[ \begin{matrix} 0&amp;amp;-1\\ 1&amp;amp;0\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ |Q| = 0 - (-1) = 1 = \lambda _{1}\lambda _{2} \]
\[ tr(Q) = 0 = \lambda _{1} + \lambda _{2} \]&lt;/p&gt;

&lt;p&gt;显然，\( \lambda _{1}\lambda _{2}\)无实数域的解，但是有复数解i和-i。&lt;/p&gt;

&lt;h2&gt;A的对角化(diagonalize)&lt;/h2&gt;

&lt;p&gt;设n阶方阵A存在n个线性无关的特征向量\(x_{i}\)，将这n个特征向量组成方阵S(也称为特征向量矩阵），则有：&lt;/p&gt;

&lt;p&gt;\[ AS = A \left[ \begin{matrix} x_{1}&amp;amp;x_{2}&amp;amp;\cdots &amp;amp;x_{n}\\ \end{matrix} \right] =  \left[ \begin{matrix} \lambda _{1}x_{1}&amp;amp;\lambda _{2}x_{2}&amp;amp;\cdots &amp;amp;\lambda _{n}x_{n}\\ \end{matrix} \right] \] 
\[    =  \left[ \begin{matrix} x_{1}&amp;amp;x_{2}&amp;amp;\cdots &amp;amp;x_{n}\\ \end{matrix} \right] \left[ \begin{matrix} \lambda _{1}&amp;amp;0&amp;amp;\cdots &amp;amp;0\\ 0&amp;amp;\lambda _{2}&amp;amp;\cdots &amp;amp;0\\ \vdots &amp;amp;\vdots&amp;amp; \cdots &amp;amp;\vdots\\ 0&amp;amp;0&amp;amp;\cdots &amp;amp;\lambda _{n}\\ \end{matrix} \right] \]
\[ = S\Lambda \]&lt;/p&gt;

&lt;p&gt;所以有：&lt;/p&gt;

&lt;p&gt;\[ A = S\Lambda S^{-1} \]&lt;/p&gt;

&lt;p&gt;这个式子称为A的\(S\Lambda S^{-1}\)分解，或特征分解(Eigendecomposition)。&lt;/p&gt;

&lt;p&gt;可以对角化的前提是A有n个线性无关的特征向量。A有n个线性无关的特征向量的前提是，所有的\(\lambda \)都不重复（没有重根）。&lt;/p&gt;

&lt;p&gt;BTW，对于A的幂，有一个性质：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果有 \( Ax = \lambda x \)，则有\( A^{2}x = AAx = \lambda Ax = \lambda \lambda x = \lambda ^{2}x\) &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( A^{2} = S\Lambda S^{-1}S\Lambda S^{-1} = S\Lambda ^{2}S^{-1} \)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个性质说明，A的n次幂的特征值等于\(\lambda ^{n}\)，且无论n等于多少(当前n得是正整数），特征向量不变。&lt;/p&gt;

&lt;p&gt;这也是求矩阵的n次幂的快速解法。&lt;/p&gt;

&lt;p&gt;特征分解还有一个用法是，求A的逆矩阵:&lt;/p&gt;

&lt;p&gt;\[ A^{-1} = (S\Lambda S^{-1})^{-1} =S\Lambda ^{-1}S^{-1} \]&lt;/p&gt;

&lt;p&gt;\(\Lambda\)的逆矩阵是非常容易求的，因为它是一个对角矩阵，所以把对角线上的\(\lambda \)都变成\(1/\lambda \)即可。&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-6/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-6/</guid>
      </item>
    
      <item>
        <title>&lt;复习向&gt;线性代数之正交矩阵</title>
        <description>&lt;h2&gt;基础知识&lt;/h2&gt;

&lt;p&gt;标准正交向量组（Orthonormal vectors）的点积(内积)性质：&lt;/p&gt;

&lt;p&gt;\( q_{i}^{T}q_{j} = 0 \) &lt;strong&gt;if&lt;/strong&gt; \( i\neq j \)&lt;/p&gt;

&lt;p&gt;\( q_{i}^{T}q_{j} = 1 \) &lt;strong&gt;if&lt;/strong&gt; \( i = j \)&lt;/p&gt;

&lt;p&gt;其中每个正交向量的长度\(||q_{i}||=1\)。&lt;/p&gt;

&lt;p&gt;标准正交向量组成的矩阵是：&lt;/p&gt;

&lt;p&gt;\( Q = \) \(  \left[ \begin{matrix} q_{1}&amp;amp;\cdots&amp;amp;q_{n}\\ \end{matrix} \right] \)&lt;/p&gt;

&lt;p&gt;注意，列向量的分量数量未知，Q所以不一定是方阵。&lt;/p&gt;

&lt;p&gt;\( Q^{T}Q =  \left[ \begin{matrix} q_{1}^{T}\\ \vdots\\ q_{n}^{T}\\ \end{matrix} \right] \left[ \begin{matrix} q_{1}&amp;amp;\cdots&amp;amp;q_{n}\\ \end{matrix} \right] = I \)&lt;/p&gt;

&lt;p&gt;当Q是方阵时，显然Q有逆矩阵，且\( Q^{-1} = Q^{T} \)。&lt;/p&gt;

&lt;p&gt;比如当Q为3阶单位矩阵I的置换矩阵时：&lt;/p&gt;

&lt;p&gt;\( Q^{T}Q =  \left[ \begin{matrix} 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ 1&amp;amp;0&amp;amp;0\\ \end{matrix} \right] \left[ \begin{matrix} 0&amp;amp;0&amp;amp;1\\ 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ \end{matrix} \right] = I \)&lt;/p&gt;

&lt;p&gt;或者三角函数作为元素的二阶Q：&lt;/p&gt;

&lt;p&gt;\( Q^{T}Q =  \left[ \begin{matrix} cos\theta&amp;amp;-sin\theta\\ sin\theta&amp;amp;cos\theta\\ \end{matrix} \right]  \left[ \begin{matrix} cos\theta&amp;amp;sin\theta\\ -sin\theta&amp;amp;cos\theta\\ \end{matrix} \right] = I \)&lt;/p&gt;

&lt;h2&gt;定义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果实数域上的方阵A满足 \( A^{T}A = I \)，则称A为正交矩阵&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当A的列向量的长度都为1时，称A为标准正交矩阵Q。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;定理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;当\(A^{-1} = A^{T}\)成立时A是正交矩阵&lt;/li&gt;
&lt;li&gt;A的列(或行)向量组是\(R^{n}\)的一组标准正交基时，A是正交矩阵&lt;/li&gt;
&lt;li&gt;正交矩阵A的行列式为1或-1&lt;/li&gt;
&lt;li&gt;如果A是正交矩阵，则\(A^{-1},A^{T},A^{*}\)都是正交矩阵&lt;/li&gt;
&lt;li&gt;如果A、B都是正交矩阵，那么AB也是正交矩阵&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;正交矩阵怎么用？&lt;/h2&gt;

&lt;p&gt;在上一篇文章中，讲到了投影矩阵的各种公式，其中有一条是：&lt;/p&gt;

&lt;p&gt;\[ A^{T}A\hat{x} = A^{T}b \]&lt;/p&gt;

&lt;p&gt;这个戴着帽子的x是未知量，要求它的值，就需要再变换下：&lt;/p&gt;

&lt;p&gt;\[ \hat{x} = (A^{T}A)^{-1}A^{T}b \]&lt;/p&gt;

&lt;p&gt;那么问题来了：右边的式子有点复杂，又要算矩阵乘法又要算逆矩阵，是不是可以简化呢？&lt;/p&gt;

&lt;p&gt;答案是可以，且要用到正交矩阵。因为A是由一组线性无关的列向量组成，当把这组向量转换为标准正交向量组时，就得到了标准正交矩阵Q。拿Q代入上面的式子，得到：&lt;/p&gt;

&lt;p&gt;\[ Q^{T}Q\hat{x} = Q^{T}b \]&lt;/p&gt;

&lt;p&gt;再根据上述的Q的公式，干掉左边的2个Q，得到：&lt;/p&gt;

&lt;p&gt;\[ \hat{x} = Q^{T}b \]&lt;/p&gt;

&lt;p&gt;瞬间豁然开朗。&lt;/p&gt;

&lt;p&gt;但是还有一个问题，怎么从A得到Q呢？&lt;/p&gt;

&lt;h2&gt;矩阵的正交化算法&lt;/h2&gt;

&lt;p&gt;因为从A可以得到Q，所以必然某个矩阵R，使得 A = QR 成立，这个过程叫做A的QR分解（QR decomposition)。&lt;/p&gt;

&lt;h3&gt;先举一个二维的例子：&lt;/h3&gt;

&lt;p&gt;设 a1 = (3,4)、a2 = (4,3)，显然a1和a2线性无关（不在同一条直线上），且a1和a2的长度都不是1。a1、a2是二维空间的一组基(basis)。&lt;/p&gt;

&lt;p&gt;a1,a2对应的矩阵为：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} a_{1}&amp;amp;a_{2}\\ \end{matrix} \right] =  \left[ \begin{matrix} 3&amp;amp;4\\ 4&amp;amp;3\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;显然，A是一个方阵。接下来就是实现A的QR分解。&lt;/p&gt;

&lt;p&gt;标准正交矩阵，可以分为2个步骤实现：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;正交化(orthogonal)&lt;/li&gt;
&lt;li&gt;标准化(normalize)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二维空间下，让2个向量正交化，即等于是要找出2个互相垂直的向量。怎么找最简单呢？因为这样的向量组无限多，于是a1或a2都可以是某组正交向量的其中一个向量。&lt;/p&gt;

&lt;p&gt;那么，我们可以让a1作为一个正交向量，然后再找出一个与a1垂直的向量，就得到一组正交向量了。&lt;/p&gt;

&lt;p&gt;设u1、u2为要求的标准正交向量组，n1、n2代表a1、a2的单位向量，那么可以有：&lt;/p&gt;

&lt;p&gt;\[ u_{1} = n_{1} \]&lt;/p&gt;

&lt;p&gt;u2怎么求？很简单，利用投影矩阵的知识即可完成。因为a2和a1线性无关，那么a2在a1上有且只有一个投影点p2，算出这个投影点p2，就能快速得到a2关于a1的error向量：&lt;/p&gt;

&lt;p&gt;\[ e_{2} = a_{2} - p_{2} \]&lt;/p&gt;

&lt;p&gt;为什么要算e2向量？因为e2向量的一个重要性质是，e2和a1是互相垂直的，换句话说就是，&lt;strong&gt;e2和a1正交!&lt;/strong&gt;。有了e2，将其单位化后，就是u2了。&lt;/p&gt;

&lt;p&gt;求u2的步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先求n1，即a1的单位向量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ n_{1} = \dfrac { a_{1} }{ ||a_{1}|| } \] &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;求出a2的投影点p2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ p_{2} = n_{1}\dfrac { n_{1}^{T}a_{2} }{  n_{1}^{T} n_{1} } = n_{1}(n_{1}^{T}a_{2}) \] &lt;/p&gt;

&lt;p&gt;那个分母为什么可以去掉呢？这是因为n1是单位向量，\( n_{1}^{T} n_{1} \)是n1的内积，显然这个内积等于1。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;求e2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ e_{2} = a_{2} - p_{2} = a_{2} - n_{1}(n_{1}^{T}a_{2}) \]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单位化e2，得到u2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ u_{2} = \dfrac { e_{2} }{ ||e_{2}|| } \]&lt;/p&gt;

&lt;p&gt;好了，公式出来了，拿上面的例子验证下：&lt;/p&gt;

&lt;p&gt;\[ u_{1} = n_{1} = \dfrac { a_{1} }{ ||a_{1}|| } = (\dfrac {3}{5},\dfrac {4}{5} ) \]&lt;/p&gt;

&lt;p&gt;\[ e_{2} = a_{2} - p_{2} = a_{2} - n_{1}(n_{1}^{T}a_{2}) = (\dfrac {28}{25},\dfrac {-21}{25}) \]&lt;/p&gt;

&lt;p&gt;\[ u_{2} = \dfrac { e_{2} }{ ||e_{2}|| } = (\dfrac {4}{5},\dfrac {-3}{5}) \]&lt;/p&gt;

&lt;p&gt;\[ u_{1} \cdot u_{2} = (\dfrac {3}{5},\dfrac {4}{5}) \cdot (\dfrac {4}{5},\dfrac {-3}{5}) = 0 \]&lt;/p&gt;

&lt;p&gt;u1和u2的内积为0，且长度均为1，所以U1和u2是一组标准正交向量。&lt;/p&gt;

&lt;p&gt;\[ Q =  \left[ \begin{matrix} u_{1}&amp;amp;u_{2}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h3&gt;高维时的通用QR解法&lt;/h3&gt;

&lt;p&gt;上面是维度为2时的QR分解过程，接下来谈谈3维以及n维的情况。&lt;/p&gt;

&lt;p&gt;当维度为3时，还是比较好想象的，我们分步构想下QR分解过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A矩阵由3个线性无关的向量构成，A的列空间是一个三维空间，即三维空间的任意一个点都可以通过线性组合这3个向量得到&lt;/li&gt;
&lt;li&gt;设3个向量为a1、a2、a3，先对a1、a2进行正交化运算，过程和上述的一致，除了\(a_{i}\)变成了3个分量。&lt;/li&gt;
&lt;li&gt;正交化a1、a2，就得到了a1、a2对应的平面空间的一组标准正交基u1、u2&lt;/li&gt;
&lt;li&gt;于是原问题变成：求解u1、u2、a3的正交化。u1和u2已经是标准正交向量，不用管它们，问题就是求出u3。&lt;/li&gt;
&lt;li&gt;a3是在u1、u2对应的平面&lt;strong&gt;之外&lt;/strong&gt;的一个点，a3在这个平面上有且只有一个投影点p3，将它求出来&lt;/li&gt;
&lt;li&gt;再求出\( e_{3} = a_{3} - p_{3} \)就得到了a3的error向量，该向量垂直于u1、u2平面！&lt;/li&gt;
&lt;li&gt;将e3标准化后，就得到了u3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;n&amp;gt;3维的情况，可以用归纳法解出。&lt;/p&gt;

&lt;p&gt;高维情况下的QR分解，公式如下：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} a_{1}&amp;amp;a_{2}&amp;amp;\cdots&amp;amp;a_{n}\\ \end{matrix} \right] \]
\[ A =  \left[ \begin{matrix} u_{1}&amp;amp;u_{2}&amp;amp;\cdots&amp;amp;u_{n}\\ \end{matrix} \right] \left[ \begin{matrix} a_{1}\cdot u_{1}&amp;amp;a_{2}\cdot u_{1}&amp;amp;\cdots &amp;amp;a_{n}\cdot u_{1}\\ 0&amp;amp;a_{2}\cdot u_{2}&amp;amp;\cdots &amp;amp;a_{n}\cdot u_{2}\\ \vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots\\ 0&amp;amp;0&amp;amp;\cdots &amp;amp;a_{n}\cdot u_{n}\\ \end{matrix} \right] = QR \]&lt;/p&gt;

&lt;p&gt;Q是标准正交矩阵，R是上三角矩阵。&lt;/p&gt;

&lt;p&gt;证明过程略，不过可以简单分析下这公式的正确性。&lt;/p&gt;

&lt;p&gt;Q乘以R的结果是A矩阵，那么可以得到：&lt;/p&gt;

&lt;p&gt;\[ a_{1} = u_{1}(a_{1}\cdot u_{1}) \]&lt;/p&gt;

&lt;p&gt;这个式子，是不是很眼熟，其实就是投影公式：&lt;/p&gt;

&lt;p&gt;\[ p_{1} = a_{1} = u_{1}\dfrac { u_{1}^{T}a_{1} }{  u_{1}^{T} u_{1} } = u_{1}(u_{1}^{T}a_{1}) = u_{1}(a_{1}\cdot u_{1}) \] &lt;/p&gt;

&lt;p&gt;（后面的内积有2种写法，同个意思，不用在意）&lt;/p&gt;

&lt;p&gt;这个式子说明，经过QR分解后，a1的投影点还是a1，且在u1上。（但a1不一定等于u1）&lt;/p&gt;

&lt;p&gt;我把a2也写出来：&lt;/p&gt;

&lt;p&gt;\[ a_{2} = u_{1}(a_{2}\cdot u_{1}) + u_{2}(a_{2}\cdot u_{2}) \]&lt;/p&gt;

&lt;p&gt;类似a1，a2 = a2在u1的投影 + a2在u2的投影。（注意：a2一定不在u上，因为这样a1和a2就线性有关了；a2不一定在u2上）&lt;/p&gt;

&lt;p&gt;然后a3，就不用写了，显然a3 = a3在u1的投影 + a3在u2的投影 + a3在u2的投影。&lt;/p&gt;

&lt;p&gt;\(a_{n}\)以此类推。所以这个公式是OK的。&lt;/p&gt;

&lt;p&gt;总结一下：&lt;/p&gt;

&lt;p&gt;要对A做QR分解，得从A本身出发，算出各个标准正交向量，并且这是一个迭代的过程：从a1算出u1，再通过a2和u1得到u2，接着，\(u_{n}\)都可以通过\(a_{n}\)和前面算出来的\(u_{i}\ \ (i&amp;lt;n)\)得到。&lt;/p&gt;

&lt;p&gt;如果QR分解的目的只是为了得到Q矩阵，那么R矩阵是没什么卵用的，因为R矩阵本身也包含了目标变量n，所以没办法用\(Q=AR^{-1}\)公式求Q矩阵。&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-5/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-5/</guid>
      </item>
    
      <item>
        <title>&lt;复习向&gt;线性代数之投影矩阵</title>
        <description>&lt;h2&gt;投影矩阵是what？&lt;/h2&gt;

&lt;p&gt;先给出结论：投影矩阵P（projection），可以把一个向量b，投影到一个“空间”上，投影点称为p，从p到b的向量称为e，e = b - p，e的含义是误差向量（error）。&lt;/p&gt;

&lt;p&gt;再举例子帮助读者理解：&lt;/p&gt;

&lt;h2&gt;上述的“空间”为一维时&lt;/h2&gt;

&lt;p&gt;一个向量b，投影到一个一维的空间，显然，这个空间是一条直线，设直线为单位向量a，那么这个投影其实就是找到这个直线上离b最近的点p，误差向量e就是b到p的距离。因为p在a上，所以有：&lt;/p&gt;

&lt;p&gt;p = ax（p和a都是向量，x是一个值）【式子1】&lt;/p&gt;

&lt;p&gt;然后，因为p是b在a上的投影，那么意味着，a与e成90度角，当2个向量互相垂直时，他们的点积（或 内积、 dot product）等于0，于是有：&lt;/p&gt;

&lt;p&gt;\[ a^{T}e = 0 \]&lt;/p&gt;

&lt;p&gt;\[ a^{T}(b-xa) = 0 \]&lt;/p&gt;

&lt;p&gt;再变换一下，得到：&lt;/p&gt;

&lt;p&gt;\[ xa^{T}a = a^{T}b  \]&lt;/p&gt;

&lt;p&gt;\[ x = \dfrac { a^{T}b }{ a^{T}a } \]&lt;/p&gt;

&lt;p&gt;根据【式子1】，最后得到：&lt;/p&gt;

&lt;p&gt;\[ p = a\dfrac { a^{T}b }{ a^{T}a } 【式子2】 \] &lt;/p&gt;

&lt;p&gt;看，式子左边的p是投影向量，右边有b和a，b是原向量，a是空间向量。所以这个式子隐含了一个变换关系：从b通过某种变换能够得到p。所谓的投影矩阵P（注意，是大写），就在这个式子里面了。&lt;/p&gt;

&lt;p&gt;投影矩阵P应该有这样的效果：&lt;/p&gt;

&lt;p&gt;\[ p = Pb  \]&lt;/p&gt;

&lt;p&gt;P作用于任意一个向量b，能够得到b在某个空间的投影点p。&lt;/p&gt;

&lt;p&gt;注意: &lt;strong&gt;P是一个矩阵，不是一个数！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;【式子2】应该要变换成什么样子，才能变出一个矩阵呢？答案如下：&lt;/p&gt;

&lt;p&gt;\[ p = \dfrac { aa^{T} }{ a^{T}a }b \] &lt;/p&gt;

&lt;p&gt;投影矩阵P：&lt;/p&gt;

&lt;p&gt;\[ P = \dfrac { aa^{T} }{ a^{T}a } \] &lt;/p&gt;

&lt;p&gt;式子右边是一个矩阵，这是因为分子是\(aa^{T}\)，这不是一个数，而是一个矩阵（分母才是一个数）。（顺序很重要！）&lt;/p&gt;

&lt;p&gt;投影矩阵P的2条重要性质：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;\( P = P^{T} \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( P^{n} = P \) , n为正整数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二条性质说明，投影点p再次经过同一个投影变换，依然还是p。这样的矩阵称为幂等矩阵。&lt;/p&gt;

&lt;h2&gt;投影的实际意义?&lt;/h2&gt;

&lt;p&gt;为什么要找投影点，这是因为，当我们要计算线性方程组 \( Ax=b \)的解时，它可能是无解的。怎么办呢？既然没有正解，就找最优解！最优解就是找一个和b最近的p，并求解\( A\hat{x}=p \)。&lt;/p&gt;

&lt;h2&gt;上述的“空间”为二维时&lt;/h2&gt;

&lt;p&gt;一个向量b，投影到一个二维的空间，显然，这个空间是一个平面。一个平面，可以由2个线性无关（independant)的向量\(a_{1}\)和\(a_{2}\)确定。a1和a2是这个平面的一组基（basis）。&lt;/p&gt;

&lt;p&gt;一组基可以写成矩阵的形式：&lt;/p&gt;

&lt;p&gt;\[ A = [ \ a_{1}\ \ a_{2} ] \ \] 【式子3】&lt;/p&gt;

&lt;p&gt;和一维情况做一个对比：&lt;/p&gt;

&lt;p&gt;投影点p，在一维时 p = ax。那么，在二维平面上呢？显然，p可以由这个平面的基得到：\( p = \hat{x_{1}}a_{1}+x_{2}a_{2} \)。&lt;/p&gt;

&lt;p&gt;根据【式子3】可以得到：&lt;/p&gt;

&lt;p&gt;\[ p = A\hat{x} \]&lt;/p&gt;

&lt;p&gt;\[ e = b - p = b - A\hat{x} \]&lt;/p&gt;

&lt;p&gt;上述一维的情况时的那个e，在二维时也是一样的，e会垂直于这个空间，也就是e和这个平面是垂直的。&lt;/p&gt;

&lt;p&gt;因为e和平面垂直，平面的基是\(a_{1}\)和\(a_{2}\)，即a与\(a_{1}\)和\(a_{2}\)垂直，所以：&lt;/p&gt;

&lt;p&gt;\[ a_{1}^{T}(b - A\hat{x}) = 0 \]&lt;/p&gt;

&lt;p&gt;\[ a_{2}^{T}(b - A\hat{x}) = 0 \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} a_{1}^{T}\\ a_{2}^{T}\\ \end{matrix} \right] (b - A\hat{x}) =  \left[ \begin{matrix} 0\\ 0\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ A^{T}(b - A\hat{x}) = 0 \]&lt;/p&gt;

&lt;p&gt;\[ A^{T}A\hat{x} = A^{T}b \]&lt;/p&gt;

&lt;p&gt;这和一维情况的其中一个式子很像，对吧。 但\(A^{T}A\)是一个高维的东西，它不是一个数，而是一个矩阵。&lt;/p&gt;

&lt;p&gt;再变换一下，得到：&lt;/p&gt;

&lt;p&gt;\[ \hat{x} = (A^{T}A)^{-1}A^{T}b \]&lt;/p&gt;

&lt;p&gt;所以投影点p和b的变换公式就是：&lt;/p&gt;

&lt;p&gt;\[ p = A\hat{x} = A(A^{T}A)^{-1}A^{T}b \]&lt;/p&gt;

&lt;p&gt;抽出投影矩阵：&lt;/p&gt;

&lt;p&gt;\[ P = A(A^{T}A)^{-1}A^{T} 【式子4】\]&lt;/p&gt;

&lt;p&gt;这条式子，中间的括号假如可以去掉的话，就变成了：&lt;/p&gt;

&lt;p&gt;\[ P = A A^{-1} (A^{T})^{-1} A^{T} \]&lt;/p&gt;

&lt;p&gt;\[ P = II = I \]&lt;/p&gt;

&lt;p&gt;为什么P变成了单位矩阵I呢？这是因为把\( (A^{T}A)^{-1} \)解开的前提是&lt;strong&gt;A是一个方阵&lt;/strong&gt;。但就现在这个二维平面的例子而言，A由2个基构成（（每个基有3个分量），A并不是方阵，所以是不能解开的。上述的变换是错误的。&lt;/p&gt;

&lt;p&gt;当A是方阵时，意味着有3个基，而又因为基之间线性无关，所以方阵A不可能只是代表一个平面空间，实际上，A代表的是一个三维空间。所以，一个在三维空间的点b，投影到三维空间后，当然还是b。所以A是方阵时，投影矩阵就是单位矩阵I。&lt;/p&gt;

&lt;p&gt;当A不是方阵时，要按照【式子4】去求投影矩阵P。&lt;/p&gt;

&lt;p&gt;另外，在高维情况下，P的那2条性质依然成立。&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-4/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-4/</guid>
      </item>
    
      <item>
        <title>More Effective C++ 笔记</title>
        <description>&lt;h2&gt;基础议题(basics)&lt;/h2&gt;

&lt;h3&gt;条款1：仔细区别pointers和references&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用引用，可以不做null判断&lt;/li&gt;
&lt;li&gt;当需要考虑“不指向任何对象”的可能性时，或是考虑“在不同时间指向不同对象”的能力时，你就应该采用pointer，前一种情况可以将pointer设为null，后一种情况可以改变pointer所指对象。&lt;/li&gt;
&lt;li&gt;当确定“总是会代表某个对象”，而且“一旦代表了该对象就不能够再改变”，那么应该选用reference。&lt;/li&gt;
&lt;li&gt;总是令operator[]返回一个reference。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;条款2：最好使用C++转型操作符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;需要使用类型转换时，先考虑能不能用static_cast&lt;/li&gt;
&lt;li&gt;不能用static_cast的情况有：

&lt;ul&gt;
&lt;li&gt;移除表达式的常量性(constness)或变易性(volatileness) [用const_cast]&lt;/li&gt;
&lt;li&gt;继承体系的转型 [用dynamic_cast]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;const_cast无法进行继承体系的向下转型(cast down)&lt;/li&gt;
&lt;li&gt;dynamic_cast无法用在缺乏虚函数的类型身上，也不能改变常量性&lt;/li&gt;
&lt;li&gt;reinterpret_cast不具移植性，是平台相关的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;条款3：绝对不要以多态(polymorphically)方式处理数组&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printBSTArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ostream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BST&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numElements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numElements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BST&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BSTArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BalanceBST&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bBSTArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printBSTArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BSTArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//OK&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printBSTArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bBSTArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//Not OK&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;array[i]其实是一个“指针算术表达式”的简写；它代表的其实是* (array+i)。array所指内存和array+i所指内存的距离是i&lt;em&gt;sizeof(数组中的单个元素)。而因为printBSTArray中，声明了array的元素的类型为BST，所以距离是i&lt;/em&gt;sizeof(BST)。但当传入的是BalanceBST的数组时，就会出错了。&lt;/p&gt;

&lt;p&gt;在删除数组时，也有这个问题，C++语言规范中说，通过base class指针删除一个由derived classes objects构成的数组，其结果未定义。&lt;/p&gt;

&lt;p&gt;总的一句话：多态和指针算术不能混用，数组对象几乎总是会涉及指针的算法运算，所以数组和多态不要混用。&lt;/p&gt;

&lt;h3&gt;条款4：非必要不提供 default constructor&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;有default constructor时，可以避免3个问题，一是类数组的初始化不支持带参数的构造函数，二是一些c++模板库，要求被实例化的目标类型必须要有default constructor，三是类的虚继承体系中，如果基类没有default constructor，那么每一层的子类都必须了解基类的构造函数。&lt;/li&gt;
&lt;li&gt;反过来看，使用default constructor时，可能会增加了类的复杂度，因为不能保证每个字段都有意义（default constructor导致赋予字段一个缺省值，这个缺省值可能是多余的）。并且，使用这些字段的调用者，都需要做一个“测试”，测试字段是否真的被初始化了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;操作符(operators)&lt;/h2&gt;

&lt;h3&gt;条款5：对定制的“类型转换函数”保持警觉&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用一个普通函数来替代类型转换操作符。因为这种操作符重载是&amp;quot;隐式(implicit)&amp;quot;的：
&lt;code&gt;c
class Rational{
public:
operator double() const; //not good
double asDouble() const; //good
}
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单自变量构造函数，前面要加一个explicit声明。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用proxy classes 技术时，可以使用隐式类型转换，因为不能连续执行多个类型转换行为（详情见条款30）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;条款6：区别 increment/decrement操作符的前置和后置形式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;后置式应以其前置式为基础（即后置式的函数体的累加实现，是调用了前置式）。&lt;/li&gt;
&lt;li&gt;后置式的返回类型必须加const，从而禁止obj++++这种写法。&lt;/li&gt;
&lt;li&gt;后置式的函数声明的参数要带一个毫无意义的int，只是用来和前置式做区分。&lt;/li&gt;
&lt;li&gt;虽然禁止obj+++++，但是++++obj是允许的。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UPInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UPInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UPInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m_num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UPInt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;UPInt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;条款7：千万不要重载&amp;amp;&amp;amp;、||和, 操作符&lt;/h3&gt;

&lt;p&gt;直接贴上我写的一个代码片段：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;get:&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;a &amp;amp;&amp;amp; b = &amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;nl&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a &amp;amp;&amp;amp; b这个表达式，b先求值了，这不反人类么。&lt;/p&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;amp;&amp;amp; || , 被重载后，“函数调用语义” 会取代 “骡死式语义”。前者的求值顺序是未定义的（C++规范里没有定义），后者必然是从左至右。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;条款8：了解各种不同意义的new和delete&lt;/h3&gt;

&lt;h4&gt;关于new&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;new operator是指：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样子的代码里的new。这个操作符是由语言内建的，就像sizeof一样，不能被改变意义，总是做相同的事情。它的动作分为2个方面，第一，它分配足够的内存，用来放置某类型的对象；第二，它调用一个constructor，为刚才分配的内存中的那个对象设定初值。new operator总是做这两件事，你无法改变其行为。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;operator new的一般用法，用来分配且仅分配内存（不调用构造函数）：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;member=&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawMemory&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rawMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rawMemory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rawMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x306850&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pm0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;placement new 用法：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;constructWidgetInBuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Widget&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;constructWidgetInBuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;使用策略：如果你希望将对象产生于heap内存，请使用new operator。它不但分配内存而且为该对象调用一个constructor。如果你只是打算分配内存，请调用operator new，那就没有任何constructor会被调用。如果你打算在heap objects产生时自己决定内存分配方式，请写一个自己的operator new（重载），并使用new operator，它将会自动调用你所写的operator new。如果你打算在已分配的内存中构造对象，请使用placement new。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;关于delete&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;类似new，delete也分为 delete operator 和 operator delete。&lt;/li&gt;
&lt;li&gt;当成对使用operator new、operator delete时，相当于C的malloc和free。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;关于数组&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;array new指的是：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样子的代码里的new operator，由于诞生的是数组，所以内存是由一个兄弟函数：operator new[]负责分配。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;array new 不仅要分配多个对象的内存(operator new[])，且要对每一个对象的内存调用一次default constructor。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;array delete(即 operator delete[])，类似array new，不过它是先调用每个对象的dtor，再调用 operator delete[]以释放内存。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;异常&lt;/h2&gt;

&lt;p&gt;大概读了一遍这些条款，最后作者的结论是，能不使用异常就不使用异常，这是因为使用异常会有附加的性能开销。但是具体的影响值不明朗，和具体的编译器有关系。&lt;/p&gt;

&lt;h3&gt;条款9：利用destructors避免泄露资源&lt;/h3&gt;

&lt;p&gt;问题：C++函数调用过程中，如果出现异常，就会导致这个函数的后续代码不被执行。想一想，如果函数开头new了一个对象，在函数末尾会delete这个对象，而异常出现在中间，那么这个对象就不会被析构，于是内存发生泄露。&lt;/p&gt;

&lt;p&gt;解决之道就是，用智能指针来管理堆对象，因为智能指针是局部变量，当异常发生时，局部变量是会正常析构的，而，智能指针所绑定的heap对象，会在智能指针析构时也顺带析构。那么这个问题就算是解决了。（真的吗？）&lt;/p&gt;

&lt;p&gt;想一下，如果是在智能指针绑定那个对象（取得资源）过程中发生异常，或者是在资源被析构时发生异常，确定不会出问题吗？&lt;/p&gt;

&lt;p&gt;很不幸，确实问题并没有完美解决。&lt;/p&gt;

&lt;h3&gt;条款10：在constructors内阻止资源泄露（resource leak）&lt;/h3&gt;

&lt;p&gt;首先要知道一个事实：C++不自动清理那些“构造期间抛出异常”的对象。&lt;/p&gt;

&lt;p&gt;所以，构造函数的编写要小心，要确保构造过程中抛出异常时，仍能对已初始化的变量进行回收处理，避免泄露。&lt;/p&gt;

&lt;p&gt;解决方法：使用trycatch，确保构造函数所有可能被抛出的异常都能够捕获到，在catch里释放资源，并，再把异常往上继续抛出。&lt;/p&gt;

&lt;p&gt;这个事情实际上并不简单。比如，如果构造函数使用了初始化列表，而初始化列表代码中使用了new，这个new就没法写trycatch了。如果初始化列表有2个变量A、B，A成功拿到对对象，和B的对象构造失败（bad_alloc），A的堆对象就没机会释放了，就悲剧了。（针对这个情况，可以把new操作封装在某个成员函数里，然后在这个成员函数写trycatch，初始化列表调用这个成员函数即可）。&lt;/p&gt;

&lt;p&gt;更明智的做法是，把这种“需要获得对对象的成员变量”，改成使用智能指针。还是那2个A、B，当B出事时，A因为是一个智能指针成员变量，且已经完整构造，A会正常析构，析构的时候会正常地把堆对象也释放。&lt;/p&gt;

&lt;h3&gt;条款11：禁止异常流出destructors之外&lt;/h3&gt;

&lt;p&gt;析构函数在2种情况下会被调用：一，对象在正常状态下被销毁；二，对象呗异常处理机制销毁。&lt;/p&gt;

&lt;p&gt;如果异常流出析构函数，当程序是处在上述第二种情况时，会导致程序被terminate。&lt;/p&gt;

&lt;p&gt;解决办法是，在析构函数里写trycatch，捕获一切可能的异常，并把catch留空，即，捕获异常后不做任何事情。&lt;/p&gt;

&lt;p&gt;另外一个不让异常流出析构函数的理由是，如果析构过程中，某个敌方抛出异常，并传播到上层，那么这个析构函数的后续代码就没有被执行，这个析构函数就没有完成它负责的任务。&lt;/p&gt;

&lt;h3&gt;条款12：了解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”之间的差异&lt;/h3&gt;

&lt;p&gt;事实：一个对象被抛出作为异常时，总是会发生复制。（即使声明为static；即使是by reference方式）&lt;/p&gt;

&lt;h3&gt;条款13：以by reference方式捕捉异常&lt;/h3&gt;

&lt;h3&gt;条款14：明智运用exception specifications&lt;/h3&gt;

&lt;h3&gt;条款15：了解异常处理的成本&lt;/h3&gt;

&lt;p&gt;为了能够在运行时期处理异常，程序需要做大量记录工作：在每一个执行点，必须能够确认“如果发生异常，哪些对象需要析构”，他们必须在每一个try语句块的进入点和离开点做记号，针对每个try语句块必须记录对应的catch子句及能偶处理的异常类型。&lt;/p&gt;

&lt;p&gt;运行时期的比对工作（以确保符合exception specifications)不是免费的；异常被抛出时销毁适当对象并找出正确的catch子句也不是免费的。&lt;/p&gt;

&lt;p&gt;第二个成本是，try语句块。代码会膨胀，效率也会下降。（这还是没有异常出现时就有这个开销了）&lt;/p&gt;

&lt;h2&gt;效率&lt;/h2&gt;

&lt;h3&gt;条款16：谨记80-20法则&lt;/h3&gt;

&lt;p&gt;2个点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;理性地优化代码来提升程序性能。有的代码优化了，并不一定能带来质的性能提升；要找到性能瓶颈之处才行。&lt;/li&gt;
&lt;li&gt;利用profiler工具来找到性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;条款17：考虑使用lazy evaluation（缓式评估）&lt;/h3&gt;

&lt;p&gt;其实就是“能拖就拖”，减少不必要的计算。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引用计数 &amp;amp;&amp;amp; 区分读和写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;考虑这样的代码：&lt;/p&gt;

&lt;p&gt;string s1 =&amp;quot;hello&amp;quot;; string s2 = s1;&lt;/p&gt;

&lt;p&gt;执行s2=s1时，执行了一次复制构造函数。这个调用是否昂贵？这个调用是否可以避免？事实上，要具体情况具体考虑。如果s2只是被“读”，而不会被“修改”，那么s2只需要存一个指向s1的引用即可，不应该创建一个副本。&lt;strong&gt;在你真正需要之前，不必着急为某物做一个副本。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lazy Fetching（缓式取出）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单地说，就是读取数据库数据时，能少拿一点就少拿一点，能不拿就不拿。&lt;/p&gt;

&lt;p&gt;比如我自己在使用redis（KV数据库），就可以把一个class实例（有多个成员变量），用hash表来存。使用这个实例时（读or写），不直接hgetall或hsetall（全部读写），而是用hget或hset（单个读写）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lazy Expression Evaluation（表达式换评估）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lazy Evaluation的反义词是Eager Evaluation（急式评估）。
贴书中的例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;m1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;m2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;m3是m1和m2的合，这是一个百万级的加法操作。如果m3的值实际上是不会被程序用到，那么这个计算就应该被忽略。&lt;/p&gt;

&lt;p&gt;一般来说，定义了m3，应该下文就会用到m3。那么m3的计算就在所难免了，但如果是这样的情况：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，按照这一个条款的指示，应该使得，m3.at(2,2)执行时，只计算(2,2)处的值，而不计算其他的值。&lt;/p&gt;

&lt;h3&gt;条款18：分期摊还预期的计算成本&lt;/h3&gt;

&lt;p&gt;如果预期到某个操作必然要执行，就可以考虑把这个计算提前，甚至计算结果可以被复用。（caching法）&lt;/p&gt;

&lt;p&gt;另一种做法是Prefetching（预先取出）。具体就是说，做一个计算时，可以一次过做多一些（batch）。比如磁盘的块读取，或者动态数组的内存动态扩张。&lt;/p&gt;

&lt;h3&gt;条款19：了解临时对象的来源&lt;/h3&gt;

&lt;p&gt;当程序产生一个non-heap object而没有为它命名，便诞生了一个临时对象。（匿名对象）&lt;/p&gt;

&lt;p&gt;一般有2种情况产生临时对象：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;隐式类型转换。比如传参时参数有可能被自动转换。&lt;/li&gt;
&lt;li&gt;函数返回对象。返回的变量的类型和函数的返回类型不同时发生。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种类型，只当对象以by value的方式传递，或当对象被传递给一个reference-to-const参数时，才会发生。如果对象被传递给一个reference-to-non-const参数，并不会发生此类转换。&lt;/p&gt;

&lt;p&gt;第二种情况，感觉这本书的分析过时了，c++11的右值引用，应该是解决这个情况的最有力武器。&lt;/p&gt;

&lt;h3&gt;条款20：协助完成“返回值优化”&lt;/h3&gt;

&lt;p&gt;撇开c++11，对于返回by value的函数，最佳的return写法是，return后面紧跟一个类构造函数。&lt;/p&gt;

&lt;p&gt;这样做可能可以让编译器优化掉这个构造函数产生的临时对象。
（这一招叫做return value optimization）。&lt;/p&gt;

&lt;h3&gt;条款21：利用重载技术（overload）避免隐式类型转换（implicit type conversions）&lt;/h3&gt;

&lt;p&gt;很显然，就是通过增加定制的重载函数（函数参数类型和实际的参数类型一致），避免不必要的类型转换开销。&lt;/p&gt;

&lt;h3&gt;条款22：考虑以操作符复合形式（op=）取代其独身形式（op）&lt;/h3&gt;

&lt;p&gt;大部分程序员都希望，如果他们能够这样写：&lt;/p&gt;

&lt;p&gt;x = x + y&lt;/p&gt;

&lt;p&gt;他们也能够写成这样：&lt;/p&gt;

&lt;p&gt;x += y&lt;/p&gt;

&lt;p&gt;一般而言，复合操作符比其对应的独身版本效率高，因为独身版本通常返回一个新对象，而我们必须因此负担一个临时对象的构造和析构成本。&lt;/p&gt;

&lt;p&gt;另外，如果同时提供某个操作符的复合形式和独身形式，便允许你的客户在效率与便利性之间做取舍。（虽然这个选择不易）&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;p&gt;d = a + b + c;&lt;/p&gt;

&lt;p&gt;和：&lt;/p&gt;

&lt;p&gt;d = 0; d += a; d += b; d += c;&lt;/p&gt;

&lt;p&gt;后者要比前者效率要高，因为没有复制对象。&lt;/p&gt;

&lt;h3&gt;条款23：考虑使用其他程序库&lt;/h3&gt;

&lt;p&gt;以iosteam和stdio这2个官方库来说明，不同的库有不同的性能。选择一个适合的库，也是提升性能的好方法。&lt;/p&gt;

&lt;h3&gt;条款24：了解virtual functions、multiple inheritance、virtual base classes、runtime type identification的成本&lt;/h3&gt;
</description>
        <pubDate>Sun, 06 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/cpp-1/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/cpp-1/</guid>
      </item>
    
      <item>
        <title>&lt;复习向&gt;线性代数之矩阵与行列式(3)</title>
        <description>&lt;h1&gt;行列式的求解&lt;/h1&gt;

&lt;p&gt;从行列式的定义出发去求行列式，是一个简单但低效的方法。而实际上，解决数学问题的途径往往有多种。这里，我将介绍其中一种比较常见的快速解法：&lt;strong&gt;PLU分解&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;PLU的LU&lt;/h2&gt;

&lt;p&gt;要理解PLU，得先搞懂LU分解。（这里分享一个外教的讲解视频，简单好理解：&lt;a href=&quot;https://www.youtube.com/watch?v=UlWcofkUDDU&quot;&gt;https://www.youtube.com/watch?v=UlWcofkUDDU&lt;/a&gt; 能翻墙的同学就直接看吧。)&lt;/p&gt;

&lt;p&gt;LU分别代表：Lower Triangular Matrix 和 Upper Triangular Matrix，即下三角矩阵和上三角矩阵。&lt;/p&gt;

&lt;p&gt;下面手动演示下LU分解过程：&lt;/p&gt;

&lt;p&gt;设A：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} 9&amp;amp;6&amp;amp;0\\ 6&amp;amp;5&amp;amp;4\\ 3&amp;amp;4&amp;amp;10\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;要把A分解成LU，第一步是先用高斯消元法，把A变成阶梯型矩阵U：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( R2 -= R1 * a_{10}/a_{00} = R1 * 6/9 \)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ A_{0} =  \left[ \begin{matrix} 9&amp;amp;6&amp;amp;0\\ 0&amp;amp;1&amp;amp;4\\ 3&amp;amp;4&amp;amp;10\\ \end{matrix} \right] = E_{0}A =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ -6/9&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]
 \left[ \begin{matrix} 9&amp;amp;6&amp;amp;0\\ 6&amp;amp;5&amp;amp;4\\ 3&amp;amp;4&amp;amp;10\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( R3 -= R1 * a_{20}/a_{00} = R1 * 3/9 \)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ A_{1} =  \left[ \begin{matrix} 9&amp;amp;6&amp;amp;0\\ 0&amp;amp;1&amp;amp;4\\ 0&amp;amp;2&amp;amp;10\\ \end{matrix} \right] = E_{1}A_{0} =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ -3/9&amp;amp;0&amp;amp;1\\ \end{matrix} \right]
 \left[ \begin{matrix} 9&amp;amp;6&amp;amp;0\\ 0&amp;amp;1&amp;amp;4\\ 3&amp;amp;4&amp;amp;10\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( R3 -= R2 * a_{21}/a_{11} = R1 * 2/1 \)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ U = A_{2} =  \left[ \begin{matrix} 9&amp;amp;6&amp;amp;0\\ 0&amp;amp;1&amp;amp;4\\ 0&amp;amp;0&amp;amp;2\\ \end{matrix} \right] = E_{2}A_{1} =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;-2/1&amp;amp;1\\ \end{matrix} \right]
 \left[ \begin{matrix} 9&amp;amp;6&amp;amp;0\\ 0&amp;amp;1&amp;amp;4\\ 0&amp;amp;2&amp;amp;10\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;因此得：\( U = E_{2}A_{1} = E_{2}E_{1}A_{0} = E_{2}E_{1}E_{0}A \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;再调换下，得到：\( A = E_{0}^{-1}E_{1}^{-1}E_{2}^{-1}U \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所以， \( L = E_{0}^{-1}E_{1}^{-1}E_{2}^{-1} \)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要得到最终的L，需要算3个\(E_{x}\)矩阵的逆矩阵，看似麻烦，其实很简单，因为\(E_{x}\)有这样的性质：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ a&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ -a&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ a&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ -a&amp;amp;0&amp;amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;a&amp;amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;-a&amp;amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;p&gt;\[ L = E_{0}^{-1}E_{1}^{-1}E_{2}^{-1} =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 6/9&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ 3/9&amp;amp;0&amp;amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;2/1&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;只要搞定右边的3矩阵乘法运算，就能得到L。而又因为：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ a_{1}&amp;amp;1&amp;amp;0\\ b_{1}&amp;amp;c_{1}&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ a_{2}&amp;amp;1&amp;amp;0\\ b_{2}&amp;amp;c_{2}&amp;amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ a_{1}+a_{2}&amp;amp;1&amp;amp;0\\ b_{1}+a_{2}c_{2}+b_{2}&amp;amp;c_{1}+c_{2}&amp;amp;1\\ \end{matrix} \right]
\]&lt;/p&gt;

&lt;p&gt;所以，L的结果可以迅速得到：&lt;/p&gt;

&lt;p&gt;\[ L = E_{0}^{-1}E_{1}^{-1}E_{2}^{-1} =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 6/9&amp;amp;1&amp;amp;0\\ 3/9&amp;amp;2/1&amp;amp;1\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;于是，A的LU分解完成了：&lt;/p&gt;

&lt;p&gt;\[ A = LU =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ 6/9&amp;amp;1&amp;amp;0\\ 3/9&amp;amp;2/1&amp;amp;1\\ \end{matrix} \right]  \left[ \begin{matrix} 9&amp;amp;6&amp;amp;0\\ 0&amp;amp;1&amp;amp;4\\ 0&amp;amp;0&amp;amp;2\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;h2&gt;PLU的P&lt;/h2&gt;

&lt;p&gt;这里的P，指的是Permutation Matrix，置换矩阵。&lt;/p&gt;

&lt;p&gt;何谓置换矩阵？其实就是经过一系列初等变换的单位矩阵，且元素\( a_{ij} = 0 or 1 \)。&lt;/p&gt;

&lt;p&gt;置换矩阵的作用，是用来交换某个矩阵的行（列）顺序。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;p&gt;\[ P =  \left[ \begin{matrix} 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ 1&amp;amp;0&amp;amp;0\\ \end{matrix} \right]\ \  A =  \left[ \begin{matrix} 3&amp;amp;4&amp;amp;0\\ 1&amp;amp;2&amp;amp;9\\ 0&amp;amp;5&amp;amp;6\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ PA =  \left[ \begin{matrix} 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ 1&amp;amp;0&amp;amp;0\\ \end{matrix} \right]  \left[ \begin{matrix} 3&amp;amp;4&amp;amp;0\\ 1&amp;amp;2&amp;amp;9\\ 0&amp;amp;5&amp;amp;6\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;amp;2&amp;amp;9\\ 0&amp;amp;5&amp;amp;6\\ 3&amp;amp;4&amp;amp;0\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ AP =  \left[ \begin{matrix} 3&amp;amp;4&amp;amp;0\\ 1&amp;amp;2&amp;amp;9\\ 0&amp;amp;5&amp;amp;6\\ \end{matrix} \right]  \left[ \begin{matrix} 0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;1\\ 1&amp;amp;0&amp;amp;0\\ \end{matrix} \right]  =  \left[ \begin{matrix} 0&amp;amp;3&amp;amp;4\\ 9&amp;amp;1&amp;amp;2\\ 6&amp;amp;0&amp;amp;5\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;从这个例子就可以看出，P左乘A时，改变了A的行的顺序；P右乘A时，改变了A的列的顺序。&lt;/p&gt;

&lt;h2&gt;PA = LU？&lt;/h2&gt;

&lt;p&gt;为什么要先对A做P置换后，再做LU分解？这是因为不这样做的话，LU会不稳定(stability)。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} 10^{-20}&amp;amp;1\\ 1&amp;amp;1\\ \end{matrix} \right]  =  \left[ \begin{matrix} 1&amp;amp;0\\ 10^{20}&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} 10^{-20}&amp;amp;1\\ 0&amp;amp;1-10^{20}\\ \end{matrix} \right] = L_{0}U_{0} \]&lt;/p&gt;

&lt;p&gt;直接分解后得到的L、U矩阵，出现了&lt;strong&gt;大数&lt;/strong&gt;，程序员读者们肯定会意识到:&amp;quot;大数！这不是要越界的节奏吗！&amp;quot;。所以这是不能接受的。&lt;/p&gt;

&lt;p&gt;而神奇的是，对A做一些P置换后，再来LU分解，是可以变稳定的：&lt;/p&gt;

&lt;p&gt;\[ PA =  \left[ \begin{matrix} 0&amp;amp;1\\ 1&amp;amp;0\\ \end{matrix} \right] \left[ \begin{matrix} 10^{-20}&amp;amp;1\\ 1&amp;amp;1\\ \end{matrix} \right] =  \left[ \begin{matrix} 1&amp;amp;1\\ 10^{-20}&amp;amp;1\\ \end{matrix} \right]  =  \left[ \begin{matrix} 1&amp;amp;0\\ 10^{-20}&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} 1&amp;amp;1\\ 0&amp;amp;1-10^{-20}\\ \end{matrix} \right] = L_{1}U_{1} \]&lt;/p&gt;

&lt;p&gt;L、U中没有出现大数，于是认为这样的分解是稳定的。&lt;/p&gt;

&lt;p&gt;PA的P，需要对P做一些检测后才可以得到，策略就是：沿着对角线从左上角到右下角遍历A，并检测当前列的最大元素在下方的哪一行（当前行上方的行保持不变），找到后就将当前行和目标行交换，并记录下一个\(E_{i}\)。最后按顺序算\(E_{i}\)的乘积就得到了P。&lt;/p&gt;

&lt;h2&gt;A的行列式&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://yiqizhumeng.com:4000/linear-algebra/&quot;&gt;&amp;lt;复习向&amp;gt;线性代数之矩阵与行列式(1)&lt;/a&gt;中，已经提到了一条行列式公式：&lt;/p&gt;

&lt;p&gt;\[ det(AB) = det(A)det(B) \]&lt;/p&gt;

&lt;p&gt;而，\( PA = LU \)又可以变成 \( A = P^{-1}LU \)，所以：&lt;/p&gt;

&lt;p&gt;\[ det(A) = det(P^{-1}LU) = det(P^{-1})det(L)det(U) \]&lt;/p&gt;

&lt;p&gt;可以进一步将这个式子简化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L、U矩阵分别是下三角矩阵和上三角矩阵，它们的行列式等于对角线上元素的乘积&lt;/li&gt;
&lt;li&gt;L矩阵上的元素都为1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是有：&lt;/p&gt;

&lt;p&gt;\[ det(A) = det(P^{-1})u_{11}u_{22}\cdots u_{nn} \]&lt;/p&gt;

&lt;p&gt;因为： \( PP^{-1} = PP^{T} =  1 \)，\( det(P_T) = det(P) \)，所以问题变成了求det(P)。&lt;/p&gt;

&lt;p&gt;P怎么求？首先，P相当于多个\(E_i\)矩阵的乘积，而又有\( det(E_i)=-1 \)  (行列式的基本性质：交换行列式的两行，行列式变号），所以有：&lt;/p&gt;

&lt;p&gt;\[ P = E_t\cdots E_2E_1 \implies \det(P) = \prod^t_{i=1}\det(E_i)=(-1)^t \]&lt;/p&gt;

&lt;p&gt;于是：&lt;/p&gt;

&lt;p&gt;\[ det(A) = det(P^{-1}LU) = det(P)u_{11}u_{22}\cdots u_{nn} = (-1)^{t}u_{11}u_{22}\cdots u_{nn} \]&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;矩阵的分解(factorization)有很多种，PA=LU只是其中一种，但此类分解法都离不开&lt;strong&gt;高斯消元&lt;/strong&gt;这把大杀器。理解好高斯消元是关键。&lt;/p&gt;

&lt;p&gt;P.S. 已经有人证明了，任何方阵都存在它的PLU分解:&lt;a href=&quot;&quot;&gt;http://arxiv.org/pdf/math/0506382v1.pdf&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Mon, 31 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-3/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-3/</guid>
      </item>
    
      <item>
        <title>&lt;复习向&gt;线性代数之矩阵与行列式(2)</title>
        <description>&lt;h1&gt;行列式的意义&lt;/h1&gt;

&lt;p&gt;貌似一般的线性代数教科书并没有告诉读者行列式的实际意义，只是教会了读者行列式的定义和计算方法。（起码我所阅读的线性代数课本没有提及）&lt;/p&gt;

&lt;p&gt;那么在这里我简单地介绍一下。&lt;/p&gt;

&lt;h2&gt;一阶行列式&lt;/h2&gt;

&lt;p&gt;要说行列式的意义，得先从行列式的&amp;quot;|&amp;quot;符号谈起。下面是一阶方阵的行列式：&lt;/p&gt;

&lt;p&gt;\[ |x| = x \]&lt;/p&gt;

&lt;p&gt;是不是想到什么？一阶方阵，其实就是一个数，且它的行列式等于这个数。且，一阶方列式的写法，恰好就是高中数学里的绝对值写法！&lt;/p&gt;

&lt;p&gt;想一下绝对值的&lt;strong&gt;几何意义&lt;/strong&gt;：指明了一个实数（这里不提虚数）距离数轴原点的大小。&lt;/p&gt;

&lt;h2&gt;二阶行列式&lt;/h2&gt;

&lt;p&gt;现在看一下二阶行列式：&lt;/p&gt;

&lt;p&gt;\( \left| \begin{matrix} x_{0}\ x_{1}\\ y_{0}\ y_{1}\\ \end{matrix} \right| \)&lt;/p&gt;

&lt;p&gt;再变成用向量来表示：&lt;/p&gt;

&lt;p&gt;\( |\ \alpha\ \beta\ | \)&lt;/p&gt;

&lt;p&gt;于是，二阶行列式等于2个向量的&amp;quot;绝对值&amp;quot;。那么，对于2个向量，这个绝对值是什么？&lt;/p&gt;

&lt;p&gt;首先，搬出向量的夹角公式：&lt;/p&gt;

&lt;p&gt;\[ cos\theta = \dfrac {\alpha \cdot\ \beta } {|\alpha |\times|\beta |} \]&lt;/p&gt;

&lt;p&gt;从上面的式子可以推出：&lt;/p&gt;

&lt;p&gt;\[ sin\theta = \sqrt{1 - \dfrac {(\alpha \cdot\ \beta )^{2}} {|\alpha |^{2}\times |\beta |^{2}} } \]&lt;/p&gt;

&lt;p&gt;\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ |\alpha |^{2} \times |\beta |^{2} - (\alpha \cdot\ \beta )^{2} } \]&lt;/p&gt;

&lt;p&gt;\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ (x_{0}^{2} + y_{0}^{2})\times (x_{1}^{2} + y_{1}^{2}) - (x_{0}x_{1}+y_{0}y_{1})^{2} } \]&lt;/p&gt;

&lt;p&gt;\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ x_{0}^{2}x_{1}^{2} + x_{0}^{2}y_{1}^{2} + y_{0}^{2}x_{1}^{2} + y_{0}^{2}y_{1}^{2} - x_{0}^{2}x_{1}^{2} - x_{0}x_{1}y_{0}y_{1} - y_{0}^{2}y_{1}^{2} } \]&lt;/p&gt;

&lt;p&gt;\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ x_{0}^{2}y_{1}^{2} + x_{1}^{2}y_{0}^{2} - 2x_{0}x_{1}y_{0}y_{1} } \]&lt;/p&gt;

&lt;p&gt;\[ |\alpha |\times |\beta |\times sin\theta = \sqrt{ (x_{0}y_{1} - x_{1}y_{0})^{2} } \]&lt;/p&gt;

&lt;p&gt;\[ |\alpha |\times |\beta |\times sin\theta = x_{0}y_{1} - x_{1}y_{0} \]&lt;/p&gt;

&lt;p&gt;\[ |\alpha |\times |\beta |\times sin\theta =     \left| \begin{matrix} x_{0}\ x_{1}\\ y_{0}\ y_{1}\\ \end{matrix} \right| = |\ \alpha\ \beta\ | \]&lt;/p&gt;

&lt;p&gt;注意到了吗，这个式子的左边，赫然是平行四边形的面积公式！&lt;/p&gt;

&lt;p&gt;所以，二阶行列式的几何意义就是&lt;strong&gt;2个向量组成的平行四边形的面积&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.8/parallelogram.svg&quot; alt=&quot;parallelogram.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;三阶行列式&lt;/h2&gt;

&lt;p&gt;通过上面的分析，可以知道行列式在几何数学中是有某种意义的，那么三阶行列式又是什么东西呢？&lt;/p&gt;

&lt;p&gt;三阶行列式：&lt;/p&gt;

&lt;p&gt;\( \left| \begin{matrix} x_{0}\ x_{1}\ x_{2}\\ y_{0}\ y_{1}\ y_{2}\\ z_{0}\ z_{1}\ z_{2}\\ \end{matrix} \right| \)&lt;/p&gt;

&lt;p&gt;再变成用向量来表示：&lt;/p&gt;

&lt;p&gt;\( |\ \alpha\ \beta\ \gamma\ | \)&lt;/p&gt;

&lt;p&gt;3个3维向量，想到了什么呢？没错，就是3维空间中的3个向量！&lt;/p&gt;

&lt;p&gt;设 \( \alpha = (1,0,0)^{T} \) \( \beta = (0,1,0)^{T} \) \( \gamma = (0,0,1)^{T} \) ， 即相当于3维正交坐标系的3条轴的单位向量。这样的3个单位向量组成的行列式，值等于1。&lt;/p&gt;

&lt;p&gt;另外，巧合的是，这3个单位向量组成的正方体，体积也为1。实际上，3阶行列式确实等价于平行六面体的体积。&lt;/p&gt;

&lt;p&gt;证明过程（暂无）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.8/parallelepiped.svg&quot; alt=&quot;parallelogram.png&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 29 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-2/</guid>
      </item>
    
      <item>
        <title>&lt;复习向&gt;线性代数之矩阵与行列式(1)</title>
        <description>&lt;h2&gt;矩阵的基本性质&lt;/h2&gt;

&lt;p&gt;我对矩阵的定义：一个含有x个元素的数组(x&amp;gt;=1)，以n个数为一段，将把这个数组按顺序分成m段，并按顺序排成m行，就构成了一个矩阵。&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;分段&lt;/strong&gt;是构成一个矩阵的充分必要条件。&lt;/p&gt;

&lt;p&gt;这个定义是从程序实现角度考虑的。一个矩阵可以用二维数组Array[m][n]来存放，也可以用一维数组Array[m*n]来存放，在不考虑实现语言之前，我更倾向于使用一维数组。&lt;/p&gt;

&lt;p&gt;矩阵的定义虽然不复杂，但是聪明的数学家对矩阵进行了各种研究，导致产生了非常多的概念、术语、定理、推论：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当m == n时，矩阵可以被称为&lt;strong&gt;n阶矩阵&lt;/strong&gt;，或&lt;strong&gt;n阶方阵&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;矩阵A的m、n和矩阵B的m、n相等时，称A和B为&lt;strong&gt;同阶矩阵&lt;/strong&gt;或&lt;strong&gt;同型矩阵&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;大写字母&lt;strong&gt;O&lt;/strong&gt;代表元素全为0的矩阵&lt;/li&gt;
&lt;li&gt;矩阵的加法运算满足以下运算律:

&lt;ol&gt;
&lt;li&gt;交换律 &lt;strong&gt;A + B = B + A&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;结合律 &lt;strong&gt;( A + B ) + C = A + ( B + C )&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A + O = O + A&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A + (-A) = (-A) + A = O&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;矩阵的数乘运算满足以下运算律:

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;k ( A + B ) = kA + kB&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;( k + t ) A = kA + tA&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;k ( tA ) = ( kt ) A&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1 * A = A&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;矩阵的加法和数乘运算统称为矩阵的&lt;strong&gt;线性运算&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;矩阵之间允许乘法运算：C = AB。但有一个前提：
左矩阵A的列数必须等于右矩阵B的行数&lt;/li&gt;
&lt;li&gt;做矩阵相乘运算要注意的一些特性：

&lt;ol&gt;
&lt;li&gt;AB 有意义时， BA 不一定有意义&lt;/li&gt;
&lt;li&gt;AB 和 BA 都有意义时，并不意味着 AB = BA（不满足交换律），但存在使得此等式成立的2个矩阵&lt;/li&gt;
&lt;li&gt;不满足消除率。两个非零矩阵的乘积可能是零矩阵，即 AB = O 成立时，并不能推出 A = O 或 B = O&lt;/li&gt;
&lt;li&gt;满足结合律：

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;( AB ) C = A ( BC )&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;k ( AB ) = ( kA ) B = A ( kB )&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A ( B + C ) = AB + AC&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;( B + C ) A = BA + CA&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;矩阵可以做幂运算：

&lt;ol&gt;
&lt;li&gt;\( \mathbf{ A^{k}A^{t} = A^{k+t} } \)&lt;/li&gt;
&lt;li&gt;\( \mathbf{ (A^{k})^{t} = A^{kt} } \)&lt;/li&gt;
&lt;li&gt;若 AB = BA，则 \( \mathbf{ (AB)^{k} = A^{k}B^{k} } \)&lt;/li&gt;
&lt;li&gt;注意，即使 \( \mathbf{ A^{k} = O } \)，也并不意味着\( \mathbf{  A = O } \)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;矩阵的转置&lt;/h2&gt;

&lt;p&gt;将\( m\times n \)矩阵 A = \( a_{ij} \)的行和列互换，得到的\( n\times m \)矩阵，称为矩阵A的转置矩阵，简称A的转置，记为\( A^{T} \)。&lt;/p&gt;

&lt;p&gt;矩阵的转置有以下性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;\( \mathbf{ (A^{T})^{T} = A }  \)&lt;/li&gt;
&lt;li&gt;\( \mathbf{ (A+B)^{T}=A^{T}+B^{T} } \)&lt;/li&gt;
&lt;li&gt;\( \mathbf{ (kA)^{T}=kA^{T} } \)&lt;/li&gt;
&lt;li&gt;\( \mathbf{ (AB)^{T}=B^{T}A^{T} } \)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;方阵的行列式&lt;/h2&gt;

&lt;p&gt;定义行列式之前，先定义2个概念：排列和逆序数&lt;/p&gt;

&lt;h3&gt;排列&lt;/h3&gt;

&lt;p&gt;由n个不同的数\(1,2,\cdots,n\)组成的一个有序数组\( i_{1}i_{2}\cdots i_{n} \)称为一个n级排列,简称为排列&lt;/p&gt;

&lt;p&gt;由数\(1,2,\cdots,n\)构成的不同的n级排列共有\( n! \)个。&lt;/p&gt;

&lt;p&gt;例:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1234、3421是4级排列&lt;/li&gt;
&lt;li&gt;25314是5级排列&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;逆序数&lt;/h3&gt;

&lt;p&gt;在一个n级排列\( i_{1}i_{2}\cdots i_{n} \)中，若数\( i_{t}&amp;gt;i_{s} \)，则称数\( i_{t} \) 与 \( i_{s} \)构成一个逆序，一个n级排序中逆数的总数称为该排列的逆序数，记为
\( \gamma (i_{1}i_{2}\cdots i_{n}) \)&lt;/p&gt;

&lt;p&gt;例:&lt;/p&gt;

&lt;p&gt;5级排列25314的逆序数:&lt;/p&gt;

&lt;p&gt;\( \gamma (25314) \) = 0 + 0 + 1 + 3 + 1 = 5&lt;/p&gt;

&lt;p&gt;逆序数为奇数的排列称为&lt;strong&gt;奇排列&lt;/strong&gt;，逆序数为偶数的排列称为&lt;strong&gt;偶排列&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;相关定理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;n个不同的数\(1,2,\cdots,n\)的n！个n级排列中，奇偶排列各占一半&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交换一个排列中某2个不同的元素，称为一次&lt;strong&gt;对换&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;p&gt;\( 31542\overset{(5,2)}{\longrightarrow}31245 \)&lt;/p&gt;

&lt;p&gt;相关定理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;任意一个排列经过一次对换后，奇偶性改变&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;行列式&lt;/h3&gt;

&lt;p&gt;定义：由 \( n^{2} \)个元素\( a_{ij} \) 排成n行n列组成的式子：&lt;/p&gt;

&lt;p&gt;\( \left| \begin{matrix} a_{11}\ a_{12}\ \ldots\ a_{1n}\\ a_{21}\ a_{22}\ \ldots\ a_{2n}\\ \vdots\ \ \ \ \ \vdots\ \ \ \ \ \vdots\ \ \ \ \ \vdots\ \ \ \ \\ a_{n1}\ a_{n2}\ \ldots\ a_{nn}\\ \end{matrix} \right| \)
\( = \sum _{ j_{1}j_{2}\ldots j_{n} }(-1)^{\gamma (j_{1}j_{2}\ldots j_{n} ) }a_{1 j_{1}}a_{2 j_{2} }\ldots a_{n j_{n} } \)&lt;/p&gt;

&lt;p&gt;它的计算结果被称为行列式(Determinant)。&lt;/p&gt;

&lt;p&gt;注意，行列式是一个数，而不是一个矩阵。
这个式子也被称为行列式的展开式。&lt;/p&gt;

&lt;p&gt;行列式的性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;\( D^{T} = D \)&lt;/li&gt;
&lt;li&gt;交换行列式的两行(列)，行列式变号&lt;/li&gt;
&lt;li&gt;用数k乘行列式的某一行(列)，等于用数k乘此行列式&lt;/li&gt;
&lt;li&gt;若行列式有一行(列)的元素全为零，则行列式等于零&lt;/li&gt;
&lt;li&gt;若行列式有两行(列)的对应元素成比例，则行列式等于零&lt;/li&gt;
&lt;li&gt;若行列式的某一行(列)各元素都是两数之和，即 \( a_{ij} = b_{ij} + c_{ij} \)，则 \( D_{a} = D_{b} + D_{c} \)&lt;/li&gt;
&lt;li&gt;将行列式某一行(列)所有元素都乘以数k后加到另一行(列)对应位置的元素上，行列式的值不变&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;行列式按某一行(列)展开:&lt;/p&gt;

&lt;p&gt;代数余子式的定义:&lt;/p&gt;

&lt;p&gt;在n阶行列式 D = det( \( a_{ij} \) )中，划去元素\( a_{ij} \)所在的第i行和第j列后，余下的元素按原来的相对位置构成的n-1阶行列式，称为D中元素\( a_{ij} \)的余子式，记为\( M_{ij} \)。&lt;/p&gt;

&lt;p&gt;再记\( A_{ij} =(-1)^{i+j}M_{ij} \)，称\( A_{ij} \)为元素\( a_{ij} \)的代数余子式。&lt;/p&gt;

&lt;p&gt;引理:&lt;/p&gt;

&lt;p&gt;若n阶行列式 D = det( \( a_{ij} \) )中，第i行除\( a_{ij} \)外的其他元素都为零，则该行列式等于\( a_{ij} \)与它的代数余子式的乘积，即：&lt;/p&gt;

&lt;p&gt;\[ D = det( a_{ij} ) = a_{ij}A_{ij} \] &lt;/p&gt;

&lt;p&gt;行列式的展开:&lt;/p&gt;

&lt;p&gt;n阶行列式 D = det( \( a_{ij} \) )等于它的任意一行(列)的各元素与其对应的代数余子式乘积之和，即&lt;/p&gt;

&lt;p&gt;\[ D = a_{i1}A_{i1} + a_{i2}A_{i2} + \cdots + a_{in}A_{in} \] &lt;/p&gt;

&lt;p&gt;\[ D = a_{1j}A_{1j} + a_{2j}A_{2j} + \cdots + a_{nj}A_{nj} \]&lt;/p&gt;

&lt;h2&gt;行列式与转置矩阵之间的一些公式：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;\( \mathbf{ |A^{T}| = |A| } \)&lt;/li&gt;
&lt;li&gt;\( \mathbf{ |kA| = k^{n}|A| } \)&lt;/li&gt;
&lt;li&gt;\( \mathbf{ |AB| = |A||B| } \)&lt;/li&gt;
&lt;li&gt;\( \mathbf{ |AB| = |BA| } \)&lt;/li&gt;
&lt;li&gt;\( \mathbf{ |A^{n}| = |A|^{n} } \)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;线性方程组与行列式&lt;/h2&gt;

&lt;p&gt;含有n个未知量、n个方程的线性方程组&lt;/p&gt;

&lt;p&gt;\[ a_{11}x_{1} + a_{12}x_{2} + \cdots + a_{1n}x_{n} = b_{1} \]
\[ a_{21}x_{1} + a_{22}x_{2} + \cdots + a_{2n}x_{n} = b_{2} \]
\[ \cdots\cdots \]
\[ a_{n1}x_{1} + a_{n2}x_{2} + \cdots + a_{nn}x_{n} = b_{n} \]&lt;/p&gt;

&lt;p&gt;系数\( a_{ij} \)构成的行列式称为该方程组的系数行列式D&lt;/p&gt;

&lt;p&gt;克拉默(Cramer)法则：若系数行列式 \( D\neq 0 \)，则方程组有唯一解，其解为：
\[ x_{i} = \dfrac {D_{j}} {D} \]&lt;/p&gt;

&lt;p&gt;\( D_{j} \)是将系数行列式D中第j列的元素\( a_{1j},a_{2j},\cdots a_{nj} \)对应地换成方程组右端的常数项\( b_{1j},b_{2j},\cdots b_{nj} \)，而其余各列保持不变得到的行列式。&lt;/p&gt;

&lt;p&gt;当\( b_{i} \)=0时，上面的线性方程组为：&lt;/p&gt;

&lt;p&gt;\[ a_{11}x_{1} + a_{12}x_{2} + \cdots + a_{1n}x_{n} = 0 \]
\[ a_{21}x_{1} + a_{22}x_{2} + \cdots + a_{2n}x_{n} = 0 \]
\[ \cdots\cdots \]
\[ a_{n1}x_{1} + a_{n2}x_{2} + \cdots + a_{nn}x_{n} = 0 \]&lt;/p&gt;

&lt;p&gt;称为&lt;strong&gt;齐次线性方程组&lt;/strong&gt;。齐次线性方程组必然有零解( \( x_{i} = 0 \) ）。&lt;/p&gt;

&lt;p&gt;定理：若齐次线性方程组的系数行列式 \( D\neq 0 \)，则只有零解； 若有非零解，则\( D = 0 \)。&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra/</guid>
      </item>
    
      <item>
        <title>实现了一个C++11 Based的光线追踪渲染器demo</title>
        <description>&lt;p&gt;本demo是根据Milo的一篇文章实现的：&lt;a href=&quot;http://www.cnblogs.com/miloyip/archive/2010/03/29/1698953.html&quot;&gt;用JavaScript玩转计算机图形学1，光线追踪入门&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;原文是js版本，我用c++实现了一个。
代码在：https://github.com/voyagingmk/raytrace_demo&lt;/p&gt;

&lt;p&gt;渲染效果图：(1000 x 1000)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.8/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 04 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/raytrace/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/raytrace/</guid>
      </item>
    
  </channel>
</rss>