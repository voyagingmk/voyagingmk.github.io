<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>博主主要学习方向：图形学、机器学习，以及各种有趣的数学。联系QQ：234707482。</description>
    <link>http://www.qiujiawei.com</link>
    <atom:link href="http://www.qiujiawei.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>forwarder开发备忘</title>
        <description>&lt;h1&gt;cmake&lt;/h1&gt;

&lt;h3&gt;1.windows下安装cmake&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://cmake.org/files/v3.7/cmake-3.7.0-rc1-win64-x64.msi&quot;&gt;https://cmake.org/files/v3.7/cmake-3.7.0-rc1-win64-x64.msi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;顺便可以下载cmake源码，源码里面有一个tests目录，有很多cmake工程可以参考，譬如官网的tutorials教程的代码都在tests里面了。&lt;/p&gt;

&lt;h3&gt;2.手写CMakeLists.txt&lt;/h3&gt;

&lt;p&gt;本文不谈cmake-gui的使用，原因是这东西界面有点怪，其次是cmake作为跨平台的构建系统，理应学习使用cmake的命令行模式，命令都是一致的，而cmake-gui是windows独有的。&lt;/p&gt;

&lt;p&gt;那么，在执行cmake构建指令前，需要在forwarder项目根目录下手写一个CMakeLists.txt文件。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;cmake_minimum_required&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VERSION&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# The version number.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FORWARDER_VERSION_MAJOR&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FORWARDER_VERSION_MINOR&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;include_directories&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;${PROJECT_SOURCE_DIR}/include&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;include_directories&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;${PROJECT_SOURCE_DIR}/enet&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_subdirectory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXTRA_LIBS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXTRA_LIBS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libenet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# add the executable&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_executable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target_link_libraries&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarder&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXTRA_LIBS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（这里推荐用vscode来编辑CMakeLists.txt，vscode有编辑CMakeLists.txt文件的插件，支持语法高亮和智能提示，很爽）&lt;/p&gt;

&lt;h3&gt;3.构建&lt;/h3&gt;

&lt;p&gt;forwarder项目目前用到了2个第三方库，一个是enet，一个是spdlog。&lt;/p&gt;

&lt;p&gt;spdlog的源码都在头文件里，直接把源码包含进来就可以了。&lt;/p&gt;

&lt;p&gt;enet则用静态链接的方式引入。需要把enet的源码都放在子目录&lt;strong&gt;enet&lt;/strong&gt;里，然后在enet目录再手写一个CMakeLists.txt：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;cmake_minimum_required&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VERSION&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libenet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# The version number.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENET_VERSION_MAJOR&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENET_VERSION_MINOR&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;include_directories&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;${PROJECT_SOURCE_DIR}/include&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;include_directories&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;${PROJECT_SOURCE_DIR}/src&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLOB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libenet_SRC&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;src/*.c&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libenet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STATIC&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libenet_SRC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;target_link_libraries&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libenet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;winmm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ws2_32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（这个CMakeLists.txt是作为根目录CMakeLists.txt的孩子存在的，由根目录的CMakeLists.txt来调用。）&lt;/p&gt;

&lt;p&gt;有了这2个个CMakeLists.txt后，在根目录新建一个文件夹叫build，然后cmd进入这个目录，并执行：&lt;/p&gt;

&lt;p&gt;cmake ..&lt;/p&gt;

&lt;p&gt;就会自动在build目录生成visual studio项目，启动forwarder.sln，点生成解决方案，如果没报错，就说明构建成功了。&lt;/p&gt;

&lt;h1&gt;docker&lt;/h1&gt;

&lt;p&gt;用docker来测试forwarder在linux系统下的运行情况，非常方便。&lt;/p&gt;

&lt;h3&gt;1.首先windows安装docker：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.docker.com/products/overview&quot;&gt;https://www.docker.com/products/overview&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;2.然后设置share目录：&lt;/h3&gt;

&lt;p&gt;docker安装完毕后在任务栏会有一个图标，右键然后点setting：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/11.png&quot; alt=&quot;11.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/10.png&quot; alt=&quot;10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;注意红圈的内容，提示了我们开启share目录后，怎么在docker中用（其实就是-v指令）。&lt;/p&gt;

&lt;h3&gt;3.然后在cmd中执行：&lt;/h3&gt;

&lt;p&gt;docker run --rm -it -v D:/workplace/forwarder:/data ubuntu:latest&lt;/p&gt;

&lt;p&gt;run代表启动一个container；&lt;/p&gt;

&lt;p&gt;最后的参数ubuntu:latest代表使用ubuntu的最新版本镜像(image)&lt;/p&gt;

&lt;p&gt;其中的-rm作用是exit时会自动删除这个container；&lt;/p&gt;

&lt;p&gt;-it作用是设置成交互模式(interactive)；&lt;/p&gt;

&lt;p&gt;-v D:/workplace/forwarder:/data，是把windows的共享目录D:/workplace/forwarder 映射到container中的/data目录。&lt;/p&gt;

&lt;p&gt;第一次执行时，会从docker官方服务器下载ubuntu:latest镜像到本地，所以会比较慢。&lt;/p&gt;

&lt;p&gt;执行成功后，就进入这个临时生成的ubuntu的控制台啦！&lt;/p&gt;

&lt;h3&gt;4.在ubuntu中构建forward&lt;/h3&gt;

&lt;p&gt;第三步建立的ubuntu镜像不是持久化的，需要永久保存的镜像的话，需要自行写Dockerfile。&lt;/p&gt;

&lt;p&gt;在forwarder根目录下的docker目录我已经写了一个。cmd进入这个目录并执行：&lt;/p&gt;

&lt;p&gt;docker build -t myubuntu  .&lt;/p&gt;

&lt;p&gt;就开始在本地创建一个自定义的image镜像了。&lt;/p&gt;

&lt;p&gt;如果update太慢，可考虑更换国内的soureces，访问：&lt;a href=&quot;http://wiki.ubuntu.org.cn/%E6%A8%A1%E6%9D%BF:16.04source&quot;&gt;http://wiki.ubuntu.org.cn/%E6%A8%A1%E6%9D%BF:16.04source&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;把Dockerfile中的那些sources链接的地址替换成国内的镜像站点即可，例如我替换成阿里云的镜像站点。&lt;/p&gt;

&lt;h3&gt;5.apt-get的一些技巧&lt;/h3&gt;

&lt;p&gt;查询一个包的版本列表：&lt;/p&gt;

&lt;p&gt;apt-cache policy &lt;package name&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/forwarder-buildsystem/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/forwarder-buildsystem/</guid>
      </item>
    
      <item>
        <title>细说红黑树(3)-基本操作之Delete</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;本文争取用精简的文字描述清楚红黑树的各种基本操作：插入、&lt;strong&gt;删除&lt;/strong&gt;、查询。&lt;/p&gt;

&lt;p&gt;在开始下文之前，再次祭出红黑树的四大性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;根节点是黑色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;叶子节点（NULL）视为黑色节点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个节点是红色，那么它的2个孩子节点都是黑色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每条从根节点出发、并到达叶子节点的路径，路径上黑色节点的数量一致（叶子节点也计算在内）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;Delete&lt;/h1&gt;

&lt;p&gt;首先，我感到不开心的一件事是，我发现红黑树的删除逻辑之复杂（比Insert还要复杂！），让红黑树变得不那么完美了。不过下文还是会慢慢介绍整个删除算法。&lt;/p&gt;

&lt;p&gt;红黑树的Delete，需要用到一个新的概念：Double-Black，即删除目标节点后，把另一个节点标记为&lt;strong&gt;双黑&lt;/strong&gt;，然后通过把它调整成&lt;strong&gt;单黑&lt;/strong&gt;，从而不破坏红黑树的性质。&lt;/p&gt;

&lt;h1&gt;资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/&quot;&gt;http://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/redblacktree-3/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/redblacktree-3/</guid>
      </item>
    
      <item>
        <title>细说红黑树(2)-基本操作之Insert</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;本文争取用精简的文字描述清楚红黑树的各种基本操作：&lt;strong&gt;插入&lt;/strong&gt;、删除、查询。&lt;/p&gt;

&lt;p&gt;在开始下文之前，再次祭出红黑树的四大性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;根节点是黑色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;叶子节点（NULL）视为黑色节点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个节点是红色，那么它的2个孩子节点都是黑色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每条从根节点出发、并到达叶子节点的路径，路径上黑色节点的数量一致（叶子节点也计算在内）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;Insert&lt;/h1&gt;

&lt;p&gt;插入操作的第一个准则是，&lt;strong&gt;插入的节点先设置为红色&lt;/strong&gt;，插入后根据插入的节点在树中的&lt;strong&gt;位置&lt;/strong&gt;以及树的&lt;strong&gt;着色状态&lt;/strong&gt;，可以划分出多种情况，这些情况总结如下：&lt;/p&gt;

&lt;p&gt;（注意，在以下所有情况中，在节点插入前红黑树是平衡的，即使从图片上看并不能看出平衡性）&lt;/p&gt;

&lt;p&gt;1.插入的节点是根节点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;显然无需调整红黑树。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2.插入的节点的父节点是&lt;strong&gt;黑&lt;/strong&gt;色&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;插入红节点，并不影响性质4。无需调整红黑树。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3.插入的节点的父节点是&lt;strong&gt;红&lt;/strong&gt;色&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3a.叔节点（即父节点的兄弟节点）也是&lt;strong&gt;红&lt;/strong&gt;色&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种情况下，需要把&lt;strong&gt;父、叔节点变为黑色，并把祖父节点变为红色&lt;/strong&gt;，这样就保证了当前局部范围内红黑树性质能够被满足，但因为祖父节点被改变了颜色，所以事情还没完，需要&lt;strong&gt;递归&lt;/strong&gt;本步骤（即把祖父节点当做是插入的节点），直到到达根节点。&lt;/p&gt;

&lt;p&gt;这个步骤被称为&lt;strong&gt;Recoloring&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3b.叔节点是&lt;strong&gt;黑&lt;/strong&gt;色&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当处于这个情况下，根据&lt;strong&gt;父节点相对祖父节点的位置（Left or Right）和  插入节点相对父节点的位置（Left or Right）&lt;/strong&gt;，总共有四种细分状态：&lt;/p&gt;

&lt;p&gt;i) Left-Left&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;右&lt;/strong&gt;旋转g&lt;/p&gt;

&lt;p&gt;2）交换g和p的颜色&lt;/p&gt;

&lt;p&gt;ii) Right-Right&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/6.png&quot; alt=&quot;6.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;左&lt;/strong&gt;旋转g&lt;/p&gt;

&lt;p&gt;2）交换g和p的颜色&lt;/p&gt;

&lt;p&gt;可以注意到，整个步骤和Left-Left非常相似，其实就是Left-Left的水平镜像。&lt;/p&gt;

&lt;p&gt;iii) Left-Right&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/7.png&quot; alt=&quot;7.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以用一个旋转操作把这个case转换成Left-Left的case，步骤如下：&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;左&lt;/strong&gt;旋转p&lt;/p&gt;

&lt;p&gt;iiii) Right-Left&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;可以用一个旋转操作把这个case转换成Right-Right的case，步骤如下：&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;右&lt;/strong&gt;旋转p&lt;/p&gt;

&lt;h2&gt;资料&lt;/h2&gt;

&lt;p&gt;本文配图使用yEd编辑：&lt;a href=&quot;http://www.yworks.com/products/yed/download&quot;&gt;http://www.yworks.com/products/yed/download&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/red-black-tree-set-2-insert/&quot;&gt;http://www.geeksforgeeks.org/red-black-tree-set-2-insert/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;红黑树测试程序：&lt;a href=&quot;https://www.cs.usfca.edu/%7Egalles/visualization/RedBlack.html&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/RedBlack.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/redblacktree-2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/redblacktree-2/</guid>
      </item>
    
      <item>
        <title>细说红黑树(1)-核心定理</title>
        <description>&lt;p&gt;我一直觉得那些著名的数据结构，都是工程设计和数学的完美结合。&lt;/p&gt;

&lt;p&gt;所有的数据&lt;strong&gt;结构&lt;/strong&gt;都是被精心&lt;strong&gt;设计&lt;/strong&gt;出来的，此所谓工程设计。但是，既然叫精心设计，就意味着有一套准则，这个准则就是数学。&lt;/p&gt;

&lt;p&gt;没有数学基础的数据结构都是耍流氓。&lt;/p&gt;

&lt;p&gt;红黑树拥有精巧的结构设计和强大的数学基础，但我总觉得有点过于复杂，故写本文来回顾总结下。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;红黑树的定义&lt;/h1&gt;

&lt;p&gt;红黑树是一种特殊的二叉树，每个节点有颜色bit，要么红色要么黑色。红黑树必然满足以下4个&lt;strong&gt;结构上&lt;/strong&gt;的性质：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;根节点是黑色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;叶子节点（NULL）视为黑色节点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个节点是红色，那么它的2个孩子节点都是黑色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于每条从根节点出发、并到达叶子节点的路径，路径上黑色节点的数量一致（叶子节点也计算在内）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.10/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这4个性质，稍微想一遍就知道是没有矛盾的。但是没有矛盾只是第一步，接着就是证明这4个性质为什么能使得红黑树变成牛逼的树。&lt;/p&gt;

&lt;p&gt;牛逼指的是这棵树很&lt;strong&gt;平衡&lt;/strong&gt;。平衡的定义是：设二叉树的节点数目为n，那么树的高度h和n必须满足：\( h = O(\log _{2}n)\)。这个就是要证明的东西。&lt;/p&gt;

&lt;h1&gt;红黑树的证明&lt;/h1&gt;

&lt;p&gt;所谓的证明，其实就是从上面的4个结构性质，分析出各种各样的数学上的性质，然后看下这些数学性质究竟能不能决定红黑树是不是平衡。&lt;/p&gt;

&lt;p&gt;若能够证明平衡，就可以抽丝剥茧，找出最关键的几条数学性质，就可以总结出一份简短的证明过程了。&lt;/p&gt;

&lt;p&gt;下面就是一份老外给出的最简单的证明过程。&lt;/p&gt;

&lt;h2&gt;定义BH(x)&lt;/h2&gt;

&lt;p&gt;首先需要定义一个函数BH(x)：x指红黑树的一个节点，BH(x)指这个x节点到叶子节点的路径上黑色节点的数量。&lt;/p&gt;

&lt;p&gt;根据上面的性质4，可以知道无论x走哪条路径到达叶子节点，BH(x)都一样。&lt;/p&gt;

&lt;h2&gt;2个引理&lt;/h2&gt;

&lt;h3&gt;引理1：对于以节点x为根节点的子树，设子树的总的节点数量n，那么有\( n \geq 2^{BH(x)} - 1  \)&lt;/h3&gt;

&lt;p&gt;要分2个情况来证明这个引理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;树只有黑色节点。此时根据性质4，可以知道这树是完全二叉树，完全二叉树的节点数量等于\( 2^{h} - 1  \)，而h又等于BH(x)
。所以此种情况满足引理。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.树有黑色也有红色节点。可以把这种情况视作第一种情况下的红黑树被添加了一些红色节点，根据性质1-4，可知道红色节点并不会影响BH(x)值。所以满足引理。&lt;/p&gt;

&lt;p&gt;综上，此引理没有问题。&lt;/p&gt;

&lt;h3&gt;引理2：设树的高度为h，那么有\( BH(root) \geq \frac {h} {2} \)&lt;/h3&gt;

&lt;p&gt;这个引理其实是在说，从根节点到叶子节点，黑色节点起码有高度的一半那么多。分2步来想：假如黑点节点数量是高度的一半，根据红黑树性质1-4，可以知道必然是黑红相间的排列方式：黑-红-黑-红 ···· ；当黑点节点数量是高度的一半再减一时，说明有一个黑色节点变红了，就说明出现了2个连在一起的红色节点了。就破坏了性质3。于是反证成功。&lt;/p&gt;

&lt;p&gt;另外一种思路：&lt;/p&gt;

&lt;p&gt;因为红黑树的性质3“红节点的2个孩子都是黑节点”，所以使得一条路径上红节点总数最大化的方法，必然是“黑(root)-红-黑-红-······-黑-红-黑-红-黑(leaf)”，注意，最后一个必然是叶子节点，根据性质2，这个叶子节点是黑节点，所以根据这个路径排列，就可以知道红节点必然比黑节点少，反而言之，黑节点数量必然大于等于高度的二分之一。&lt;/p&gt;

&lt;h3&gt;定理：任意一棵红黑树必然满足：\( h \leq 2log_{2}(n+1) \)&lt;/h3&gt;

&lt;p&gt;证明：&lt;/p&gt;

&lt;p&gt;根据引理1，有：&lt;/p&gt;

&lt;p&gt;\[  n \geq 2^{BH(root)} - 1 \]&lt;/p&gt;

&lt;p&gt;再因为引理2，有：&lt;/p&gt;

&lt;p&gt;\[  n \geq 2^{BH(root)} - 1 \geq 2^{\frac {h} {2}} - 1\]&lt;/p&gt;

&lt;p&gt;\[  n \geq 2^{\frac {h} {2}} - 1\]&lt;/p&gt;

&lt;p&gt;再变换一下：&lt;/p&gt;

&lt;p&gt;\[  n + 1 \geq 2^{\frac {h} {2}} \]&lt;/p&gt;

&lt;p&gt;\[  log_{2}(n + 1) \geq log_{2}2^{\frac {h} {2}} \]&lt;/p&gt;

&lt;p&gt;\[  log_{2}(n + 1) \geq \frac {h} {2} \]&lt;/p&gt;

&lt;p&gt;\[ h \leq 2log_{2}(n + 1)   \]&lt;/p&gt;

&lt;p&gt;得证。&lt;/p&gt;

&lt;p&gt;这个定理的重要性在于，它保证了红黑树是&lt;strong&gt;平衡&lt;/strong&gt;的。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;上面介绍的红黑树核心定理的证明过程，似乎并没有多么复杂。所以说伟大的东西往往不复杂是对的。&lt;/p&gt;

&lt;p&gt;红黑树和一般的二叉树相比，在空间上只是多了一个bit，这个特性对红黑树的实际运用非常棒；而围绕“red or black&amp;quot;设计出来的4个性质，恰好使得红黑树获得了最后的不等式，这个不等式使得红黑树和最理想的平衡二叉树也相差无几了。&lt;/p&gt;

&lt;p&gt;虽然红黑树能够简单地被理解，但是它的发明过程想必是不简单的，这需要天才般的想象力(红黑树只用一个标记位)和数学分析能力。也可以称为发明创造能力，这是不容易的。吾等只能膜拜大神。&lt;/p&gt;

&lt;p&gt;除了红黑树平衡性证明之外，还有别的算法设计工作要做，也就是红黑树的插入、删除、调整运算，必须足够快，不然实际价值就会降低。&lt;/p&gt;

&lt;p&gt;当然，上文只能证明红黑树&lt;strong&gt;在理论上的优秀&lt;/strong&gt;。如果在工程上能够实现这套理论，才算是完美的，然而实际上不那么简单（要正确实现红黑树的插入、删除、旋转操作啊）。下一篇文章前我会自己实现一遍红黑树，再写下心得体会。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.dgp.toronto.edu/people/JamesStewart/378notes/16redBlack/&quot;&gt;http://www.dgp.toronto.edu/people/JamesStewart/378notes/16redBlack/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/redblacktree-1/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/redblacktree-1/</guid>
      </item>
    
      <item>
        <title>蒙特·卡罗(Monte Carlo)积分在图形学中的应用</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;计算着色点的间接光照&lt;/h1&gt;

&lt;p&gt;在计算一个着色点的间接光照时，理论上可以通过从着色点往上半球各个方向发射无数条光线，并计算这些光线返回的Rdiance值，就可以得到这个着色点的间接光照。但因为计算机的计算速度问题，不可能给一个着色点生成“无数”条光线，在工程实现上必然是得做成有限数量的光线，且很悲哀的，这个数量值不会很大。&lt;/p&gt;

&lt;p&gt;那么如何用有限的光线，得到最真实的间接光照值呢？答案是用蒙特·卡罗积分。蒙特·卡罗积分的特性是，采样数越多就越接近真实积分值，而这正是做间接光照计算所需要的。譬如我们可以根据实际需求，设置采样数量，数量大就出图慢、精度高，数量小就出图快但粗糙。&lt;/p&gt;

&lt;p&gt;下面开始数学环节。&lt;/p&gt;

&lt;h2&gt;计算间接光照的蒙特·卡罗方法&lt;/h2&gt;

&lt;p&gt;生成间接光照的各个光线时，需要有一个随机变量\(\omega \)，这个随机变量就是光线的“出射角度”，更严格地说应该是“&lt;a href=&quot;http://www.qiujiawei.com/solid-angle/&quot;&gt;立体角&lt;/a&gt;”。&lt;/p&gt;

&lt;p&gt;对于一个半球，它的总立体角是2π，那么关于\(\omega \)的pdf函数记为\(p(\omega ) \)，而在上一篇文章中我们知道pdf的积分等于1，所以有：&lt;/p&gt;

&lt;p&gt;\[ \int _{\omega = 0 }^{2π}p(\omega )d\omega = 1 \]&lt;/p&gt;

&lt;p&gt;又因为我们希望\(\omega \)是符合均匀分布的，从而使得间接光照采样是概率无偏的，那么\(p(\omega ) \)是一个常数：&lt;/p&gt;

&lt;p&gt;\[ p(\omega ) = C \]&lt;/p&gt;

&lt;p&gt;\[ C\int _{\omega = 0 }^{2π}d\omega = 1 \]&lt;/p&gt;

&lt;p&gt;这个方程是可以解出来的:&lt;/p&gt;

&lt;p&gt;\[ C\int _{\omega = 0 }^{2π}d\omega = C(2π - 0 ) =  1 \]&lt;/p&gt;

&lt;p&gt;\[  p(\omega ) = C = \frac {1}{2π} \]&lt;/p&gt;

&lt;p&gt;成功解决了第一个事情：&lt;strong&gt;随机变量\(\omega \)的pdf函数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下一个问题是：&lt;strong&gt;把立体角\(\omega \)转换成球形角\(\phi 、\theta  \)，从而方便实际计算&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;\[  p(\omega ) d\omega =  p(\theta , \phi) d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;其中，\(d\omega \)的转换方法在&lt;a href=&quot;http://www.qiujiawei.com/solid-angle/&quot;&gt;立体角(Solid Angle)详解&lt;/a&gt;中已经阐述过了，公式为：&lt;/p&gt;

&lt;p&gt;\[ d\omega = sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;所以有：&lt;/p&gt;

&lt;p&gt;\[  p(\omega ) d\omega =  p(\theta , \phi) d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;\[  p(\omega ) sin\theta d\theta d\phi =  p(\theta , \phi) d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;\[  \frac {1}{2π} sin\theta d\theta d\phi =  p(\theta , \phi) d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;\[  \frac {1}{2π} sin\theta  =  p(\theta , \phi)  \]&lt;/p&gt;

&lt;p&gt;\[  p(\theta , \phi) = \frac {sin\theta}{2π}  \]&lt;/p&gt;

&lt;p&gt;\( p(θ,ϕ)\) 被称为联合概率分布(joint probability distribution)。此时，我们需要实现对θ,ϕ各自的独立采样，所以需要把\( p(θ,ϕ)\)拆分开，求出\( p(θ)\) 和 \( p(ϕ) \)。幸运地是，有简单的方法可以实现同样的效果，那就是用&lt;a href=&quot;https://en.wikipedia.org/wiki/Marginal_distribution&quot;&gt;边缘分布(marginal distribution)&lt;/a&gt;。计算过程如下：&lt;/p&gt;

&lt;p&gt;\[ p(θ) = \int _{\phi = 0}^{2π}p(θ,ϕ)d\phi = \int _{\phi = 0}^{2π}\frac {sin\theta}{2π}d\phi = 2π \frac {sin\theta}{2π} =sin\theta \]&lt;/p&gt;

&lt;p&gt;\[ p(ϕ) = \int _{θ = 0}^{ \frac {π}{2} }p(θ,ϕ)dθ = \int _{ θ = 0}^{ \frac {π}{2} }\frac {sin\theta}{2π}dθ = \frac {-cos\theta}{2π} | _{0}^{\frac {π}{2}}= \frac {-cos \frac {π}{2} }{2π} - \frac {-cos0 }{2π} = \frac {1}{2π} \]&lt;/p&gt;

&lt;p&gt;\(p(ϕ)\)也可以用联合概率公式来求解：&lt;/p&gt;

&lt;p&gt;\[ p(ϕ) =\frac {p(θ,ϕ)}{p(θ)} =  \frac { \frac {sin\theta}{2π}  }{ sin\theta }  = \frac {1}{2π} \]&lt;/p&gt;

&lt;p&gt;到了这里，事情还没完，还有2个东西要学习：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cumulative_distribution_function&quot;&gt;CDF, Cumulative distribution function&lt;/a&gt; 和 &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_transform_sampling&quot;&gt;Inverse transform sampling&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;CDF 累积分布函数&lt;/h2&gt;

&lt;p&gt;公式如下：&lt;/p&gt;

&lt;p&gt;\[ CDF(x) = P( -\infty &amp;lt; X \leq x ) \]&lt;/p&gt;

&lt;p&gt;大写X是指随机变量，小写x指的是参数，P是概率函数，因此CDF(x)的含义是，&lt;strong&gt;随机变量X的值小于等于x的概率&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对于连续随机变量X，CDF可以用积分形式表示：&lt;/p&gt;

&lt;p&gt;\[ CDF(s) = \int _{-\infty }^{s}pdf(x)dx \]&lt;/p&gt;

&lt;p&gt;从基本定义延伸出来的公式：&lt;/p&gt;

&lt;p&gt;\[ P(a &amp;lt; x \leq b) = CDF(b) - CDF(a) = \int _{ a }^{b}pdf(x)dx  \]&lt;/p&gt;

&lt;p&gt;CDF的性质：&lt;/p&gt;

&lt;p&gt;\[ \lim _{x\to -\infty }CDF(x) = 0 \]&lt;/p&gt;

&lt;p&gt;\[ \lim _{x\to +\infty }CDF(x) = 1 \]&lt;/p&gt;

&lt;p&gt;实例，取值范围是[0,1]的随机变量X的CDF：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.8/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;CDF一般也可以用\(F_{X}\)表示。&lt;/p&gt;

&lt;h2&gt;Inverse transform sampling 逆采样方法&lt;/h2&gt;

&lt;p&gt;步骤一：获得一个均布分布的随机变量u，这个u必须落在[0,1]范围内，并把这个u解释为“概率值”（概率的范围也是[0,1])。&lt;/p&gt;

&lt;p&gt;步骤二：获得一个CDF(x)函数&lt;/p&gt;

&lt;p&gt;步骤三：计算使得下面的不等式成立的x的最大值：&lt;/p&gt;

&lt;p&gt;\[ CDF(x) = P( -\infty &amp;lt; X \leq x ) = F_{X}(x) &amp;lt; u \]&lt;/p&gt;

&lt;p&gt;因为&lt;strong&gt;逆采样&lt;/strong&gt;本质上是一个函数，变量是u，解是x，所以用这个不等式来表达逆采样方法是不方便的，更常见的做法是用\(F_{X}^{-1}(u) \)来表示&lt;strong&gt;逆采样&lt;/strong&gt;。\(F_{X}^{-1}(u) \)的完整表达式一般用&lt;a href=&quot;https://en.wikipedia.org/wiki/Infimum_and_supremum&quot;&gt;下确界或上确界&lt;/a&gt;等式表示：&lt;/p&gt;

&lt;p&gt;上确界形式：&lt;/p&gt;

&lt;p&gt;\[ F_{X}^{-1}(u) = \sup \lbrace F_{X}(x) &amp;lt; u \rbrace \]&lt;/p&gt;

&lt;p&gt;下确界形式：&lt;/p&gt;

&lt;p&gt;\[ F_{X}^{-1}(u) = \inf \lbrace F_{X}(x) \geq u \rbrace \]&lt;/p&gt;

&lt;p&gt;\(F_{X}^{-1}(u) \)的重要性质：u的每一个取值都有唯一的x与之对应。使得这个性质的原因是CDF是一个递增的函数。&lt;/p&gt;

&lt;p&gt;因此，在实际应用中，可以先随机一个u，再通过CDF函数计算出对应的x，又因为u是均匀采样(uniform sample)的，于是x也是均匀采样的。&lt;/p&gt;

&lt;h2&gt;再回到间接光照的问题&lt;/h2&gt;

&lt;p&gt;前面已经得到了\( p(θ)\) 和 \( p(ϕ) \):&lt;/p&gt;

&lt;p&gt;\[ p(θ) = sin\theta \]&lt;/p&gt;

&lt;p&gt;\[ p(ϕ) = \frac {1}{2π} \]&lt;/p&gt;

&lt;p&gt;现在可以推导它们的CDF函数了：&lt;/p&gt;

&lt;p&gt;\[ CDF(θ) = \int _{0 }^{θ}p(θ)dθ = \int _{0 }^{θ}sin\theta dθ = (-cos\theta) |_{0}^{θ}  = -cos\theta - (-cos0) = 1 - cos\theta \]&lt;/p&gt;

&lt;p&gt;\[ CDF(ϕ) = \int _{0 }^{ϕ}p(ϕ)dϕ = \int _{0 }^{ϕ}\frac {1}{2π}dϕ = \frac {1}{2π}\int _{0 }^{ϕ}dϕ = \frac {ϕ}{2π} \]&lt;/p&gt;

&lt;p&gt;即：&lt;/p&gt;

&lt;p&gt;\[ F_{θ}(θ) = 1 - cos\theta  \]&lt;/p&gt;

&lt;p&gt;\[ F_{ϕ}(ϕ) = \frac {ϕ}{2π} \]&lt;/p&gt;

&lt;p&gt;然后就是推导这两个CDF的逆采样公式，设：&lt;/p&gt;

&lt;p&gt;\[ u_{1} = 1 - cos\theta \]&lt;/p&gt;

&lt;p&gt;\[ cos\theta = 1 - u_{1}  \]&lt;/p&gt;

&lt;p&gt;\[ \theta = cos^{-1}(1 - u_{1})  \]&lt;/p&gt;

&lt;p&gt;即：&lt;/p&gt;

&lt;p&gt;\[ F_{θ}^{-1}(u_{1}) = cos^{-1}(1 - u_{1}) \]&lt;/p&gt;

&lt;p&gt;再设：&lt;/p&gt;

&lt;p&gt;\[ u_{2} = \frac {ϕ}{2π} \]&lt;/p&gt;

&lt;p&gt;\[ ϕ = u_{2}2π  \]&lt;/p&gt;

&lt;p&gt;即：&lt;/p&gt;

&lt;p&gt;\[ F_{ϕ}^{-1}(u_{2}) =  u_{2}2π   \]&lt;/p&gt;

&lt;p&gt;汇总一下：&lt;/p&gt;

&lt;p&gt;\[ F_{θ}^{-1}(u_{1}) = cos^{-1}(1 - u_{1}) \]&lt;/p&gt;

&lt;p&gt;\[ F_{ϕ}^{-1}(u_{2}) =  u_{2}2π   \]&lt;/p&gt;

&lt;p&gt;总结一下：只要生成2个在[0,1]范围的符合均匀分布的随机数\( u_{1}、u_{2}\)，就可以得到均匀分布的\(θ、ϕ\)了，就是这么简单。&lt;/p&gt;

&lt;p&gt;有了\(θ、ϕ\)后，就可以代入3维的极坐标公式，得到3维的笛卡尔坐标：&lt;/p&gt;

&lt;p&gt;\[ x= sinθ cosϕ \]&lt;/p&gt;

&lt;p&gt;\[ y= cosθ \]&lt;/p&gt;

&lt;p&gt;\[ z= sinθ sinϕ \]&lt;/p&gt;

&lt;p&gt;坐标(x,y,z)必然落在圆心在原点、半径为1、法向量为(0,1,0)的半球的球面。&lt;/p&gt;

&lt;p&gt;有了(x,y,z)坐标，就可以生成沿着半球面的均匀的出射光线了。之后的就是光线追踪的问题了。本文不表。&lt;/p&gt;

&lt;h1&gt;实际测试&lt;/h1&gt;

&lt;p&gt;把蒙特卡洛应用到我的离线渲染器中，效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.9/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;有看起来比较奇怪的边缘噪点。暂时先这样吧。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing/global-illumination-path-tracing-practical-implementation&quot;&gt;http://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing/global-illumination-path-tracing-practical-implementation&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 03 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/monte-carlo2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/monte-carlo2/</guid>
      </item>
    
      <item>
        <title>蒙特·卡罗(Monte Carlo)积分详解</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;蒙特·卡罗积分公式&lt;/h2&gt;

&lt;p&gt;对于一个连续函数f，它的积分公式为：&lt;/p&gt;

&lt;p&gt;\[ F = \int _{a}^{b}f(x)dx \]&lt;/p&gt;

&lt;p&gt;对应的，f的&lt;a href=&quot;https://en.wikipedia.org/wiki/Monte_Carlo_integration&quot;&gt;蒙特·卡罗积分公式&lt;/a&gt;如下：&lt;/p&gt;

&lt;p&gt;\[ F^{N} = \frac {1}{N}\sum _{i=1}^{N}\frac {f(X_{i})}{ pdf(X_{i}) } \]&lt;/p&gt;

&lt;p&gt;蒙特卡罗最关键的就是理解这条公式了。其他延伸探讨都可以暂时忽略。那么这条公式如何理解呢？首先第一点是，虽然这条公式没有积分符号\(\int  \)，但是它认被称为&lt;strong&gt;积分&lt;/strong&gt;，这是因为这公式的作用相当于在对f(x)做积分，只不过不那么“精确”，即蒙特·卡罗积分是&lt;strong&gt;对理想积分的近似&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;那么这个近似是如何完成的？很简单，核心就是两个字：&lt;strong&gt;采样(Sampling)&lt;/strong&gt;。对一个连续函数的采样方法是在该函数的定义域中随机挑N个值，并求出对应的N个\( f(X_{i}) \)，就得到了样本集合。再对这些样本集合做一些换算，就可以得到一个近似的积分了。对于蒙特·卡罗积分，&lt;strong&gt;采样样本越多，就越逼近真实的积分结果&lt;/strong&gt;，这是蒙特·卡罗积分的最核心特性。&lt;/p&gt;

&lt;p&gt;继续观察上面的公式，里面还有一个极其重要的参数：pdf(probability distribution function，概率分布函数)。pdf还有个近亲pmf，下面小节详解pdf、pmf的由来。&lt;/p&gt;

&lt;h2&gt;pdf和pmf&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;pmf(probability mass function)，指的是&lt;strong&gt;离散的&lt;/strong&gt;随机变量的概率分布函数&lt;/li&gt;
&lt;li&gt;pdf(probability distribution function)， 指的是&lt;strong&gt;连续的&lt;/strong&gt;随机变量的概率分布函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;离散的随机变量X的数学期望为：&lt;/p&gt;

&lt;p&gt;\[E[X] = \sum _{ x_{i} }pmf(x_{i})x_{i} \]&lt;/p&gt;

&lt;p&gt;连续的随机变量X的数学期望为：&lt;/p&gt;

&lt;p&gt;\[E[X] = \int ^{\infty }_{-\infty }pdf(x)xdx \]&lt;/p&gt;

&lt;p&gt;pdf和pmf名字接近，含义也是接近。pdf、pmf函数的参数都是样本值x，返回值是概率，即表示一个样本出现的概率，所有样本的出现概率之和(概率的积分)应等于1。要注意的是，pdf、pmf的存在说明有可能每个样本的出现概率都是各不相同的。&lt;/p&gt;

&lt;h3&gt;pmf&lt;/h3&gt;

&lt;p&gt;pmf的简单例子就是&lt;strong&gt;基于均匀分布的离散的随机变量X&lt;/strong&gt;，此时\( pmf(X_{i}) \)恒等于\( \frac{1}{N} \)，含义是每个随机样本的出现概率等于\( \frac{1}{样本总数} \)。&lt;/p&gt;

&lt;p&gt;通过这个例子也印证了pmf的性质：&lt;strong&gt;pmf函数的所有结果值之和等于1&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;pdf&lt;/h3&gt;

&lt;p&gt;借用&lt;a href=&quot;http://www.scratchapixel.com/&quot;&gt;http://www.scratchapixel.com/&lt;/a&gt;的一个很好的例子来说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.8/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个例子中，目标问题是求出该函数[a,b]段曲线下方的面积(最后一幅图的黑色区域)，也就是要求该函数[a,b]段的积分。基于蒙特·卡罗积分的解法，就要用上面给出的公式：&lt;/p&gt;

&lt;p&gt;\[ F^{N} = \frac {1}{N}\sum _{i=1}^{N}\frac {f(X_{i})}{ pdf(X_{i}) } \]&lt;/p&gt;

&lt;p&gt;在此图中，做了四次随机采样，得到了四个随机样本\( x_{i} \)：\( x_{1}、x_{2}、x_{3}、x_{4} \)，并且进而得到了这四个样本的\( f(x_{i}) \)值：\( f(x_{1})、f(x_{2})、f(x_{3})、f(x_{4}) \)。（原文没有提及如何得到\( f(x_{i}) \)。函数f是奇形怪状的，不太可能有表达式存在，难道是用尺子量的？暂且忽略这个事吧。）&lt;/p&gt;

&lt;p&gt;有了这4个样本后，可以针对每一个样本求一个&lt;strong&gt;近似面积值&lt;/strong&gt;，这个面积值等于\( f(x_{i})  (b - a) \)。为什么可以这样做呢？是因为每一个单独的样本是对原函数f的近似，即在每个样本中，认为\( f(x) \)恒等于\( f(x_{i}) \)，从而让原函数曲线简化成一个矩形区域，而矩形的面积显然就是长(b-a)乘以宽\( f(x_{i}) \)。&lt;/p&gt;

&lt;p&gt;得到4个&lt;strong&gt;近似面积值&lt;/strong&gt;后，再求出它们的均值(数学期望)，就完成了蒙特·卡罗积分。把上述流程汇总得到：&lt;/p&gt;

&lt;p&gt;\[ Area = \frac {1}{4}(f(x_{1})(b - a) + f(x_{2})(b - a) + f(x_{3})(b - a) + f(x_{4})(b - a)) \]&lt;/p&gt;

&lt;p&gt;\[ = \frac {1}{4}(b - a)( f(x_{1}) + f(x_{2}) + f(x_{3}) + f(x_{4}) ) \]&lt;/p&gt;

&lt;p&gt;\[ = \frac {1}{4}(b - a)\sum _{i=1}^{4}f(x_{i}) \]&lt;/p&gt;

&lt;p&gt;此时，对比下蒙特·卡罗积分公式：&lt;/p&gt;

&lt;p&gt;\[ F^{N} = \frac {1}{N}\sum _{i=1}^{N}\frac {f(X_{i})}{ pdf(X_{i}) } \]&lt;/p&gt;

&lt;p&gt;发现两个式子非常相似，对式子做下转换得到：&lt;/p&gt;

&lt;p&gt;\[ Area =  \frac {1}{4}\sum _{i=1}^{4}\frac {f(x_{i})}{\frac {1}{b - a} } \]&lt;/p&gt;

&lt;p&gt;于是可以知道\( pdf(x_{i}) \)等于：&lt;/p&gt;

&lt;p&gt;\[ pdf(x_{i}) = \frac {1}{b - a } \]&lt;/p&gt;

&lt;p&gt;这意味着，对于连续函数f，f的每个可能取值x的出现概率等于x的取值范围[a,b]的倒数\(\frac{1}{b-a}\)。&lt;/p&gt;

&lt;p&gt;在实际应用场合，随机变量X要写成F(X)，即可能需要对X做一个转换再使用。这时候要注意F(X)的pdf不等于X的pdf。&lt;/p&gt;

&lt;h2&gt;蒙特·卡罗积分的数学期望等于理想积分？&lt;/h2&gt;

&lt;p&gt;对于下面的\(F\)和\(F^{N}\)：&lt;/p&gt;

&lt;p&gt;\[ F = \int _{a}^{b}f(x)dx \]&lt;/p&gt;

&lt;p&gt;\[ F^{N} = \frac {1}{N}\sum _{i=1}^{N}\frac {f(X_{i})}{ pdf(X_{i}) } \]&lt;/p&gt;

&lt;p&gt;是否随着N变大，\(F^{N}\)会逼近\(F\)？即\(F^{N}\)的数学期望是否等于\(F\)?&lt;a href=&quot;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration&quot;&gt;Monte Carlo Methods in Practice&lt;/a&gt;文章中给出了推导过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.8/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;第二行到第三行是最不好理解的。因为这里其实用到了新的知识点：&lt;a href=&quot;https://en.wikipedia.org/wiki/Law_of_the_unconscious_statistician&quot;&gt;Law of the unconscious statistician&lt;/a&gt;(简称：LOTUS)。LOTUS的应用情景是，已知随机变量X的概率分布，但不知道f(x)的分布，此时用LOTUS公式能计算出函数f(x)的数学期望。LOTUS的公式如下：&lt;/p&gt;

&lt;p&gt;f(x)是离散函数时:&lt;/p&gt;

&lt;p&gt;\[ E[f(X)] = \sum _{x_{i}}f(x_{i})pmf(x_{i}) \]&lt;/p&gt;

&lt;p&gt;f(x)是连续函数时:&lt;/p&gt;

&lt;p&gt;\[ E[f(X)] = \int _{-\infty }^{\infty}f(x)pdf(x)dx \]&lt;/p&gt;

&lt;p&gt;(建议对比第二小节开头的两条公式来理解)&lt;/p&gt;

&lt;p&gt;有了LOTUS公式，再来看第二行到第三行的转换，就好理解了：&lt;/p&gt;

&lt;p&gt;\[ E[ \frac {f(X_{i})}{pdf(X_{i})} ] = E[ \frac {f(x)}{pdf(x)} ] =\int _{-\infty }^{\infty}\frac {f(x)}{pdf(x)}pdf(x)dx \]&lt;/p&gt;

&lt;p&gt;\[ =\int _{-\infty }^{\infty}f(x)dx \]&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration&quot;&gt;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations/expected-value-of-the-function-of-a-random-variable&quot;&gt;http://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-mathematical-foundations/expected-value-of-the-function-of-a-random-variable&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/monte-carlo/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/monte-carlo/</guid>
      </item>
    
      <item>
        <title>渲染基础理论的介绍(2)——工程实现</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;从SPD到XYZ&lt;/h2&gt;

&lt;p&gt;在上一篇文章中，已经提到了SPD需要转换成XYZ值，才能进一步转换成RGB从而变成位图。这里面的工程实现还是需要学习一下的。&lt;/p&gt;

&lt;p&gt;首先，先回顾下三色XYZ三色刺激值(tristimulus vlaues)的图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/14.png&quot; alt=&quot;14.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个图怎么用到程序里呢？方法就是打表，图中有3个函数\( \hat {x}(\lambda ) 、 \hat {y}(\lambda ) 、 \hat {z}(\lambda )\)，可以建立4个数组来表示：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//切片数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;471&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//存了λ值的数组，范围是从360到830，即可见光波段&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;360&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;361&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;362&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;363&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;364&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;365&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;366&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;367&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;368&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;369&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;370&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;371&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;372&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;373&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;374&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;······&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;825&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;826&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;827&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;828&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;829&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;830&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//下面三个数组的元素的取值范围是[0.0, 2.0]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//hat(x)函数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.0001299000f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.0001458470f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.0001638021f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mf&quot;&gt;0.0001840037f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;······&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.000001439440f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.000001341977f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.000001251141f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//hat(y)函数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.000003917000f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.000004393581f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;0.000004929604f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.000005532136f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;······&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.0000005198080f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0000004846123f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0000004518100f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//hat(z)函数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.0006061000f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0006808792f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0007651456f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0008600124f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;······&lt;/span&gt;
    &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为\( \hat {x}(\lambda ) 、 \hat {y}(\lambda ) 、 \hat {z}(\lambda )\)是常量（和万有引力常数一样的常数）,所以上面的4个数组只需要制作一次就行了，然后可以把它们硬编码到你的程序里(pbrt就是这么干的)。&lt;/p&gt;

&lt;h2&gt;SPD数据源&lt;/h2&gt;

&lt;p&gt;SPD数据源如何获得暂且不提，这里关注的是SPD数据源的存放格式：它应该是一个序列，序列中的元素是一个tuple，tuple里存了2个元素，一是λ值，二是v值，代表眼睛-光谱敏感度(spectral sensitivity)，后者一般是一个单位化的值(0.0到1.0之间):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//n由数据提供方给出&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;···&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;从SPD转换到XYZ到RGB&lt;/h2&gt;

&lt;p&gt;先贴上pbrt的实现代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//pbrt-v2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RGBSpectrum&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FromSampled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//part I&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nCIESamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InterpolateSpectrumSamples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                               &lt;span class=&quot;n&quot;&gt;CIE_lambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CIE_Z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//part II&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//part III&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FromXYZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数的参数分别是SPD曲线的λ值、v值、λ-v对数(即采样次数)，这3者确定了一条离散的SPD曲线；该函数的返回值就是一个RGB值。&lt;/p&gt;

&lt;p&gt;可以把这个函数分成3部分来阅读理解。&lt;/p&gt;

&lt;p&gt;part I是其中最关键的，这个for循环计算出了xyz各个分量的值，循环次数和nCIESamples一致，每次循环需要执行一个InterpolateSpectrumSamples函数得到一个val值(这个val是波长!)，再把这个val值分别和CIE_X、CIE_Y、CIE_Z相乘，并累加到xyz数组里。这个步骤其实就是下面的公式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/15.png&quot; alt=&quot;15.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;的离散版本:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/16.png&quot; alt=&quot;16.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;InterpolateSpectrumSamples做的事情也不复杂。因为SPD的n值和nCIESamples不一定一样，也就是说不可能SPD和XYZ表的切片刚好一致，所以必然要做线性插值，从而把SPD切片数据转换成可用数据。具体转换过程看pbrt源码即可。&lt;/p&gt;

&lt;p&gt;part II是把xyz规范化(Normalize)的过程。part I 加上 part II总的公式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/24.png&quot; alt=&quot;24.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;part III做的事情就是把XYZ转换成RGB，公式在上一篇文章已经给出了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/17.png&quot; alt=&quot;17.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;对应的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;XYZToRGB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.240479f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.537150f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.498535f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.969256f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.875991f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.041556f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.055648f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.204043f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.057311f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，这里得到的RGB是线性空间的RGB，并没有做gamma校正。gamma校正的公式如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/21.png&quot; alt=&quot;21.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;gamma校正应放在【线性空间】到【非线性空间】的转换时做，也就是最后输出时。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//gamma校正&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GammaCorrect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0031308f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;12.92f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.055f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.4f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.055f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;//Clamp函数&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;//RGB_linear转成sRGB&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GammaCorrect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GammaCorrect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GammaCorrect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;255.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;pbrt源码&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/rendering-equation2/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/rendering-equation2/</guid>
      </item>
    
      <item>
        <title>记录c++一些神奇的报错</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;Heap Corruption Deteched&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/10.png&quot; alt=&quot;10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这个报错发生在main函数返回时。出错原因是在堆数组的赋值上。&lt;/p&gt;

&lt;p&gt;先是初始化一个数组指针：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后循环赋值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，这个循环溢出了，这个循环对array[100]进行了赋值，即数组的第101个元素，而数组长度只有100。&lt;/p&gt;

&lt;p&gt;然后再执行delete[] array就会出上面截图那个报错了。&lt;/p&gt;

&lt;p&gt;修了那个循环次数就没事了，就酱。&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/c++-error-solved/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/c++-error-solved/</guid>
      </item>
    
      <item>
        <title>渲染基础理论的介绍(1)</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;基础概念&lt;/h1&gt;

&lt;h2&gt;辐射度学 Radiometry&lt;/h2&gt;

&lt;p&gt;辐射度学是指测量电磁辐射(包括可见光)的一系列技术，它是和观察者无关的。而近似的光度学(photometric)，是观察者相关的。这里我所说的观察者无关，是指测量值和人眼并无关系，是绝对值。&lt;/p&gt;

&lt;p&gt;基于辐射度学来做渲染，需要了解下面这些东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;光谱 Spectrum&lt;/li&gt;
&lt;li&gt;光谱功率分布(SPD, spectral power distribution)&lt;/li&gt;
&lt;li&gt;XYZ 和 RGB 两种CIE颜色系统以及它们之间、它们和SPD之间的转换&lt;/li&gt;
&lt;li&gt;辐射通量(Flux)&lt;/li&gt;
&lt;li&gt;立体角(Solid Angle)&lt;/li&gt;
&lt;li&gt;辐射密度(Irradiance)&lt;/li&gt;
&lt;li&gt;辐射亮度(Radiance)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;光谱 Spectrum&lt;/h2&gt;

&lt;p&gt;现实中大部分光源（非直接光源也算），发射出的光都是复合光，即是由不同波长的色光混合而成的。 光谱就是指所有光波的&lt;strong&gt;分布&lt;/strong&gt;。光谱图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/11.png&quot; alt=&quot;11.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;其中波长在 390 nm 到700 nm之间的光波称为可见光。&lt;/p&gt;

&lt;h2&gt;光谱功率分布&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectral_power_distribution&quot;&gt;spectral power distribution&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;光谱功率分布描述的是这样一件事情：对于一个直接或间接光源物体，它发射出的复合光中各个波长的色光分别有多少能量，或者说，这个光源的能量是如何分布到各个波长的光波的？&lt;/p&gt;

&lt;p&gt;譬如，水银灯的光主成分是波长为404.7, 407.8, 435.8, 546.1, 577.0, 579.0纳米的光波（见下图）。这意味着能量分布非常不平衡，主要集中在这几个波长上了，相当于离散了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/12.png&quot; alt=&quot;12.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;上图就是水银灯的SPD曲线了。&lt;/p&gt;

&lt;p&gt;而白炽灯的SPD曲线是这样子的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/13.png&quot; alt=&quot;13.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;注意上面两个图中，横轴是指波长，纵轴是指每单位纳米(10纳米一个单位)的波长的功率（能量）。&lt;/p&gt;

&lt;p&gt;SPD曲线都是用&lt;a href=&quot;https://en.wikipedia.org/wiki/Spectroradiometer&quot;&gt;Spectroradiometers&lt;/a&gt; 这种专门仪器测量的。&lt;/p&gt;

&lt;p&gt;SPD一般用符号P(λ)表示。&lt;/p&gt;

&lt;h2&gt;XYZ 三色刺激值(tristimulus vlaues)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/14.png&quot; alt=&quot;14.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(CIE标准观察者颜色匹配函数)(The CIE standard observer color matching functions)&lt;/p&gt;

&lt;p&gt;当看到CIE standard observer字眼时，其实指的就是上面这个图。这个图是通过测量获得的，好处是这个图相当于一个数据表，当需要把SPD曲线转换成XYZ三刺激值时，就可以用这个图做，坏处是它不是数学描述出来的，那么应用起来就有一定限制性。&lt;/p&gt;

&lt;p&gt;那么SPD如何转换到XYZ呢？公式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/15.png&quot; alt=&quot;15.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这里面用到了积分，但因为匹配函数是非数学描述的（上面的图的3条曲线），所以这个公式不可用，然而我们可以另辟蹊径，用采样和线性叠加的方法计算XYZ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/16.png&quot; alt=&quot;16.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;这里的下标i代表第几个刻度的采样。采样间隔(spacing)一般是1到20纳米，采样空间(span)是整个可见光波段（这个波段的具体范围取决于实际需求和SPD曲线）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.brucelindbloom.com/index.html?Eqn_Spect_to_XYZ.html&quot;&gt;通过SPD计算XYZ：Computing XYZ From Spectral Data&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;XYZ和RGB之间的互相转换&lt;/h2&gt;

&lt;h3&gt;XYZ到RGB&lt;/h3&gt;

&lt;p&gt;公式是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/17.png&quot; alt=&quot;17.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(此矩阵只适用于 &lt;a href=&quot;https://en.wikipedia.org/wiki/SRGB&quot;&gt;sRGB&lt;/a&gt; 定义中的RGB)&lt;/p&gt;

&lt;p&gt;(对于右边的输入值XYZ，也是有要求的，这是因为左边的\(RGB_{linear} \)的取值范围是[0,1]，所以右边的XYZ也需要做规范化。在我的下一篇文章中会介绍这部分。)&lt;/p&gt;

&lt;p&gt;得到的\(RGB_{linear} \)是线性空间的，有什么意义呢？因为一般渲染器都是在线性空间下进行光照计算的，所以这个\(RGB_{linear} \)可直接用到光照等计算中。但是当要把最终的渲染结果输出时，例如写入到位图文件或显示到屏幕上，就需要对每个像素的\(RGB_{linear} \)做gamma校正，校正成sRGB，公式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/21.png&quot; alt=&quot;21.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;校正后的sRGB是单位化的，各个分量的取值范围是[0.0, 1.0]，输出时需要乘以255并取整。&lt;/p&gt;

&lt;h3&gt;RGB到XYZ&lt;/h3&gt;

&lt;p&gt;当输入的RGB是sRGB时，需要做逆gamma校正，公式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/22.png&quot; alt=&quot;22.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;得到线性空间的RGB值后，就可以用下面的公式转换到XYZ空间：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/23.png&quot; alt=&quot;23.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;辐射通量(Flux)&lt;/h2&gt;

&lt;p&gt;辐射通量(Radiant Flux)，指的是单位时间到达一块平面(或一个局部空间区域)的能量总和。单位是焦耳每秒(joules/second,，J/s)，或瓦特(watts，W)。符号是\(\Phi \)。&lt;/p&gt;

&lt;p&gt;一个点光源发射出去的能量大小可以用Flux来描述。其中要注意的是，Flux描述的是单位时间的能量，那么对于点光源来说，Flux只和光源的强弱有关，所以下图的2个圆圈的Flux值是一样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;辐射密度(Irradiance)  (或称辐射照度(Radiant Exitence))&lt;/h2&gt;

&lt;p&gt;辐射密度也叫辐射照度。定义了辐射通量后，就可以定义辐射照度了，辐射照度指的是单位面积&lt;strong&gt;进入&lt;/strong&gt;的辐射通量，单位是\(W/m^{2}\)。根据这个定义用符号E表示。&lt;/p&gt;

&lt;p&gt;辐射照度和辐射密度是近似的东西，辐射照度指的是单位面积&lt;strong&gt;离开&lt;/strong&gt;的辐射通量，单位也是\(W/m^{2}\)。用符号M表示。&lt;/p&gt;

&lt;p&gt;以上面的点光源来分析，可以知道上图中内圆圈的辐射照度比外圆圈的辐射照度大，这是因为内圆圈的面积更小而点光源的Flux值恒定，所以内圆圈的E值就大。&lt;/p&gt;

&lt;p&gt;用公式表示：&lt;/p&gt;

&lt;p&gt;\[ E = \frac { 点光源辐射通量 }{ 球的表面积 } =  \frac {\Phi}{4\pi r^{2} } \]&lt;/p&gt;

&lt;p&gt;可见，W恒定，半径r越小，那么辐射照度E越大。&lt;/p&gt;

&lt;p&gt;当假设光源在无限远处时，可把光源认为是一块平面（这种光源叫方向光）。此时，光源平面与被照射平面存在2种情形：光源平面与被照射平面平行（下图中的A）、光源平面与被照射平面不平行（下图中的B）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/5.png&quot; alt=&quot;5.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图中的平面附近的A指的是面积Area)&lt;/p&gt;

&lt;p&gt;当光源平面与被照射平面平行时，有：&lt;/p&gt;

&lt;p&gt;\[ E_{1} = \frac {\Phi}{ A } \]&lt;/p&gt;

&lt;p&gt;当光源平面与被照射平面不平行时，需要根据平面的法向量和光线方向的夹角θ，先求出\( A^{&amp;#39;} \)：&lt;/p&gt;

&lt;p&gt;\[ cos\theta = \frac { A }{ A^{&amp;#39;} }  \]&lt;/p&gt;

&lt;p&gt;\[ A^{&amp;#39;}= \frac { A }{ cos\theta }  \]&lt;/p&gt;

&lt;p&gt;于是得到：&lt;/p&gt;

&lt;p&gt;\[ E_{2} = \frac {\Phi}{ A^{&amp;#39;} } =  \frac {\Phi}{ \frac { A }{ cos\theta }  } =  \frac {  \Phi  cos\theta  }{ A } \]&lt;/p&gt;

&lt;p&gt;也可以记为&lt;/p&gt;

&lt;p&gt;\[ E = \frac { \Phi  cos\theta  }{ A^{\perp } }  \]&lt;/p&gt;

&lt;p&gt;( \(  A^{\perp } \) 指A&amp;#39;在光线的方向的正交平面上的投影)&lt;/p&gt;

&lt;p&gt;微分形式：&lt;/p&gt;

&lt;p&gt;\[ dE = \frac {  d\Phi  cos\theta  }{ dA^{\perp }  } \]&lt;/p&gt;

&lt;p&gt;根据这个式子，可以想到，当θ逼近0度时，cosθ等于1，法向量和光线方向平行（上图中的A）；当θ逼近90度时，cosθ等于0，辐射照度E为0（光线垂直于法向量了）。&lt;/p&gt;

&lt;h2&gt;立体角(Solid Angle)&lt;/h2&gt;

&lt;p&gt;立体角的介绍请访问：&lt;a href=&quot;http://www.qiujiawei.com/solid-angle/&quot;&gt;立体角(Solid Angle)详解&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;辐射亮度(Radiance)&lt;/h2&gt;

&lt;p&gt;辐射亮度是指辐射通量与单位面积(注意，是与光线方向正交的那块)单位立体角的比值。符号为L。定义式如下：&lt;/p&gt;

&lt;p&gt;\[ L = \frac { d\Phi }{ d\omega dA^{\perp } } = \frac { d\Phi }{ d\omega dA cos\theta  } \]&lt;/p&gt;

&lt;p&gt;或：&lt;/p&gt;

&lt;p&gt;\[ L = \frac { \Phi }{ \omega A^{\perp } } \]&lt;/p&gt;

&lt;p&gt;物理含义如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/7.png&quot; alt=&quot;7.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;辐射密度E和辐射亮度L的关系是&amp;quot;总体&amp;quot;和&amp;quot;个体&amp;quot;的区别，可以对比下两者的公式来理解：&lt;/p&gt;

&lt;p&gt;\[ E = \frac { \Phi }{ A }  \]&lt;/p&gt;

&lt;p&gt;\[ L = \frac { \Phi }{ \omega A^{\perp } } \]&lt;/p&gt;

&lt;p&gt;E是指进入目标区域的总辐射通量与目标区域总面积的比值；而L是指进入目标区域的总辐射通量与目标区域总面积、&lt;strong&gt;总的入射立体角&lt;/strong&gt;的比值，也就是说L是比E多除了立体角。直观图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/19.png&quot; alt=&quot;19.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;也就是说其实E和L可以认为是同一个东西，只是L描述的是E的局部。用一句话记住两者的区别：有特定方向时是L，无特定方向时是E。这个区别相当重要，因为它体现在了渲染方程中。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意：在计算机图形学中，辐射亮度比起上面其他物理量，都重要地得多。&lt;/p&gt;

&lt;p&gt;如果要求平面上某点p的某方向\(\omega \)的辐射亮度L(Radiance)，可用下面的符号表示：&lt;/p&gt;

&lt;p&gt;\[ L(p,\omega ) \]&lt;/p&gt;

&lt;p&gt;其中，\(\omega \)的方向需要注意，因为它是一个立体角，立体角的圆心是p，\(\omega \)的朝向必然是从圆心p往外（向量起点是p）。&lt;/p&gt;

&lt;p&gt;实际上，需要区分成入射(input)和出射(output)2种辐射亮度L，用下面2个符号表示：&lt;/p&gt;

&lt;p&gt;\[ L_{i}(p,\omega ) \]&lt;/p&gt;

&lt;p&gt;\[ L_{o}(p,\omega ) \]&lt;/p&gt;

&lt;p&gt;且在现实世界中有：&lt;/p&gt;

&lt;p&gt;\[ L_{i}(p,\omega ) \neq L_{o}(p,\omega ) \]&lt;/p&gt;

&lt;p&gt;还有，上面的这个p不能简单认为真的是一个无体积的点，它也可能是一个无限小的平面块，即它是一个有面积A、有法向量n的“点”。对于这样一个“点”，我们可以求出它的上半球(沿着n的方向)的辐射密度值\( E(p, n) \)：&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = \int _{\Omega } L_{i} (p,\omega ) |cos\theta |d\omega \]&lt;/p&gt;

&lt;p&gt;分析下这个式子的由来。首先搬出上文给出的L和E的公式：&lt;/p&gt;

&lt;p&gt;\[ L = \frac { d\Phi }{ d\omega dA^{\perp } } \]&lt;/p&gt;

&lt;p&gt;\[ dE = \frac {  d\Phi  cos\theta  }{ dA^{\perp }  } \]&lt;/p&gt;

&lt;p&gt;所以有：&lt;/p&gt;

&lt;p&gt;\[ d\Phi = L d\omega dA^{\perp } \]&lt;/p&gt;

&lt;p&gt;\[ 
dE = \frac {  d\Phi  cos\theta  }{ dA^{\perp }  }
= \frac {  L d\omega dA^{\perp }  cos\theta  }{ dA^{\perp }  }&lt;br&gt;
= L d\omega cos\theta \]&lt;/p&gt;

&lt;p&gt;对上式做整个半球的积分，就得到了：&lt;/p&gt;

&lt;p&gt;\[ E = \int _{\Omega }L|cos\theta |d\omega \]&lt;/p&gt;

&lt;p&gt;也就是：&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = \int _{\Omega } L_{i} (p,\omega ) |cos\theta |d\omega \]&lt;/p&gt;

&lt;p&gt;其中的\( cos\theta \)加绝对值是因为我们求的是半球的积分，立体角\(\omega \)和法向量的夹角必然是锐角，锐角的余弦值必然大于等于0。&lt;/p&gt;

&lt;p&gt;如果把式子中的\(d\omega \)替换成球形角(Sphere Angle)，则得到：&lt;/p&gt;

&lt;p&gt;\[ d\omega = sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = \int _{\Omega } L_{i} (p,\omega ) |cos\theta |sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;这个式子是不对的，因为积分那里用了立体角，需要将其转换成对\(\theta 和 \phi \)的积分。因为这里积分的是半球，那么\(\theta \)的取值范围是\( [0,\frac {π}{2}] \)、\(\phi \)的取值范围是\( [0,2π] \)：&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = \int _{0 }^{ 2π } \int _{0 }^{ \frac {π}{2} }  L_{i} (p,\theta ,\phi ) cos\theta sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;（因为已经明确限定了\(\theta \)的取值范围，所以\( cos\theta \)必然大于等于0，可去掉绝对值符号）&lt;/p&gt;

&lt;p&gt;如果\(L_{i} (p,\theta ,\phi ) \)是一个常量值，那么就意味着任意方向的Radiance都是相等的，于是上式可以求出积分：&lt;/p&gt;

&lt;p&gt;\[ E(p, n) = L_{i} (p,\theta ,\phi ) \int _{0 }^{ 2π } \int _{0 }^{ \frac {π}{2} }  cos\theta sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) \int _{0 }^{ 2π } (\frac {1}{2}sin^{2}\theta )\rvert ^{\frac {π}{2}}_{0} d\phi \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) \int _{0 }^{ 2π } (\frac {1}{2}sin^{2}\frac {π}{2} - \frac {1}{2}sin^{2}0  ) d\phi \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) \int _{0 }^{ 2π } \frac {1}{2} d\phi \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) \frac {1}{2}( 2π - 0) \]&lt;/p&gt;

&lt;p&gt;\[ = L_{i} (p,\theta ,\phi ) π  \]&lt;/p&gt;

&lt;p&gt;注意，这个简化公式在渲染中很重要。因为当计算一个点到摄像机的Radiance，第一步就是先求这个点的入射E（求E的过程可以很复杂），当求出E之后，就可以认为这个点对任意方向的出射Radiance是均等的，也就是\( L = \frac {E}{\pi } \)。&lt;/p&gt;

&lt;h1&gt;渲染方程 Rendering Equation&lt;/h1&gt;

&lt;p&gt;把wiki的渲染方程贴进来：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/18.png&quot; alt=&quot;18.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Rendering_equation&quot;&gt;https://en.wikipedia.org/wiki/Rendering_equation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;各个组成元素的解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;λ&lt;/strong&gt; 指代波长为λ的光&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;t&lt;/strong&gt; 某一时间点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;x&lt;/strong&gt; 指空间上的某个点，也即被渲染的点(微分平面) (其实应该写成p吧)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;n&lt;/strong&gt; 被渲染的点(平面)的法向量，可以人为指定也可以根据一定规则自动生成&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( \omega _{o} \)  出射光线的方向（是一个立体角)，起点在x(被渲染的点)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( \omega _{i} \)  入射光线的反方向（是一个立体角)，起点也在x，所以才叫反方向&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( L_{o}(x, \omega _{o}, λ, t) \)   在t时刻、从x点往\( \omega _{o} \)方向的光(λ)的总辐射亮度(Radiance)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( L_{e}(x, \omega _{o}, λ, t) \)  指x点自身发射出的辐射亮度(Radiance)，其他参数含义同\( L_{o}(x, \omega _{o}, λ, t) \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\(\Omega \)是以x为圆心的单位半球，半球的朝向和法向量&lt;strong&gt;n&lt;/strong&gt;一致&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\(\int _{ \Omega } \cdots d\omega _{i} \) 指对这个半球做积分&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\(f_{r}(x, \omega _{i}, \omega _{o}, λ, t) \) BRDF函数，函数的返回值是一个比值(ratio scalar)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( L_{i}(x, \omega _{i}, λ, t) \)  在t时刻、沿着\( \omega _{i} \)方向进入x点的光(λ)的辐射亮度(Radiance)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\(\omega _{i} \cdot n \) 是一个衰减比值(一般是0到1)，指入射光的方向和法向量的夹角\( \theta _{i} \)，这个夹角导致产生的衰减。原因请参考上面的&lt;strong&gt;辐射通量&lt;/strong&gt;小节。这个参数也可以写成\( \cos \theta _{i} \)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的可能太教科书了，下面展示一个简化的渲染方程：&lt;/p&gt;

&lt;p&gt;\[ L_{o}(p, \omega _{o}) = L_{e}(p, \omega _{o})  + \int _{\Omega }f(p, \omega _{o}, \omega _{i}) L_{i}(p, \omega _{i}) |cos \theta _{i}|d\omega _{i} \]&lt;/p&gt;

&lt;p&gt;能简化成这个式子的原因是，在做渲染器的时候，本来就是把t值固定的，即做动画渲染的话，也是把动画离散成一帧帧来渲染，对每一帧来说t值是常量值；而另外的λ值蕴含在颜色空间(XYZ RGB)中。&lt;/p&gt;

&lt;p&gt;还有一个要说清楚的，就是这个方程3个部分的含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/20.png&quot; alt=&quot;20.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;为什么右边那坨是E？上文已经说过了:&amp;quot;有特定方向时是L，无特定方向时是E&amp;quot;,因为它是对L做整个半球的积分（注意，积分的是入射角度），也就是无特定方向，所以它是E。而另外2个分部都是指定了朝向了\(\omega _{o} \)（出射方向）的，所以是L。&lt;/p&gt;

&lt;p&gt;整个渲染方程可以说就是在求出射方向到底有多少辐射通量（为什么不是L？因为被渲染区域的面积一般都限定为单位面积，即等于1，所以L相当于\(\Phi \) )，辐射通量一旦确定就可以知道这个被渲染区域的颜色。&lt;/p&gt;

&lt;p&gt;基于光线追踪的离线渲染中，是可以直接基于上面的渲染方程去做工程实现的。（相比而言，实时渲染更多的是用各种trick技术来近似渲染方程。）&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/candycat1992/article/details/46228771&quot;&gt;http://blog.csdn.net/candycat1992/article/details/46228771&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.poynton.com/GammaFAQ.html&quot;&gt;http://www.poynton.com/GammaFAQ.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.poynton.com/PDFs/GammaFAQ.pdf&quot;&gt;http://www.poynton.com/PDFs/GammaFAQ.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.brucelindbloom.com/index.html?Equations.html&quot;&gt;Useful Color Equations&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html&quot;&gt;RGB/XYZ Matrices&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/rendering-equation/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/rendering-equation/</guid>
      </item>
    
      <item>
        <title>立体角(Solid Angle)详解</title>
        <description>&lt;p&gt;理解立体角之前要先理解圆心角。在二维平面上，一个圆的圆弧的微分记为ds(也叫弧微分)，半径为r，则圆心角指的是弧微分与半径的比值:&lt;/p&gt;

&lt;p&gt;\[ d\theta = \frac {ds}{r} \]&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;对这个式子做0到2π的积分的话，显然右边的分子变成了圆周长2πr，圆心角为\( \frac { 2πr }{r} = 2π \)。&lt;/p&gt;

&lt;p&gt;立体角与圆心角非常类似。立体角的ds的含义是球面上的面积微分(下文用dA表示)，而分母需要变成半径r的平方（1&lt;a href=&quot;https://en.wikipedia.org/wiki/Steradian&quot;&gt;球面度&lt;/a&gt;所对应的立体角所对应的球面表面积为\(r^{2}\) ）：&lt;/p&gt;

&lt;p&gt;\[ d\omega = \frac {dA}{r^{2}} \]&lt;/p&gt;

&lt;p&gt;因为球体表面积等于\( 4πr^{2} \)，所以上面的式子积分到整个球体的话，立体角等于4π。&lt;/p&gt;

&lt;p&gt;再换个角度分析。在宏观上看，立体角的定义是：&lt;/p&gt;

&lt;p&gt;\[ \Omega = \frac {A}{r^{2} } sr \]&lt;/p&gt;

&lt;p&gt;其中，sr是单位，叫做球面度；A是这个立体角所对应的球表面积，A被叫做&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Spherical_cap&quot;&gt;spherical cap&lt;/a&gt;&lt;/strong&gt;(球帽?)。&lt;/p&gt;

&lt;p&gt;spherical cap的几何表示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/8.png&quot; alt=&quot;8.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(from wiki)&lt;/p&gt;

&lt;p&gt;spherical cap面积等于\(2\pi rh \)，所以上式可变成：&lt;/p&gt;

&lt;p&gt;\[ \Omega = \frac {2\pi rh}{r^{2} } sr \]&lt;/p&gt;

&lt;p&gt;当h等于r时，得到：&lt;/p&gt;

&lt;p&gt;\[ \Omega = \frac {2\pi rr}{r^{2} } sr = 2\pi \ sr \]&lt;/p&gt;

&lt;p&gt;此时得到的是半球的立体角，那么就可以知道整个球的立体角为\(4\pi  \)，和上述结论一致。&lt;/p&gt;

&lt;h2&gt;立体角(Solid Angle)转换到球形角(Sphere Angle)&lt;/h2&gt;

&lt;p&gt;Spherical Coordinates坐标系下的单位球，可用2个&lt;strong&gt;弧度变量&lt;/strong&gt;来定位球面上一个点：\(\theta 和 \phi \)。和三维坐标系的对应关系如下：&lt;/p&gt;

&lt;p&gt;\[ x = sin\theta cos\phi \]&lt;/p&gt;

&lt;p&gt;\[ y = sin\theta sin\phi \]&lt;/p&gt;

&lt;p&gt;\[ x = cos\theta \]&lt;/p&gt;

&lt;p&gt;简单验证下。把上面3个式子代入单位球公式:\(x^{2}+y^{2}+z^{2} = 1\)，可得：&lt;/p&gt;

&lt;p&gt;\[ (sin\theta cos\phi)^{2} + (sin\theta sin\phi )^{2} + cos^{2}\theta = 1 \]&lt;/p&gt;

&lt;p&gt;\[ sin^{2}\theta (cos^{2}\phi  + sin^{2}\phi ) + cos^{2}\theta = 1 \]&lt;/p&gt;

&lt;p&gt;\[ sin^{2}\theta  + cos^{2}\theta = 1 \]&lt;/p&gt;

&lt;p&gt;那么，立体角\(\omega \)和\(\theta 、 \phi \)是什么关系呢？先给出答案：&lt;/p&gt;

&lt;p&gt;\[ d\omega = sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;似乎有点莫名其妙，这里我详细解释吧。首先先搞懂\(  d\theta 和  d\phi \)的几何意义。&lt;/p&gt;

&lt;p&gt;弧度变量的单位是&lt;strong&gt;弧度&lt;/strong&gt;，1弧度的定义是：弧长s等于半径r的弧对应的圆心角为1弧度。因此可以知道整个圆的弧度为周长\(2\pi r\)除以半径\(r\)等于\(2\pi \)。&lt;/p&gt;

&lt;p&gt;因此，如果已知弧度和半径，就可以求出弧长s，那么上面的\(\theta 、 \phi \)对应的弧长就是：&lt;/p&gt;

&lt;p&gt;\[ s_{ \theta } = r_{ \theta }\theta  \]&lt;/p&gt;

&lt;p&gt;\[ s_{ \phi } = r_{ \phi }\phi  \]&lt;/p&gt;

&lt;p&gt;微分形式：&lt;/p&gt;

&lt;p&gt;\[ ds_{ \theta } = r_{ \theta } d\theta  \]&lt;/p&gt;

&lt;p&gt;\[ ds_{ \phi } = r_{ \phi } d\phi  \]&lt;/p&gt;

&lt;p&gt;\( r_{ \theta }、r_{ \phi }\)的值并不是相等的，需要接着分析。&lt;/p&gt;

&lt;p&gt;在球坐标系下，\(\theta 、 \phi \)指的是这2个角：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.7/9.png&quot; alt=&quot;9.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;\(\theta\)是目标点p与z轴的夹角；而\(\phi\)是目标点p在xy平面上的投影与y轴的夹角。&lt;/p&gt;

&lt;p&gt;从图可知，\( r_{ \theta } \)与圆的半径r相等；而\( r_{ \phi } \)是小于等于r的(注意看上面的小圆)，且有：&lt;/p&gt;

&lt;p&gt;\[ sin\theta = \frac { r_{ \phi } } {r_{ \theta } }\]&lt;/p&gt;

&lt;p&gt;当球是单位球时，球的半径为1，所以有：&lt;/p&gt;

&lt;p&gt;\[ r_{ \theta } = 1\]&lt;/p&gt;

&lt;p&gt;\[ r_{ \phi } = sin\theta  r_{ \theta } = sin\theta \]&lt;/p&gt;

&lt;p&gt;又因为在微观下，立体角对应的曲面(或者叫球帽)面积可以当做一个小矩形看，这个小矩形dA的面积等于2个弧长\( ds_{ \theta } \)和\( ds_{ \phi } \)的积：&lt;/p&gt;

&lt;p&gt;\[ dA = ds_{ \theta }ds_{ \phi } = r_{ \theta } r_{ \phi }d\theta d\phi = sin\theta d\theta d\phi \]&lt;/p&gt;

&lt;p&gt;再因为立体角的微分其实也就是这个小矩形的面积，那么就有：&lt;/p&gt;

&lt;p&gt;\[ d\omega = dA = sin\theta d\theta d\phi \]&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/solid-angle/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/solid-angle/</guid>
      </item>
    
  </channel>
</rss>