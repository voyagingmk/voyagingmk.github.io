<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>博主主要学习方向：图形学、机器学习，以及各种有趣的数学。联系QQ：234707482。</description>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>现代抗锯齿技术——PPAA中的新星SMAA</title>
        <description>&lt;h1&gt;PPAA&lt;/h1&gt;

&lt;p&gt;所谓PPAA（Post Process Antialiasing)，也叫FBAA（Filter-Based Antialiasing），是基于后处理的各种抗锯齿技术的统称。在PPAA之前，主流AA技术是MSAA（MultiSamples AA）、SSAA（SuperSamples AA）。SSAA是AA中最暴力也是最完美的解决方案，而MSAA是与硬件紧密结合的built-in AA。对于forward rendering来说，MSAA几乎是唯一的选择。&lt;/p&gt;

&lt;p&gt;然而，MSAA这种古老的、built-in的技术，已经不太能满足现代渲染器的需求了。它有两大问题，一是MSAA会有多余的AA计算，二是MSAA不适用于deferred rendering。&lt;/p&gt;

&lt;p&gt;鉴于MSAA的不足，PPAA就蓬勃发展起来了。PPAA强大之处在于可以自定义、且硬件无关、兼容forward／defer，所以基于PPAA的算法非常多。而其中的翘楚，SMAA(Subpixel Morphological Antialiasing)，性能以及AA质量都很不错。本文将着重介绍SMAA。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;值得一提的是，SMAA的前身是Jimenez&amp;#39;s MLAA，也是同一个团队做出来的，SMAA可以认为是在质量和性能两方面都超越Jimenez&amp;#39;s MLAA的一个进化版。所以可以先阅读Jimenez&amp;#39;s MLAA的论文再来学习SMAA。&lt;/p&gt;

&lt;h1&gt;SMAA&lt;/h1&gt;

&lt;p&gt;总共3个pass：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pass 1，边缘检测原始图像得到edgesTex&lt;/li&gt;
&lt;li&gt;Pass 2，用edgesTex得到weightTex&lt;/li&gt;
&lt;li&gt;Pass 3，用weightTex混合原始图像，得到抗锯齿图像&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;边缘检测 Edge Detection&lt;/h2&gt;

&lt;p&gt;锯齿问题体现在图像上几何物体的边缘处，也就是说，如果能准确地post process出图像上哪些地方是边，哪些地方不是。检测过少，锯齿边就会残留；检测过多，图像就会糊。为来更好地提升AA质量，SMAA边缘检测算法的选取非常关键。&lt;/p&gt;

&lt;p&gt;相比基于normal map、depth map，基于颜色的边缘检测尤佳。一是因为，颜色信息容易获得，而深度图／法线图相对难获得，例如对于图像处理领取，用户提供的只有照片而已；二是因为它还有一个优点：对于做了shading后才产生的锯齿，也一样能处理（例如有梯度的toon shading）。&lt;/p&gt;

&lt;p&gt;SMAA首推的是基于Luma（亮度）的边缘检测算法。&lt;/p&gt;

&lt;p&gt;1，vertex shader，根据纹理坐标输出3组offset，每组2个边，总共6个边要检测：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SMAA_RT_METRICS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Offsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SMAA_RT_METRICS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyxy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texCoord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyxy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Left / Top Edge&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Offsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SMAA_RT_METRICS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyxy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texCoord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyxy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Right / Bottom Edge&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Offsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SMAA_RT_METRICS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyxy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texCoord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyxy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Leftx2 / Topx2 Edge&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;../images/2017.10/smaa1.png&quot; alt=&quot;smaa1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;2，fragment shader，先求出当前fragment的luma值：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Calculate lumas:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.2126&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.7152&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0722&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;colorTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;texcoord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（RGB-&amp;gt;luma的公式来自wiki &lt;a href=&quot;https://en.wikipedia.org/wiki/Relative_luminance&quot;&gt;https://en.wikipedia.org/wiki/Relative_luminance&lt;/a&gt;  ）&lt;/p&gt;

&lt;p&gt;3，算Left和Top的luma值，以及算Left和L的差值delta.x、Top和L的差值delta.y；如果delta.x &amp;lt; threshold.x，edges.x就等于0.0，代表不是边（因为差值很小，即亮度差异小），y方向同理：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Lleft&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;colorTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ltop&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;colorTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;float4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lleft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ltop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;discard&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 如果2个方向都没有边，就可以排除这个fragment了&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;如果Left或Top至少有一个是边，就再进一步做检测。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 计算Right Bottom的luma差值&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Lright&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;colorTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Lbottom&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;colorTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lright&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Lbottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 和算delta.xy过程差不多&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 分别算出x、y方向的最大luma差值&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxDelta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 算出 Left x2 and Top x2 的luma:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Lleftleft&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;colorTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ltoptop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;colorTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offsets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 算出Left和Left x2的luma差值、Top和Top x2的luma差值&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lleft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ltop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lleftleft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ltoptop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Calculate the final maximum delta:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// x、y方向分别最终的最大luma差值&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maxDelta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxDelta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// x、y两个方向中取其中最大的luma差值&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finalDelta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxDelta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxDelta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Local contrast adaptation:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Left、Top亮度差值*2后需超过finalDelta才真的是边&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;finalDelta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;权重混合计算 Blending Weight Calculation&lt;/h2&gt;

&lt;p&gt;最复杂的一个pass&lt;/p&gt;

&lt;h3&gt;模式处理&lt;/h3&gt;

&lt;p&gt;SMAA的模式处理较之MLAA有了新的改进。MLAA的方法，对sharp物体的轮廓的&amp;quot;边角&amp;quot;和&amp;quot;锯齿角&amp;quot;并不能区分（都认为是交叉角crossing edges），导致边角也被当作锯齿角处理，导致边角被修成了圆角。而SMAA中，做了进一步的观察：对于锯齿角，大小不超过一个像素，而sharp的边角很大几率超过1个像素。&lt;/p&gt;

&lt;p&gt;因此，SMAA判断锯齿角需要计算2个像素长度的范围，也从而识别出真的边角。&lt;/p&gt;

&lt;p&gt;(待续)&lt;/p&gt;

&lt;h1&gt;最终效果&lt;/h1&gt;

&lt;p&gt;原始图像:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.10/alias.png&quot; alt=&quot;alias.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;经过SMAA 1x过滤后:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.10/antialias.png&quot; alt=&quot;antialias.png&quot;&gt;&lt;/p&gt;

&lt;h1&gt;资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.iryoku.com/smaa/&quot;&gt;http://www.iryoku.com/smaa/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.iryoku.com/mlaa/&quot;&gt;http://www.iryoku.com/mlaa/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/antialiasing/</link>
        <guid isPermaLink="true">http://localhost:4000/antialiasing/</guid>
      </item>
    
      <item>
        <title>法向量矩阵</title>
        <description>&lt;p&gt;在对vertex做model、view、projection计算过程中，还有一个要同时考虑的东西是&lt;strong&gt;法向量的矩阵变换&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;normal的变换并不能直接使用vertex的变换。如果直接使用的话，就会放了一个定时炸弹在你的shader里面，当哪天你的object做了一个不uniform的缩放变换时，例如x、y轴放大1.5倍，而z轴放大3倍，输出的normal就会出错，进而导致光照计算出错。&lt;/p&gt;

&lt;p&gt;下面开始推导正确的只属于的normal的变换矩阵。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;推导&lt;/h3&gt;

&lt;p&gt;在做顶点变换时，model、view、projection三个连续变换矩阵一般可以合并为一个变换矩阵，设为M。&lt;/p&gt;

&lt;p&gt;假设现在要渲染一个三角形，它的三个顶点分别为P1、P2、P3。&lt;/p&gt;

&lt;p&gt;那么可以设，做M变换前，有切向量T = P2 - P1， P2&amp;#39; = P2 * M， P1‘ = P1 * M。&lt;/p&gt;

&lt;p&gt;且有关系式：&lt;/p&gt;

&lt;p&gt;T * M = (P2 - P1) * M = P2 * M - P1 * M = P2&amp;#39; - P1&amp;#39; =  T&amp;#39;&lt;/p&gt;

&lt;p&gt;M变换后，T’是P2、P1的切向量，且有T * M = T&amp;#39;。也就是说，M变换对切向量也同时成立。&lt;/p&gt;

&lt;p&gt;现在，假设做M变换前三角形面片的法向量为N，则有：&lt;/p&gt;

&lt;p&gt;\[ N \cdot T = N^{T}T = 0 \]&lt;/p&gt;

&lt;p&gt;设M变换后，新的三角形P1&amp;#39;、P2&amp;#39;、P3&amp;#39;的法向量为N&amp;#39;，那么可以列出等式：&lt;/p&gt;

&lt;p&gt;\[ N&amp;#39; \cdot T&amp;#39; = (GN) \cdot (MT) \]&lt;/p&gt;

&lt;p&gt;其中，新出现的G是法向量专属的变换矩阵，也是我们要求出来的东西。&lt;/p&gt;

&lt;p&gt;因为上式是一个点积，所以有：&lt;/p&gt;

&lt;p&gt;\[ (GN) \cdot (MT) =  (GN)^{T}(MT) = N^{T}G^{T}MT  \]&lt;/p&gt;

&lt;p&gt;回顾刚才的一个式子：\( N^{T}T = 0 \)，那么可以假设存在一个合适的G使得等式\( G^{T}M = I \)成立，从而使\( N&amp;#39; \cdot T&amp;#39; = 0 \) 也成立。&lt;/p&gt;

&lt;p&gt;解开\( G^{T}M = I \)很简单：&lt;/p&gt;

&lt;p&gt;\[ G^{T} = M^{-1} \]&lt;/p&gt;

&lt;p&gt;\[ G = (M^{-1})^{T} \]&lt;/p&gt;

&lt;p&gt;G就是我们要求的normal matrix，相应的G变换的shader代码就是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;G&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transpose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mat3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，这里先对mat4的M做了个mat3的操作。这是为了去掉M变换的translation信息（因为normal和position不同，它是个朝向向量）。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/&quot;&gt;http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/linear-algebra-18/</link>
        <guid isPermaLink="true">http://localhost:4000/linear-algebra-18/</guid>
      </item>
    
      <item>
        <title>ssao介绍</title>
        <description>&lt;h2&gt;AO，ambient occlusion&lt;/h2&gt;

&lt;p&gt;环境光遮蔽，大致上指的是几何物体的拐角处，因为受光不全面（被相邻的面挡光／遮蔽），导致变暗。&lt;/p&gt;

&lt;h2&gt;SSAO，screen-space ambient occlusion&lt;/h2&gt;

&lt;p&gt;屏幕空间环境光遮蔽，简称SSAO，是一种让画面更‘真实’的后处理技术。该方法较为简单实用，但需要先获得view space的场景的几何信息，因此比较适合在defer rendering框架下应用。除了SSAO之外，还存在voxel based 的world space的AO技术。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;SSAO的基本原理&lt;/h2&gt;

&lt;p&gt;实时渲染下做AO，基本做法都是计算出一张全屏的AO单通道(float)纹理，有了该纹理后，在做lighting pass时就可以逐像素采样该AO纹理，得到一个遮蔽率 （occlusion factor），对fragment的颜色值乘以该遮蔽率（遮蔽率越接近0，颜色更黑，遮蔽率越接近1，颜色则贴近原来的色），就完成了AO操作。&lt;/p&gt;

&lt;p&gt;为了得到该AO纹理，需要先做G-Buffer pass，具体细节在此不表。&lt;/p&gt;

&lt;p&gt;有了G-Buffer后，剩下问题就是&lt;strong&gt;如何用G-Buffer算出准确的遮蔽率纹理&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;遮蔽率的计算方法：球采样／半球采样&lt;/h2&gt;

&lt;p&gt;遮蔽率算的就是一个0.0到1.0的值。SSAO方案下，计算这个值，无非就是对逐个fragment的周围的n个采样点做遮蔽测试，然后统计有百分之多少的采样点通过了测试，那么就得到了粗略的遮蔽率。&lt;/p&gt;

&lt;p&gt;以下两张图可以形象地说明这个过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.10/ssao_sphere.png&quot; alt=&quot;ssao_sphere.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.10/ssao_hemisphere.png&quot; alt=&quot;ssao.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一张是球型采样。从图中可以很清楚看出这个球采样的不足：即使一个平面没有被周围的平面遮蔽，该平面的遮蔽率也只是0.5。这样就会导致画面变灰。&lt;/p&gt;

&lt;p&gt;第二张是半球采样，即限制采样点都在平面法向量同一侧。从图中可以看出这个方案更好。&lt;/p&gt;

&lt;h3&gt;采样点的生成算法&lt;/h3&gt;

&lt;p&gt;然后就是采样点的生成问题。采样点需要在tangent space下计算，即默认normal向量指向z轴正方向。所以每一个采样点只需要随机在x、y轴上做一点偏移即可：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateSampleKernel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vector3dF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ssaoKernel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 随机分布采样点，x、y在[-1.0, 1.0]随机，而z在[0.0, 1.0]范围随机&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 确保采样点落在normal向量同一侧，即z必须大于0&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Vector3dF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;random0_1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;random0_1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;random0_1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random0_1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 单位化后随机分配距离 &lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;64.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 缩放因子，初始化为i/64是为了确保每一个点不会位置重复&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lerp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 使得大部分采样点会更靠近原点&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 应用缩放因子&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ssaoKernel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到的采样点分布大致如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.10/ssao_kernel_weight.png&quot; alt=&quot;ssao.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;采样次数越多，遮蔽率就算得越准确，但性能也就下降。为了降低采样次数，为此要引入一个random noise随机化的旋转噪声贴图，使得相邻的fragment采样点差异性变大。&lt;/p&gt;

&lt;h3&gt;采样点的随机噪声和TBN矩阵&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 获取随机旋转向量并单位化&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;randomVec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texNoise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TexCoord&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noiseScale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 计算TBN，用TBN左乘samplePos就可以把samplePos从tangent space转换到view space&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tangent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomVec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomVec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// TBN的x方向&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bitangent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cross&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tangent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// TBN的y方向&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mat3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TBN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mat3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tangent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bitangent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// TBN的z方向&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;计算TBN矩阵最为精妙的就是第一步：tangent向量的计算。因为最终要构造出的TBN的z方向是normal的方向，所以未知数就是相应的x、y方向，而因为正交矩阵的一个基可以用另外2个基做叉乘得到，所以未知的y方向（bitangent）等于normal和tangent的cross。真正要算的只有x的方向：tangent向量。&lt;/p&gt;

&lt;p&gt;tangent向量，必然和normal正交，但方向和randomVec有关（所以randomVec才被称为旋转向量）。&lt;/p&gt;

&lt;p&gt;首先，randomVec和normal的角度关系需要先计算出来，方法就是做点积：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dot(randomVec, normal) = cosθ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cosθ就是一个投影系数，用cosθ去乘以randomVec就得到normal在randomVec上的投影（方向相同，长度不等），同理，用cosθ去乘以normal就得到randomVec在normal上的投影。&lt;/p&gt;

&lt;p&gt;再看一下上面的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tangent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomVec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randomVec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// TBN的x方向&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出normal * dot(randomVec, normal) 就是指randomVec在normal上的投影，有了这个投影点r向量后，就可以用randomVec - r，得到垂直于normal的tangent向量。记得需要再单位化。 &lt;/p&gt;

&lt;h3&gt;最终的遮蔽率计算&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;radius&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 可以调整的参数，控制采样半径范围&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;occlusion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kernelSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 把采样点从tangent space转到view space&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;samplePos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TBN&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;samples&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; 

   &lt;span class=&quot;c1&quot;&gt;// 做偏移，得到真正的采样坐标(view space)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;samplePos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fragPos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;samplePos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;radius&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

    &lt;span class=&quot;c1&quot;&gt;// 从view space转到screen space&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;samplePos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

    &lt;span class=&quot;c1&quot;&gt;// perspective divide，得到NDC坐标（normalized device coordinates）&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

    &lt;span class=&quot;c1&quot;&gt;// 映射NDC到[0.0, 1.0]，从而可以采样GBuffer的纹理&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

    &lt;span class=&quot;c1&quot;&gt;// 获得GBuffer中该位置的深度值&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sampleDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sampleGBufferPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// view space&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 深度比较 bias是调整值 bias太小就会出现acne现象 建议0.025&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_occlusion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sampleDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;samplePos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bias&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rangeCheck&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smoothstep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;radius&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fragPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sampleDepth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;occlusion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_occlusion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rangeCheck&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FragColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;occlusion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kernelSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// occlusion越接近kernelSize，FragColor即遮蔽率就越低&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的rangeCheck步骤是比较特殊的处理，它解决的是这么个情况：对于一个物体的轮廓处的fragment，在做采样计算时会把后面的远处的fragment也拉进来测试。所以要计算fragPos.z - sampleDepth，求出当前fragment的深度以及被采样点的深度的距离，距离过大就说明不是近邻的会遮蔽自己的fragment。距离越大，rangeCheck就会越接近0，从而_occlusion值也会削弱。（注意fragPos.z - sampleDepth小于等于radius）&lt;/p&gt;

&lt;p&gt;去掉rangeCheck后的现象如下，可以看到茶壶边缘出现了ao黑边，是不对的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.10/ssao_1.png&quot; alt=&quot;ssao.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;最终效果图&lt;/h2&gt;

&lt;p&gt;ssao纹理图（未做模糊处理）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.10/ssao.png&quot; alt=&quot;ssao.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;ssao纹理图（做了模糊处理）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.10/ssaoBlur.png&quot; alt=&quot;ssaoBlur.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;ssao + shading：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.10/ssaoFinal.png&quot; alt=&quot;ssaoFinal.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;工程上遇到的坑&lt;/h2&gt;

&lt;p&gt;因为我做的是基于defer框架的ssao，所以一部分坑来自于defer。&lt;/p&gt;

&lt;h3&gt;G-Buffer输出的position和normal需要位于什么空间？&lt;/h3&gt;

&lt;p&gt;G-Buffer的vertex shader需要对传入的postion和normal信息做矩阵变换操作并输出到frame buffer里。&lt;/p&gt;

&lt;p&gt;这个矩阵变换有些坑，需要仔细思考下。首先，它必须要有object space到world space的变换，也就是model变换，这是每个object自有的。&lt;/p&gt;

&lt;p&gt;到里world space后，是否需要到view space呢？即是否要再乘以view matrix。答案因应用情况而异。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果是在G-Buffer就做了view变换：那么到了ssao pass，因为ssao本来就是view space下的计算，所以是ok的，但是对于deferred lighting pass，就不太友好，因为光照计算要在world space下算，position和normal都需要乘以view matrix的逆矩阵（可以在cpu先算好），从而恢复到world space。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果不在G-Buffer做view变换：G-Buffer输出的就是干净的world space信息。ssao pass就需要自己做view变换，而deferred lighting pass则不用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我自己是采用里第一种做法。&lt;/p&gt;

&lt;h3&gt;G-Buffer的position和normal具体怎么做变换？&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// position的变换&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WorldPos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;FragPos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WorldPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xyz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 输出&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gl_Position&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WorldPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// normal的变换&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// mat3 normalMatrix = mat3(view * transpose(inverse(model))); // Wrong!&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// mat3 normalMatrix = mat3(transpose(inverse(view * mat4(mat3(model))))); // not good&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mat4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normalMatrix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mat4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transpose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mat3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Normal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mat3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normalMatrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 输出&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;position的变换一目了然，没什么坑。但是normal的坑就大了。&lt;/p&gt;

&lt;p&gt;首先，为了防止model矩阵的平移属性影响到normal，需要把mat4的model直接裁剪成mat3，从而去掉平移属性。&lt;/p&gt;

&lt;p&gt;然后，需要计算normal matrix。公式推导另外成文。只需要记得公式是transpose(inverse(mat3(model)))即可。&lt;/p&gt;

&lt;p&gt;最后再把mat3的normal matirx转成mat4，从而可以和mat4的view相乘，从而得到G-Buffer真正需要的normal matirx。&lt;/p&gt;

&lt;h3&gt;G-Buffer的position纹理需要设置GL_CLAMP_TO_EDGE&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;glTexParameteri&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_TEXTURE_2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_TEXTURE_WRAP_S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_CLAMP_TO_EDGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;glTexParameteri&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GL_TEXTURE_2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_TEXTURE_WRAP_T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_CLAMP_TO_EDGE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就能限制G-Buffer之后的pass采样position纹理时，position的范围不会超出[0.0, 1.0]。&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/ssao/</link>
        <guid isPermaLink="true">http://localhost:4000/ssao/</guid>
      </item>
    
      <item>
        <title>PBR渲染原理</title>
        <description>&lt;p&gt;基于PBR做渲染，需要涉及到很多物理学、几何学、热辐射学概念，本文将逐一介绍每个关键概念，并给出相关重要公式。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;微平面(microfacets)理论&lt;/h2&gt;

&lt;p&gt;微观尺度下的任意一个平面(surface)都可以用多个微小的、完美反射的镜面来描述，这些微小镜面被称为&lt;strong&gt;微平面&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;粗糙度(roughness)&lt;/h3&gt;

&lt;p&gt;平面的&lt;strong&gt;粗糙度&lt;/strong&gt;决定了它的各个微平面的镜面反射情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.9/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;粗糙度可以用0.0到1.0来近似。&lt;/p&gt;

&lt;h3&gt;中间方向矢量(halfway vector)&lt;/h3&gt;

&lt;p&gt;halfway vector(简称h)等于光线方向矢量l加上视角方向矢量v并单位化（即处于l和v的中间）：&lt;/p&gt;

&lt;p&gt;\[ \mathbf h = \frac { \mathbf l + \mathbf v}{ \parallel \mathbf l + \mathbf v \parallel } \]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.9/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;h的特性是：h与平面法线越靠近，那么镜面光越强。&lt;/p&gt;

&lt;p&gt;在这个微平面理论下，可以推出：&lt;strong&gt;越多的微平面的法线与h对齐，这个平面的镜面反射就会越强&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;能量守恒(energy conservation)&lt;/h2&gt;

&lt;p&gt;不考虑自发光的平面，所有平面的出射光能量总和不能高于入射光能量总和。&lt;/p&gt;

&lt;p&gt;观察下图，可以发现一个规律，粗糙度越高、镜面反射区域越大、镜面反射区域亮度越低。如果反射区域变大，然而亮度不变，那说明能量不守恒了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.9/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;在渲染里，简单地说，要做到能量守恒，就是要遵守一个原则：&lt;strong&gt;平面接收到的光能量要么被反射，要么被吸收&lt;/strong&gt;，也就是说，吸收和反射，是互斥关系。&lt;/p&gt;

&lt;p&gt;直接反射出去的光能量，也叫镜面光、反射光；吸收的光能量，大部分也会变成光发射出去（真正被吸收的就变成热能了），叫漫反射光、折射光。&lt;/p&gt;

&lt;p&gt;镜面/反射光、漫反射/折射光的能量可以用2个系数kS、kD控制，两者满足关系式kD + kS = 1、kD &amp;gt; 0、kS &amp;gt; 0，从而确保发射的光能量不超过接收的光能量。&lt;/p&gt;

&lt;h2&gt;渲染方程&lt;/h2&gt;

&lt;p&gt;渲染方程的详细讨论已经写在&lt;a href=&quot;http://www.qiujiawei.com/rendering-equation/&quot;&gt;渲染基础理论的介绍&lt;/a&gt;一文。&lt;/p&gt;

&lt;h2&gt;双向反射分布函数BRDF&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://www.qiujiawei.com/rendering-equation/&quot;&gt;渲染基础理论的介绍&lt;/a&gt;一文里，没有详细讨论到的是brdf这个东西。简单地说，brdf是个控制系数，这个系数并不是常量，需要根据平面属性、光线属性计算得到，是个动态属性。基于PBR渲染，关键点就是选择合理的brdf函数。brdf函数将囊括上文提到的各个概念。&lt;/p&gt;

&lt;p&gt;brdf很多种，最主流的是cook-Torrance BRDF，其基本框架公式是：&lt;/p&gt;

&lt;p&gt;\[ f_{r} = k_{d}f_{lambert} + k_{s}f_{cook−torrance} \]&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;p&gt;\[ f_{lambert} = \frac {c}{\pi } \]&lt;/p&gt;

&lt;p&gt;这里的c是指平面自身的颜色值，一般就是指采样纹理贴图出来的颜色。&lt;/p&gt;

&lt;p&gt;右边的镜面光部分才是最复杂的：&lt;/p&gt;

&lt;p&gt;\[ f_{cook−torrance} = \frac { DFG }{ 4 (\omega _{o} \cdot \mathbf n)(\omega _{i} \cdot \mathbf n) } \]&lt;/p&gt;

&lt;p&gt;这条公式怎么来的，改天再写一篇数学推导文。现在需要重点关注右边的分子部分：DFG。DFG其实是3个函数，每个函数算出一个scalar因子，3个因子得到后相乘。D、F、G有很多公式可以选择，下面会介绍几个常用的DFG函数。&lt;/p&gt;

&lt;h3&gt;D， Normal Distribution Function，法线分布函数&lt;/h3&gt;

&lt;p&gt;这个函数其实不是正态分布函数，不要被normal这个单词搞懵了。在渲染一个mesh的一个fragment时，就是在渲染一个平面，这个平面又是由一堆更加小的&lt;strong&gt;微平面&lt;/strong&gt;组成。这些微平面有自己的&lt;strong&gt;微法线&lt;/strong&gt;，D函数就是用来近似算出究竟有多少微法线和h向量对齐。&lt;/p&gt;

&lt;h4&gt;Trowbridge-Reitz GGX&lt;/h4&gt;

&lt;p&gt;\[ D(n, h, \alpha ) = \frac { \alpha ^{2} } { \pi ( (n\cdot h)^{2}(\alpha ^{2} - 1) + 1 )^{2} } \]&lt;/p&gt;

&lt;p&gt;输入参数：平面法线n、h向量、粗糙度\( \alpha \)。&lt;/p&gt;

&lt;p&gt;shader：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DistributionGGX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NdotH&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NdotH2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NdotH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NdotH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nom&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;denom&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NdotH2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;denom&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;denom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;denom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;denom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;F，Fresnel equation，菲涅尔方程&lt;/h3&gt;

&lt;p&gt;对于真实的物理材质，光照向量、视角向量不同，平面的反射情况就会不同。F函数能算出不同角度时的反射光情况，也是用一个比值(也叫做平面的真实的反射率）表示。这个比值能反应出有多少百分比的光被反射和被吸收(记住反射和吸收是互斥关系)。&lt;/p&gt;

&lt;h4&gt;Fresnel-Schlick approximation&lt;/h4&gt;

&lt;p&gt;\[ F_{Schlick}(n, v, F_{0}) = F_{0} + (1 - F_{0})( 1- (n\cdot v))^{5} \]&lt;/p&gt;

&lt;p&gt;\( F_{0} \)就是垂直观察平面时的&lt;strong&gt;基本反射率&lt;/strong&gt;，一般要用一个vec3表示。注意，这条公式其实只适用于绝缘体（dielectric），对于金属/导体（metal/conductor）是不适用的。这时就有了些取巧的做法。&lt;/p&gt;

&lt;p&gt;一是先预计算出各种常见材质的基本反射率，汇总成一个表，然后需要的时候查表即可。&lt;/p&gt;

&lt;p&gt;有了表之后就会发现，对于绝缘体，基本反射率基本都在0.17这个水平线以下，且rgb分量一致；而对于导体，基本反射率都在0.5到1.0之间，且rgb分量值不一致（正是这个不一致性，使得不同的金属有显著的颜色差异，如金、铜、银颜色各异）。&lt;/p&gt;

&lt;p&gt;综上,\( F_{0} \)的求取实际上可以做得非常简化，用shader代码可以看出：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.04&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;surfaceColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;metalness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行是绝缘体基本反射率，0.04是统计了大部分绝缘体的基本反射率并取平均值得到。&lt;/p&gt;

&lt;p&gt;第二行使用了一个新的参数叫金属性metalness，这是个十分人为的控制变量，范围为0.0到1.0；surfaceColor就是反射颜色值，例如黄金反射颜色为(1.00, 0.71, 0.29)。然后就可以使用mix函数和metalness做插值，metalness越接近0，那么就越接近绝缘体，metalness越接近1，那么就越接近surfaceColor。&lt;/p&gt;

&lt;p&gt;有了\( F_{0} \)后，就可以代入到菲涅尔方程做运算了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fresnelSchlick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;5.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;G，Geometry function，几何属性函数&lt;/h3&gt;

&lt;p&gt;微平面的起伏不定，导致微平面之间产生了自阴影（self-shadowing）。G函数模拟计算的就是这个事情. 粗糙度越高，自阴影越多，反射出去的光就越少。G函数输出的是一个比值，0.0表示百分百自阴影（全黑掉），1.0表示没有任何自阴影（全白）。&lt;/p&gt;

&lt;h4&gt;Smith&amp;#39;s Schlick-GGX&lt;/h4&gt;

&lt;p&gt;\[ G(n, v, k) = \frac { n\cdot v }{ (n\cdot v)(1 - k) + k } \]&lt;/p&gt;

&lt;p&gt;输入参数：平面法线n、视角向量v、粗糙度\( \alpha \)的重新映射k。&lt;/p&gt;

&lt;p&gt;k的公式要看情况做选择，例如对于方向光，有:&lt;/p&gt;

&lt;p&gt;\[ k = \frac { (\alpha + 1)^{2} }{ 8 } \]&lt;/p&gt;

&lt;p&gt;为了更加地近似模拟平面几何属性，可以再应用一条公式（Smith&amp;#39;s method）:&lt;/p&gt;

&lt;p&gt;\[ G&amp;#39;(n,v,l,k) = G(n,v,k)G(n,l,k) \]&lt;/p&gt;

&lt;p&gt;Smith&amp;#39;s method同时处理掉了微平面的高低起伏导致的对光线、对视角的障碍问题，如下图。图中左边，视角向量（红色）的路线上有一个微平面突起，导致接收不到左边的光线的反射，这种情况叫&lt;strong&gt;几何障碍（geometry obstruction）&lt;/strong&gt;；图中右边，光线到达微平面后又反射到另一个微平面上（能量衰减了），没有直接反射到眼睛，这种情况叫&lt;strong&gt;几何遮蔽（geometry shadowing）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2017.9/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;shader：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GeometrySchlickGGX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NdotV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nom&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NdotV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;denom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NdotV&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;denom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GeometrySmith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NdotV&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NdotL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ggx1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GeometrySchlickGGX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NdotV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ggx2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GeometrySchlickGGX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NdotL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ggx1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ggx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Cook-Torrance reflectance equation&lt;/h2&gt;

&lt;p&gt;有了brdf函数后，之前的渲染方程就可以变成：&lt;/p&gt;

&lt;p&gt;\[ L_{o}(p, \omega _{o}) = L_{e}(p, \omega _{o})  + \int _{\Omega } (k_{d}\frac {c}{\pi } + k_{s}\frac { DFG }{ 4 (\omega _{o} \cdot \mathbf n)(\omega _{i} \cdot \mathbf n) } ) L_{i}(p, \omega _{i}) |cos \theta _{i}|d\omega _{i} \]&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/pbr-rendering/</link>
        <guid isPermaLink="true">http://localhost:4000/pbr-rendering/</guid>
      </item>
    
      <item>
        <title>渲染器开发笔记2-延迟渲染下的天空盒</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;defer和forward框架下实现天空盒渲染，区别并不是很大，这里备忘下流程：&lt;/p&gt;

&lt;h2&gt;Deferred rendering:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;geometry pass（计算GBuffer）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Deferred lighting pass（根据GBuffer计算光照）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把GBuffer的深度信息复制到main framebuffer&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;渲染天空盒&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Forward rendering:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;正常渲染场景（一遍vs + fs？）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;渲染天空盒&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;对比&lt;/h2&gt;

&lt;p&gt;可以看到，天空盒都是放在最后一步渲染的。这是因为天空盒体积巨大，如果放在第一步就渲染就可能会有多余的fs着色是白做的，具体地说就是和视角有关，如果摄像机朝天，那么天空盒提前算也没关系，最终还是看得到这些像素，但如果视角朝地面，可能所有天空盒的像素都被深度剔除了，那就不好了。&lt;/p&gt;

&lt;h2&gt;天空盒的实现要点&lt;/h2&gt;

&lt;h3&gt;view矩阵问题&lt;/h3&gt;

&lt;p&gt;首先天空盒的渲染需要用到Proj和View矩阵，但需要做一点trick：天空盒不需要translate变换（摄像机不能&amp;quot;靠近&amp;quot;天空盒），需要把view矩阵的translate信息剔除掉。学到的一个很聪明的做法是：mat4(mat3(view))，即剔除view矩阵的前三行前三列信息（translate信息在最后一列），然后再恢复成mat4。&lt;/p&gt;

&lt;h3&gt;天空盒的深度值问题&lt;/h3&gt;

&lt;p&gt;天空盒必须渲染后到最深的位置，所以天空盒的每一个fragment的depth必须为1.0。怎么保证呢？做法就是在vertex shader里加一行这样的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;gl_Position = pos.xyww;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为OpenGL有一个perspective divide的过程，会在vs着色完成时，对gl_Position除以gl_Position的z值，所以x、y、w、w会变成x/w、y/w、1.0, 1.0，z值就固定1.0了。&lt;/p&gt;

&lt;h3&gt;glDepthFunc问题&lt;/h3&gt;

&lt;p&gt;glDepthFunc的默认值为GL_LESS，渲染天空盒时需要临时改为GL_LEQUAL，因为对于屏幕上空白的地方（没有任何fragment画上去），depth buffer的深度值为1.0，如果是GL_LESS，那么天空盒的深度值即使是1.0也会过不了depth test。所以要加上EQUAL。&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/renderer-progress-2/</link>
        <guid isPermaLink="true">http://localhost:4000/renderer-progress-2/</guid>
      </item>
    
      <item>
        <title>再谈四元数的应用：朝向四元数、朝向四元数插值、旋转四元数？</title>
        <description>&lt;p&gt;最近在做的东西涉及到四元数的知识，做的过程中发现四元数有一些很容易让人迷惑的点，现写这篇文章备忘。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;四元数作为对象的朝向(Orientation)以及需要做朝向之间的插值时&lt;/h2&gt;

&lt;p&gt;一个3D的对象一般有这些基本几何属性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;空间位置。用一个vector3d即可表示&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缩放系数。同样也可以用一个vector3d表示，每个分量代表物体在每一个正交基的缩放系数&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;朝向。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;朝向，这是个看名字很容易知道含义的属性，但是用数学语言描述的话却有很多种方式，不像&amp;quot;位置&amp;quot;、&amp;quot;缩放&amp;quot;那么容易就可以确定用一个vector3d来实现。&lt;/p&gt;

&lt;p&gt;基于笛卡尔3D坐标系，普遍在用的朝向表示方法有这么几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;欧拉角&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.qiujiawei.com/linear-algebra-14/&quot;&gt;旋转矩阵&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四元数&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这3个随便一个都是蛮复杂的东西（不是学3D的应该都不知道这3个吧）。首先比较下3种方法的数据存储效率：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;欧拉角，需要3个分量（ 前进方向(heading)、海拔(elevation)、 倾斜(bank) 或 偏航(yaw),
俯仰(pitch)、 翻滚（roll））。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;旋转矩阵。4 x 4 = 16个分量（不考虑压缩）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四元数。4个分量。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;显然从数据存储上看，欧拉角最有优势，但问题是，欧拉角（or旋转矩阵）是有万向节锁问题的。实际上，只要是用三个旋转角来表示朝向的变化就会出现万向节锁问题，即使存储朝向时用了四元数。这是因为欧拉角和四元数可以等价转换，朝向变换计算时用欧拉角，只是存储的时候转换成四元数，这样四元数并没有什么卵用。&lt;/p&gt;

&lt;p&gt;考虑这一点，&lt;strong&gt;四元数直接表示朝向以及朝向之间的插值&lt;/strong&gt;的优势就凸现出来了，比欧拉角多一个分量，但能处理好万向节锁问题。为什么会这样呢？这其中的神奇之处就在于四元数的4个分量的含义和欧拉角的三个分量的含义差别很大，我举例说明下：&lt;/p&gt;

&lt;p&gt;欧拉角(pitch yaw roll)  &amp;lt;—&amp;gt; 四元数(第一个值是虚部，后面三个是实部)&lt;/p&gt;

&lt;p&gt;0.0,  0.0,  0.0  &amp;lt;—&amp;gt; 1.000000, 0.000000, 0.000000, 0.000000&lt;/p&gt;

&lt;p&gt;90.0, 0.0,  0.0  &amp;lt;—&amp;gt; 0.707107, 0.707107, 0.000000, 0.000000&lt;/p&gt;

&lt;p&gt;0.0, 90.0,  0.0  &amp;lt;—&amp;gt; 0.707107, 0.000000, 0.707107, 0.000000&lt;/p&gt;

&lt;p&gt;0.0,  0.0, 90.0  &amp;lt;—&amp;gt; 0.707107, 0.000000, 0.000000, 0.707107&lt;/p&gt;

&lt;p&gt;可以看到，用四元数表示的朝向，只看数值是无法直观知道这个四元数是代表什么朝向的。所以&lt;strong&gt;不能以轴-旋转角度的概念去看待朝向四元数，完全不是同一回事&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;总结一下：&lt;/h3&gt;

&lt;p&gt;明确你的程序里的欧拉角和四元数的对应关系后，做一个欧拉角到四元数的转换接口。初始化对象朝向时，先以欧拉角的思考角度确定欧拉角的三个值，然后用这个接口把欧拉角转成四元数，就可以用四元数来做朝向数据的存储（多消耗一个float）。&lt;/p&gt;

&lt;p&gt;使用四元数朝向数据时，不能转换回欧拉角来使用（如果你这样就等同于只在存储时应用四元数），而是应该继续以四元数的思考角度来做各种操作，如做朝向的插值。（&lt;a href=&quot;http://www.qiujiawei.com/understanding-quaternions/#7&quot;&gt;四元数SLERP&lt;/a&gt;）。&lt;/p&gt;

&lt;h2&gt;四元数作为旋转变换参数时&lt;/h2&gt;

&lt;p&gt;这种情景下，朝向是否用四元数存储不再重要。只是在做&lt;strong&gt;旋转&lt;/strong&gt;这个事情时，使用了四元数。这个四元数也被称为旋转四元数。旋转四元数的构造需要2个东西：&lt;strong&gt;笛卡尔坐标系下的旋转轴\( \hat { \mathbf v } \)（Vector3d）和绕着这个旋转轴的旋转角度\( \theta \)(Radian)&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;\[ q = [cos\frac {1}{2}\theta ,sin\frac {1}{2}\theta \mathbf { \hat { \mathbf v } }] \]&lt;/p&gt;

&lt;p&gt;构造了旋转四元数后，剩下的就是怎么使用的问题。假设现在要对一个3D坐标点\( \vec p \)做\( \mathbf q \)旋转，那么变换公式如下：&lt;/p&gt;

&lt;p&gt;\[ \mathbf p&amp;#39; = \mathbf q \mathbf p \mathbf q^{-1} \]&lt;/p&gt;

&lt;p&gt;其中的\( \mathbf p \)四元数的虚部为0，实部为\( \vec p \)向量。&lt;/p&gt;

&lt;p&gt;(详细的公式细节可以查阅&lt;a href=&quot;http://www.qiujiawei.com/understanding-quaternions&quot;&gt;Understanding Quaternions 中文翻译《理解四元数》&lt;/a&gt;)&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/quaternion4/</link>
        <guid isPermaLink="true">http://localhost:4000/quaternion4/</guid>
      </item>
    
      <item>
        <title>渲染器开发笔记1-ECS框架实现</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;目前进展：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;已把项目改造使用ECS框架，顺眼很多&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;做了基本的一系列system设计和实现&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正在弄Deferred Rendering框架&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;开发计划：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;据某大牛说，不结合实际的游戏项目而去开发游戏引擎，就是扯淡。所以目前还不打算把这个renderer项目弄成引擎，而是当做一个纯粹的渲染器来做。focus在渲染这块，所以会忽略开发一些次要模块，如脚本引擎、音频播放器、控制器啥的，都不搞。不过渲染这个东西里面，还有很多问题得暂时忽略的，例如是否要嵌入一个物理引擎还是自己做一个简易版（当学习CD算法）、超大世界渲染是否要做、动画系统等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于第一点，目前打算实现的是：Deferred + Forward的框架。实现之后的下一个计划是PBR渲染和SSAO。其他就不管先了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;记录一些渲染的心得&lt;/h2&gt;

&lt;h3&gt;单纯的Forward Rendering为什么不好？&lt;/h3&gt;

&lt;p&gt;正向渲染，每一个模型都得跑一遍shader（vs做mvp变换、fs做光照），那么就是说每一个通过depth test的fragment都得做光照，而光照计算一般是一个线性叠加的过程，有几个光源就做几遍lighting pass，所以：&lt;/p&gt;

&lt;p&gt;大致的时间复杂度 = O(模型面片数量 * 光源数量)&lt;/p&gt;

&lt;p&gt;（注意，这里的光源数量非常关键，多一个光源就等于多跑了一遍fs。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;正向渲染的不足之处在于有大量的做了光照计算的fragment被覆盖掉了，即光照白做了。&lt;/strong&gt;例如我先draw一个10万面片的角色，然后又在这个角色前面draw了一堵墙，完全把这个角色挡住了，那么这个角色的光照计算就是白做的。&lt;/p&gt;

&lt;h3&gt;Deferred Rendering的正确做法和优点&lt;/h3&gt;

&lt;p&gt;延迟渲染的延迟指的是把光照计算延迟了，以刚刚的例子来说，先渲染一个10万面片的模型，再渲染一堵墙，不会再有光照计算的浪费。延迟渲染的GBuffer，不会有光照计算信息。&lt;strong&gt;光照计算延迟到geometry pass之后再做，和模型面片数量再无关系，而与frame buffer分辨率产生关系&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;大致的时间复杂度 = O(模型面片数量) + O(光源数量 * 分辨率)&lt;/p&gt;

&lt;p&gt;从这条公式可以发现，即使模型再多面片再多，光照计算只会和分辨率有关系，从而理论上可以做到超多光源渲染。&lt;/p&gt;

&lt;p&gt;但Deferred Rendering不是一种用来替代Forward Rendering的技术，而是一钟补充。延迟渲染的特性导致有一些技巧会不好使，例如半透明的混合渲染。正确的做法是先延迟后正向，两步渲染。&lt;/p&gt;

&lt;p&gt;值得一提的是， O(光源数量 * 分辨率)，这一步还得特别优化下才能实现超多光源渲染。优化原理是：&lt;strong&gt;剔除掉和目标fragment无关的光照计算&lt;/strong&gt;。比如可以根据光源强度和距离，把足够远的光源排除掉，那么就可以省下很多计算量。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/renderer-progress-1/</link>
        <guid isPermaLink="true">http://localhost:4000/renderer-progress-1/</guid>
      </item>
    
      <item>
        <title>错误使用四元数依然会出现Gimble Lock</title>
        <description>&lt;p&gt;一直都说用欧拉角做旋转会出现万向节锁Bug（Gimble Lock），而用四元数就不会。其实这样的说法是不准确的，当用四元数做旋转，如果使用姿势错误，依然会出现Gimble Lock。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;错误的用法&lt;/h2&gt;

&lt;p&gt;下面是我自己录制的演示视频，当x轴转90度，y轴和z轴就合二为一了：&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/ZDQkzR_L7b0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;演示代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Transform4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trans1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Translate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vector3dF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Transform4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trans2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pitch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yaw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pitch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;90.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;yaw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;roll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RotateX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pitch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RotateY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yaw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// y&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotZ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RotateZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// z&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotZ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Transform4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelTrans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trans1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trans2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform4x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMatrix4x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pitch即x轴，pitch到90度时，yaw和roll转的是同一条轴。这和欧拉角的情况没有区别。&lt;/p&gt;

&lt;p&gt;原因在于要理解Gimble Lock问题的本质。只要你是利用坐标系3个正交基x、y、z去做转换，当其中一个基旋转了90度时，&lt;strong&gt;另外的2个基的其中之一会跟着旋转90度&lt;/strong&gt;，然后和第三个基合并，那么对这合并的2个基做旋转，肯定都是一个效果。换句话说就是丢失一个自由度。&lt;/p&gt;

&lt;p&gt;正确的旋转机制是，不要用3个&lt;strong&gt;互相关联的&lt;/strong&gt;变量来表示物体的旋转，例如pitch、yaw、roll；而是用一个变量表示，例如用唯一一个四元数或旋转矩阵（旋转矩阵也可以由一个四元数导出）来表示物体的&lt;strong&gt;朝向&lt;/strong&gt;，则是可行的。上面的例子虽然也用了四元数，但是错就错在用了三个四元数，所以就出bug了。&lt;/p&gt;

&lt;p&gt;下面是正确的四元数转换代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pitch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yaw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RotateX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pitch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RotateY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yaw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// y&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotZ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RotateZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// z&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;QuaternionF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quatDiff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rotZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quatDiff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Transform4x4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modelTrans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trans1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trans2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform4x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toMatrix4x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这段代码里依然出现了pitch、yaw、roll。为什么呢？这是因为&lt;strong&gt;旋转&lt;/strong&gt;的数学描述用正交基表示依然是最人性化的。这段代码之所以可行是在于用了一个新的变量orientation，来表示物体的当前&lt;strong&gt;朝向&lt;/strong&gt;。每次迭代更新朝向时，先把pitch、yaw、roll转成Quaternion，然后相乘，从而得到这一帧的&lt;strong&gt;朝向改变量quatDiff&lt;/strong&gt;，最后把quatDiff应用到orientation里，就改变了当前朝向了。&lt;/p&gt;

&lt;p&gt;最后要注意的是，orientation每次改变后都要重新规范化&lt;strong&gt;(Normalize)&lt;/strong&gt;，否则旋转效果会和预期的不一样。&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/RfM83dFT9ks&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
</description>
        <pubDate>Tue, 30 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/quaternion3/</link>
        <guid isPermaLink="true">http://localhost:4000/quaternion3/</guid>
      </item>
    
      <item>
        <title>碰撞检测算法</title>
        <description>&lt;p&gt;碰撞检测算法，暴力解决是一个\( O(n^{2}) \)的过程：对于场景中的每一个obj都和所有其他的obj做相交测试。2个for循环解决问题，所以时间复杂度是\( O(n^{2}) \)，这是最坏情况了。于是可以说，现在流传的各种碰撞检测算法的存在意义都是为了降低这个复杂度\( O(n^{2}) \)。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;实际可用的碰撞检测算法，一般要分2个阶段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Broadphase&quot;&gt;broad phase&lt;/a&gt; 快速找出潜在的碰撞物体对列表，不在这个列表里的是绝对没可能碰撞的。broad phase确定了一批需要进一步检查的物体对。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;narrow phase 准确找出发生碰撞的物体对列表。因为上一个阶段的部分物体对实际上是没有碰撞的，需要在这个阶段剔除。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;broad phase用的数据结构不一定和narrow phase用的数据结构是同一个结构。&lt;/p&gt;

&lt;h3&gt;broad phase&lt;/h3&gt;

&lt;p&gt;分2个阶段的好处是，在第一个阶段，可以用不那么精确但快速的算法，找出潜在的碰撞物体。总好过直接就是应用narrow phase的精确但缓慢的算法去处理n个物体。更深刻的原因是，如果单个物体具有复杂的几何结构，那么narrow phase的计算开销非常大。&lt;/p&gt;

&lt;p&gt;broad phase阶段的算法和需要的数据结构数据信息和narrow phase是不一样的。&lt;/p&gt;

&lt;p&gt;broad phase阶段要求提供物体的包围盒信息，例如AABB盒。这就是broad phase为什么快但不精确的原因：物体的几何信息被近似地压缩了。&lt;/p&gt;

&lt;p&gt;broad phase还要求把场景所有物体的包围盒信息放进一个数据结构（一般是一个树结构）中，例如插入到一个四叉树、八叉树、AABB树等。通过这个数据结构来实现快速相交判定。例如在Box2d中，是设计了一个proxy机制，每个场景物体对应唯一一个proxyAABB盒，这些proxyAABB盒就记录在一颗称之为Dynamic AABB Tree里，然后就可以做broad phase了。&lt;/p&gt;

&lt;p&gt;broad phase其中有一个简单算法叫&lt;a href=&quot;https://en.wikipedia.org/wiki/Sweep_and_prune&quot;&gt;sweep and prune(SAP)&lt;/a&gt;，本质上是利用了排序算法。第一步是初始化排序列表，列表中的元素是包围盒，可以用任意排序算法完成，例如快排；之后的排序就不是用快排了，而是用冒泡排序，为什么用冒泡排序更好呢？是因为一个默认的前提：物体的运动有&lt;strong&gt;时间相关性（temporal coherence）&lt;/strong&gt;，即当前帧和下一帧的位置是相近的，所以在冒泡排序过程中，发生的位置交换预期都很靠近。如果这个前提不成立，例如物体会经常发生远距离瞬移，那就不能用这种算法了。&lt;/p&gt;

&lt;h3&gt;narrow phase&lt;/h3&gt;

&lt;h2&gt;相交判定算法&lt;/h2&gt;

&lt;p&gt;根据我的调研，在2维情况下，可以用SAT算法做任意凸多边形的碰撞检测，十分简单；但在3维情况下，只能GJK算法，因为SAT相对毕竟暴力、慢，以及GJK算法还有更多的SAT不具备的高级特性。另外，Box2D用的是GJK算法，所以证明了GJK算法是可以应用到2维情况的。除了SAT和GJK，还有一个sweep line算法可以求出多边形的相交点，此算法内部需要用到排序算法。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperplane_separation_theorem&quot;&gt;Separating Axis Theorem, SAT, 分离轴算法&lt;/a&gt;&lt;/h3&gt;

&lt;h3&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm&quot;&gt;GJK算法&lt;/a&gt;&lt;/h3&gt;

&lt;h2&gt;用于做碰撞检测的场景管理树&lt;/h2&gt;

&lt;p&gt;这里讨论的场景管理树，只针对碰撞检测。&lt;/p&gt;

&lt;h3&gt;基于空间划分的八叉树&lt;/h3&gt;

&lt;p&gt;一般说到场景管理，都会想到四叉树（八叉树的简化）、八叉树，这种基于空间划分的结构，然而，基于空间划分的树，会遇到一个十分蛋疼的问题：物体可能会overlap边界。这种情况，有几种可行的处理方案：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://anteru.net/blog/2008/11/14/315/&quot;&gt;Loose OCTree&lt;/a&gt;，松散八叉树。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大概就是说，空间划分后的各个cell bound，各对应一个loose bound（relaxing the bounds slightly！），loose bound应是cell bound的两倍大小，这个loose bound可以保证完全包含cell bound里的所有物体的包围盒。这是个重要的性质，比如说如果有一个物体的包围盒刚好和cell bound一样大，但是物体包围盒中心点刚好在cell bound里，那么此时可以保证loose bound仍然能完全包含物体包围盒。&lt;/p&gt;

&lt;p&gt;有了这个性质后，根据任意物体的包围盒中心点，决定把它放进哪个cell的列表里。即不会出现一个物体同时存在于2个cell的情况。然后查询相交时，就好办了，只需要根据query point确定要检查的cell，不过缺点是，如果query point处于多个loose bound的重叠区域，就需要这些loose bound的cell都做一次相交判定。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;允许内部节点存物体的OCTree。overlap了边界的物体，通通丢到父节点去。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;允许一个物体同时存进多个叶子节点的OCTree。这种方案主要是怕出bug，因为2个叶子节点都存了这个物体。需要严格管理好节点的增删，防止出现不一致性。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，还有一个问题是：当大量物体集中于一个cell。此时八叉树基本就废了，退化成了\( O(n^{2}) \)级别的算法了。&lt;/p&gt;

&lt;p&gt;因此我觉得，八叉树适合处理的场景是，物体分布均匀、静态物体较多、动态物体较少的情况。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://www.bulletphysics.org/mediawiki-1.5.8/index.php?title=BtDbvt_dynamic_aabb_tree&quot;&gt;btDbvt - Dynamic AABB Tree&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;这个btDbvt数据结构是从Box2D、Bullet源码中发现的，并且Box2D在注释里写到Box2D的Dynamic AABB Tree是参考了Bullet的，那么可以知道Bullet的Dynamic AABB Tree才是根源。&lt;/p&gt;

&lt;p&gt;更让人激动的是，Bullet的官网有介绍这个数据结构的&lt;a href=&quot;http://www.bulletphysics.org/mediawiki-1.5.8/index.php/BtDbvt_dynamic_aabb_tree&quot;&gt;资料&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;btDbvt是一个&lt;strong&gt;基于物体集合划分的二叉树&lt;/strong&gt;，注意和八叉树的区别，八叉树是基于空间划分的。btDbvt另一个性质是，它考虑到了时间相干性，这也是这个数据结构更适合物体引擎的原因，因为物理世界里，物体不会发生瞬移。&lt;/p&gt;

&lt;p&gt;时间相干性是用了一个fatBound的机制体现的，大概意思是，每个物体的proxyBound都会比实际的Bound大那么一点，当物体移动时，如果移动后的没有超过fatBound范围，那么不会发生节点的移动。从而降低树的更新频率。&lt;/p&gt;

&lt;p&gt;先贴出算法伪代码：&lt;/p&gt;

&lt;h3&gt;场景管理树的比较&lt;/h3&gt;
</description>
        <pubDate>Wed, 10 May 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/collision-detection/</link>
        <guid isPermaLink="true">http://localhost:4000/collision-detection/</guid>
      </item>
    
      <item>
        <title>mini引擎开发备忘</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;跨平台问题汇总&lt;/h2&gt;

&lt;h3&gt;XCode 8 + iOS + SDL2 + OpenGL ES&lt;/h3&gt;

&lt;p&gt;首先是记录xcode项目的创建问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个iOS平台的game或Single View Application项目。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Main和Lauch Screen这2个storyboard可以去掉，去掉后还要把info.plist里2个storyboard的选项也去掉，并设置用默认的Lauch Screen storyboard： 【Launch screen interface file base name：iOS Launch Screen】。相应的ViewController的h和m文件也去掉，只留下AppDelegate和main.m。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AppDelegate的h和m文件可以不修改，但main.m里面的代码需要全部删除（因为SDL自身会定义main入口）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载SDL2源码，解压后找到里面的xcode-iOS目录，用xcode打开其中的SDL子目录里的工程，然后直接build，就获得里libsdl2.a静态库。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把libsdl2.a放到刚才创建的xcode项目根目录里。并在Build Phases的Link项里把libsdl2.a加上。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后继续添加iOS项目需要的官方frameworks: GLKit、OpenGLES、CoreMotion、AVFoundation、GameController、AudioToolbox&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把SDL2的include目录复制到项目目录，并把目录拖进xcode左边的目录树里，然后设置后search path，这样等下编译就能找到SDL2库了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后就可以新建一个main.cpp文件，开始写SDL程序了&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;renderer的代码在xcode中编译遇到的报错&lt;/h3&gt;

&lt;p&gt;一大堆报错，处理了一两个小时，主要产生原理是vc和gcc的不一致性，以及一些平台相关代码问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Point模板类，Vector模板继承Point，会出现一个偏特化的问题，症状就是Vector的代码里调用父类成员x y z，gcc会找不到（vc没问题），原因暂时没完全搞懂，关键词是偏特化，gcc要求明确指出x y z是哪来的对象，也就是说要么写成Point&lt;T&gt;::x, 要么写成this-&amp;gt;x。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当class的构造函数的参数没有加const限定符，但用右值作为参数去创建类实例时，vc不会报错，而gcc报错了，加上const后可以解决。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【Non-constant-expression cannot be narrowed from type &amp;#39;unsigned long&amp;#39; to &amp;#39;int&amp;#39; in initializer list】 initial list初始化列表不支持非常量表达式的long到int的narrow转换，需要自行加上static_cast&lt;int&gt;。（vc不会报这个错）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【Use of overloaded operator &amp;#39;/&amp;#39; is ambiguous (with operand types &amp;#39;value_type&amp;#39; (aka &amp;#39;nlohmann::basic_json&lt;std::map, std::vector, std::__1::basic_string&lt;char&gt;, bool, long long, double, std::allocator&amp;gt;&amp;#39;) and &amp;#39;float&amp;#39;) 】这个错和第三方json库有关，但vc没报错，大概就是编译器找到多个／操作符重载，不知道用哪个，需要把代码从 c[0] / 255.0f 改成 float(c[0]) / 255.0f&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【Non-const lvalue reference to type &amp;#39;renderer::Ray&amp;#39; cannot bind to a temporary of type &amp;#39;renderer::Ray&amp;#39;】 问题处在函数返回值类型和变量类型上。函数返回的是Ray，而变量是Ray&amp;amp;，如果是vc，那么不会报错。如果是gcc，有三个办法解决报错，一改成const Ray&amp;amp;（注意，改const的话，其他代码可能会有冲突），二改成Ray&amp;amp;&amp;amp;，三改成Ray。vc真是人性化到有点可怕，这种返回值没弄好，分分钟变成性能瓶颈的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;【Control may reach end of non-void function】，这个在vc里没有报，在gcc里报了，gcc要严格得多呀。这个报错就是要求说，每个函数能到达的结束位置，都必须有返回值。我这里是不小心写漏了。小问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;头文件include报错，这种属于工程问题，通过配置xcode的include路径应该可以解决。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平台相关的编译报错，通过#if可以粗暴解决。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 17 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/game-engine-notes/</link>
        <guid isPermaLink="true">http://localhost:4000/game-engine-notes/</guid>
      </item>
    
  </channel>
</rss>