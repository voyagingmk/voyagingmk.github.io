<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>写作主题覆盖：游戏开发技术、图形学、机器学习。QQ：234707482</description>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>redis5.0源码学习笔记（1）</title>
        <description>&lt;p&gt;Note：本文实际绑定的版本是branch5.0（2018-7-25）。&lt;/p&gt;

&lt;p&gt;持续更新中。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;数据结构&lt;/h1&gt;

&lt;h2&gt;SDS 简单动态字符串&lt;/h2&gt;

&lt;h3&gt;基本特点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;涉及字符串的存储基本都基于SDS，例如set nickname Luffy，就创建了nicknmae和Luffy2个SDS&lt;/li&gt;
&lt;li&gt;不止用于字符串，还用于缓冲区：AOF缓冲区、客户端状态中的输入缓冲区&lt;/li&gt;
&lt;li&gt;减少修改字符串长度时所需的内存重分配次数&lt;/li&gt;
&lt;li&gt;杜绝缓冲区溢出问题&lt;/li&gt;
&lt;li&gt;二进制安全&lt;/li&gt;
&lt;li&gt;兼容部分C字符串函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;源码位置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;sds.h&lt;/li&gt;
&lt;li&gt;sds.c&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;结构定义&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Note: sdshdr5 is never used, we just access the flags byte directly.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; * However is here to document the layout of type 5 SDS strings. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__packed__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sdshdr5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 3 lsb of type, and 5 msb of string length */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__packed__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sdshdr8&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__packed__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sdshdr16&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__packed__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sdshdr32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__attribute__&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__packed__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sdshdr64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* used */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* excluding the header and null terminator */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 3 lsb of type, 5 unused bits */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;sds被定义为5种，根据sds的len属性的bit数量划分：5、8、16、32、64bits，5bits的结构没有被使用。&lt;/li&gt;
&lt;li&gt;紧凑对齐：&lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;packed&lt;/strong&gt;)) 告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。&lt;/li&gt;
&lt;li&gt;char buf[]很有意思，这样子声明buf，是不会增大sizeof(sdshdr#T)的，因为编译器不知道buf的长度，默认0，而如果声明成指针，就会占4或8字节。&lt;/li&gt;
&lt;li&gt;综上，5个sds结构的size分别为1、3、5、9、17&lt;/li&gt;
&lt;li&gt;typedef char *sds，指向的是buf字段，如果要访问sdshdr的len、alloc、flags，是用宏SDS_HDR来定位sdshdr的首字节。&lt;/li&gt;
&lt;li&gt;sds依然遵守C语言用&amp;#39;\0&amp;#39;（null terminator）结尾的习惯，使得sds可以使用C字符串函数库。&lt;/li&gt;
&lt;li&gt;len相当于strlen(buf) - 1，记录实际使用了buf的多少字节&lt;/li&gt;
&lt;li&gt;alloc记录buf的容量，不含&amp;#39;\0&amp;#39;&lt;/li&gt;
&lt;li&gt;&amp;#39;\0&amp;#39;由sds自动处理，用户不会感知到&amp;#39;\0&amp;#39;；len、alloc也是&lt;/li&gt;
&lt;li&gt;因为有len字段，获取sds长度时间复杂度为O(1)&lt;/li&gt;
&lt;li&gt;len、alloc字段能防止缓冲区溢出&lt;/li&gt;
&lt;li&gt;alloc - len = avail, avail有效地降低了频繁内存重分配的开销。这种策略叫空间预分配、惰性空间释放。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;接口说明&lt;/h3&gt;

&lt;p&gt;sds.h直接定义的简单接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;size_t sdslen(const sds s)：获得s的len字段&lt;/li&gt;
&lt;li&gt;size_t sdsavail(const sds s)：返回这个s的空闲空间字节长度&lt;/li&gt;
&lt;li&gt;sdssetlen(sds s, size_t newlen)：直接设置s的len字段（不验证上限的）&lt;/li&gt;
&lt;li&gt;sdsinclen(sds s, size_t inc)：s的len增加inc（不验证上限的）&lt;/li&gt;
&lt;li&gt;size_t sdsalloc(const sds s)：获得s的alloc字段（并不是分配一个sds）&lt;/li&gt;
&lt;li&gt;sdssetalloc(sds s, size_t newlen)：直接设置s的alloc字段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在sds.c定义的简单接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;int sdsHdrSize(char type)：根据SDS_TYPE_xx，返回对应的sdshdr结构的sizeof&lt;/li&gt;
&lt;li&gt;char sdsReqType(size_t string_size)：根据给定大小，返回对应的sdshdr的类型SDS_TYPE_xx，策略是从小到大匹配&lt;/li&gt;
&lt;li&gt;size_t sdsAllocSize(sds s)：等于sdsalloc(s) + 头部长度 + 1，即sds总共占了多少内存&lt;/li&gt;
&lt;li&gt;void *sdsAllocPtr(sds s)：即得到s的sdshdr头部指针&lt;/li&gt;
&lt;li&gt;sds sdsempty(void)：实际调用sdsnewlen(&amp;quot;&amp;quot;,0);&lt;/li&gt;
&lt;li&gt;sds sdsnew(const char *init)：把C字符串转成sds&lt;/li&gt;
&lt;li&gt;sds sdsdup(const sds s)：克隆一个sds&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;核心接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sds sdsnewlen(const void *init, size_t initlen)：创建一个新的sds对象，内容为init，len字段为initlen&lt;/li&gt;
&lt;li&gt;void sdsfree(sds s)：销毁一个sds&lt;/li&gt;
&lt;li&gt;void sdsupdatelen(sds s)：更新s的len为strlen的结果，如果sds某个字节被置0，就会导致strlen长度发生变化。&lt;/li&gt;
&lt;li&gt;void sdsclear(sds s)：清空sds，但不释放sds内存&lt;/li&gt;
&lt;li&gt;sds sdsMakeRoomFor(sds s, size_t addlen)：增大sds的alloc，但不影响已存内容和len字段，会返回新的sds(地址发生改变)&lt;/li&gt;
&lt;li&gt;sds sdsRemoveFreeSpace(sds s)：缩小sds的alloc，使得没有avail空间（100%利用率），会返回新的sds&lt;/li&gt;
&lt;li&gt;void sdsIncrLen(sds s, ssize_t incr)：和sdsinclen类似，区别在于加了assert防止超过上限，以及会把newlen字节置0&lt;/li&gt;
&lt;li&gt;sds sdsgrowzero(sds s, size_t len)：oldlen增大到len，len - oldlen这段空间会自动置0&lt;/li&gt;
&lt;li&gt;sds sdscatlen(sds s, const void *t, size_t len)：即concat操作&lt;/li&gt;
&lt;li&gt;sds sdscat(sds s, const char *t)：用strlen(t)去调用sdscatlen&lt;/li&gt;
&lt;li&gt;sds sdscatsds(sds s, const sds t)：concat2个sds&lt;/li&gt;
&lt;li&gt;sds sdscpylen(sds s, const char *t, size_t len)：把t复制进sds&lt;/li&gt;
&lt;li&gt;sds sdscpy(sds s, const char *t)：用strlen(t)去调用sdscpylen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他接口：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;int sdsll2str(char *s, long long value)：long long转成字符串并放进s缓冲区&lt;/li&gt;
&lt;li&gt;int sdsull2str(char *s, unsigned long long v)：同上&lt;/li&gt;
&lt;li&gt;sds sdsfromlonglong(long long value) ：long long转成sds&lt;/li&gt;
&lt;li&gt;sds sdscatvprintf(sds s, const char *fmt, va_list ap) ：打印相关&lt;/li&gt;
&lt;li&gt;sds sdscatprintf(sds s, const char *fmt, ...)：打印相关&lt;/li&gt;
&lt;li&gt;sds sdscatfmt(sds s, char const *fmt, ...)：格式化相关&lt;/li&gt;
&lt;li&gt;sds sdstrim(sds s, const char *cset) ：trim掉头尾连续字符串，用cset识别&lt;/li&gt;
&lt;li&gt;void sdsrange(sds s, ssize_t start, ssize_t end)：返回s的子串&lt;/li&gt;
&lt;li&gt;void sdstolower(sds s)：转小写&lt;/li&gt;
&lt;li&gt;void sdstoupper(sds s)：转大写&lt;/li&gt;
&lt;li&gt;int sdscmp(const sds s1, const sds s2)：比较两个sds&lt;/li&gt;
&lt;li&gt;sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count)：用指定的sep字符串切割sds&lt;/li&gt;
&lt;li&gt;void sdsfreesplitres(sds *tokens, int count)：sdssplitlen、sdssplitargs后要调用这个释放数组&lt;/li&gt;
&lt;li&gt;sds sdscatrepr(sds s, const char *p, size_t len) ：concat p串，p会被转成escaped的串&lt;/li&gt;
&lt;li&gt;int is_hex_digit(char c)：判断是不是hex字符&lt;/li&gt;
&lt;li&gt;int hex_digit_to_int(char c)：hex字符转int&lt;/li&gt;
&lt;li&gt;sds *sdssplitargs(const char *line, int *argc)：把用空格间隔的参数列表转成sds数组&lt;/li&gt;
&lt;li&gt;sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) ：sdsmapchars(mystring, &amp;quot;ho&amp;quot;, &amp;quot;01&amp;quot;, 2)，&amp;quot;hello&amp;quot; -&amp;gt; &amp;quot;0ell1&amp;quot;&lt;/li&gt;
&lt;li&gt;sds sdsjoin(char **argv, int argc, char *sep)：join一组C字符串&lt;/li&gt;
&lt;li&gt;sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen)：join一组SDS对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;参考资料：&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/z69183787/article/details/81121779&quot;&gt;https://blog.csdn.net/z69183787/article/details/81121779&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/redis-1/</link>
        <guid isPermaLink="true">http://localhost:4000/redis-1/</guid>
      </item>
    
      <item>
        <title>漫谈网络通讯加密（4）用openSSL学习TLS1.3</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;编译&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.openssl.org/index.php/Compilation_and_Installation?&quot;&gt;官方教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1, 先下载openssl-1.1.1-pre8, 解压，进目录&lt;/p&gt;

&lt;p&gt;2, 配置编译参数：./config ， 我用的参数： enable-ssl-trace no-ssl no-dtls no-tls1 no-tls1_1 no-tls1_2，在INSTALL文件里有说明这些参数&lt;/p&gt;

&lt;p&gt;3, 执行make，等生成libcrypto.a、libssl.a；&lt;/p&gt;

&lt;p&gt;4, 创建一个my_demo目录，并创建一个test.c文件，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;openssl/ssl.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPENSSL_init_ssl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPENSSL_INIT_ENGINE_ALL_BUILTIN&lt;/span&gt;
                          &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OPENSSL_INIT_LOAD_CONFIG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;init success&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5, 编译：clang（或gcc) test.c -I../include  -L../ -lcrypto -lssl&lt;/p&gt;

&lt;p&gt;6, 运行：./a.out，输出init success即正常。&lt;/p&gt;

&lt;p&gt;7, 为了使用openssl命令行工具，执行make install&lt;/p&gt;

&lt;h2&gt;用openSSL测试TLS连接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.openssl.org/docs/manmaster/man1/s_server.html&quot;&gt;s_server&lt;/a&gt;和&lt;a href=&quot;https://www.openssl.org/docs/manmaster/man1/s_client.html&quot;&gt;s_client&lt;/a&gt; 是openssl提供的测试工具，教程在&lt;a href=&quot;https://blog.jorisvisscher.com/2015/07/22/create-a-simple-https-server-with-openssl-s_server/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;因为本机Mac不好更新openSSL，所以我是在docker里测试TLS1.3。&lt;/p&gt;

&lt;p&gt;先搞定安装了openSSL 1.1.1的container，跑起来，然后执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes -subj &amp;#39;/CN=www.mydom.com/O=My Dom, Inc./C=US/ST=Oregon/L=Portland&amp;#39; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成了自签名的公钥证书cert.pem和对应的私钥key.pem，然后启动简易服务器：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;openssl s_server -key key.pem -cert cert.pem -www  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在浏览器打开以下地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://127.0.0.1:14433/&quot;&gt;https://127.0.0.1:14433/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;chrome的话会提示不是安全连接，这是因为自签名公钥证书的问题。点继续，强行打开这个地址，就能访问到docker里的s_server了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;s_server -key key.pem -cert cert.pem -www 
Secure Renegotiation IS supported
Ciphers supported in s_server binary
TLSv1.3    :TLS_AES_256_GCM_SHA384    TLSv1.3    :TLS_CHACHA20_POLY1305_SHA256 
TLSv1.3    :TLS_AES_128_GCM_SHA256    TLSv1.2    :ECDHE-ECDSA-AES256-GCM-SHA384 
TLSv1.2    :ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2    :DHE-RSA-AES256-GCM-SHA384 
TLSv1.2    :ECDHE-ECDSA-CHACHA20-POLY1305 TLSv1.2    :ECDHE-RSA-CHACHA20-POLY1305 
（略）  
---
Ciphers common between both SSL end points:
TLS_AES_128_GCM_SHA256     TLS_AES_256_GCM_SHA384     TLS_CHACHA20_POLY1305_SHA256
ECDHE-ECDSA-AES128-GCM-SHA256 ECDHE-RSA-AES128-GCM-SHA256 ECDHE-ECDSA-AES256-GCM-SHA384
ECDHE-RSA-AES256-GCM-SHA384 ECDHE-ECDSA-CHACHA20-POLY1305 ECDHE-RSA-CHACHA20-POLY1305
ECDHE-RSA-AES128-SHA       ECDHE-RSA-AES256-SHA       AES128-GCM-SHA256         
AES256-GCM-SHA384          AES128-SHA                 AES256-SHA
Signature Algorithms: ECDSA+SHA256:RSA-PSS+SHA256:RSA+SHA256:ECDSA+SHA384:RSA-PSS+SHA384:RSA+SHA384:RSA-PSS+SHA512:RSA+SHA512:RSA+SHA1
Shared Signature Algorithms: ECDSA+SHA256:RSA-PSS+SHA256:RSA+SHA256:ECDSA+SHA384:RSA-PSS+SHA384:RSA+SHA384:RSA-PSS+SHA512:RSA+SHA512:RSA+SHA1
Supported Elliptic Groups: 0xEAEA:X25519:P-256:P-384
Shared Elliptic groups: X25519:P-256:P-384
---
No server certificate CA names sent
---
New, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES128-GCM-SHA256
    Session-ID: 
    Session-ID-ctx: 01000000
    Master-Key: 3FF0D7A74290173761702ABE91C08C67B43B6ED54BE69F48F11976C4AE5C209E5EE7E097326F5726063E8121000142BA
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    Start Time: 1531989327
    Timeout   : 7200 (sec)
    Verify return code: 0 (ok)
    Extended master secret: yes
---
   0 items in the session cache
   0 client connects (SSL_connect())
   0 client renegotiates (SSL_connect())
   0 client connects that finished
  13 server accepts (SSL_accept())
   0 server renegotiates (SSL_accept())
  13 server accepts that finished
   0 session cache hits
   0 session cache misses
   0 session cache timeouts
   0 callback cache hits
   0 cache full overflows (128 allowed)
---
no client certificate available
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;因为我的chrome开启了draft28，所以能看到上面显示支持TLSv1.3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果本机是Mac，可以用s_client访问这个简易服务器：&lt;/p&gt;

&lt;p&gt;openssl s_client -connect localhost:14433&lt;/p&gt;

&lt;p&gt;返回：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;CONNECTED(00000005)
depth=0 CN = www.mydom.com, O = &amp;quot;My Dom, Inc.&amp;quot;, C = US, ST = Oregon, L = Portland
verify error:num=18:self signed certificate
verify return:1
depth=0 CN = www.mydom.com, O = &amp;quot;My Dom, Inc.&amp;quot;, C = US, ST = Oregon, L = Portland
verify return:1
---
Certificate chain
 0 s:/CN=www.mydom.com/O=My Dom, Inc./C=US/ST=Oregon/L=Portland
   i:/CN=www.mydom.com/O=My Dom, Inc./C=US/ST=Oregon/L=Portland
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIDoTCCAomgAwIBAgIUH0Fpo...略
-----END CERTIFICATE-----
subject=/CN=www.mydom.com/O=My Dom, Inc./C=US/ST=Oregon/L=Portland
issuer=/CN=www.mydom.com/O=My Dom, Inc./C=US/ST=Oregon/L=Portland
---
No client certificate CA names sent
Server Temp Key: ECDH, X25519, 253 bits
---
SSL handshake has read 1554 bytes and written 293 bytes
---
New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384
Server public key is 2048 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES256-GCM-SHA384
    Session-ID: 418F508D841D1B9F574A7AF0B7C4C555E56199CCBA9D8D5051D44736674C5DB7
    Session-ID-ctx: 
    Master-Key: 64AFECF1FEE891647EF174B417DF960DA6C8A137958075E1AB7F423F9154EBAF0CC0AEE53F0E4176881FD12AC128C1E8
    TLS session ticket lifetime hint: 7200 (seconds)
    TLS session ticket:
    0000 - 85 7c e6 ba 9c 02 b9 c0-e9 6c c6 6c 02 3f 81 0c   .|.......l.l.?..
    0010 - e3 14 bb 65 76 4f a0 cd-64 a7 ff ff 02 73 b9 dc   ...evO..d....s..
    0020 - e6 4d 7f 57 52 ee dc 18-eb 05 8a ed b2 f4 18 44   .M.WR..........D
    0030 - 0f c1 90 88 f6 30 7b 20-eb 87 f0 39 5e a6 37 fd   .....0{ ...9^.7.
    0040 - ff 5f 92 7b da 61 7e 83-30 7a 04 a8 ef ef 5b 24   ._.{.a~.0z....[$
    0050 - fa a4 b2 86 55 fd ed 42-9f e6 b7 09 ed f6 2e 3b   ....U..B.......;
    0060 - a7 d9 89 3f 27 de d1 b8-c8 98 aa e3 32 e0 96 9c   ...?&amp;#39;.......2...
    0070 - 67 d9 69 2f 0c ed f1 d2-09 fe f8 8f 9f b1 77 67   g.i/..........wg
    0080 - f3 55 31 07 bb 4e 2e a4-df f5 1f 9d 51 df a4 35   .U1..N......Q..5
    0090 - 5c 54 71 c0 3c f6 b3 41-e7 4f 07 c4 54 dd a4 d3   \Tq.&amp;lt;..A.O..T...

    Start Time: 1531989017
    Timeout   : 7200 (sec)
    Verify return code: 18 (self signed certificate)
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;而因为命令行的openSSL还是旧的，所以显示的是TLSv1.2&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;可以在s_server指令最后面加上-msg -state，打印调试信息，来分析TLS握手过程。不过这样子只能看到状态信息，具体的通讯数据是Hex的，可以再加一个 -trace选项，把Hex信息都打印出来。&lt;/p&gt;

&lt;p&gt;要支持-trace，需要重新编译openSSL，参数是 enable-ssl-trace&lt;/p&gt;

&lt;h2&gt;抓包分析TLS1.3握手过程&lt;/h2&gt;

&lt;p&gt;首先，为了屏蔽旧协议，需要修改/include/openssl/ssl.h里的一个宏：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; * Enable TLSv1.3 Compatibility mode. This is on by default. A future version&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; * of OpenSSL may have this disabled by default.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;# define SSL_OP_ENABLE_MIDDLEBOX_COMPAT                  0x00100000U&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改为:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;# define SSL_OP_ENABLE_MIDDLEBOX_COMPAT                  0x00000000U&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后重新编译openssl。&lt;/p&gt;

&lt;p&gt;接着开一个tcpdump的进程：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;tcpdump -i lo host localhost and port 4433 -nn -vvv -X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后开2个bash分别执行：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;openssl s_server -key key.pem -cert cert.pem -msg -state -tls1_3 -trace no_middlebox -no_ssl3 -no_tls1 -no_tls1_1 -no_tls1_2 no_comp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;openssl s_client -connect localhost:4433 -msg -state -trace -tls1_3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三个进程的输出：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../images/2018.7/server.out&quot;&gt;server.out&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../images/2018.7/client.out&quot;&gt;client.out&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../images/2018.7/tcpdump.out&quot;&gt;tcpdump.out&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后就可以开始分析了。&lt;/p&gt;

&lt;h2&gt;ClientHello&lt;/h2&gt;

&lt;p&gt;根据tcpdump.out，发现在三次握手后的第一个包是从client发到服务器的，数据长度205字节(不含IP header）。这个就是ClientHello。&lt;/p&gt;

&lt;p&gt;然后看client.out和server.out，发现205字节的头5个字节是独立出来的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;16 03 01 00 c8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这5个字节要分成3部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0x16，这个字节指出了包的类型（Content Type），0x16是handshake。&lt;/li&gt;
&lt;li&gt;0x0301，这2个字节指示SSL/TLS版本（Version），0x0301代表TLSv1.0。&lt;/li&gt;
&lt;li&gt;0x00c8，转10进制后是200，显然是正文长度(205 - 5)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/10.png&quot; alt=&quot;10.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;( &lt;a href=&quot;https://wand.net.nz/trac/libprotoident/wiki/SSL&quot;&gt;图片来源&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;ContentType在/include/openssl/ssl3.h里定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;# define SSL3_RT_CHANGE_CIPHER_SPEC      20&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;# define SSL3_RT_ALERT                   21&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;# define SSL3_RT_HANDSHAKE               22&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;# define SSL3_RT_APPLICATION_DATA        23&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;# define DTLS1_RT_HEARTBEAT              24&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就是正文200个字节，根据tcpdump.out，按顺序解读下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4字节，0100 00c4，未知，可能是子协议类型&lt;/li&gt;
&lt;li&gt;2字节，0303，这个是client_version，0x303表示TLS 1.2&lt;/li&gt;
&lt;li&gt;4字节，9AC0 E522，gmt_unix_time，时间戳&lt;/li&gt;
&lt;li&gt;28字节，65 1348 2735 f2d9 ac8c bc83 1850 a0c3 c3f0 a681 ceff 4876 4d1b 80ba 1e，random_bytes&lt;/li&gt;
&lt;li&gt;1字节，00，session_id，表示长度为0，没有session id&lt;/li&gt;
&lt;li&gt;2字节，00 08，表示接下来有4个cipher suites（每个要占2个字节，2*4=8）&lt;/li&gt;
&lt;li&gt;8字节，1302 1303 1301 00ff，4个cipher_suites，撇除最后一个TLS_EMPTY_RENEGOTIATION_INFO_SCSV，实则只有3个cipher_suites&lt;/li&gt;
&lt;li&gt;1字节，01，未知，可能是分隔符&lt;/li&gt;
&lt;li&gt;1字节，compression_methods，选择什么压缩算法，0x00表示不压缩&lt;/li&gt;
&lt;li&gt;2字节，0093，等于10进制147，表示接下来有147字节的extensions&lt;/li&gt;
&lt;li&gt;147字节，各种extensions，每个extension的长度各不一样。在这里面给出了终端支持的算法列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;200 = 4 + 2 + 4 + 28 + 1 + 2 + 8 + 1 + 1 + 2 + 147。虽然里面有一些字节从抓下来的log看不出来。&lt;/p&gt;

&lt;h2&gt;服务端收到ClientHello后的响应&lt;/h2&gt;

&lt;p&gt;接下来看tcpdump.out，发现服务器收到ClientHello后发了个很长的回包，足足有1451字节（不包含IP header）。看起来很长，实则是几个协议包合并发送了。&lt;/p&gt;

&lt;h3&gt;ServerHello（95字节）&lt;/h3&gt;

&lt;p&gt;头5字节：16 03 03 00 5a&lt;/p&gt;

&lt;p&gt;协议包头部和ClientHello类似，也是5字节。&lt;/p&gt;

&lt;p&gt;0303表示这个分组的版本是TLSv1.2的。&lt;/p&gt;

&lt;p&gt;最后2字节是005a，十进制是90，表示正文是90字节。&lt;/p&gt;

&lt;p&gt;正文结构和ClientHello很像，除了几点要说的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;和ClientHello一样没有session_id&lt;/li&gt;
&lt;li&gt;ClientHello的Version是TLSv1.0，这是为了应付低版本的服务器，实际上在client_version里指出自己能支持TLS 1.2。ServerHello于是把Version填成TLS1.2，以告诉客户端自己支持1.2。&lt;/li&gt;
&lt;li&gt;cipher_suite字段不再是列表，而是指出了一个加密套件：TLS_AES_256_GCM_SHA384，这就完成了加密套件的协商。&lt;/li&gt;
&lt;li&gt;extensions里面有一个extension_type=supported_versions的扩展，用这个扩展告诉客户端自己其实还支持到TLS1.3（draft 28）&lt;/li&gt;
&lt;li&gt;extensions里还有一个extension_type=key_share，指出了秘钥协商算法为ecdh_x25519并且给出了一个key_exchange参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/serverhello.png&quot; alt=&quot;serverhello.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;write encrypted extensions（28字节）&lt;/h3&gt;

&lt;p&gt;头5字节：17 03 03 00 17&lt;/p&gt;

&lt;p&gt;最后2字节是0017，十进制是23，表示正文是23字节。&lt;/p&gt;

&lt;p&gt;看server.out，发现Inner Content Type = Handshake (22)，说明握手还在进行中。&lt;/p&gt;

&lt;p&gt;23个正文字节，实际上是21+2，2是EncryptedExtensions。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/appdata.png&quot; alt=&quot;appdata.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;write certificate（968字节）&lt;/h3&gt;

&lt;p&gt;头5字节：17 03 03 03 c3&lt;/p&gt;

&lt;p&gt;最后2字节是03c3，十进制是963，表示正文是963字节。这么长是因为这个分组包含了服务端的公钥证书！&lt;/p&gt;

&lt;p&gt;看server.out，发现Inner Content Type = Handshake (22)，说明握手还在进行中。&lt;/p&gt;

&lt;p&gt;963个正文字节，实际上是21+942，942字节是Certificate。&lt;/p&gt;

&lt;p&gt;Certificate不能为空，空的话就报错、中止握手了。&lt;/p&gt;

&lt;h3&gt;write server certificate verify（286字节）&lt;/h3&gt;

&lt;p&gt;头5字节：17 03 03 01 19&lt;/p&gt;

&lt;p&gt;最后2字节是0119，十进制是281，表示正文是281字节。&lt;/p&gt;

&lt;p&gt;看server.out，发现Inner Content Type = Handshake (22)，说明握手还在进行中。&lt;/p&gt;

&lt;p&gt;281个正文字节，实际上是21+260，260字节是CertificateVerify。&lt;/p&gt;

&lt;p&gt;CertificateVerify的组成部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Signature Algorithm，4字节，告诉客户端用了什么签名算法（rsa_pss_rsae_sha256）&lt;/li&gt;
&lt;li&gt;Signature，256字节，用该签名算法计算出来的签名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，CertificateVerify这260个字节应该是做了对称加密了的。&lt;/p&gt;

&lt;p&gt;CertificateVerify的作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;证明服务端掌握了公钥证书对应的私钥。&lt;/li&gt;
&lt;li&gt;用于确认握手信息完整性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数字签名是对摘要（digest）的加密，而摘要是对一些原文信息的hash值，原文信息组成部分如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A string that consists of octet 32 (0x20) repeated 64 times（即0x202020202020····,64个20)&lt;/li&gt;
&lt;li&gt;The context string（上下文字符串，RFC规定了是&amp;quot;TLS 1.3, server CertificateVerify&amp;quot;, 在statem_lib.c里也能找到这个字符串。这是用来阻止cross-protocol attacks）&lt;/li&gt;
&lt;li&gt;A single 0 byte which serves as the separator（0x00，分隔符）&lt;/li&gt;
&lt;li&gt;The content to be signed（加密正文，唯一产生随机性的字段，即握手信息的hash，也就是ssl_locl.h里的cert_verify_hash，而cert_verify_hash是用ssl_handshake_hash函数计算出来的）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算代码在statem_lib.c里。&lt;/p&gt;

&lt;p&gt;客户端收到CertificateVerify后，就启动验证程序，验证程序需要以下输入：
- 被签名的内容，就是上面的4个组成部分
- 上一个Certificate协议包里的公钥证书里的公钥
- CertificateVerify里的数字签名字段&lt;/p&gt;

&lt;p&gt;如果验证失败，就终止握手。&lt;/p&gt;

&lt;h3&gt;write finished（74字节）&lt;/h3&gt;

&lt;p&gt;头5字节：17 03 03 00 45&lt;/p&gt;

&lt;p&gt;最后2字节是0045，正文是69字节。&lt;/p&gt;

&lt;p&gt;看server.out，发现Inner Content Type = Handshake (22)，说明握手还在进行中。&lt;/p&gt;

&lt;p&gt;69个正文字节，实际上是21+48，表示握手Finished，48字节存了一个verify_data。&lt;/p&gt;

&lt;p&gt;verify_data也是加密了的。&lt;/p&gt;

&lt;h3&gt;综上&lt;/h3&gt;

&lt;p&gt;服务端收到ClientHello后，总共响应了5个分组，总共占1451字节（不包含IP header）：1451 = 95 + 28 + 968 + 286 + 74。&lt;/p&gt;

&lt;h2&gt;Client收到ServerHello5个分组后的响应&lt;/h2&gt;

&lt;h3&gt;early data（Client Finished 74字节）&lt;/h3&gt;

&lt;p&gt;客户端发了一个和服务端的Finished同等结构的Finished。区别在于verify_data。&lt;/p&gt;

&lt;p&gt;正文一样是69字节。&lt;/p&gt;

&lt;p&gt;这是用来告诉服务端，客户端也完成握手了。&lt;/p&gt;

&lt;h2&gt;Server收到Client Finished后的响应&lt;/h2&gt;

&lt;h3&gt;write session ticket (两次255字节)&lt;/h3&gt;

&lt;p&gt;服务端发了2个&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-tls-tls13-28#section-4.6.1&quot;&gt;NewSessionTicket&lt;/a&gt;协议分组。&lt;/p&gt;

&lt;p&gt;每个协议是5 + 250 = 255字节。&lt;/p&gt;

&lt;p&gt;第一个是在04:06:58.702027时发送，第二个是在04:06:58.703919。&lt;/p&gt;

&lt;p&gt;这2个分组发完，就没有和TLS有关的分组了。抓包到这里结束。&lt;/p&gt;

&lt;p&gt;服务端会看情况发1到多个session ticket，作用如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;允许打开多个并行的HTTP连接（Opening multiple parallel HTTP connections）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行跨网卡接口和地址族的连接竞争（Performing connection racing across interfaces and address families）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;回顾整个流程&lt;/h2&gt;

&lt;h3&gt;流程&lt;/h3&gt;

&lt;p&gt;按照数据流方向：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C-&amp;gt;S:

&lt;ul&gt;
&lt;li&gt;ClientHello&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;S-&amp;gt;C:

&lt;ul&gt;
&lt;li&gt;ServerHello&lt;/li&gt;
&lt;li&gt;write encrypted extensions&lt;/li&gt;
&lt;li&gt;write certificate&lt;/li&gt;
&lt;li&gt;write certificate verify&lt;/li&gt;
&lt;li&gt;write Finished&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;C-&amp;gt;S:

&lt;ul&gt;
&lt;li&gt;client Finished (early data)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;S-&amp;gt;C:

&lt;ul&gt;
&lt;li&gt;write session ticket 1&lt;/li&gt;
&lt;li&gt;write session ticket 2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从中可以看出在1-rtt就完成了握手；从第2-rtt开始，已经可以发early data了。&lt;/p&gt;

&lt;h3&gt;信息一览&lt;/h3&gt;

&lt;p&gt;server.out最后面打印了关于此次连接的TLS信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Shared ciphers，共享的加密套件列表，TLS_AES_256_GCM_SHA384、TLS_CHACHA20_POLY1305_SHA256、TLS_AES_128_GCM_SHA256&lt;/li&gt;
&lt;li&gt;Signature Algorithms，签名算法列表，ECDSA+SHA256、ECDSA+SHA384、ECDSA+SHA512、Ed25519、Ed448、RSA-PSS+SHA256、RSA-PSS+SHA384、RSA-PSS+SHA512、RSA-PSS+SHA256、RSA-PSS+SHA384、RSA-PSS+SHA512、RSA+SHA256、RSA+SHA384、RSA+SHA512&lt;/li&gt;
&lt;li&gt;Shared Signature Algorithms，共享的签名算法列表（同上）&lt;/li&gt;
&lt;li&gt;Supported Elliptic Groups，支持的椭圆曲线组，X25519、P-256、X448、P-521、P-384&lt;/li&gt;
&lt;li&gt;Shared Elliptic groups，共享的椭圆曲线组（同上）&lt;/li&gt;
&lt;li&gt;No server certificate CA names sent&lt;/li&gt;
&lt;li&gt;CIPHER is TLS_AES_256_GCM_SHA384，最终协商出来的加密套件&lt;/li&gt;
&lt;li&gt;Secure Renegotiation IS supported&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 18 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/crypto-4/</link>
        <guid isPermaLink="true">http://localhost:4000/crypto-4/</guid>
      </item>
    
      <item>
        <title>漫谈网络通讯加密（3）HKDF</title>
        <description>&lt;p&gt;本文将简单介绍&lt;a href=&quot;https://tools.ietf.org/html/rfc5869&quot;&gt;rfc5869&lt;/a&gt;提出的HKDF。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;HKDF = HMAC + KDF&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/HMAC&quot;&gt;HMAC&lt;/a&gt;，基于Hash的MAC算法&lt;/h2&gt;

&lt;p&gt;HMAC是指Hash-based的MAC算法，hash函数是可选的，例如存在这些HMAC实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HMAC_MD5&lt;/li&gt;
&lt;li&gt;HMAC_SHA1&lt;/li&gt;
&lt;li&gt;HMAC_SHA256&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然hash函数可选，但HMAC是有严格的定义的：&lt;/p&gt;

&lt;p&gt;\[ HMAC(k, m) = H ( (k \oplus opad) || H( (k \oplus ipad) || m) ) \]&lt;/p&gt;

&lt;p&gt;伪代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hmac&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;opad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x5c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;blocksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Where blocksize is that of the underlying hash function&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;ipad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x36&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;blocksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;blocksize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Where &amp;#39;hash&amp;#39; is the underlying hash function&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;ipad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ipad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;XOR&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;opad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;opad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;XOR&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;opad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ipad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Where || is concatenation&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码逻辑和上面的公式是一致的，一共调用了2次hash函数，2次异或操作，2次concat操作。&lt;/p&gt;

&lt;p&gt;唯一特别的是多了一个if的判断：如果key的长度比要求的blocksize还长，那么需要缩短，方法是用hash函数hash一下这个key，从而变成blocksize长度。&lt;/p&gt;

&lt;p&gt;HMAC的图解如下(from wiki)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/8.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/HKDF&quot;&gt;KDF&lt;/a&gt;， key derivation function, 密钥导出函数&lt;/h2&gt;

&lt;p&gt;KDF是加密系统中十分基本和必要的组件。KDF的任务是，&lt;strong&gt;给定某初始密钥材料(IKM，initial keying material)，以及可选的salt，导出1或多个密码级强度的密钥&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;HKDF&lt;/h2&gt;

&lt;p&gt;HKDF是基于HMAC的KDF，功能上和其他KDF没什么区别。&lt;/p&gt;

&lt;p&gt;HKDF分两个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;extract&lt;/li&gt;
&lt;li&gt;expand&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;extract&lt;/h3&gt;

&lt;p&gt;接口定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HKDF_Extract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IKM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Options:
      Hash     a hash function; HashLen denotes the length of the
               hash function output in octets&lt;/p&gt;

&lt;p&gt;输入：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;salt: 可选的“盐”，如果不提供，则默认为0串&lt;/li&gt;
&lt;li&gt;IKM: 初始密钥材料&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PRK: 定长的伪随机密钥&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用HMAC_Hash(key, message)实现HKDF_Extract：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HMAC_Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IKM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;expand&lt;/h3&gt;

&lt;p&gt;接口定义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HKDF_Expand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OKM&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PRK：HKDF_Extract的输出&lt;/li&gt;
&lt;li&gt;info：可选的上下文信息，默认是空字符串“”，当IKM被用于多种业务时，就可以用info来保证导出不一样的OKM&lt;/li&gt;
&lt;li&gt;L：指定输出的OKM的字节长度，不能超过255*HashLen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OKM: 输出密钥材料&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HKDF_Expand的伪代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HashLen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 向上取整，保证T的长度大于等于L&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;OKM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;octets&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 裁剪成L个字节&lt;/span&gt;

   &lt;span class=&quot;nl&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zero&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HMAC_Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HMAC_Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HMAC_Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x03&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

   &lt;span class=&quot;c1&quot;&gt;// 0x01 0x02 0x03是递增的单字节常量&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;python实现HKDF&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;#!/usr/bin/env python3&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;hashlib&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;hmac&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;math&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;hash_len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hmac_sha256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hmac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashlib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sha256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;digest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hkdf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ikm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;salt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;prk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hmac_sha256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;salt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ikm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;okm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hmac_sha256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;okm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;okm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Tue, 17 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/crypto-3/</link>
        <guid isPermaLink="true">http://localhost:4000/crypto-3/</guid>
      </item>
    
      <item>
        <title>分布式杂谈</title>
        <description>&lt;!--more--&gt;

&lt;h3&gt;分布式中心化/去中心化&lt;/h3&gt;

&lt;p&gt;既然分布式了为什么还有中心化？其中关键是简化了中心节点的任务，中心节点是作为任务派发者、网络管理者存在的，类似领导和员工的关系。&lt;/p&gt;

&lt;p&gt;领导节点可能是所有节点一起选举出来的，而不是固定的。从而避免领导节点故障导致整个网络崩溃。&lt;/p&gt;

&lt;p&gt;例子是raft算法。&lt;/p&gt;

&lt;h3&gt;分布式一致性&lt;/h3&gt;

&lt;p&gt;一致性是指所有节点的数据状态一致。一般是用来做大型数据库的多机备份和海量服务。多机备份使得单个数据库节点坏了，还有别的数据库可用，数据不易丢失；海量服务是指，既然可以保证多个数据库节点是一致的，那么数据库节点越多，能服务于用户的能力越强，因为用户可以任意选择一个节点存取数据。&lt;/p&gt;

&lt;p&gt;分布式一致性算法：paxos、raft。&lt;/p&gt;

&lt;p&gt;因为节点之间的同步存在网络延迟，故一致性要分强弱：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;强一致：强调读操作读到的肯定是最新的值，即写操作同步到整个网络前，读操作是要阻塞的。&lt;/li&gt;
&lt;li&gt;弱一致：单机写入后，不保证其他节点可以立即读到最新的值，也不保证多久之后数据能够达到一致，只是尽可能保证某个时间级别后（秒），能够一致。&lt;/li&gt;
&lt;li&gt;最终一致：弱一致的特例，保证会在一定时间内，能够达到一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;CAP理论&lt;/h3&gt;

&lt;p&gt;Consistency一致性、Availability可用性、Partition tolerance分区容错性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据一致性（C），等同于所有节点访问同一份最新的数据副本；&lt;/li&gt;
&lt;li&gt;对数据更新具备高可用性（A）；&lt;/li&gt;
&lt;li&gt;能容忍网络分区（P）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CAP不能同时做到。&lt;/p&gt;

&lt;p&gt;只可能做到CP或AP或CA。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CA：只有一个数据中心，没有分区，保证节点之间通讯可靠；单机数据库。&lt;/li&gt;
&lt;li&gt;CP：有多个数据中心时，放弃可用性，强调一致性（不常见）&lt;/li&gt;
&lt;li&gt;AP：有多个数据中心时，放弃一致性，强调可用性（常见）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;BASE理论&lt;/h3&gt;

&lt;p&gt;BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。&lt;/p&gt;

&lt;p&gt;源于CAP。&lt;/p&gt;

&lt;p&gt;BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。&lt;/p&gt;

&lt;p&gt;1、基本可用&lt;/p&gt;

&lt;p&gt;基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2、软状态&lt;/p&gt;

&lt;p&gt;软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时&lt;/p&gt;

&lt;p&gt;3、最终一致性&lt;/p&gt;

&lt;p&gt;最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。&lt;/p&gt;

&lt;h3&gt;消息队列&lt;/h3&gt;

&lt;p&gt;我见过的游戏后端是不存在什么消息队列的。这个东西更多是在互联网产品后端才会出现。但我觉得游戏后端也是能用上的，关键在于游戏需求。&lt;/p&gt;

&lt;p&gt;没有消息队列前的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在高并发分布式环境下，大量请求都同步处理的话，请求往往会阻塞。例如大量insert、update操作同时到达mysql，触发各种行锁、表锁，如果请求增加速度大于处理速度，还会不断堆积，触发too many connection错误。&lt;/li&gt;
&lt;li&gt;RPC（远程过程调用），服务和服务之间高度耦合是个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了消息队列后：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大量请求先放进消息队列，&lt;strong&gt;异步处理&lt;/strong&gt;，缓解系统压力。&lt;/li&gt;
&lt;li&gt;MQ提供了松耦合的应用架构。&lt;strong&gt;任何一个应用对MQ的调用不依赖于任何其他应用&lt;/strong&gt;，甚至没有时序要求。但应用依赖MQ保证消息传递的能力。触发和忘记（fire-and-forget)：应用发送消息到MQ后并不关心消息如何或者什么时候被传递，同样的，消息接收者也不关心消息从何而来。这样就允许不同语言相互通信。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;分布式缓存&lt;/h3&gt;

&lt;h4&gt;LFU&lt;/h4&gt;

&lt;p&gt;Least Frequently Used（LFU），如果一个数据在最近一段时间内使用&lt;strong&gt;次数&lt;/strong&gt;很少，那么在将来一段时间内被使用的可能性也很小。&lt;/p&gt;

&lt;h4&gt;LRU&lt;/h4&gt;

&lt;p&gt;Least Recently Used（LRU），如果一个数据在最近一段时间&lt;strong&gt;没有被访问到&lt;/strong&gt;，那么在将来它被访问的可能性也很小。&lt;/p&gt;

&lt;h3&gt;分布式锁&lt;/h3&gt;

&lt;h3&gt;节点互访：RPC&lt;/h3&gt;

&lt;p&gt;功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;远程调用&lt;/li&gt;
&lt;li&gt;服务注册&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;服务监控&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最基础的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;稳定&lt;/li&gt;
&lt;li&gt;高性能&lt;/li&gt;
&lt;li&gt;多语言&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;微服务&lt;/h3&gt;

&lt;h3&gt;对象序列化技术&lt;/h3&gt;

&lt;p&gt;最普通的：JSON&lt;/p&gt;

&lt;p&gt;更高级的：MessagePack、Protocol Buffers、FlatBuffers。&lt;/p&gt;

&lt;h3&gt;消息队列&lt;/h3&gt;

&lt;h3&gt;分布式数据库拆分&lt;/h3&gt;

&lt;p&gt;先垂直拆分：不同服务的数据(库)要相互隔离，不要放一起。&lt;/p&gt;

&lt;p&gt;后水平拆分：隔离后，单机数据库如果遇到瓶颈，就拆成多机（分片）。&lt;/p&gt;

&lt;p&gt;水平拆分会遇到问题：没有一个唯一的入口，来操作数据库。&lt;/p&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端来实现数据路由：客户端自己决定连接哪个数据库节点，存什么数据。缺点是&lt;/li&gt;
&lt;li&gt;中间件：把多机数据库封装成单机的使用方法，客户端操作起来和单机一样，简单很多&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/szlbm/p/5588543.html&quot;&gt;https://www.cnblogs.com/szlbm/p/5588543.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zfrong/article/details/3372106&quot;&gt;https://blog.csdn.net/zfrong/article/details/3372106&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/distributed-1/</link>
        <guid isPermaLink="true">http://localhost:4000/distributed-1/</guid>
      </item>
    
      <item>
        <title>《现代操作系统》17年第四版 阅读笔记</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;系统调用&lt;/h2&gt;

&lt;h3&gt;fork&lt;/h3&gt;

&lt;p&gt;创建一个原有进程的精确副本。&lt;/p&gt;

&lt;p&gt;被复制的东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有的文件描述符&lt;/li&gt;
&lt;li&gt;所有的寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;没被复制的东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;程序正文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在fork后，原有的进程和其副本（父与子）就分开了。&lt;/p&gt;

&lt;p&gt;返回值，用来在进程里区分谁是父谁是子：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在子进程中该值为0&lt;/li&gt;
&lt;li&gt;在父进程中等于子进程的PID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;shell为例：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;while(true) {
    type_prompt();
    read_command(cmd, params);
    if(fork()!=0) {
        // 父
        waitpid(-1, &amp;amp;status, 0);
    } else {
        // 子
        execve(command, params, 0);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;waitpid&lt;/h3&gt;

&lt;p&gt;参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;子进程PID，填-1就是任意一个子进程PID&lt;/li&gt;
&lt;li&gt;status（statloc）子进程的返回状态码&lt;/li&gt;
&lt;li&gt;一般为0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;exec&lt;/h3&gt;

&lt;p&gt;使得整个核心映像（core image）被一个文件所替代。&lt;/p&gt;

&lt;p&gt;参数：将要执行的文件名、一个指向变量数组的指针、一个指向环境数组的指针（通常为0）&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;p&gt;cp file1 file2&lt;/p&gt;

&lt;p&gt;execve(cp, [file1, file2], 0)&lt;/p&gt;

&lt;p&gt;main(argc, argv, envp)&lt;/p&gt;

&lt;p&gt;argc为3，argv[0]为cp，argv[1]为file1，argv[2]为file2；没有envp。&lt;/p&gt;

&lt;h3&gt;exit(status)&lt;/h3&gt;

&lt;p&gt;status是用户指定的，status其实就是waitpid的staloc，子进程设定的status最终可以告诉父进程。&lt;/p&gt;

&lt;h3&gt;link&lt;/h3&gt;

&lt;p&gt;在unix中，每个文件都有唯一的编号（i-node）。&lt;/p&gt;

&lt;p&gt;每个目录有一个i-node到文件名的表。&lt;/p&gt;

&lt;p&gt;link时，是在指向目录里面创建一个新条目，i-node为原文件的i-node，文件名都link参数里指定的文件名。&lt;/p&gt;

&lt;p&gt;目录和i-node是双向指向的，i-node也存有一个表，记录了指向该i-node的目录项。&lt;/p&gt;

&lt;h1&gt;进程和线程&lt;/h1&gt;

&lt;h2&gt;进程模型&lt;/h2&gt;

&lt;h3&gt;CPU利用率&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;t1, 一个进程等待I/O操作的时间&lt;/li&gt;
&lt;li&gt;t, 一个进程停留在内存中时间&lt;/li&gt;
&lt;li&gt;p, 一个进程等待I/O操作的时间与其停留在内存中时间的比。&lt;/li&gt;
&lt;li&gt;n为同时存在的进程数量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用率 = \( 1 - p^{n}\)&lt;/p&gt;

&lt;p&gt;这是简单模型，只适用于进程之间互相独立。例如对于单CPU，即使进程就绪，但已有一个进程正在被CPU处理，那么还是会等待。&lt;/p&gt;

&lt;h3&gt;用户空间线程&lt;/h3&gt;

&lt;p&gt;优缺点：&lt;/p&gt;

&lt;h3&gt;内核空间线程&lt;/h3&gt;

&lt;h3&gt;调度程序激活机制 和 上行调用（upcall)&lt;/h3&gt;

&lt;h3&gt;IPC：信号量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;创建信号量：sem_t *sem_open(const char *name, int oflag, 权限, 初始值)。返回值：返回一个信号量对象，若失败，则返回SEM_FAILED，并设置errno。&lt;a href=&quot;https://linux.die.net/man/3/sem_open&quot;&gt;man page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;P(down)操作，即int sem_wait(sem_t *sem)，检查信号量的值是不是大于0，若大于0，则减1并返回；若等于0，则进程睡眠，sem_wait阻塞不返回；非阻塞版本是sem_trywait，用返回值EAGAIN代替阻塞；限时的down操作是sem_timedwait，使得阻塞不是永久的。返回值：0代表成功，-1代表失败，并设置errno。&lt;/li&gt;
&lt;li&gt;V(up)操作，即int sem_post(sem_t *sem),对信号量加1，若是从0变1，那么那些阻塞在这个信号量的进程或线程会被唤醒。返回值同P。V操作是怎么都不会阻塞的。&lt;/li&gt;
&lt;li&gt;本进程关闭信号量：int sem_close(sem_t *sem)。没什么特别的。&lt;/li&gt;
&lt;li&gt;真·销毁信号量：sem_unlink，前提是open了信号量的进程已经调用了close或者已经结束了进程（调用了exit或者main函数返回），如果还没close就调用，那么没效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tomasbruckner/minimalSemaphoreDemo/blob/master/semaphore_synchronization/semaphore_synchronization.c&quot;&gt;github代码实例&lt;/a&gt;，双信号量实现父进程和子进程的同步。&lt;/p&gt;

&lt;p&gt;信号量2个能力：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现互斥量&lt;/li&gt;
&lt;li&gt;实现计数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;IPC：futex 快速用户空间互斥&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;linux特有&lt;/li&gt;
&lt;li&gt;实现了基本的锁（很像互斥锁），但避免了陷入内核&lt;/li&gt;
&lt;li&gt;内核服务：提供一个等待队列，它允许多个进程在一个锁上等待。把进程放到等待队列代价很大（系统调用）。&lt;/li&gt;
&lt;li&gt;避免锁争用：没有争用时，futex完全在用户空间工作；加锁时，如果锁没有被锁，那么直接加锁成功，不需要陷入内核；如果已经被锁了，执行系统调用把线程放到等待队列（不自旋）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;IPC：管程 montior&lt;/h3&gt;

&lt;p&gt;原因：为了更易于编写正确的程序。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;管程是编程语言的组成部分，能不能用管程得看是什么语言，例如java&lt;/li&gt;
&lt;li&gt;任一时刻管程中只能有一个活跃进程&lt;/li&gt;
&lt;li&gt;进程可在任何需要的时候调用管程中的过程（procdeure)&lt;/li&gt;
&lt;li&gt;进入管程是的互斥由编译器负责，出错的可能性要小得多&lt;/li&gt;
&lt;li&gt;写管程的人无需关心编译器是如何实现互斥的，只需知道将所有临界区转换成管程即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;IPC：消息传递&lt;/h3&gt;

&lt;p&gt;其实就是用socket来实现IPC。&lt;/p&gt;

&lt;h3&gt;IPC：屏障 barrier&lt;/h3&gt;

&lt;p&gt;概念上像是gpu渲染一帧，n个gpu核都在计算它负责的像素点，有的快有的慢，但必须全部核的任务都处理完毕，才能进入下一个阶段。&lt;/p&gt;

&lt;h3&gt;IPC：无锁化，RCU（读取-复制-更新）&lt;/h3&gt;

&lt;h2&gt;调度&lt;/h2&gt;

&lt;h3&gt;何时进行调度&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;创建一个新进程后，需要决定是运行父进程还是运行子进程。可以任意决定。&lt;/li&gt;
&lt;li&gt;一个进程退出时必须做出调度决策。必须从就绪进程集合选择另外某个进程。&lt;/li&gt;
&lt;li&gt;当一个进程阻塞在I/O和信号量上或由于其他原因阻塞是，必须选择其他进程运行。&lt;strong&gt;阻塞原因会成为选择的因素，然而调度程序并不拥有做出这种相关考虑的必要信息&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在一个I/O中断发生时，必须做出调度决策。可能等待I/O的进程变成就绪了，有三种可能，让新就绪进程运行；继续当前进程的运行；让别的进程运行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据如何处理时钟中断，可以把调度算法分2类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非抢占式：进程自己释放CPU时/阻塞时，才会切换到别的进程。即时钟中断不会进行调度。&lt;/li&gt;
&lt;li&gt;抢占式：让进程运行某个固定时段的最大值，然后挂起它，调度别的进程继续运行。前提是有时钟，不然就得用非抢占式的调度算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据环境选择算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;批处理。适合用非抢占式调度。一个进程需要运行长时间。也就减少了进程切换，优化了性能。&lt;/li&gt;
&lt;li&gt;交互式。适合抢占式。&lt;/li&gt;
&lt;li&gt;服务器。适合抢占式。&lt;/li&gt;
&lt;li&gt;实时系统。一般是非抢占式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;调度算法目标&lt;/h3&gt;

&lt;p&gt;适用所有环境的目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;公平&lt;/li&gt;
&lt;li&gt;策略强制执行。即调度进程有一些优先级策略&lt;/li&gt;
&lt;li&gt;平衡。保证系统的所有部分都忙碌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;批处理系统的测量指标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;吞吐量：每小时完成的作业数量&lt;/li&gt;
&lt;li&gt;周转时间：一个作业从提交到完成的统计平均时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;能够使吞吐量最大化的调度算法不一定就有最小的周转时间。例如，系统优先处理大量小作业导致长作业无法被处理，这样有做大的吞吐量但平均周转时间无限长。&lt;/p&gt;

&lt;p&gt;交互式系统：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最小响应时间。能够让所有的交互式请求首先运行的则是好服务。&lt;/li&gt;
&lt;li&gt;均衡性。满足用户的期望（这个概念比较模糊）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;交互式系统的调度&lt;/h3&gt;

&lt;h4&gt;轮转调度(round robin)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;每个进程被分配一个时间片（quantum)。注意，进程可在时间片花完前提前结束运行，例如阻塞了。&lt;/li&gt;
&lt;li&gt;时间片过小，容易发生抢占，过多的切换进程，降低CPU效率；&lt;/li&gt;
&lt;li&gt;时间片太长，则引起对短的交互请求的响应时间变长。&lt;/li&gt;
&lt;li&gt;一般为20~50ms&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;优先级调度&lt;/h4&gt;

&lt;p&gt;每个进程加一个优先级属性，优先级大的先执行完，再执行次优先的。&lt;/p&gt;

&lt;p&gt;问题：只按优先级来执行进程的话，低优先级进程可能永远都不会被执行。&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;被执行的进程的优先级每个时钟滴答减1，直到低于次优先级进程时切换。&lt;/li&gt;
&lt;li&gt;最大时间片法，用完时间片就轮到次优先的进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优先级的赋予：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;静态：人工分配，例如商业计算中心，高优先级的任务价格高&lt;/li&gt;
&lt;li&gt;动态：根据 1/f公式分配优先级。例如在50ms的时间片中只使用2ms就挂起的进程，优先级为1/(2/50) = 25。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变种：按优先级分类，然后用轮转调度，高优先级的进程组里的进程集合轮转调度，优先执行，都执行完时切换到次优先级组。&lt;/p&gt;

&lt;h4&gt;多级队列&lt;/h4&gt;

&lt;p&gt;基于上面的优先级分类，设计了多级队列调度。&lt;/p&gt;

&lt;p&gt;原理是：属于最高优先级类的进程运行一个时间片，属于次高优先级类的进程运行2个时间片，再次一级运行4个时间片；当进程用完分配的时间片后，它被移送到下一类。&lt;/p&gt;

&lt;p&gt;例子：假设一个进程要完成计算任务总共需要100个时间片。一开始被分配1个时间片，然后就被换出，下次到它时获得2个时间片，又被换出。总共经历了1、2、4、8、16、32、64个优先级类。在64优先级类的第37个时间片就完成了工作。总共用了7次进程上下文切换。要比轮转算法轮转100次要高效。&lt;/p&gt;

&lt;h4&gt;最短进程优先&lt;/h4&gt;

&lt;p&gt;最短路程含义是进入运行到挂起的时间间隔最短，这种进程优先处理，对实时系统挺友好。例如交互式进程，每条用户命令相当于一次短作业。&lt;/p&gt;

&lt;p&gt;但如何知道这个作业将执行多久呢？方法是用过去的数据来做预测，\( T = aT_{0} + (1 - a)T_{1} \)。&lt;/p&gt;

&lt;h4&gt;保证调度&lt;/h4&gt;

&lt;p&gt;也是绝对公平的调度。有两种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多用户同时登录工作。每个用户可获得CPU的1/n的处理能力。&lt;/li&gt;
&lt;li&gt;n个进程在运行的单用户系统。每个进程获得CPU的1/n的处理能力。不过这种情况需要记录每个进程从创建以来已累积获得的CPU时间。因为没有时间片的概念，所以进程实际获得的运行时间和理应获得的时间可能会不一致，此时可以算一个比值（优先级），使得较亏的进程可以先运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;彩票调度&lt;/h4&gt;

&lt;p&gt;即给每个进程发一些彩票。调度时，随机抽一张彩票，哪个进程持有这张彩票就被执行。&lt;/p&gt;

&lt;p&gt;可以给某个进程赋予比别人多的彩票数量，来提高优先级(中奖几率)。&lt;/p&gt;

&lt;h4&gt;公平分享调度&lt;/h4&gt;

&lt;p&gt;这个是对于多用户环境而言的。每个用户的所有进程占x%的时间。有点像上面的保证调度。&lt;/p&gt;

&lt;h3&gt;调度策略参数化&lt;/h3&gt;

&lt;p&gt;例如一个数据库父进程下面有多个子进程，父进程才知道怎么调度子进程才是最优。那么就可以设计一种参数化调度机制，让父进程向内核设置参数，如子进程优先级，更好地做调度。&lt;/p&gt;

&lt;h3&gt;线程调度&lt;/h3&gt;

&lt;p&gt;要分用户级线程和内核级线程两种情况。&lt;/p&gt;

&lt;h3&gt;经典IPC问题&lt;/h3&gt;

&lt;h3&gt;页面置换算法&lt;/h3&gt;

&lt;h4&gt;最优页面置换算法&lt;/h4&gt;

&lt;p&gt;基于2点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当缺页中断(page fault)发生时，有些页面在内存中，其中有一个页面（包含紧接着的下一条指令的那个页面）将很快被访问，其他页面则可能要10、100、1000条指令后才会访问，这个指令数就是标记&lt;/li&gt;
&lt;li&gt;最优页面置换，就是置换掉标记最大的页面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而无法实现，因为操作系统无法知道各个页面下一次将在什么时候被访问。&lt;/p&gt;

&lt;p&gt;不过可以作为性能对比工具，例如弄个仿真程序，先跟踪一遍所有页面的访问情况，然后第二次运行则可以用第一次的数据来跑出最优页面置换算法。之后再用其他算法也跑一下，从而做对比。不过此方案问题在于是针对某个特定程序而言的。&lt;/p&gt;

&lt;h4&gt;最近未使用页面置换算法（NRU，not recently used）&lt;/h4&gt;

&lt;p&gt;首先每个页面设置2个状态位:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;R位，被访问时设置&lt;/li&gt;
&lt;li&gt;W位，被写入时设置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法：&lt;/p&gt;

&lt;p&gt;当启动一个进程时，它的所有页面的两个位都由操作系统设置成0，R位被定期地清零（比如每次时钟中断时）以区别最近没有被访问的页面和被访问的页面。&lt;/p&gt;

&lt;p&gt;当发生缺页中断时，操作系统检查所有的页面并根据它们当前的R位和M位的值，把它们分为4类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;没有被访问，没有被修改&lt;/li&gt;
&lt;li&gt;没有被访问，被修改&lt;/li&gt;
&lt;li&gt;被访问，没有被修改&lt;/li&gt;
&lt;li&gt;被访问，被修改&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本算法随机地从类编号最小的非空类中挑选一个页面淘汰。&lt;/p&gt;

&lt;h4&gt;先进先出置换算法 FIFO&lt;/h4&gt;

&lt;p&gt;页面按照访问时间顺序组成链表，每次发生缺页中断时直接从表头的页面干掉，并把新页面放到表尾。&lt;/p&gt;

&lt;p&gt;问题在于常用页面也可能会被淘汰，&lt;/p&gt;

&lt;h4&gt;第二次机会页面置换算法&lt;/h4&gt;

&lt;p&gt;这个是 FIFO的改进：要淘汰时，检查最老页面的R位，如果是0，那么可以置换掉；如果是1，那么就是最近访问过的，把R位设0，并移动到链表末端。&lt;/p&gt;

&lt;p&gt;如果所有页面都被访问过了，那么退化为普通的FIFO。&lt;/p&gt;

&lt;h4&gt;时钟页面置换算法&lt;/h4&gt;

&lt;p&gt;上面的算法的问题在于要经常在链表移动页面。改进方法：改成环形链表，一个指针指向最老的页面。&lt;/p&gt;

&lt;p&gt;当发生缺页中断时：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查指针指向的页面，若R位为0，则淘汰该页面，把新页面放入这个位置，指针移动到下一个位置；&lt;/li&gt;
&lt;li&gt;若R为1，则清除R位，指针还是++，重复这个过程直到找到一个R为0的页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;最近最少使用算法（LRU）&lt;/h4&gt;

&lt;p&gt;在缺页中断发生时，置换未使用时间最长的页面。&lt;/p&gt;

&lt;p&gt;假设还是用链表，要达到LRU，需要每次访问内存都更新链表：在链表中找到这个页面，删除它，然后把它移动到表头。&lt;/p&gt;

&lt;p&gt;不用链表，有别的方案：&lt;/p&gt;

&lt;p&gt;每个页表存一个属性：指令计数器，每条指令执行完后加1；当发生缺页中断时，检查所有页表项的计数器值，找到值最小的页面，就是最近最少使用的页面了。这是基于硬件的方案。&lt;/p&gt;

&lt;h4&gt;软件实现的LRU&lt;/h4&gt;

&lt;p&gt;NFU（Not Frequently Used，最不常用）算法：&lt;/p&gt;

&lt;p&gt;内存里做一个表，把每个页面和一个软件计数器相关联，初值为0，每次时钟中断时，操作系统扫描内存中&lt;strong&gt;所有的页面&lt;/strong&gt;，把每个页面的R位的值加到计数器上，这个计数器大体跟踪了各个页面被访问的频繁程度。发生缺页中断时，淘汰计数器值最小的页面。&lt;/p&gt;

&lt;p&gt;改进的NFU——Aging老化算法：&lt;/p&gt;

&lt;p&gt;因为NFU对旧状态记忆得太深，不能应对快速变化的程序状态，有可能根据计数器淘汰了最经常访问的页面。可以修改一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在R位被加进计数器前，计数器右移一位（除2）；&lt;/li&gt;
&lt;li&gt;将R位加到计数器最左端的位而不是最右端的位；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发生缺页中断还是淘汰计数器值最小的页面。老化算法的问题在于计数器只有有限位，限制了它对过往状态的记忆能力。&lt;/p&gt;

&lt;h4&gt;基本工作集页面置换算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;工作集：一个进程当前正在使用的页面的集合称为它的工作集。&lt;/li&gt;
&lt;li&gt;颠簸：如果内存太小不足以容纳整个工作集，那么每执行几条指令就会发生一次缺页中断&lt;/li&gt;
&lt;li&gt;预先调页：在进程运行前预先装入其工作集页面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;工作集的严格定义：在任一时刻t，都存在一个集合，它包含所有最近k次内存访问所访问过的页面，称为w(k,t)&lt;/p&gt;

&lt;p&gt;w是k的单调非递减函数，且会收敛到一个稳定的范围。预先调页原理就是基于以下推测：程序上次结束时w有一个稳定范围，可预先装下这个范围的工作集。&lt;/p&gt;

&lt;p&gt;实现条件：操作系统必须跟踪哪些页面在工作集中。&lt;/p&gt;

&lt;p&gt;基于工作集的页面置换算法：当发生缺页中断时，淘汰一个不在工作集的页面。精确地统计工作集，就是确定一个k值。&lt;/p&gt;

&lt;p&gt;问题：工作集的计算不容易。2种方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按使用频率计。成本比较高。k还是按次数的k。&lt;/li&gt;
&lt;li&gt;按执行时间计。k变成秒数r，工作集变成在过去的r秒实际运行时间(使用了CPU的时间)中进程所访问页面的集合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺页中断时，需要扫描整个页表，找出适合的页面来淘汰。&lt;/p&gt;

&lt;h4&gt;工作集时钟页面置换算法&lt;/h4&gt;

&lt;p&gt;上面的算法问题在于需要扫描整个页表来淘汰页面。&lt;/p&gt;

&lt;p&gt;改进（类似前面的时钟页面置换算法）:&lt;/p&gt;

&lt;p&gt;建立一个以页框为元素的循环表。每次缺页中断时，首先检查指针指向的页面，如果R为1，则把R改为0，并把指针++，重复这个逻辑；R为0时，如果指针当前页面的生存时间大于r，并且页面是干净的（M=0），它就不在工作集中且磁盘上有一个有效的副本，置换替换掉此页框即可，如果M为1，为了避免写磁盘操作引起进程切换，指针继续++，检查下一个页。&lt;/p&gt;

&lt;h4&gt;总结&lt;/h4&gt;

&lt;p&gt;最好的算法是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;老化算法（LRU）&lt;/li&gt;
&lt;li&gt;工作集时钟算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;分页系统的设计问题&lt;/h3&gt;

&lt;h4&gt;进程之间的内存竞争&lt;/h4&gt;

&lt;p&gt;考虑多个进程的页面置换算法称为全局算法，反之就是局部算法。&lt;/p&gt;

&lt;p&gt;全局算法一般是基于&lt;strong&gt;PFF&lt;/strong&gt;，page fault frequency，缺页中断率，它指出了&lt;strong&gt;何时增加或减少分配给一个进程的页面&lt;/strong&gt;，但却完全没有说明在发生缺页中断时应该替换掉哪一个页面。仅控制分配集的大小。&lt;/p&gt;

&lt;p&gt;PFF的测量：PFFF = (当前1秒的PFF + 旧PFF）/ 2&lt;/p&gt;

&lt;h4&gt;负载控制&lt;/h4&gt;

&lt;p&gt;问题：即使是使用最优页面置换算法，也可能会发生颠簸，如内存不足的时候。&lt;/p&gt;

&lt;p&gt;解决方案：将一部分进程交换到磁盘，释放他们所占有的所有页面。&lt;/p&gt;

&lt;h4&gt;页面大小&lt;/h4&gt;

&lt;p&gt;有公式可以算页面大小，对于平均进程大小为1MB，每个页表项为8B的系统，最优页面是4KB。一般范围是到64KB。&lt;/p&gt;

&lt;h4&gt;分离指令空间和数据空间&lt;/h4&gt;

&lt;p&gt;地址空间太小时，拆成2个空间就会改善情况。不过现在64位系统的地址空间很大，拆2个空间是因为别的原因了。&lt;/p&gt;

&lt;h4&gt;共享页面&amp;amp;共享库&amp;amp;内存映射文件&lt;/h4&gt;

&lt;p&gt;原因：避免在内存中有一个页面的两个副本。&lt;/p&gt;

&lt;p&gt;策略：共享I空间。&lt;/p&gt;

&lt;p&gt;还有问题：释放页面要考虑有没别的进程在使用这个页面。所以共享页面要有特殊的数据结构来记录。&lt;/p&gt;

&lt;p&gt;其他问题：fork调用，理应拷贝数据段，但就会产生大量副本。解决方法是写时复制COW。&lt;/p&gt;

&lt;p&gt;共享库就是DLL了，不过有个问题是地址。共享库要用相对地址，办法是编译时设置参数。&lt;/p&gt;

&lt;p&gt;内存映射文件，应该就是共享内存了。&lt;/p&gt;

&lt;h4&gt;清除策略&lt;/h4&gt;

&lt;p&gt;弄个分页守护进程（paging daemon），定时被唤醒检查内存、看是不是要置换掉页面，如果已修改，那么要写硬盘，如果未修改且硬盘有副本，则直接清除。&lt;/p&gt;

&lt;h3&gt;有关实现&lt;/h3&gt;

&lt;h4&gt;缺页中断处理流程&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;硬件陷入内核，在堆栈中保存程序计数器。大多数机器将当前指令的各种状态信息保存在特殊的CPU寄存器中。&lt;/li&gt;
&lt;li&gt;启动一个汇编代码例程保存通用寄存器和其他易失的信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。&lt;/li&gt;
&lt;li&gt;当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么。&lt;/li&gt;
&lt;li&gt;一旦知道了发生缺页中断的虚拟地址，操作系统检査这个地址是否有效，并检査存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程(&lt;strong&gt;segment fault！&lt;/strong&gt;)。如果地址有效且没有保护错误发生，系统则检査是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。&lt;/li&gt;
&lt;li&gt;如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，&lt;strong&gt;让其他进程运行直至磁盘传输结束&lt;/strong&gt;。无论如何，该页框被&lt;strong&gt;标记为忙&lt;/strong&gt;，以免因为其他原因而&lt;strong&gt;被其他进程占用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;—旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统査找所需页面在磁盘上的地址，通过磁盘播作将其装入，该页面正在被装入时，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行„&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;磁盘中断&lt;/strong&gt;发生时，表明该页已经被装人，页表已经更新并可以反映它的位置，页框也被标记为正常状态。&lt;/li&gt;
&lt;li&gt;恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。&lt;/li&gt;
&lt;li&gt;调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。&lt;/li&gt;
&lt;li&gt;该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;指令备份&lt;/h4&gt;

&lt;p&gt;即怎么记忆发生中断的指令位置，以及怎么恢复。方法是在执行一条指令前用一个寄存器备份这条指令。&lt;/p&gt;

&lt;h4&gt;锁页面&lt;/h4&gt;

&lt;p&gt;例如缺页中断时把别的进程的缓冲区的页面置换掉了，别的进程如果用DMA传输数据中，就会覆盖掉了刚被装入的页面，全乱了。解决方法是对页面加锁。&lt;/p&gt;

&lt;h4&gt;后备存储&lt;/h4&gt;

&lt;p&gt;即置换页面，把页面放到硬盘哪里的问题。&lt;/p&gt;

&lt;p&gt;方法：设立一个交换分区，专门来做这个事情。具体而言要3个区：正文、堆栈、数据。&lt;/p&gt;

&lt;h4&gt;分段&lt;/h4&gt;

&lt;p&gt;现在x86-64都去掉分段机制了，目测没有学习的必要。&lt;/p&gt;

&lt;h2&gt;文件系统&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;主引导记录：磁盘的0号扇区（Master Bot Record, MBR)，用来引导计算机&lt;/li&gt;
&lt;li&gt;分区表：在MBR的末尾，给出了每个分区的起始和结束地址&lt;/li&gt;
&lt;li&gt;活动分区：分区表的某一个分区被定为活动分区&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;启动流程：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;计算机被引导&lt;/li&gt;
&lt;li&gt;BIOS读入并执行MBR&lt;/li&gt;
&lt;li&gt;MBR确定活动分区&lt;/li&gt;
&lt;li&gt;MBR读入活动分区的第一个块（引导块）&lt;/li&gt;
&lt;li&gt;引导块中的程序将装在该分区中的操作系统&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note：为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统&lt;/p&gt;

&lt;h4&gt;文件的实现&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;连续分配。读取速度快，但容易产生碎片。存储时就需要知道文件大小。&lt;/li&gt;
&lt;li&gt;链表分配。随机读取速度慢。指针占用一些字节，导致一些效率问题。&lt;/li&gt;
&lt;li&gt;文件分配表FAT。在内存中弄一张表，用来获取磁盘块链表信息，从而避免了在磁盘块头存节点信息。随机读取速度变快。问题是如果块大小才1KB，但是磁盘空间1T，内存分配表就需要10亿个项，假设每项3个字节，就需要3GB内存。&lt;/li&gt;
&lt;li&gt;i节点。是对FAT的改进，把链表信息存到磁盘上形成一个i节点文件，打开某个文件时把i节点文件信息载入到内存。i节点的唯一问题是定长大小的话，怎么动态扩容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;目录的实现&lt;/h4&gt;

&lt;p&gt;目录系统主要功能：把文件名映射成定位文件数据所需的信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;目录：一堆目录项，kv对&lt;/li&gt;
&lt;li&gt;目录项：k是文件名，v可以随意，一般是i节点号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;问题：文件名不定长。定长的话容易浪费空间。&lt;/p&gt;

&lt;p&gt;解决方案:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;让目录项大小不一致。问题一是如果移走一个文件会导致出现大小不定的空隙，二是目录项可能会跨页面，在读取文件名时可能会发生缺页中断。&lt;/li&gt;
&lt;li&gt;目录项大小一致，但把文件名移出目录项，放到目录最后的堆里。但就要对堆进行管理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;共享文件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;硬链接：创建直接与目标文件关联的i节点。删除文件操作会变得复杂。&lt;/li&gt;
&lt;li&gt;符号链接：创建一个符号文件（类型link），文件中只包含&lt;strong&gt;所链接的文件的路径&lt;/strong&gt;。删除文件没什么大问题。额外开销时是要通过路径找到目标文件的i节点，以及符号文件本身还是要有一个i节点和一个磁盘块放路径，毕竟还是个文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;文件系统&lt;/h1&gt;

&lt;h3&gt;mmap&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hj605635529/article/details/73163513&quot;&gt;https://blog.csdn.net/hj605635529/article/details/73163513&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luckywang1103/article/details/50619251&quot;&gt;https://blog.csdn.net/luckywang1103/article/details/50619251&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/os-1/</link>
        <guid isPermaLink="true">http://localhost:4000/os-1/</guid>
      </item>
    
      <item>
        <title>漫谈网络通讯加密（2）握手流程设计</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;加密通讯的基础&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonce&lt;/a&gt;（不重数）&lt;/h2&gt;

&lt;p&gt;在进入正文前，先介绍一个关键的东西：nonce，以及几个粗糙的例子，以说明nonce的作用。&lt;/p&gt;

&lt;p&gt;nonce本质就是一段随机码，因为不一定是数字，可能是字符，所以不能叫随机数。因此取了个名字叫nonce。&lt;/p&gt;

&lt;p&gt;nonce的存在是为了对付&lt;strong&gt;彩虹表(raintable)&lt;/strong&gt;、&lt;strong&gt;重放攻击(replay attack)&lt;/strong&gt;，或者说为了制造&lt;strong&gt;请求唯一性(request unique)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;nonce有server nonce、client nonce之分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要client nonce的原因：阻止邪恶的客户端做重放攻击。&lt;/li&gt;
&lt;li&gt;需要server nonce的原因：阻止中间人攻击。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;nonce的生成策略有讲究：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以是时间相关变量&lt;/li&gt;
&lt;li&gt;可以是一个通过强随机算法生成的足够长的bits&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;例子：登录与登录密码&lt;/h3&gt;

&lt;h4&gt;方案1&lt;/h4&gt;

&lt;p&gt;直接经过无加密的tcp或者http，发password到服务器进行登录。&lt;/p&gt;

&lt;p&gt;问题：登录包一被截取，密码就泄露了，攻击者想怎么搞就怎么搞了。即使不去截取分析密码，也可以直接把登录包保存下来，之后就可以进行重放攻击。&lt;/p&gt;

&lt;p&gt;小结：&lt;strong&gt;密码容易泄露；会被重放攻击&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;方案2&lt;/h4&gt;

&lt;p&gt;对password做一个经典的hash：&lt;/p&gt;

&lt;p&gt;secret = Hash(password);&lt;/p&gt;

&lt;p&gt;客户端只发secret给服务器，服务器执行（这里假设存了密码原文）：&lt;/p&gt;

&lt;p&gt;secrect_server = Hash(password_server)；&lt;/p&gt;

&lt;p&gt;得到secret_server即可做校验。&lt;/p&gt;

&lt;p&gt;问题：攻击者还是截包，就获得了secret，因为每次登录都是发一样的secret，所使攻击者首先可以做&lt;strong&gt;重放攻击&lt;/strong&gt;，直接copy用户的登录包，发给服务器，就可以登录了；其次，因为Hash函数无非md5、SHA256这些，完全可以用raintable暴力查表，获得password。&lt;/p&gt;

&lt;p&gt;小结：&lt;strong&gt;密码不太容易泄露，但可能会被攻击者用raintable破解密码；仍然会被重放攻击&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;方案3&lt;/h4&gt;

&lt;p&gt;改进：客户端每次登录前，服务器会生成一个nonce并发给客户端，客户端计算：&lt;/p&gt;

&lt;p&gt;secret = Hash(nonce_server, password);&lt;/p&gt;

&lt;p&gt;客户端只发secret给服务器，服务器执行：&lt;/p&gt;

&lt;p&gt;secrect_server = Hash(nonce_server, password_server)；&lt;/p&gt;

&lt;p&gt;然后比较secret和secret_server是否一致即可。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端每次登录发出去的包都不一样，阻止了重放攻击。&lt;/li&gt;
&lt;li&gt;每次登录hash出来的secret都不一样，用户密码比较安全了，要破解密码，得根据secret、nonce_server、Hash，逆向出password，可行，但耗时。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;问题：服务端发送的nonce可以被中间人篡改成固定的nonce，从而导致nonce特性还是被消去了，攻击者就还是可以弄raintable，暴力破解密码。
拿到密码后，就可以骗过服务器了，实现中间人攻击。&lt;/p&gt;

&lt;p&gt;小结：&lt;strong&gt;阻止了重放攻击；密码还是有可能被raintable破解；不能阻止中间人攻击&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;基于方案3的方案4&lt;/h4&gt;

&lt;p&gt;既然方案3中，客户端接收了攻击者篡改出来的固定nonce，并发送了符合攻击者raintable预期的secret，导致密码容易被破解，那么客户端是否可以做一些保护措施，使得发到网络中的secret是随机的呢？&lt;/p&gt;

&lt;p&gt;方法是有的，就是客户端也生成nonce， 称之为nonce_client，secret的计算变成：&lt;/p&gt;

&lt;p&gt;secret = nonce_client || Hash(nonce_client, nonce_server, password)&lt;/p&gt;

&lt;p&gt;（Note：||表示concat操作）&lt;/p&gt;

&lt;p&gt;服务器收到secret后拆出nonce_client和hash值，本地也执行一遍这条公式，就能做登录校验。&lt;/p&gt;

&lt;p&gt;这样处理后，攻击者即使篡改了nonce_server，攻击者收到的客户端secret依然是随机的。并不能直接查raintable获得password，而必须根据客户端的nonce_client，即时算出一份新的raintable表（计算量巨大），才能破解密码。&lt;/p&gt;

&lt;p&gt;问题：&lt;/p&gt;

&lt;p&gt;在登录过程中，本质上还是发送了password，就依然有被猜出密码的可能。&lt;/p&gt;

&lt;p&gt;首先是因，中间人攻击问题依然存在，中间人继续用固定的nonce_server骗用户发送登录包，消去了一个nonce；如果用户用了位数较少、常见字符组合的密码，即时地暴力破解的难度并不大。&lt;/p&gt;

&lt;p&gt;如果这个密码还是用户的常用密码，那后果还是很可怕的，例如拿去别的网站撞库。&lt;/p&gt;

&lt;p&gt;进一步的思路：既然发送加密的密码不妥，那就是用DH密钥交换了，就不会有密钥在网络中传输的问题。当然对于用户输入密码登录的场景，DH应该是用不了了。&lt;/p&gt;

&lt;p&gt;小结：&lt;strong&gt;阻止了重放攻击；用raintable破解密码的难度很大，密码较为安全；一定程度削弱了中间人攻击&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;nonce在TLS规范中被称为ClientHello.random和ServerHello.random。&lt;/p&gt;

&lt;p&gt;双nonce能阻止重复攻击(replay attack)、削弱中间人攻击(mitm, man in the middle)。&lt;/p&gt;

&lt;p&gt;双nonce也可能导致用户密码泄露。&lt;/p&gt;

&lt;h1&gt;简单版本的加密通讯&lt;/h1&gt;

&lt;p&gt;首先以一个较为简单的例子来说明：某客户端想和某服务器建立tcp加密通讯。&lt;/p&gt;

&lt;p&gt;首先需要一个工具：公钥私钥对（非对称加密技术）。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务器在本地或数据库中存放了用于和任意客户端建立通讯的公钥私钥对。&lt;/li&gt;
&lt;li&gt;客户端想和服务器通讯时，服务器发送公钥给客户端。客户端确信用这个公钥加密的数据只有这个服务器能解密。（暂时不考虑中间人攻击问题）&lt;/li&gt;
&lt;li&gt;客户端计算一个key（其实是master key，下文会介绍），这个key可能真的是本地算出来的，也可能用DH算法和服务器交换出来的。如果是本地算出来的，那就必须用刚刚的非对称加密通讯信道，发给服务器。总之，key是客户端服务器都得持有。&lt;/li&gt;
&lt;li&gt;客户端服务器各自生成nonce，互发给对方。此时双方都持有key、cnonce、snonce。&lt;/li&gt;
&lt;li&gt;客户端服务器各自本地计算Hash(key，cnonce，snonce)获得真正用于通讯的对称密钥encrypt key。&lt;/li&gt;
&lt;li&gt;另外的，客户端服务器还可以计算Hash2(key，cnonce，snonce)，获得用于别的用途的key，例如integrity protection key，验证消息用的key。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这6步搞懂后，再看以下4点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;仔细看，第三步传递key之后的步骤其实不是必须的，因为key是用安全的非对称加密信道协商了，没有泄露key的问题。&lt;/li&gt;
&lt;li&gt;基于第1点，如果每次建立通讯，都走一遍1-3步，就已经保证每次通讯用的key都是不一样的。&lt;/li&gt;
&lt;li&gt;然而，如果每次建立通讯都要走1-3步骤的话，开销会比较大，所以key其实是要复用的。例如客户端可以缓存在本机，服务器就缓存到数据库，设个过期时间。&lt;/li&gt;
&lt;li&gt;基于第2、3点，复用key且废弃4-6步，能使得建立通讯的成本很低，但每次通讯都用的同一个key。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但这么搞会有个&lt;strong&gt;前向保密（forward privacy）&lt;/strong&gt;问题：&lt;/p&gt;

&lt;p&gt;假如哪天这个非对称加密的信道被破解了，即服务器私钥泄露，而攻击者早已抓了用户和服务器之间的所有包，那么攻击者就可以用这个私钥解开登录包，获得key。&lt;strong&gt;这种攻击也算是中间人攻击&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;所以反过来说，&lt;strong&gt;每次建立通讯，不计成本，都完整走完1-6步，就能保证前向安全&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;这个版本的加密通讯已经假设保证了一个非对称加密信道，但如果不使用nonce的话，还是有可能遭到中间人攻击。对于已经了解过公钥加密体系/https原理的同学，想必此时已经很清楚nonce重要性。&lt;/p&gt;

&lt;h1&gt;完整版本的加密通讯&lt;/h1&gt;

&lt;h2&gt;一，公钥证书&lt;/h2&gt;

&lt;p&gt;在互联网中通讯，只有依靠公钥证书这套机制，才能&lt;strong&gt;确认正在通讯的对端是不是你所预期的服务器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;简要地回顾下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务器向客户端出示由某CA签发的公钥证书，即CA用&lt;strong&gt;CA私钥&lt;/strong&gt;加密了服务器公钥，导出来的东西，称之为公钥证书&lt;/li&gt;
&lt;li&gt;在握手前，用户的浏览器已经安装了该CA的证书，该证书里面有CA的公钥&lt;/li&gt;
&lt;li&gt;客户端用本地CA公钥，&lt;strong&gt;解密&lt;/strong&gt;收到的公钥证书得到服务器公钥。解得出来，那就说明这个服务器公钥（证书）确实是这个CA曾经用私钥加密过的。&lt;/li&gt;
&lt;li&gt;当然，公钥证书是有过期问题的，例如服务器把私钥泄露了，那相应的公钥证书就得从CA里删掉，这就涉及到了&lt;strong&gt;证书撤销列表CRL&lt;/strong&gt;。CRL就是一个数据库，这个数据库显然得支持分布式，否则全世界的用户都涌到中心化的服务器去验证证书是否已被撤销，那是做不到的。而分布式数据库，显然就有个更新同步延迟问题，中心数据库更新了CRL，什么时候本地能更新CRL缓存，就决定了安全度有多高。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第4步骤先不说，前3步骤才是最关键的。这些流程，完全是为了&lt;strong&gt;确认正在通讯的服务器是不是自己所信任的CA签名了的服务器&lt;/strong&gt;。信任的根基是CA，客户端只相信CA，CA说什么就是什么。&lt;/p&gt;

&lt;p&gt;值得思考的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端会不会装了不可靠的CA证书。如果是，那后面的所有流程都是白搭了。中间人攻击问题浮现。&lt;/li&gt;
&lt;li&gt;通讯双端没有CA基础设施怎么办？例如假设开发工具只有socket（tcp udp）可用，没有openSSL、也访问不了本地CA数据库。答案是直接把服务器公钥硬编码到客户端安装包里，只要用户确保是从正规途径下载的安装包，那么就可以保证客户端里的公钥是真实服务器的公钥。例如从app store下载游戏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;二，都是为了加密性能&lt;/h2&gt;

&lt;p&gt;第一步中，客户端和服务器已经建立了可靠的&lt;strong&gt;非对称加密通讯&lt;/strong&gt;，客户端持有服务器的公钥，客户端用公钥加密自己数据，只有服务器才能解密，不就万事大吉了吗？&lt;/p&gt;

&lt;p&gt;然而很可惜的是，非对称加密算法，性能一般都差强人意，远不如&lt;strong&gt;对称加密算法&lt;/strong&gt;。所以如果用户要发送大量隐私数据给服务器，且只用非对称加密的话，先不说客户端耗能，服务器的CPU首先就炸了。&lt;/p&gt;

&lt;p&gt;用指令openssl speed xxx，可以认识到各种算法的性能：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;                        sign        verify          sign/s    verify/s
rsa 2048 bits 0.000738s 0.000022s   1354.2  45918.7

因为rsa是按次的，这里得换算成k bytes才能和aes比较，即乘以256再除以1000：
rsa 2048 bits 0.000738s 0.000022s   346.7k 11755.2k


type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
aes-128 cbc      99115.02k   115128.04k   122790.06k   126412.46k   126915.93k

                              op      op/s
 256 bit ecdh (nistp256)   0.0001s  14937.4
 384 bit ecdh (nistp384)   0.0008s   1265.2
 521 bit ecdh (nistp521)   0.0009s   1148.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然可以看出rsa和aes根本不是同个数量级的，rsa私钥运算大约比aes慢1000倍。&lt;/p&gt;

&lt;p&gt;性能是关键，接下来的步骤，都得归咎于非对称加密算法的性能。&lt;/p&gt;

&lt;h2&gt;三，前主密钥和主密钥：pre-master key和master key&lt;/h2&gt;

&lt;p&gt;因为性能问题，我们希望尽可能不使用非对称加密通讯信道，甚至不去建立非对称加密通讯。&lt;/p&gt;

&lt;p&gt;最终的，非对称加密通讯所要负责的事情，被精简成一件事：协商一个master key。&lt;/p&gt;

&lt;p&gt;在说master key时，需要搞清楚pre-master key和master key分别是什么，有什么区别：&lt;/p&gt;

&lt;p&gt;pre-master key：&lt;/p&gt;

&lt;p&gt;是服务器和客户端&lt;strong&gt;直接协商&lt;/strong&gt;出来的产物（key exchange）。例如用ECDH密钥协商算法算出来的东西。要提的2点是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pre-master key是&lt;strong&gt;不定长&lt;/strong&gt;的，取决于选择了什么样的密钥协商算法，一般算法越强，长度越长。&lt;/li&gt;
&lt;li&gt;pre-master key是保密的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;master key：&lt;/p&gt;

&lt;p&gt;正因为pre-master key不定长的问题，导致分裂出了pre-master key和master key两个东西。&lt;/p&gt;

&lt;p&gt;master key是&lt;strong&gt;定长&lt;/strong&gt;的。master key从pre-master key派生，是它的亲儿子。&lt;/p&gt;

&lt;p&gt;这个&lt;a href=&quot;https://tools.ietf.org/html/rfc5246#section-8.1&quot;&gt;RFC&lt;/a&gt;里有提及如何算master key:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master_secret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre_master_secret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;master secret&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;ClientHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServerHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                          &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0..47&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用本文的术语来表达的就是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;master_key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre_master_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;master key&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;nonce_client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonce_server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                          &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0..47&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（PRF（Pseudo-random function），是&lt;strong&gt;伪随机导出函数&lt;/strong&gt;。这段代码意思是，根据pre-master key、nonce_client、nonce_server三个参数，伪随机地，导出了一个master key，定长48字节。）&lt;/p&gt;

&lt;p&gt;（PRF的简单实现是hash(key || msg)或hash(msg || key)或hash(key || msg || key)，三种情况的问题不太一样，但都是naive的，例如可能会遇到&lt;a href=&quot;https://en.wikipedia.org/wiki/Length_extension_attack&quot;&gt;Length extension attack&lt;/a&gt;。严格的PRF实现是HKDF，下篇文章再介绍。）&lt;/p&gt;

&lt;p&gt;RFC里补充说，一旦得到了master key，即可从内存干掉pre-master key。对待生父是如此的残忍啊，不过也是必要的，免得给恶意程序可乘之机。（nonce_client、nonce_server并不能删除，之后还要用到）&lt;/p&gt;

&lt;p&gt;pre-master key在master key出来后消失了，生命期非常短暂，所以本节重点显然是master key。&lt;/p&gt;

&lt;p&gt;这节不说master key的作用，先说master key的管理问题。&lt;/p&gt;

&lt;p&gt;在常规的https通讯中，每次tcp连接都意味着计算一个新的master key，成本挺高，当然安全性也高。&lt;/p&gt;

&lt;p&gt;但有的时候想要节约掉这个成本，例如连续不断地对同个服务器发起多次https请求（短连接），于是就有人发明了缓存机制。&lt;/p&gt;

&lt;p&gt;缓存，就是指长时间地妥当地把master key存起来，随时拿出来用。但并不能直接存取，会有安全问题。&lt;/p&gt;

&lt;p&gt;有2种套路，一个是session id，本质是服务器做缓存；另一个是session ticket，是客户端做缓存。&lt;/p&gt;

&lt;h3&gt;session id&lt;/h3&gt;

&lt;p&gt;在之前的密钥协商后，服务器会分配一个session id，并在数据库中存入以session id为键的会话信息如master key。下次做密钥协商时，客户端发现已经缓存了一个session id，那么发id给服务器，如果服务器能在数据库找出这个id对应的master key，那么就不需要去协商master key了。不过缺点是很难维护一个这样子的数据库。&lt;/p&gt;

&lt;h3&gt;session ticket&lt;/h3&gt;

&lt;p&gt;新的会话建立时，服务器用一个只有自己知道的密钥（ticket key）对master key做加密，把密文ticket发给客户端，客户端单纯地只把ticket缓存起来。下次要建立会话时，把缓存的ticket发给服务器，服务器解密，就拿到之前的master key。因为ticket key必须所有服务器一致，且不可变，也有一定安全风险，现在一般是采用轮转的方式，定时地渐进式地淘汰旧的ticket key（新的会话用旧的ticket key尝试解密，用新的ticket key加密）。&lt;/p&gt;

&lt;p&gt;这两种方案中，共同点都是客户端依然得自己缓存好master key。&lt;/p&gt;

&lt;p&gt;关于master key还有它自身的时效性问题。是否缓存一次，永久使用？答案是不可以，这不安全。&lt;/p&gt;

&lt;p&gt;一般master key要设个过期时间，一天、一个星期、一个月，加了限时，就保证了要定期更换，一定程度降低了master key泄露的风险。过期时间服务器决定，客户端如果缓存的是过期的master key，那服务器应有反馈，并重新协商新的master key。&lt;/p&gt;

&lt;p&gt;Note: 在TLS1.3中，session id、session ticket的做法已经被废弃了。session ticket被更新为一个类似的东西：PSK(pre-shared key)。&lt;/p&gt;

&lt;h2&gt;四，基于master key，得到对称加密密钥，建立对称加密通讯&lt;/h2&gt;

&lt;p&gt;刚才的简化例子有一点没有说清楚的，就是nonce怎么发送。&lt;/p&gt;

&lt;p&gt;实际上，nonce_client, nonce_server，都可以不经过加密通讯信道直接发送，泄露了也没关系。&lt;/p&gt;

&lt;p&gt;因为需要的对称加密密钥基于三个参数：&lt;/p&gt;

&lt;p&gt;master key = Hash(pre-master key，nonce_client, nonce_server)&lt;/p&gt;

&lt;p&gt;我们不怕泄露后2个，因为第一个pre-master key已经保证保密了。这样子hash出来的master key也依然是保密的。&lt;/p&gt;

&lt;p&gt;有了双方一致的master key，就可以拿出各种对称加密算法，来建立加密通讯了。&lt;/p&gt;

&lt;p&gt;要注意的点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nonce_client, nonce_server存在的意义前文也说过了，主要是防止重放攻击、中间人攻击，所以每次想要用pre-master key建立加密通讯，都是即时地重新协商nonce，并算新的master key。&lt;/li&gt;
&lt;li&gt;master key实际上不能直接用来加密，而是要导出（派生？）成多个key，按实际需求导出，要多少个就导多少个。例如因为tcp是全双工连接，有2个数据流方向，2个方向的encrypt key如果一样，安全系数就降低了。master key这种导出性质，使得它被称为&lt;strong&gt;主&lt;/strong&gt;密钥。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;五，加密数据的完整性保证&lt;/h2&gt;

&lt;p&gt;前四步骤已经几乎建立了绝对可靠的性能不错的加密通讯，但还有一个问题：建立加密通讯后，客户端发出去的包，依然还是有被截包篡改的可能。&lt;/p&gt;

&lt;p&gt;例如A用encrypt key加密了原文a得到密文b，用tcp把b发出去，b被攻击者截取，攻击者可能用各种奇奇怪怪的方法尝试篡改这个密文b变成密文c，亦或者替换了b变成密文d（很可能是通讯早期截获的包！），然后继续发向服务器，那么就还是不安全，因为客户端想要发给服务器的密文b并没有真正送到，服务器还处理了别的密文！&lt;/p&gt;

&lt;p&gt;还有一种情况是，客户端和服务器的对称密钥因为某种原因不同步了，这样会导致服务器用错误的对称密钥解密数据得到了“乱码”，但服务器是完全感知不到用了错误的密钥，服务器无法知道乱码是不是乱码。&lt;/p&gt;

&lt;p&gt;（即使是加密通讯的建立过程本身，都有完整性安全漏洞，包括下一节会说到的&lt;strong&gt;算法选取&lt;/strong&gt;。根源在于一开始使用的非对称加密信道是单向安全而不是双向安全的。）&lt;/p&gt;

&lt;p&gt;那怎么办呢？答案是再给密文b加一层&lt;strong&gt;认证&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;简单理解就是，客户端给密文b做个hash，得到消息验证码MAC（上一篇文章介绍过的)，把密文b和MAC一起发给服务器，服务器也对收到的密文做一样的hash，如果服务器得到的MAC值和客户端的MAC值不一致，那就说明数据不是客户端发来的。&lt;/p&gt;

&lt;p&gt;hash函数刚才也提到过了，需要一个integrity key，也是基于master key的。攻击者没有办法获得一样的hash函数。&lt;/p&gt;

&lt;p&gt;MAC的安全隐患上一篇文章也说到过了。最经典的是重放攻击，就是攻击者并不篡改密文和MAC，而只是原样地保存下来，并伺机重复发送给服务器。这个问题的解决办法就是对每条消息加一个递增的序号。同样的消息就不可能收到两次。&lt;/p&gt;

&lt;p&gt;P.S. 用一个额外的MAC（其实应该叫做MtE，EtM，E&amp;amp;M）来保证完整性已经是一种过时的思路，有安全缺陷。其中只有EtM(encrypt then MAC)是安全的，是一个大坑。让程序员搞懂这三者区别也是痛苦。所以现在并不提倡EtM之类的做法了。&lt;/p&gt;

&lt;p&gt;取而代之的是AEAD。所谓AEAD，含义是在对称加密算法里添加了完整性验证的功能，例如AES-128-GCM、ChaCha20-IETF-Poly1305。所以AEAD并不是一种算法，而只是方案的代名词。在即将到来的TLSv1.3中，已经彻底干掉MAC，而统一用AEAD了。&lt;/p&gt;

&lt;p&gt;然后剩下就是&lt;strong&gt;握手过程&lt;/strong&gt;的认证问题。&lt;/p&gt;

&lt;p&gt;这个问题很有意思，因为我们的加密通讯已经建立了，认证机制也有了。&lt;strong&gt;这时候反而可以回过头来认证下握手过程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;客户端和服务器在tcp三次握手后直到建立SSL连接，中间n次交流的内容（有对称性），都记录下来，然后在连接建立完成后，互相在本地对这些内容做一次HMAC计算，并把MAC值发给对方校验，如果不一致，说明有中间人篡改了某次交流，那么关闭本次连接。&lt;/p&gt;

&lt;h2&gt;六，加密算法选取&lt;/h2&gt;

&lt;p&gt;上面的五大步骤，其实都没有限定具体用什么算法。据我了解，如果不用openSSL之类的库，而是自己手动组合，那么可以这么弄：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;master key：ECDH&lt;/li&gt;
&lt;li&gt;对称加密：AES&lt;/li&gt;
&lt;li&gt;生成encrypt key：SHA256&lt;/li&gt;
&lt;li&gt;生成integrity key：SHA256 with salt&lt;/li&gt;
&lt;li&gt;生成消息验证码：HMAC with integrity key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这对程序员的要求比较高，需要了解各种算法的优缺点和如何组合，是否适合配对。&lt;/p&gt;

&lt;p&gt;所以算法选取这个事情，已经被建立起规范，关键词叫做cipherSuite，例如openSSL就支持，可以执行openssl ciphers -V | column -t，看到系统的openSSL支持的cipherSuites：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/4.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;（注意，SSLv3已经过时了，现在都是TLSv1.2，即将出现TLSv1.3）&lt;/p&gt;

&lt;p&gt;第一列2个十六进制值相当于ID。&lt;/p&gt;

&lt;p&gt;以其中最常见的0xC0,0x2F为例：&lt;/p&gt;

&lt;p&gt;0xC0,0x2F  -  ECDHE-RSA-AES128-GCM-SHA256    TLSv1.2  Kx=ECDH        Au=RSA    Enc=AESGCM(128)    Mac=AEAD&lt;/p&gt;

&lt;p&gt;含义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用于TLSv1.2版本&lt;/li&gt;
&lt;li&gt;kx = key exchange，使用ECDHE做秘钥交换。就是上一篇文章说的DH基于椭圆曲线EC算法的变种。最后的E代表ephemeral，表示转瞬即逝性。&lt;/li&gt;
&lt;li&gt;Au = authenticity，使用RSA做认证&lt;/li&gt;
&lt;li&gt;Enc = encryption，使用AES-128-GCM做对称加密。GCM意味着加密算法支持认证功能。&lt;/li&gt;
&lt;li&gt;MAC = AEAD（authenticated encryption with associated data），一种同时具备保密性(confidentiality)，完整性(integrity)和可认证性(authenticity assurances)的加密形式。 MAC=AEAD意思是说“把这些认证问题交给对称加密算法就行了，不需要MAC”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以撇除掉融合到加密算法里的MAC，那么CipherSuite其实只有3个东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1个key exchange 密钥交换算法&lt;/li&gt;
&lt;li&gt;1个authentication 认证算法&lt;/li&gt;
&lt;li&gt;1个encryption 对称加密算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;引入CipherSuite，说明算法的选取不是完全定死的，而是可以根据需要协商的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;协商过程会发生在tcp三次握手后的第一个包里&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这就要注意1个问题：&lt;strong&gt;算法选取过程是无加密的&lt;/strong&gt;，发生什么攻击都可能。&lt;/p&gt;

&lt;p&gt;例如中间人攻击，中间人篡改了算法协商的内容，使得通讯双方用了安全度较低的、符合中间人预期的加密算法，那么这次通讯就不那么安全了。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;h2&gt;概括一下加密通讯标准过程&lt;/h2&gt;

&lt;p&gt;从tcp握手到算法协商完成，步骤大致如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;tcp完成三次握手&lt;/li&gt;
&lt;li&gt;客户端发送它支持的CipherSuite列表和client nonce（所谓的ClientHello）&lt;/li&gt;
&lt;li&gt;服务器从该列表中，选择一套合适的算法，然后连同自己的&lt;strong&gt;公钥证书&lt;/strong&gt;、server nonce、握手信息的数字签名，发给客户端（ServerHello）&lt;/li&gt;
&lt;li&gt;客户端验证证书，得到服务器公钥，基于公钥协商pre-master key，导出master key。&lt;/li&gt;
&lt;li&gt;客户端服务器各自本地计算各个对称密钥。&lt;/li&gt;
&lt;li&gt;客户端验证本次连接握手信息（数字签名）。（单向认证）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;0-rtt，1-rtt？&lt;/h2&gt;

&lt;p&gt;搞通讯偶尔会看到什么0-rtt，1-rtt，其实都指的是基于TLS连接，和tcp的三次握手没关系。&lt;/p&gt;

&lt;p&gt;TLS连接握手，是发生tcp三次握手后的事情，即三次握手后，还要经过多少个rtt回合，才能建立TLS连接？&lt;/p&gt;

&lt;p&gt;用1-rtt搞定TLS连接，那么这一个rtt必然是用来协商对称加密密钥的。比如说，你的程序可以强制客户端和服务端只用DH算法协商密钥，并且这个rtt里也发送各自的nonce，那么1-rtt后，通讯两端就都拥有了master key、cnonce、snonce。&lt;/p&gt;

&lt;p&gt;至于0-rtt，必然是有损安全性的。0-rtt意味着第一个数据包就得支持发送用户数据，那必然是用某种缓存的key来加密用户数据。这个key叫做半静态ECDH公钥。原理有点像前面说的，游戏客户端硬编码了服务器公钥。&lt;/p&gt;

&lt;p&gt;缺陷在于：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;0-RTT发送的应用数据没有前向安全性&lt;/li&gt;
&lt;li&gt;跨连接可以重放0-RTT里的应用数据（任何服务器端无共享状态的协议，都无法做到跨连接防重放）&lt;/li&gt;
&lt;li&gt;如果服务器端 半静态 ECDH公钥对应的私钥泄露了，攻击者就可以伪装成客户端随意篡改数据了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这简直就是性能和安全的博弈。google的QUIC就很好地实现了0-rtt。&lt;/p&gt;

&lt;h1&gt;微信mmtls对比&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://www.52im.net/thread-310-1-1.html&quot;&gt;mmtls介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;mmtls是微信自己设计的简化的&amp;quot;TLS1.3&amp;quot;协议。&lt;/p&gt;

&lt;p&gt;mmtls分为3个部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;handshake协议：tcp连接建立后的密钥协商。&lt;/li&gt;
&lt;li&gt;alert协议：handshake失败时需要显式告诉对端。微信是服务端告诉客户端，让客户端来关闭连接，避免服务端过多的TIME_WAIT状态。&lt;/li&gt;
&lt;li&gt;record协议：负责上层数据的加密传输&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法组成：ECDH + ECDSA + AES-GCM（AEAD）&lt;/p&gt;

&lt;p&gt;几个关键点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;去掉了CA公钥证书这个环节，取而代之的是把认证公钥（verify_key）直接嵌入到客户端里，只要保证客户端来自官方渠道，就保证了verify_key不是中间人伪造的。&lt;/li&gt;
&lt;li&gt;把verify_key固定在客户端后，如果认证私钥（sign_key）泄露，怎么撤掉verify_key。方法是强制更新客户端，同时服务端加强对认证私钥的存放管理，怎么管理原文没有细说。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mmtls是对TLS1.3草案的精简，觉得与其分析mmtls还不如先好好看一遍TLS1.3，而且openSSL1.1.1-pre8已经发布了，支持TLS1.3。&lt;/p&gt;

&lt;p&gt;。。。&lt;/p&gt;

&lt;p&gt;嗯，后来我也看了下TLS1.3，因为带了很多历史包袱，其实不太好理解。openSSL的代码，也是巨复杂，啃不动。所以TLS1.3目前觉得还不是时候学习，等openSSL发布正式版，再来抓包、追踪代码学习，可能比较好。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/&quot;&gt;https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.helong.info/blog/2015/01/23/ssl_tls_ciphersuite_intro/&quot;&gt;https://blog.helong.info/blog/2015/01/23/ssl_tls_ciphersuite_intro/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cryptologie.net/article/340/tls-pre-master-secrets-and-master-secrets/&quot;&gt;https://www.cryptologie.net/article/340/tls-pre-master-secrets-and-master-secrets/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://robertheaton.com/2015/04/06/the-ssl-freak-vulnerability/&quot;&gt;https://robertheaton.com/2015/04/06/the-ssl-freak-vulnerability/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 01 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/crypto-2/</link>
        <guid isPermaLink="true">http://localhost:4000/crypto-2/</guid>
      </item>
    
      <item>
        <title>《计算机网络-自顶向下方法》笔记</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;网络层&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;是否对ip包分片，取决于输出链路的mtu，如果包大小大于mtu（可能500多到1500字节），那么就会自动分片&lt;/li&gt;
&lt;li&gt;分片有3个不可或缺字段：ip包的唯一标识（ID)、字节偏移offset、结束标志（0或1，1表示还没结束，0表示当前已是最后一个片）&lt;/li&gt;
&lt;li&gt;分片是ipv4的机制，且有安全问题，ipv6没有分片，杜绝了安全隐患&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分片重组是在目的地端主机上进行的，路由器只可能做分片，而不会做重组&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主机和物理链路之间的边界叫做接口&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个接口有自己的ip地址，所以ip地址技术是与接口关联，而不是和主机或路由器&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子网：直接互联并与其他网络岛隔离的主机接口+路由器接口组成子网&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子网掩码：例如223.1.1.0/24，/24就是子网掩码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络层有三个主要组件：IP协议、路由选择协议(RIP、OSPF、BGP）、因特网控制报文协议ICMP&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看和修改系统的mtu值：&lt;/p&gt;

&lt;p&gt;查看：&lt;/p&gt;

&lt;p&gt;ifconfig eth0&lt;/p&gt;

&lt;p&gt;修改：&lt;/p&gt;

&lt;p&gt;ifconfig eth0 mtu 1460&lt;/p&gt;

&lt;h2&gt;DHCP动态主机配置协议&lt;/h2&gt;

&lt;p&gt;四大步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DHCP发现报文，用UDP，端口67，src ip为0.0.0.0，dst ip为255.255.255.255，广播一个发现报文，报文里包含一个事物ID。&lt;/li&gt;
&lt;li&gt;DHCP提供报文，DHCP服务器收到广播而来的发现报文后，用一个提供报文做响应，src ip为自己的ip，dst ip为255.255.255.255，也是广播。因为DHCP服务器不一定唯一，所以客户机有选择权。提供报文包含，收到的发现报文的事物ID、向客户推荐的IP地址、IP地址的掩码、IP地址租用期（address lease time），租用期一般为几小时到几天。&lt;/li&gt;
&lt;li&gt;DHCP请求报文，客户机从1到多个提供报文中选择一个，并向该服务器发送DHCP请求报文。&lt;/li&gt;
&lt;li&gt;DHCP ACK报文，就是第三步的响应报文，告诉客户配置参数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第四步完成后，客户就可以在租用期里使用这个ip。另外，DHCP也有延长租用期的办法。&lt;/p&gt;

&lt;h2&gt;NAT网络地址转换&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;NAT是用来解决ipv4的ip地址不够用问题的&lt;/li&gt;
&lt;li&gt;NAT会使得外部主机不能直接访问内网主机（内网主机不可见），因为内网主机没有自己的全球唯一ip地址&lt;/li&gt;
&lt;li&gt;NAT用一张转换表来双向转发数据包&lt;/li&gt;
&lt;li&gt;内网主机可以主动访问外网，反过来就不行&lt;/li&gt;
&lt;li&gt;NAT的存在对实现p2p应用很不好&lt;/li&gt;
&lt;li&gt;应用NAT穿越技术，可以改善p2p应用的通讯问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NAT穿越：&lt;a href=&quot;https://www.jianshu.com/p/84e8c78ca61d&quot;&gt;https://www.jianshu.com/p/84e8c78ca61d&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;ICMP控制报文协议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;常用于差错报告，例如目的地不可达时，中间路由器就会返回类型3的ICMP报文&lt;/li&gt;
&lt;li&gt;ICMP协议是建立在IP协议上面的，因为是用IP分组承载的。类似TCP、UDP。但一般认为ICMP是属于网络层的协议。&lt;/li&gt;
&lt;li&gt;ICMP报文组成：类型、编码。编码可理解为大类型里的子类型。&lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol&quot;&gt;wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ping程序： 发一个ICMP[8,0]报文，目的主机发回一个ICMP[0,0]的报文。&lt;/p&gt;

&lt;p&gt;源抑制报文：从wiki可以看到已经deprecated了，最初是用来做拥塞控制的，不过tcp自己有拥塞控制，所以没卵用。&lt;/p&gt;

&lt;p&gt;traceroute：原理就是发送一系列IP数据报，每个数据报携带UDP报文，目的地ip为目标主机，端口号设置为不可达的端口号。关键的，第一个数据报的TTL设为1，第二个的TTL为2，以此类推。当第n个数据报到达第n台路由器时，第n台路由器发现这个数据报的TTL正好过期，然后就会发给源主机一个ICMP[11,0]，携带了该路由器的ip地址。然后每个数据报都设置了定时器，收到回复时就可以算出往返延迟RTT。&lt;/p&gt;

&lt;p&gt;traceroute还有个问题是何时停止发送udp报文，这是通过ICMP的类型和编码字段判断的，因为如果目的地主机在线，那么最终会返回一个ICMP[3,3]，表示目的主机端口不可达。&lt;/p&gt;

&lt;h2&gt;ipv6&lt;/h2&gt;

&lt;p&gt;改进：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;去掉了分片功能，因为分片功能是耗时操作，去掉后能提高路由器性能&lt;/li&gt;
&lt;li&gt;没有分片后，如果包太大，就无法发进链路层，只能丢弃，并返回ICMP差错报文，让发送方重新发一个小的&lt;/li&gt;
&lt;li&gt;去掉了首部校验和，因为传输层协议、链路层协议也会做校验和，所以多余了。另外，因为IP头部有个动态的跳数，会导致每次修改跳数都得重新计算校验和，影响性能。&lt;/li&gt;
&lt;li&gt;选项字段从IP首部去掉，但依然可以存在选项，方法是用“下一个头部”字段来实现，就是说选项信息是一个可选的头部。&lt;/li&gt;
&lt;li&gt;去掉了选项后，ipv6的头部就是定长的40字节，非常高效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2个ipv6主机之间通讯，可能会经过一段由仅支持ipv4的主机组成的路径，这时可以用隧道技术，把ipv6分组，放到ipv4分组的有效载荷里。&lt;/p&gt;

&lt;h2&gt;路由选择算法&lt;/h2&gt;

&lt;p&gt;全局式算法：路由器拥有网络拓扑信息、连通信息、链路费用信息，从而算出最优路径。也称为链路状态算法。链路费用一般取决于链路承载流量。&lt;/p&gt;

&lt;p&gt;分散式算法：路由器没有网络链路信息，而只需要拥有和路由器直接相连链路的费用信息就可开始工作。通过迭代、和邻居交换信息，就能逐渐计算出到达某目的地结点的最低费用路径。&lt;/p&gt;

&lt;p&gt;静态算法：依靠人工。&lt;/p&gt;

&lt;p&gt;动态算法：拓扑或负载变化时更新。不过容易受&lt;strong&gt;路由选择循环、路由震荡&lt;/strong&gt;影响。&lt;/p&gt;

&lt;p&gt;负载敏感算法：链路费用会动态地变化，以反映链路拥塞情况。&lt;/p&gt;

&lt;p&gt;负载迟钝算法：相反的，对拥塞不敏感，费用固定。更普遍可行的方法。&lt;/p&gt;

&lt;p&gt;路由震荡：用随机化的链路通告时间，可以改善震荡。&lt;/p&gt;

&lt;p&gt;LS链路状态算法：基于无向图最短路算法。最坏情况n平方。&lt;/p&gt;

&lt;p&gt;DV距离向量算法：是一种迭代、异步、分布式的算法。&lt;/p&gt;

&lt;h2&gt;互联网当前的路由算法&lt;/h2&gt;

&lt;h3&gt;RIP，&lt;strong&gt;路由选择信息协议&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;路由选择表（routing table），也叫RIP表，包含该路由器的距离向量、转发表。&lt;/li&gt;
&lt;li&gt;目的子网，就是把目的地路由器当成一个子网网络&lt;/li&gt;
&lt;li&gt;跳数，理解为到目的子网的链接边数即可&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;转发表的结构：目的子网，下一台路由器，到目的子网的跳数。每个子网占一行。&lt;/p&gt;

&lt;p&gt;转发表的状态是迭代的，不可能是实时获得整个网络的状态信息。&lt;/p&gt;

&lt;p&gt;邻居路由器之间会互相通告最新的转发表信息。大概30秒一次。&lt;/p&gt;

&lt;p&gt;如果邻居超过180秒没有发来报文，认为不可达，更新自己的路由表，并向其他存活的邻居发公告。&lt;/p&gt;

&lt;p&gt;每次收到转发表信息，都可能导致当前路由器的所知的到达某个子网的跳数、下一跳路由器信息，产生更新，因为新的路径（跳数）可能会更短。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/2.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/3.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/4.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;路由器可以主动询问邻居&lt;strong&gt;到指定目的地的费用&lt;/strong&gt;（RIP请求报文）。基于UDP 520端口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RIP是一个基于传输层UDP协议的应用层进程（叫routed），用UDP来控制IP路由。&lt;/strong&gt;这也是一个特殊进程，因为它可以操作系统内核的转发表。&lt;/p&gt;

&lt;p&gt;routed会和邻居路由器的routed进程相互联系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.6/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;OSPF&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;被设想为RIP的后继者，因为有许多先进特性&lt;/li&gt;
&lt;li&gt;洪泛链路状态信息的链路状态协议 + Dijkstra最低费用路径算法&lt;/li&gt;
&lt;li&gt;是基于完整信息状态的算法&lt;/li&gt;
&lt;li&gt;各条链路费用可用网络管理员配置，如果都设为1，则退化成&lt;strong&gt;最少跳数路由选择（RIP）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;管理员可以根据带宽大小来设置链路费用，反比，带宽越大，费用越低。&lt;/li&gt;
&lt;li&gt;路由选择信息是广播到整个网络的，而不仅仅是邻居&lt;/li&gt;
&lt;li&gt;当一跳链路状态（费用、连接/中断）变化时，更新并广播&lt;/li&gt;
&lt;li&gt;即使无变化，也要定期广播&lt;/li&gt;
&lt;li&gt;OSPF报文直接承载于IP层，所以OSPF要自行实现可靠传输，链路状态广播功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安全，对网络成员有身份鉴别功能，从而鉴别假冒的OSPF协议包。但这是可选的功能。鉴别方法是在每台路由器上配置一样的共享密钥，发包时，把密钥添加到分组里然后算一个MD5，再把MD5放到发包分组里，接收端收到分组后，对内容段添加自己的密钥并算一个MD5，并和收到的MD5进行比较鉴别。另外还有个序号，用来针对重放攻击。&lt;/li&gt;
&lt;li&gt;负载均衡，如果去某个目的地存在多条费用一样的路径，OSPF允许同时使用多条路径，而不是只用其中一条。&lt;/li&gt;
&lt;li&gt;层次结构&lt;/li&gt;
&lt;li&gt;对多播的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OSPF可按区域划分（大区分小区），区域和区域外的联系要经过&lt;strong&gt;区域边界路由器&lt;/strong&gt;，边界路由器都连到主干路由，从而实现区域之间的连通。&lt;/p&gt;

&lt;h3&gt;BGP 边界网关协议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;BGP确保了因特网中所有AS知道该子网以及如何到达那里。&lt;/li&gt;
&lt;li&gt;没有BGP，那么每个子网将是隔离的，不为互联网其他部分所知。&lt;/li&gt;
&lt;li&gt;是BGP这个协议将所有东西粘合在一起&lt;/li&gt;
&lt;li&gt;BGP基于TCP端口179，半永久TCP连接&lt;/li&gt;
&lt;li&gt;BGP作用：使得每个AS知道经过其相邻AS可达哪些目的地。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关键词定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BGP对等方，BGP peers，即一条BG TCP连接的两端&lt;/li&gt;
&lt;li&gt;沿着该连接发送所有BGP报文的TCP连接称为BGP会话&lt;/li&gt;
&lt;li&gt;跨越2个AS的BGP会话称为外部BGP，eBGP；同理，内部的叫iBGP。&lt;/li&gt;
&lt;li&gt;目的地：不是主机IP，而是CDIR化的前缀，表示一个子网或子网的集合，如：138.16.64/24。&lt;/li&gt;
&lt;li&gt;前缀聚合：如果AS连接了4个子网，138.16.64/24，138.16.65/24，138.16.66/24，138.16.67/24，可以聚合成138.16.64/22&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;链路层&lt;/h1&gt;

&lt;h2&gt;交换局域网-ARP协议&lt;/h2&gt;

&lt;h3&gt;ARP表&lt;/h3&gt;

&lt;p&gt;每个主机维护一张ARP表，key是IP地址（所在子网的其他主机的局域网地址），value是MAC地址，并且有一个ttl，指明这key到value的映射关系什么时候过期。&lt;/p&gt;

&lt;h3&gt;适配器、接口、ARP模块、MAC地址&lt;/h3&gt;

&lt;p&gt;一个接口对应一个适配器、一个ARP模块、一个MAC地址&lt;/p&gt;

&lt;h3&gt;例子：同子网下的ARP&lt;/h3&gt;

&lt;p&gt;主机10.10.10.1要发送一个数据报，给本子网上的另一台主机10.10.10.2或路由器&lt;/p&gt;

&lt;p&gt;分2种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发送主机的ARP表有目的主机ip的MAC地址：直接可以发。&lt;/li&gt;
&lt;li&gt;发送主机没有目的主机的MAC地址：发送方用ARP协议来解析这个目的ip地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ARP解析过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;发送主机构造一个ARP分组（ARP packet），发送IP地址、接收IP地址、MAC地址。ARP分组细分为&lt;strong&gt;查询分组&lt;/strong&gt;和&lt;strong&gt;响应分组&lt;/strong&gt;，格式一样。&lt;/li&gt;
&lt;li&gt;发送方把ARP查询分组送到适配器，并且指示适配器&lt;strong&gt;用MAC广播地址FF-FF-FF-FF-FF-FF&lt;/strong&gt;发送它&lt;/li&gt;
&lt;li&gt;适配器在链路层帧中封装这个查询分组，用广播地址作为帧的目的地址，并把该帧传输进子网（广播）&lt;/li&gt;
&lt;li&gt;同子网上的所有其他适配器都会收到这个ARP查询，因为地址是广播地址，所以适配器底层不能直接判断是否丢弃分组，而是向上传递给&lt;strong&gt;ARP模块&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;ARP模块检查自己的IP地址是否和分组的目的IP地址相匹配。&lt;/li&gt;
&lt;li&gt;最终只有一个ARP模块会匹配，此时回发给最开始的发送主机一个响应分组（响应分组的目的MAC地址是已知的，不需要广播）。&lt;/li&gt;
&lt;li&gt;发送主机收到响应分组，更新ARP表。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由此可见，ARP协议是一个同时跨越链路层和网络层边界的协议&lt;/p&gt;

&lt;h3&gt;例子：跨子网ARP&lt;/h3&gt;

&lt;p&gt;背景：1个路由器打通了2个子网，子网1的主机A想要发数据报给子网2的主机B&lt;/p&gt;

&lt;p&gt;问题：目的地主机不在同一子网上，意味着即使已知目的主机的MAC地址，也不可能让链路帧直接送达&lt;/p&gt;

&lt;p&gt;流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;发送主机把数据帧发送到路由器接口1&lt;/li&gt;
&lt;li&gt;路由器会看到该帧的目的地址是自己的接口1，于是解析链路帧，把数据报传递到路由器的网络层&lt;/li&gt;
&lt;li&gt;路由器网络层观察数据报的ip目的地址，发现转发表里有这个子网（最长前缀匹配），并且知道得通过接口2转发这个数据报&lt;/li&gt;
&lt;li&gt;接口2的适配器把该数据报封装到一个新的帧中，帧的目的MAC地址就是主机B的MAC地址（路由器从自己的ARP表获得），并且将帧发送进子网2中&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;交换局域网-以太网&lt;/h2&gt;

&lt;p&gt;以太网是高速局域网。&lt;/p&gt;

&lt;p&gt;21世纪早期，集线器（hub）换成了交换机（switch）。&lt;/p&gt;

&lt;p&gt;交换机特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无碰撞&lt;/li&gt;
&lt;li&gt;存储转发分组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交换机和路由器区别：交换机仅工作在2层，而路由器是3层。&lt;/p&gt;

&lt;p&gt;以太网帧结构：&lt;/p&gt;

&lt;p&gt;前同步码(Preamble) | 帧开始符（Start of frame delimiter, SFD）| 目的MAC地址 | 源MAC地址 | tag (optional) | 类型（或长度）| 数据 | FCS，Frame check sequence（即CRC） | IPG(interpacket gap)&lt;/p&gt;

&lt;p&gt;各字段占用字节数：&lt;/p&gt;

&lt;p&gt;7 | 1 | 6 | 6 | 4(optional) | 2 | 46~1500 | 4 | 12&lt;/p&gt;

&lt;p&gt;一帧里面要分为两部分，一部分是2层链路层的，一部分是1层物理层的。&lt;/p&gt;

&lt;p&gt;物理层的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preamble （用于链路2端的时钟同步，10101010····，且有唤醒接收适配器的作用）&lt;/li&gt;
&lt;li&gt;SFD（标明下一个字节为目的MAC字段，10101011，最后2位突然变成2个1，警告接收适配器重要的内容要来了）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Interpacket_gap&quot;&gt;IPG&lt;/a&gt; (一个pause段，让接收者有时间准备接收下一个分组)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;占7 + 1 + 12 = 20字节。&lt;/p&gt;

&lt;p&gt;链路层的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;目的MAC地址&lt;/li&gt;
&lt;li&gt;源MAC地址&lt;/li&gt;
&lt;li&gt;tag (optional) &lt;/li&gt;
&lt;li&gt;类型（或长度）&lt;/li&gt;
&lt;li&gt;数据 (3层协议数据)&lt;/li&gt;
&lt;li&gt;FCS (对接收网卡提供判断是否传输错误的一种方法，如果发现错误，丢弃此帧)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;min：6 + 6 + 2 + 46 + 4 = 64字节，max：6 + 6 + 4 + 2 + 1500 + 4 = 1522字节&lt;/p&gt;

&lt;p&gt;注意，数据字段是有填充需求的，即要让以太网帧至少有64字节。&lt;/p&gt;

&lt;p&gt;另外，如果上下文是物理层，那么以太网帧应该叫以太网分组（Ethernet packet），以太网分组包括上面整个帧结构。&lt;/p&gt;

&lt;p&gt;以太网技术特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;向网络层提供无连接服务，类似3层数据报、4层UDP&lt;/li&gt;
&lt;li&gt;向网络层提供不可靠服务，接收端无论是否正确接收，都不会做任何反馈，错帧直接丢弃。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;交换局域网-链路层交换机&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;交换机的任务：接收&lt;strong&gt;入链路层帧&lt;/strong&gt;，并将它们转发到&lt;strong&gt;出链路&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;交换的是链路层帧，工作在2层&lt;/li&gt;
&lt;li&gt;对子网中的主机和路由器&lt;strong&gt;透明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;交换机有缓存，因为转发输出速率可能会超过输出接口的链路容量&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;转发&amp;amp;过滤&lt;/h3&gt;

&lt;p&gt;过滤和转发的实现，依赖于&lt;strong&gt;交换机表（switch table）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;交换机表包含局域网上&lt;strong&gt;某些主机和路由器&lt;/strong&gt;的表项：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/2.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;例子：假设有一个目的地地址为DD-DD-DD-DD-DD-DD的帧从交换机接口x到达，交换机用该MAC地址索引交换机表。有3种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;表中没有对于DD-DD-DD-DD-DD-DD的表项。交换机向除了接口x外的所有接口广播该帧。广播前，实际是把帧放到接口的缓冲区。&lt;/li&gt;
&lt;li&gt;表中有一个表项将DD-DD-DD-DD-DD-DD与接口x联系起来。交换机丢失该帧。&lt;/li&gt;
&lt;li&gt;表中有一个表项将DD-DD-DD-DD-DD-DD与接口y（y!=x）联系起来。该帧被转发到与接口y相连的局域网网段，交换机通过将该帧放到接口y的输出缓冲区完成转发功能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;自学习&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;交换机表初始为空&lt;/li&gt;
&lt;li&gt;对于在每个接口接收到的每个入帧，该交换机在其表中存储：

&lt;ol&gt;
&lt;li&gt;帧里的源MAC地址&lt;/li&gt;
&lt;li&gt;该帧到达的接口&lt;/li&gt;
&lt;li&gt;当前时间&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;因为每条记录有时间戳，所以过期的记录会删除&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自学习性质使得交换机变成即插即用设备，不需要做配置。&lt;/p&gt;

&lt;h3&gt;交换机和路由器的区别&lt;/h3&gt;

&lt;p&gt;共同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;都是存储转发分组交换机&lt;/li&gt;
&lt;li&gt;有时候相互可替代&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;路由器使用网络层IP地址转发分组；交换机用MAC地址转发分组&lt;/li&gt;
&lt;li&gt;路由器是3层设备；交换机是2层设备&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各自特点优缺点：&lt;/p&gt;

&lt;p&gt;交换机特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MAC地址寻址扁平&lt;/li&gt;
&lt;li&gt;为了防止广播帧的循环，交换网络的活跃拓扑限制为一颗&lt;strong&gt;生成树&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交换机优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;即插即用&lt;/li&gt;
&lt;li&gt;具有相对高的分组过滤和转发速率（只需要处理高到2层的帧，而路由器高至3层）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交换机缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;交换机对于广播风暴并不提供任何保护措施，即某主机故障并传输无尽的以太网广播帧，交换机将转发所有这些帧，导致整个以太网崩溃&lt;/li&gt;
&lt;li&gt;所以如果没有生成树，会循环。而生成树限制了转发路径唯一。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;路由器优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;即使存在冗余路径，分组也不会循环&lt;/li&gt;
&lt;li&gt;没有生成树限制。允许以丰富的拓扑结构构建因特网，例如：欧洲与北美之间的多条活跃链路。&lt;/li&gt;
&lt;li&gt;对2层的广播风暴提供了防火墙保护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;路由器缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不是即插即用（但DHCP使得路由器可以自动分配IP）&lt;/li&gt;
&lt;li&gt;对每个分组的处理时间比交换机更长&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择策略：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通常，由几百台主机组成的小网络有几个局域网网段。对于这些小网络，交换机就足够了，&lt;strong&gt;因为它们不要求IP地址的任何配置就能使流量局部化并增加总计吞吐量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果是几千台主机，则需要路由器，因为&lt;strong&gt;路由器提供了更健壮的流量隔离方式和对广播风暴的控制，并在网络的主机之间使用更智能的路由&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/3.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/4.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;h2&gt;实例：web页面请求的历程&lt;/h2&gt;

&lt;p&gt;背景：Bob用以太网电缆将他的电脑连到学校的以太网交换机，交换机又与学校的路由器相连，路由器和一个ISP（comcast）相连；comcast为学校提供DNS服务，所以DNS服务器在comcast网络里；DHCP服务器运行在路由器中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.7/5.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;第1步：Bob电脑连接网络&lt;/h3&gt;

&lt;p&gt;刚连接时，Bob电脑没有本机IP，所以第一步是获得IP。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Bob电脑运行DHCP协议，生成&lt;strong&gt;DHCP请求报文&lt;/strong&gt;，并将这个报文放入一个&lt;strong&gt;UDP报文段&lt;/strong&gt;，UDP报文段的的目的地端口为67、源端口为68&lt;/li&gt;
&lt;li&gt;该UDP报文段进而被放置在一个&lt;strong&gt;IP数据报&lt;/strong&gt;中，数据报的目的地IP地址为255.255.255.255（广播地址）、源IP地址为0.0.0.0&lt;/li&gt;
&lt;li&gt;包含DHCP请求报文的IP数据报则被放置在以&lt;strong&gt;太网帧&lt;/strong&gt;中，以太网帧的目的MAC地址为FF:FF:FF:FF:FF:FF，这会使该帧广播到&lt;strong&gt;与交换机连接的所有设备&lt;/strong&gt;，源MAC地址为Bob电脑的MAC地址00:16:D3:23:68:8A&lt;/li&gt;
&lt;li&gt;该以太网帧是第一个由Bob电脑发送到以太网交换机的帧，该交换机在所有的出端口广播这个入帧&lt;/li&gt;
&lt;li&gt;路由器在它的具有MAC地址00:22:6B:45:1F:1B的接口收到该广播以太网帧(该帧中包含DHCP请求)，从该以太网帧中抽取出IP数据报。因为该IP数据报的目的地IP地址为广播地址，所以该IP数据报的载荷被分解向上到达UDP模块，DHCP请求报文从该UDP报文段中抽取出来，此时路由器即DHCP服务器有了DHCP请求报文&lt;/li&gt;
&lt;li&gt;假设路由器DHCP服务器能够以CIDR块68.85.2.0/24分配IP地址，DHCP服务器因此分配地址68.85.2.101给Bob电脑。&lt;/li&gt;
&lt;li&gt;除了分配IP地址，DHCP服务器还需要将DNS服务器的IP地址（68.87.71.226）、默认网关路由器的IP地址（68.85.2.1）、子网块（68.85.2.0/24）（子网掩码），这些东西组成一个DHCP ACK报文。&lt;/li&gt;
&lt;li&gt;该DHCP ACK报文被放入一个UDP报文段，UDP报文段被放入一个IP数据报，IP数据报被放入以太网帧中，这个以太网帧的源MAC地址是00:22:6B:45:1F:1B（归属网络的接口），目的地址是Bob电脑的MAC地址&lt;/li&gt;
&lt;li&gt;包含DHCP ACK的以太网帧由路由器发给交换机，因为交换机是自学习的，并且先前从Bob电脑收到DHCP请求报文以太网帧，所以该交换机知道寻址到00:16:D3:23:68:8A的帧仅从通向Bob电脑的端口转发。&lt;/li&gt;
&lt;li&gt;Bob电脑接收到包含DHCP ACK的以太网帧，从里面抽出DHCP ACK报文，Bob电脑的DHCP客户端记录下它的IP地址和DNS服务器的IP地址，另外，它还在IP转发表中安装默认网关的IP地址68.85.2.1，Bob电脑将向该网关发送目的地址为其子网68.85.2.0/24以外的所有数据报。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第2步：DNS和ARP（1）&lt;/h3&gt;

&lt;p&gt;Bob电脑初始化好它的网络组件后，准备访问一个google的网页。&lt;/p&gt;

&lt;p&gt;首先需要知道www.google.com的地址。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Bob电脑生成一个DNS查询报文，将字符串www.google.com放入DNS报文的问题段，DNS报文被放进一个UDP报文段，UDP目的地端口为53；UDP报文进而被放入一个IP数据报， IP数据报的目的地IP地址为68.87.71.226（DNS服务器的IP地址！），源IP地址为68.85.2.101&lt;/li&gt;
&lt;li&gt;Bob电脑把这个IP数据报放入一个以太网帧，该帧将发送到Bob学校网络中的网关路由器（因为不在同子网），但Bob电脑并不知道DNS服务器的MAC地址，Bob电脑为了获得该网关路由器的MAC地址，需要使用ARP协议。&lt;/li&gt;
&lt;li&gt;Bob电脑生成一个具有目的地IP地址为68.85.2.1（默认网关）的ARP查询报文，将该ARP报文放置在一个具有广播目的地址（FF:FF:FF:FF:FF:FF）、源MAC地址为00:16:D3:23:68:8A(Bob电脑)的以太网帧中，并向交换机发送该以太网帧，交换机将该帧广播到所有连接的设备，包括网关路由器。&lt;/li&gt;
&lt;li&gt;网关路由器在通往学校网络的接口上接收到包含该ARP查询报文的帧，发现在ARP报文中目标IP地址68.85.2.1匹配自己的接口的IP地址，网关路由器因此发送一个ARP应答，指示它的MAC地址00:22:6B:45:1F:1B，对应IP地址68.85.2.1。它将ARP回答放在一个以太网帧中，其目的地址为00:16:D3:23:68:8A(Bob电脑)，并向交换机发送该帧，再由交换机将帧交付给Bob电脑。&lt;/li&gt;
&lt;li&gt;Bob电脑接收到包含ARP应答报文的以太网帧，从中拿出网关路由器的MAC地址。&lt;/li&gt;
&lt;li&gt;此时，Bob电脑能够使包含DNS查询的以太网帧寻址到网关路由器的MAC地址。这个以太网帧的目的IP地址为68.87.71.226（DNS服务器）、MAC目的地址为00:22:6B:45:1F:1B（网关）。Bob电脑向交换机发送该帧，交换机将该帧交付网关路由器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;小结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bob电脑已知DNS服务器IP，所以发送DNS请求，因为DNS服务器不在同子网，所以得先把请求发到默认网关，然而又发现没有网关的MAC地址，所以只能先发起ARP查询；&lt;/li&gt;
&lt;li&gt;ARP查询返回应答时，Bob电脑就能继续向网关发送包含DNS查询的udp包，但此时DNS请求还没有到达DNS服务器，下面继续。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;第3步：DNS（2）&lt;/h3&gt;

&lt;p&gt;此时，网关路由器收到了来自Bob电脑的包含DNS查询的IP数据报。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;网关路由器查找该数据报的目的地址68.87.71.226（DNS服务器），并根据其&lt;strong&gt;转发表&lt;/strong&gt;决定该数据报应当发送到comcast网路中最左边的路由器。&lt;/li&gt;
&lt;li&gt;这个comcast路由器收到转发来的IP数据报，也查看数据报的目的IP地址，并根据本地转发表确定出口，朝着DNS服务器继续转发。转发表由域内协议（RIP、OSPF、IS-IS）和域间协议（BGP）填写。&lt;/li&gt;
&lt;li&gt;最终的，包含DNS查询的数据报到达了DNS服务器，DNS查询抽取出DNS查询报文，在自己的DNS数据库中查找名字www.google.com，找到包含对应www.google.com的IP地址（64.233.169.105）的&lt;strong&gt;DNS源记录&lt;/strong&gt;（这里假设了该记录已缓存在本机，源于权威DNS服务器）。&lt;/li&gt;
&lt;li&gt;DNS服务器生成一条包含主机名www.google.com到IP地址（64.233.169.105）的DNS回答报文，放入UDP、UDP放入到寻址到Bob电脑的IP数据报，该数据报通过comcast网络反向转发到学校的路由器，并从这里经过以太网交换机到Bob电脑。&lt;/li&gt;
&lt;li&gt;Bob电脑收到这条DNS应答报文，从中取出www.google.com的IP地址。此时就可以真正地访问google网站了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;第4步：Web客户端-服务器交互：TCP和HTTP&lt;/h3&gt;

&lt;p&gt;这一步就是传输层和应用层的事情了：tcp三次握手，tcp承载了HTTP协议。&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/network/</link>
        <guid isPermaLink="true">http://localhost:4000/network/</guid>
      </item>
    
      <item>
        <title>select和epoll多路复用用法总结</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;select&lt;/h2&gt;

&lt;p&gt;资料：&lt;a href=&quot;https://notes.shichao.io/unp/ch6/#select-function&quot;&gt;https://notes.shichao.io/unp/ch6/#select-function&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;struct fd_set，fd的集合&lt;/li&gt;
&lt;li&gt;FD_ZERO(fd_set *)， 清零一个fd_set，传fd_set的地址&lt;/li&gt;
&lt;li&gt;FD_SET(int fd, fdset *)，把fd添加到这个fd_set&lt;/li&gt;
&lt;li&gt;FD_CLR(int fd, fdset *)，把fd移出这个fd_set&lt;/li&gt;
&lt;li&gt;int FD_ISSET(int fd, fd_set *fdset); 查询fd是否在这个fd_set&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;核心函数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;返回值：&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;&amp;lt;0：出错&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;0：select超时返回了，没有读、写事件&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;&amp;gt;0：有事件发生的fd数量&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;maxfdp：是最大的fd再加1！&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;readfds、writefds、errorfds是值-结果参数，调用的时候作为值语义参数，函数返回的时候作为结果，所以没有const修饰&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;readfds：   要监听读事件的fd集合   /    有读事件的fd集合&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;writefds：  要监听写事件的fd集合   /    有写事件的fd集合&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;errorfds：  错误事件，一般传null即可&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxfdp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writefds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errorfds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用法要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按读、写声明2个fd_set：rfds、wfds&lt;/li&gt;
&lt;li&gt;需要再声明2个读、写fd_set，用于存放第一步的fd_set的拷贝，用于select：_rfds、_wfds&lt;/li&gt;
&lt;li&gt;用FD_SET和FD_CLR控制要监听哪个fd的读、写事件&lt;/li&gt;
&lt;li&gt;调用select前，要先复制一份fd_set，用memcpy即可&lt;/li&gt;
&lt;li&gt;调用select：retval = select(eventLoop-&amp;gt;getMaxFd() + 1, &amp;amp;_rfds, &amp;amp;_wfds, NULL, tvp);&lt;/li&gt;
&lt;li&gt;如果retval&amp;gt;0，就遍历所有fd（[0, maxfd]），用FD_ISSET(fd, _rfds)，判断这个fd是否可读，写事件同理&lt;/li&gt;
&lt;li&gt;到此就完成一次循环，做完其他逻辑后，回到第4步&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;select是基于位掩码的设计，所以fd_set有固定长度。长度由FD_SETSIZE确定，FD_SETSIZE可以用户自己定。默认只有1024。&lt;/p&gt;

&lt;h2&gt;epoll&lt;/h2&gt;

&lt;h3&gt;创建epfd&lt;/h3&gt;

&lt;p&gt;epoll_create1(0)，创建一个epfd，epoll所有接口都会用到它，它也是个文件描述符，持有资源&lt;/p&gt;

&lt;h3&gt;添加监听事件&lt;/h3&gt;

&lt;p&gt;需要区分是首次添加还是修改操作（用户自己要做记录），op = EPOLL_CTL_ADD或者EPOLL_CTL_MOD。&lt;/p&gt;

&lt;p&gt;然后创建一个epoll_event ee，如果需要监听读事件就执行ee.events |= EPOLLIN，写事件就 ee.events |= EPOLLOUT；然后要登记目标fd到ee里，ee.data.fd = fd。&lt;/p&gt;

&lt;p&gt;ee准备好后，就可以调用epoll_ctl(epfd, op, fd, &amp;amp;ee)。&lt;/p&gt;

&lt;p&gt;epoll_ctl返回值：0是成功；-1失败，errno记录错误类型。&lt;/p&gt;

&lt;h3&gt;删除监听事件&lt;/h3&gt;

&lt;p&gt;和添加监听事件类似，也是构造ee，也要设置ee.data.fd，最终调用epoll_ctl。&lt;/p&gt;

&lt;p&gt;op的就有点不一样，如果已经没有任何要监听的事件了，那么op是EPOLL_CTL_DEL；如果至少有监听某种事件，那么用EPOLL_CTL_MOD。&lt;/p&gt;

&lt;p&gt;需要注意的是，即使是删除监听事件，epoll_ctl一个参数都不能少。&lt;/p&gt;

&lt;h3&gt;轮询&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;epoll_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;timeout：-1，永久阻塞；0，立即返回，不阻塞； &amp;gt;0，阻塞多少毫秒后返回
events和maxevents：就是指定一块数组用来存epoll_wait的返回结果，maxevents就是这个数组的长度。&lt;/p&gt;

&lt;p&gt;如果返回值（numevents）大于0，那么就可以遍历events，遍历上限为numevents，逐个epoll_event访问它的events变量，看含有什么事件。也就是说，epoll_wait只返回了有事件的fd集合，比select要高效。&lt;/p&gt;

&lt;h3&gt;底层特点&lt;/h3&gt;

&lt;p&gt;epfd被创建时，会相应地创建一个eventpoll结构体：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&lt;span&gt;&lt;/span&gt;struct eventpoll {  
    /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/  
    struct rb_root  rbr;  
    /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/  
    struct list_head rdlist;    
};  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;eventpoll可理解为存了2个数据结构的头部指针，一个指向一个红黑树的根，一个指向双向链表的头。&lt;/p&gt;

&lt;p&gt;只要某个fd的某个事件被监听中，就会存在和这个fd关联的一个epitem:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epitem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rb_node&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;rbn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//红黑树节点  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;rdllink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//双向链表节点  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_filefd&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ffd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//事件句柄信息  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eventpoll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//指向其所属的eventpoll对象  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoll_event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//期待发生的事件类型  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;红黑树中的每个节点都等同于某个epitem的rbn对象指针；双向链表的每个节点都等同于某个epitem的rdllink指针。&lt;/p&gt;

&lt;p&gt;所以epitem应该是一个内存连接的数组，而红黑树和双向链表用指针的方式和这个数组产生联系。&lt;/p&gt;

&lt;p&gt;为什么高效：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当监听的事件发生时，会回调ep_poll_callback，把事件信息添加到双向链表rdlist&lt;/li&gt;
&lt;li&gt;当调用epoll_wait检查是否有事件发生时，只需检查eventpoll的rdlist链表中是否有epitem元素即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1、2点已经凸显了epoll_wait的高效，这是一种基于驱动回调的技术，epoll_wait的成本只是获取这个rdlist而已。&lt;/p&gt;

&lt;p&gt;另外，为了保证不会重复添加同个fd的epitem，只能遍历内核的epitem数组，但这是个O(n)的操作，所以就需要红黑树，可以快速找出某个fd是否已被监听，并且也用于快速找到epitem从而修改fd的监听事件。这可是log(n)的复杂度，性能大大提高。&lt;/p&gt;

&lt;h3&gt;总结：&lt;/h3&gt;

&lt;p&gt;epoll是在内核维护复杂数据结构的设计，用户态的接口就相对复杂一些，但可控制性高一点；另外利用了回调技术，就不需要主动去查询每个fd是否有事件，效率自然就高了。&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/multiplexing/</link>
        <guid isPermaLink="true">http://localhost:4000/multiplexing/</guid>
      </item>
    
      <item>
        <title>C++ STL的一些笔记</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;set和multiset&lt;/h2&gt;

&lt;p&gt;set有去重；multiset无去重。&lt;/p&gt;

&lt;p&gt;multiset可以用来做计时器容器，因为计时器需要按时间排序，而时间戳可能会出现相同的，即同一时刻添加了2个定时任务。&lt;/p&gt;

&lt;p&gt;使用set和multiset的易错点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;存储的元素需要是const含义的，即添加到容器后，原则上是不能修改的。原因是排序需要。如果添加到容器后用户还能修改容器元素，那么应触发某种全排序，否则容器有序性就丢失了。&lt;/li&gt;
&lt;li&gt;然而容器没有办法保证用户不可修改元素，所以容易用错。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个易错点，只能好好记住了，不然迟早酿成bug。如果一定要在添加元素后，对这个元素做修改，那么需要先erase然后再insert回去。&lt;/p&gt;

&lt;p&gt;另外的问题是，容器和智能指针结合使用时的易错点。&lt;/p&gt;

&lt;p&gt;当元素为shared_ptr&lt;T&gt;包装的类实例时，直接放进(multi)set就有2个潜在问题，一是容器排序的依据是shared_ptr，而不是T，这是很容易误解的，解决这个问题的办法是声明容器时添加一个Comparator参数，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Compare&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;multiset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样子写才会真正地按照T的定义去排序。&lt;/p&gt;

&lt;p&gt;然而还有个细节问题：用于容器的Compare或者说operator&amp;lt;，必须满足&lt;strong&gt;strict weak ordering&lt;/strong&gt;。这个概念会贯穿整个STL。&lt;/p&gt;

&lt;p&gt;这个东西简单理解就是说，类T必须实现operator&amp;lt;，从而容器sort元素的时候，可以用这个operator&amp;lt;实现==、&amp;gt;比较。&lt;/p&gt;

&lt;p&gt;为什么一个&amp;lt;就能实现==呢？这是用了一个有趣的技巧： a==b 可认为等价于 !(a &amp;lt; b) &amp;amp;&amp;amp; !(b &amp;lt; a)。&lt;/p&gt;

&lt;p&gt;对于只有单个属性的T来说，实现strict weak ordering很简单，只要operator&amp;lt;里写一行a.x &amp;lt; a.x就行了。&lt;/p&gt;

&lt;p&gt;对于一个有复合属性的类T，operator&amp;lt;需要小心一点，但也是大同小异。例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeEvent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;逆序排序的话，&amp;lt;的结果取反即可。所以总之遇到(multi)set排序，重载operator&amp;lt;就对了。&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/cpp-8/</link>
        <guid isPermaLink="true">http://localhost:4000/cpp-8/</guid>
      </item>
    
      <item>
        <title>漫谈网络通讯加密（1）加密学算法之RSA</title>
        <description>&lt;p&gt;首先强推大神的文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&quot;&gt;RSA算法原理（一）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&quot;&gt;RSA算法原理（二）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;（Note：里面有些图片要上梯子才能加载，chart.googleapis.com，你懂得）&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;RSA加密/解密&lt;/h1&gt;

&lt;h2&gt;需要用到的数论知识&lt;/h2&gt;

&lt;h3&gt;每个正整数n都能够被分解成多个质数的乘积&lt;/h3&gt;

&lt;p&gt;\[ n = p_{1}^{ a_{1} } p_{2}^{ a_{2} } \cdots p_{k}^{ a_{k} }  \]&lt;/p&gt;

&lt;p&gt;这个分解是唯一的。不过质因子的乘积顺序可以变。质因子可以重复出现。&lt;/p&gt;

&lt;h3&gt;全等关系式&lt;/h3&gt;

&lt;p&gt;当2个整数a、b的差等于k个整数n的积时（k可以是任意整数）:&lt;/p&gt;

&lt;p&gt;\[ a - b = kn \]&lt;/p&gt;

&lt;p&gt;可以写成：&lt;/p&gt;

&lt;p&gt;\[a \equiv b (mod \ n) \]&lt;/p&gt;

&lt;p&gt;例如a = 9，b = 1，n = 4时，有:&lt;/p&gt;

&lt;p&gt;\[ a - b = 9 - 1 = 2 \cdot 4 \]&lt;/p&gt;

&lt;p&gt;\[ 9 \equiv 1 (mod \ 4) \]&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler_function&quot;&gt;欧拉函数(Euler&amp;#39;s function)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;\[ \phi (n) = \prod _{k=1}^{ \infty } ( 1 - n^{k} ) \]&lt;/p&gt;

&lt;p&gt;\( \phi (n) \)的含义是：在小于等于n的正整数之中，有\( \phi (n) \)个数与n构成互质关系。&lt;/p&gt;

&lt;p&gt;这条公式深究起来是蛮复杂的。简单地去理解，其实是这么一个公式：&lt;/p&gt;

&lt;p&gt;\[ \phi (n) = n ( 1 - \frac{ 1 }{ p_{1} } ) ( 1 - \frac{ 1 }{ p_{2} } ) \cdots ( 1 - \frac{ 1 }{ p_{k} } )  \]&lt;/p&gt;

&lt;p&gt;\( p_{1} \ p_{2} \cdots p_{k} \) 就是上文说的质因数分解了。注意，这些质数是不能重复的，每个不同的p只会在\(\phi (n) \)公式里出现一次。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;特殊情况1&lt;/strong&gt;，当n为质数时，质因数分解得到1和n，1不算，那么\( \phi (n) \)简化成：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ \phi (n) = n ( 1 - \frac{ 1 }{ n } )  \]&lt;/p&gt;

&lt;p&gt;\[ \phi (n) = n  - \frac{ n }{ n }  = n - 1 \]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;特殊情况2&lt;/strong&gt;，当n为2个质数p、q的积时：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ \phi (n) = \phi (pq) = (pq) ( 1 - \frac{ 1 }{ p } ) ( 1 - \frac{ 1 }{ q} )   \]&lt;/p&gt;

&lt;p&gt;\[ \phi (pq) = ( p - \frac{ p }{ p } ) ( q - \frac{ q }{ q} )   \]&lt;/p&gt;

&lt;p&gt;\[ \phi (pq) = ( p - 1 ) ( q - 1 )   \]&lt;/p&gt;

&lt;p&gt;资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://artofproblemsolving.com/wiki/index.php?title=Euler%27s_totient_function&quot;&gt;https://artofproblemsolving.com/wiki/index.php?title=Euler%27s_totient_function&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/eulers-totient-function/&quot;&gt;https://www.geeksforgeeks.org/eulers-totient-function/&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler%27s_theorem&quot;&gt;欧拉定理(Euler&amp;#39;s theorem)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;对于任意的互质的2个正整数a和n，都满足以下全等关系式：&lt;/p&gt;

&lt;p&gt;\[ a^{\phi (n) } \equiv 1 (mod \ n) \]&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fermat%27s_little_theorem&quot;&gt;费马小定理(Fermat&amp;#39;s little theorem)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;这个是欧拉定理的特殊情况：若正整数n还是个质数，把n记为p，那么有：&lt;/p&gt;

&lt;p&gt;\[ \phi (p) = p - 1 \]&lt;/p&gt;

&lt;p&gt;代入欧拉定理公式，得到：&lt;/p&gt;

&lt;p&gt;\[ a^{ p - 1 } \equiv 1 (mod \ p) \]&lt;/p&gt;

&lt;p&gt;这就是费马小定理。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_multiplicative_inverse&quot;&gt;模逆元(Modular multiplicative inverse)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;当2个正整数a和n互质时（Note：a、n本身不一定是质数），必然存在一个整数x，使得：&lt;/p&gt;

&lt;p&gt;\[ ax \equiv 1 (mod \ n) \]&lt;/p&gt;

&lt;p&gt;x就是所谓的模逆元。另外限定x取值范围为[0, n-1]，就使得&lt;strong&gt;模逆元x是唯一的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;x的存在性证明：&lt;/p&gt;

&lt;p&gt;可以用欧拉定理来证明，因为a和n互质，所以有：&lt;/p&gt;

&lt;p&gt;\[ a^{\phi (n) } \equiv 1 (mod \ n) \]&lt;/p&gt;

&lt;p&gt;对左边转换一下：&lt;/p&gt;

&lt;p&gt;\[ a\cdot a^{\phi (n) - 1 } \equiv 1 (mod \ n) \]&lt;/p&gt;

&lt;p&gt;显然，模逆元x的其中一个解等于：&lt;/p&gt;

&lt;p&gt;\[ x = a^{\phi (n) - 1 } \]&lt;/p&gt;

&lt;p&gt;这个解可能会超过限定范围，得做模运算才能得到真正的模逆元：&lt;/p&gt;

&lt;p&gt;\[ x = a^{\phi (n) - 1 } (mod \ n) \]&lt;/p&gt;

&lt;p&gt;直接用这条公式计算x，据说比较慢，更快速的算法是用&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm&quot;&gt;扩展欧几里得算法&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;中文wiki有更详细的例子：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95&quot;&gt;扩展欧几里得算法&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;RSA加密解密原理&lt;/h2&gt;

&lt;h3&gt;准备&lt;/h3&gt;

&lt;p&gt;用户首先任意选择2个质数p、q，并计算p、q乘积n：&lt;/p&gt;

&lt;p&gt;\[ n = pq \]&lt;/p&gt;

&lt;p&gt;然后应用欧拉定理的特殊情况2公式：&lt;/p&gt;

&lt;p&gt;\[ \phi (n) = (p - 1)(q - 1) \]&lt;/p&gt;

&lt;p&gt;这2个值算出来时，就可以&lt;strong&gt;彻底删除p、q&lt;/strong&gt;了。后面的计算步骤和原始的p、q无关。&lt;/p&gt;

&lt;p&gt;接着，用户随机选择一个正整数e，e的取值范围为\( [1, \phi (n)] \)。&lt;/p&gt;

&lt;p&gt;e确定后，计算关于\( e、\phi (n) \)的模逆元d：&lt;/p&gt;

&lt;p&gt;\[ ed \equiv 1 (mod \ \phi (n) ) \]&lt;/p&gt;

&lt;p&gt;此时，用户总共持有4个对象：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;\( n \)&lt;/li&gt;
&lt;li&gt;\( \phi (n) \)&lt;/li&gt;
&lt;li&gt;\( e \)&lt;/li&gt;
&lt;li&gt;\( d \)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中的(e、n)组成了RSA算法的公钥；(d, n)组成了私钥。&lt;/p&gt;

&lt;p&gt;现在举个栗子来理解上面的流程：&lt;/p&gt;

&lt;p&gt;假设p、q分别为61、53，则\(n、\phi (n) \)分别等于：&lt;/p&gt;

&lt;p&gt;\( n = 61 \cdot 53 = 3233\)&lt;/p&gt;

&lt;p&gt;\( \phi (n) = (61 - 1) (53 - 1) = 3120 \)&lt;/p&gt;

&lt;p&gt;e选择17（在范围[1,3120]内即可），并算出d：&lt;/p&gt;

&lt;p&gt;\( d = 2753 \)&lt;/p&gt;

&lt;p&gt;（用扩展欧几里得算法计算得到）&lt;/p&gt;

&lt;p&gt;所以公钥为(17, 3233)，私钥为(2753, 3233)。&lt;/p&gt;

&lt;h3&gt;加密&lt;/h3&gt;

&lt;p&gt;假设用户A把公钥(e,n)给到用户B，让用户B给他发送一个原文信息m，m为一个数字。&lt;/p&gt;

&lt;p&gt;原文m的加密过程如下：&lt;/p&gt;

&lt;p&gt;\[ m^{e} \equiv c ( mod \ n) \]&lt;/p&gt;

&lt;p&gt;用上面的例子来理解：假设m为65，公钥为(e,n)(17, 3233)，则有：&lt;/p&gt;

&lt;p&gt;\[ 65^{17} \equiv 2790 (mod \ 3233) \]&lt;/p&gt;

&lt;p&gt;密文c等于2790。&lt;/p&gt;

&lt;h3&gt;解密&lt;/h3&gt;

&lt;p&gt;解密流程就不太好理解了，先搬出公式：&lt;/p&gt;

&lt;p&gt;\[ c^{d} \equiv m (mod \ n) \]&lt;/p&gt;

&lt;p&gt;代入密文c 2790和私钥(d,n)(2753, 3233)，算出原文m：&lt;/p&gt;

&lt;p&gt;\[ 2790^{2753} \equiv 65 (mod \ 3233) \]&lt;/p&gt;

&lt;p&gt;这样就算出了原文m，是不是和变魔术一样。&lt;/p&gt;

&lt;h3&gt;分析小结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;因为要对原文m做模n运算，意味着原文m是不能超过n的，不然取模前后的值是不一致的，就达不到加密解密效果&lt;/li&gt;
&lt;li&gt;解决办法是对原文m切成多段m1、m2、m3，每一段都小于n，对每一小段加解密（分组加密）&lt;/li&gt;
&lt;li&gt;另一种办法是，不直接用RSA对原文加解密，而是用别的对称加密算法如AES对原文加解密，RSA只用来加密AES对称密钥&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;解密公式的数学依据&lt;/h3&gt;

&lt;p&gt;前面的内容，并没有提到为什么以下这条公式可以保证解出原文m：&lt;/p&gt;

&lt;p&gt;\[ c^{d} \equiv m (mod \ n) \]&lt;/p&gt;

&lt;p&gt;这需要做一番推导才能理解。&lt;/p&gt;

&lt;p&gt;首先，搬出加密公式：&lt;/p&gt;

&lt;p&gt;\[ m^{e} \equiv c ( mod \ n) \]&lt;/p&gt;

&lt;p&gt;从加密公式开始推导（以下等式都隐含\(mod \ n\)操作）：&lt;/p&gt;

&lt;p&gt;\[ c \equiv m^{e}  \]
\[ c^{d} \equiv m^{ed} \]
\[ c^{d} \equiv m^{1 + k(p - 1)(q - 1) } \]
\[ c^{d} \equiv m\cdot m^{ k(p - 1)(q - 1) } \]
\[ c^{d} \equiv m\cdot (m^{ (p - 1)(q - 1) })^{ k } \]
\[ c^{d} \equiv m\cdot (1)^{ k } \]
\[ c^{d} \equiv m\]&lt;/p&gt;

&lt;p&gt;得证 \( c^{d} \equiv m (mod \ n)\)&lt;/p&gt;

&lt;p&gt;其中不好理解的是第2行到第3行、第5行到第6行。&lt;/p&gt;

&lt;p&gt;第2行到第3行的原理：&lt;/p&gt;

&lt;p&gt;\[ ed \equiv 1 (mod \ \phi (n) ) \]&lt;/p&gt;

&lt;p&gt;\[ ed = 1 + k\phi (n) \]&lt;/p&gt;

&lt;p&gt;\[ ed = 1 + k(p - 1)(q - 1) \]&lt;/p&gt;

&lt;p&gt;第5行到第6行的原理是欧拉定理：&lt;/p&gt;

&lt;p&gt;\[ m^{\phi (n) } \equiv 1 (mod \ n) \]&lt;/p&gt;

&lt;p&gt;\[ m^{ (p - 1)(q - 1) } \equiv 1 (mod \ n) \]&lt;/p&gt;

&lt;h3&gt;RSA算法的可靠性保证&lt;/h3&gt;

&lt;p&gt;公钥是(e,n)，私钥是(d,n)，攻击者唯一能知道的只有公钥(e,n)，那么攻击者是否能算出d，得到私钥(d,n)呢？&lt;/p&gt;

&lt;p&gt;破解d的思路：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;\( ed \equiv 1 (mod \ \phi (n) ) \)，只有知道e和\(\phi (n) \)，才能算出d；&lt;/li&gt;
&lt;li&gt;而 \( \phi (n) = (p - 1)(q - 1) \)，只有知道p和q，才能算出\(\phi (n) \)；&lt;/li&gt;
&lt;li&gt;而 pq = n。只有对n做质因数分解，才能算出p和q。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，能否在短时间内对n做分解得到p、q，是RSA算法是否可靠的关键。目前来说，还没有快速地求质因数分解的算法。&lt;/p&gt;

&lt;h3&gt;针对RSA加密/解密的攻击问题&lt;/h3&gt;

&lt;p&gt;上面的加密解密公式：&lt;/p&gt;

&lt;p&gt;\[ m^{e} \equiv c ( mod \ n) \]&lt;/p&gt;

&lt;p&gt;\[ c^{d} \equiv m (mod \ n) \]&lt;/p&gt;

&lt;p&gt;可以用函数R表达：&lt;/p&gt;

&lt;p&gt;\[ c = R(m, e) \]&lt;/p&gt;

&lt;p&gt;\[ m = R(c, d) \]&lt;/p&gt;

&lt;p&gt;对于同一个RSA加密解密函数，输入同样的原文，就会输出同样的密文，这就给了攻击者可乘之机。攻击者如果观察到有2个密文是一样的，就有可能推导出关于此次通讯的更多信息。&lt;/p&gt;

&lt;p&gt;解决办法是增加前后处理：&lt;/p&gt;

&lt;p&gt;\[ c = R(preprocess(m), e) \]&lt;/p&gt;

&lt;p&gt;\[ m = postprocess(R(c, d)) \]&lt;/p&gt;

&lt;p&gt;这种前后处理方法被叫做padding schemes，但并不只是做padding。&lt;/p&gt;

&lt;p&gt;这类方法最常见的是&lt;a href=&quot;https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding&quot;&gt;OAEP&lt;/a&gt;，optimal asymmetric encryption padding（1994年）：&lt;/p&gt;

&lt;p&gt;OAEP-pre(m): &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;r = random nonce &lt;/li&gt;
&lt;li&gt;X = (m || 00...0) XOR G(r) // pad m with zeros &lt;/li&gt;
&lt;li&gt;Y = r XOR H(X) &lt;/li&gt;
&lt;li&gt;output：m&amp;#39; = X || Y&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OAEP-post(m&amp;#39;): &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;split m&amp;#39; into X || Y &lt;/li&gt;
&lt;li&gt;r = Y XOR H(X) &lt;/li&gt;
&lt;li&gt;(m || 00...0) = X XOR G(r) &lt;/li&gt;
&lt;li&gt;output m&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;G、H是典型的某种加密学哈希函数。&lt;/p&gt;

&lt;p&gt;综上，RSA-PAEP的加密解密公式如下：&lt;/p&gt;

&lt;p&gt;\[ c = R(OAEPpre(m), e) = R(m&amp;#39;, e)  \]&lt;/p&gt;

&lt;p&gt;\[ m = OAEPpost(R(c, d)) = OAEPpost(m&amp;#39;) \]&lt;/p&gt;

&lt;p&gt;wiki的这张图非常清晰地诠释了OAEP的处理过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2018.4/oaep.png&quot; alt=&quot;oaep.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;参考资料：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://certauth.epfl.ch/rsa/&quot;&gt;https://certauth.epfl.ch/rsa/&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;RSA数字签名&lt;/h1&gt;

&lt;h2&gt;RSA数字签名就是RSA加密的逆&lt;/h2&gt;

&lt;p&gt;签名过程，用私钥k加密原文m：&lt;/p&gt;

&lt;p&gt;\[ c = R(m,k) \]&lt;/p&gt;

&lt;p&gt;验证签名过程，用公钥解密密文c得到m&amp;#39;，验证m&amp;#39;是否等于m：&lt;/p&gt;

&lt;p&gt;\[ R(c,K) == m \]&lt;/p&gt;

&lt;p&gt;只有持有私钥的人才可以做签名，每个获得公钥的人都可以做验证。签名/验证签名的一个特点是，原文m是暴露的，没有秘密可言。&lt;/p&gt;

&lt;h2&gt;RSA签名的问题&lt;/h2&gt;

&lt;h3&gt;原文m长度超过上限n&lt;/h3&gt;

&lt;p&gt;此时，可以对m做哈希，算出来的摘要控制在n长度内：&lt;/p&gt;

&lt;p&gt;\[ c = R(H(m), k) \]&lt;/p&gt;

&lt;p&gt;\[ c = R(s, K) == H(m) \]&lt;/p&gt;

&lt;p&gt;里面H可以用上面的OAEP里的H算法。&lt;/p&gt;

&lt;p&gt;然而这个流程也只是最简单的RSA数字签名方案，还有更完善的PSS。&lt;/p&gt;

&lt;h2&gt;RSA-PSS&lt;/h2&gt;

&lt;p&gt;RSA-PSS（Probabilistic Signature Scheme），基于概率的RSA数字签名方案。&lt;/p&gt;

&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cs.cornell.edu/courses/cs5430/2015sp/notes/rsa_sign_vs_dec.php&quot;&gt;https://www.cs.cornell.edu/courses/cs5430/2015sp/notes/rsa_sign_vs_dec.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34911465/article/details/78790377&quot;&gt;https://blog.csdn.net/qq_34911465/article/details/78790377&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pdfs.semanticscholar.org/b459/5fffe0562776a2830c7b525ba9f641110d7a.pdf&quot;&gt;https://pdfs.semanticscholar.org/b459/5fffe0562776a2830c7b525ba9f641110d7a.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mrpre/article/details/81118423&quot;&gt;https://blog.csdn.net/mrpre/article/details/81118423&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/crypto-1-rsa/</link>
        <guid isPermaLink="true">http://localhost:4000/crypto-1-rsa/</guid>
      </item>
    
  </channel>
</rss>