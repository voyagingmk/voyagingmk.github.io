<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wyman的技术博客</title>
    <description>伪技术宅，兴趣点：服务器编程、游戏开发、人工智能</description>
    <link>http://www.qiujiawei.com</link>
    <atom:link href="http://www.qiujiawei.com/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>最小二乘估计(Least Squares Estimator)的公式的推导</title>
        <description>&lt;!--more--&gt;

&lt;p&gt;最近在学习ML(machine learning)，注意到了一个有趣的东西：(最小二乘估计)[&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_least_squares_(mathematics)%5D%E3%80%82&quot;&gt;https://en.wikipedia.org/wiki/Linear_least_squares_(mathematics)]。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先从简单说起吧。看下面的式子：&lt;/p&gt;

&lt;p&gt;\[ y = ax + e \]&lt;/p&gt;

&lt;p&gt;这是一个非常简单的直线方程。如果赋予y、a、x、b具体的意义，这个式子就有意思了：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;假设x是一个统计变量（预先就知道的），譬如，x代表人的年龄。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设y是关于x的一个label量（预先就知道的），譬如，y代表的是年龄为x时的人的智商。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假设y和x存在线性关系，那么可以有 y = ax。这个式子表明年龄为x时，智商为ax。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当x、y的取值只有一对时，a = y/x，但当x、y不只一对时，y = ax可能会无解（因为求解的是方程组 \( y_{i} = ax_{i} \) 了）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了使方程组 \( y_{i} = ax_{i} \) 可以求解，需要把方程组扩展成 \( y_{i} = ax_{i} + e_{i} \) 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\( y_{i} = ax_{i} + e_{i} \)使得我们有机会求出a，但同时也产生了很多个\( e_{i} \)。每对&lt;y,x&gt;都有它自己的error系数的话，这个a的意义就减弱了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了使得a变得更有意义，我们希望每个error系数尽可能地小（无限逼近0最好了），同时又能求出唯一的a。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;又因为现实生活中，智商肯定不只跟年龄x有关系，还和其他参数有关系，那么可以再把公式扩展成:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;\[ y_{i} = a_{1}x_{i1} + a_{2}x_{i2} + \cdots + a_{k}x_{ik} + e_{i} , 1\le i\le n, k\ge 1 \]&lt;/p&gt;

&lt;p&gt;现在，把上式写成矩阵形式：&lt;/p&gt;

&lt;p&gt;\[ \vec y = X\vec a + \vec e \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} y_{1}\\ y_{2}\\ \vdots \\ y_{n}\\ \end{matrix} \right] =  \left[ \begin{matrix} x_{11}&amp;amp;x_{12}&amp;amp;\cdots &amp;amp;x_{1k}\\    x_{21}&amp;amp;x_{22}&amp;amp;\cdots &amp;amp;x_{2k}\\    \vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots \\   x_{n1}&amp;amp;x_{n2}&amp;amp;\cdots &amp;amp;x_{nk}\\ \end{matrix} \right] \left[ \begin{matrix} a_{1}\\ a_{2}\\ \vdots \\ a_{k}\\ \end{matrix} \right] +  \left[ \begin{matrix} e_{1}\\ e_{2}\\ \vdots \\ e_{n}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;再回到上面的第7点：为了使得\(\vec a\)变得更有意义，我们希望\(\vec e\)的每个分量尽可能地小。明确这一点非常重要。&lt;/p&gt;

&lt;p&gt;那么，这个目标完成情况应该如何衡量？其实很简单，既然\(\vec e\)是一个向量（n维空间），那么\(\vec e\)的长度就是我们需要的指标：&lt;/p&gt;

&lt;p&gt;\[ |\vec e| = \sqrt { \sum ^{n}_{i=1}e_{i}^{2} } \]&lt;/p&gt;

&lt;p&gt;开根号是不必要的，我们可以换成下面这个指标：&lt;/p&gt;

&lt;p&gt;\[ |\vec e|^{2} = \sum ^{n}_{i=1}e_{i}^{2} = \vec e\vec e = \vec e^{T}\vec e \]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;小结一下：当\( \vec e^{T}\vec e \)取得最小值时，\(\vec a\)能取得最优解。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;继续推导。&lt;/p&gt;

&lt;p&gt;由上文可知：&lt;/p&gt;

&lt;p&gt;\( \vec e = \vec y - X\vec a \)&lt;/p&gt;

&lt;p&gt;\( \vec e^{T} = (\vec y - X\vec a)^{T} \)&lt;/p&gt;

&lt;p&gt;\( \vec e^{T}\vec e = (\vec y - X\vec a)^{T}(\vec y - X\vec a)  \)&lt;/p&gt;

&lt;p&gt;\( = (\vec y^{T} - \vec a^{T}X^{T})(\vec y - X\vec a)  \)&lt;/p&gt;

&lt;p&gt;\( = \vec y^{T}\vec y - \vec a^{T}X^{T}\vec y - \vec y^{T}X\vec a + \vec a^{T}X^{T}X\vec a \)&lt;/p&gt;

&lt;p&gt;注意，中间的2个子项是可以合并的。首先，仔细观察\( \vec a^{T}X^{T}\vec y \)这个子项，发现它是一个&lt;strong&gt;值&lt;/strong&gt;，那么就有：&lt;/p&gt;

&lt;p&gt;\( \vec a^{T}X^{T}\vec y  = (\vec a^{T}X^{T}\vec y)^{T} \)&lt;/p&gt;

&lt;p&gt;（一个数值可认为是一个1维的方阵，1维方阵的转置矩阵是它本身）&lt;/p&gt;

&lt;p&gt;而又有：&lt;/p&gt;

&lt;p&gt;\( (\vec a^{T}X^{T}\vec y)^{T} = \vec y^{T}(\vec a^{T}X^{T})^{T} \)&lt;/p&gt;

&lt;p&gt;\( = \vec y^{T}(X\vec a) = \vec y^{T}X\vec a  \)&lt;/p&gt;

&lt;p&gt;得：&lt;/p&gt;

&lt;p&gt;\( \vec a^{T}X^{T}\vec y  = \vec y^{T}X\vec a  \)&lt;/p&gt;

&lt;p&gt;所以上面的方程可变为：&lt;/p&gt;

&lt;p&gt;\[ \vec e^{T}\vec e = \vec y^{T}\vec y - 2\vec y^{T}X\vec a + \vec a^{T}X^{T}X\vec a \]&lt;/p&gt;

&lt;p&gt;如何让\( \vec e^{T}\vec e \)取得最小值？此时需要使用新的招数：矩阵微分。&lt;/p&gt;

&lt;h2&gt;矩阵微分&lt;/h2&gt;

&lt;p&gt;介绍下矩阵微分公式：&lt;/p&gt;

&lt;p&gt;设：&lt;/p&gt;

&lt;p&gt;\[ \vec y = A\vec x \]&lt;/p&gt;

&lt;p&gt;y是一个\(m \times 1\)的矩阵，A是一个\(m \times n\)的矩阵，x是一个\(n \times 1\)的矩阵。&lt;/p&gt;

&lt;p&gt;则有：&lt;/p&gt;

&lt;p&gt;\[ \frac {\partial \vec y}{\partial \vec x} = A 【公式1】 \]&lt;/p&gt;

&lt;p&gt;这是如何得到的呢？实际上超级简单，上面这个式子指的是，\(\vec y \)的每一个分量对\(\vec x \)的每一个分量的微分，结果显然就是一个\(m \times n\)矩阵。&lt;/p&gt;

&lt;p&gt;扩展公式：&lt;/p&gt;

&lt;p&gt;设：&lt;/p&gt;

&lt;p&gt;\[ \alpha = \vec y^{T}A\vec x \]&lt;/p&gt;

&lt;p&gt;则有：&lt;/p&gt;

&lt;p&gt;\[ \frac {\partial \alpha }{\partial \vec x} = \vec y^{T}A  【公式2】 \]&lt;/p&gt;

&lt;p&gt;\[ \frac {\partial \alpha }{\partial \vec y} = \vec x^{T}A^{T}  【公式3】 \]&lt;/p&gt;

&lt;p&gt;设：&lt;/p&gt;

&lt;p&gt;\[ \alpha = \vec x^{T}A\vec x \]&lt;/p&gt;

&lt;p&gt;且A是对称矩阵，&lt;/p&gt;

&lt;p&gt;则有：&lt;/p&gt;

&lt;p&gt;\[ \frac {\partial \alpha }{\partial \vec x} = 2\vec x^{T}A  【公式4】 \]&lt;/p&gt;

&lt;h2&gt;应用矩阵微分公式&lt;/h2&gt;

&lt;p&gt;再来看下刚才的\( \vec e^{T}\vec e  \)方程：&lt;/p&gt;

&lt;p&gt;\[ \vec e^{T}\vec e  = \vec y^{T}\vec y - 2\vec y^{T}X\vec a + \vec a^{T}X^{T}X\vec a \]&lt;/p&gt;

&lt;p&gt;对等号右边的式子求关于\(\vec a\)的微分，得到：&lt;/p&gt;

&lt;p&gt;\( \frac {\partial \vec y^{T}\vec y}{\partial \vec a} - 2\frac {\partial \vec y^{T}X\vec a}{\partial \vec a} + \frac {\partial \vec a^{T}X^{T}X\vec a}{\partial \vec a} \)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当这个式子(导数)等于0时, 就得到了\( \vec e^{T}\vec e \)的最小值。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;显然，第一个子项为0，所以可把它去掉，得到：&lt;/p&gt;

&lt;p&gt;\( - 2\frac {\partial \vec y^{T}X\vec a}{\partial \vec a} + \frac {\partial \vec a^{T}X^{T}X\vec a}{\partial \vec a}  = 0\)&lt;/p&gt;

&lt;p&gt;\(  2\frac {\vec y^{T}X\vec a}{\partial \vec a} = \frac {\vec a^{T}X^{T}X\vec a}{\partial \vec a} \)&lt;/p&gt;

&lt;p&gt;观察左边的式子，和上文的【公式2】是一样的，所以有：&lt;/p&gt;

&lt;p&gt;\( 2\frac {\vec y^{T}X\vec a}{\partial \vec a} = 2\vec y^{T}X \)&lt;/p&gt;

&lt;p&gt;观察右边的式子，符合上文的【公式4】，所以有：&lt;/p&gt;

&lt;p&gt;\(  \frac {\vec a^{T}X^{T}X\vec a}{\partial \vec a} = 2\vec a^{T}X^{T}X \)&lt;/p&gt;

&lt;p&gt;综上，得：&lt;/p&gt;

&lt;p&gt;\(  2\vec y^{T}X = 2\vec a^{T}X^{T}X \)&lt;/p&gt;

&lt;p&gt;\(  \vec y^{T}X = \vec a^{T}X^{T}X \)&lt;/p&gt;

&lt;p&gt;\(  (\vec y^{T}X)^{T} = (\vec a^{T}X^{T}X)^{T} \)&lt;/p&gt;

&lt;p&gt;\(  X^{T}\vec y = X^{T}X\vec a \)&lt;/p&gt;

&lt;p&gt;\(  \vec a = (X^{T}X)^{-1}X^{T}\vec y  \)&lt;/p&gt;

&lt;p&gt;这个东西就是所谓的&lt;strong&gt;最小二乘估计(Least Squares Estimator)&lt;/strong&gt;了。&lt;/p&gt;
</description>
        <pubDate>Fri, 06 May 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-15/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-15/</guid>
      </item>
    
      <item>
        <title>用线性代数知识解决光线和三角形的交点问题</title>
        <description>&lt;p&gt;本文可认为是《PBRT》3.6节的公式推导笔记。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3&gt;Step1 抽象化问题&lt;/h3&gt;

&lt;p&gt;首先是问题中的3个对象的抽象：&lt;/p&gt;

&lt;p&gt;三角形：由三角形的定义可知，只要确定空间中三个顶点的坐标，就能确定唯一的一个三角形。设三个顶点分别为\(\vec p_{0}\)，\(\vec p_{1}\)，\(\vec p_{2}\)。&lt;/p&gt;

&lt;p&gt;光线：光线在本问题中，设为有起点、有发射方向的射线，起点设为\(\vec o\)，方向为\(\vec d\)。&lt;/p&gt;

&lt;p&gt;光线和三角形的交点：设该交点为\(\vec g\)。&lt;/p&gt;

&lt;p&gt;这时候还要再用到几何数学的一个东西：质心坐标 Barycentric Coordinates。 &lt;a href=&quot;http://mathworld.wolfram.com/BarycentricCoordinates.html&quot;&gt;http://mathworld.wolfram.com/BarycentricCoordinates.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;\[ \vec p_{BC} = b_{0}\vec p_{0} + b_{1}\vec p_{1} + b_{2}\vec p_{2}\]&lt;/p&gt;

&lt;p&gt;规范化的质心坐标被称为Homogeneous  Barycentric Coordinates，特性是\( b_{0} +  b_{1} + b_{2} = 1 \)，&lt;/p&gt;

&lt;p&gt;因为光线和三角形的交点必然落在三角形内部，所以这个交点可认为是一个\(\vec p_{BC} \)。所以有：&lt;/p&gt;

&lt;p&gt;\[ \vec g = (1 - b_{1} - b_{2})\vec p_{0} + b_{1}\vec p_{1} + b_{2}\vec p_{2} \]&lt;/p&gt;

&lt;h3&gt;Step2 问题方程&lt;/h3&gt;

&lt;p&gt;因为光线和三角形的交点要么不存在、要么有且只有一个，所以可列出下面的方程：&lt;/p&gt;

&lt;p&gt;\[ \vec o + t \vec d = \vec g  = (1 - b_{1} - b_{2})\vec p_{0} + b_{1}\vec p_{1} + b_{2}\vec p_{2} \]&lt;/p&gt;

&lt;p&gt;中间的\(\vec g\)去掉：&lt;/p&gt;

&lt;p&gt;\[ \vec o + t \vec d = (1 - b_{1} - b_{2})\vec p_{0} + b_{1}\vec p_{1} + b_{2}\vec p_{2} \]&lt;/p&gt;

&lt;p&gt;可以看到，只剩下3个未知量：\(t\)、\(b_{1}\)、\( b_{2}\)，它们就是最终要求出来的东西。(注意：这3个都是数，不是向量)&lt;/p&gt;

&lt;p&gt;为了应用线性代数的知识来解决问题，我们需要把这个方程写成线性代数里的线性方程组形式：&lt;/p&gt;

&lt;p&gt;\[ \vec o + t \vec d = (1 - b_{1} - b_{2})\vec p_{0} + b_{1}\vec p_{1} + b_{2}\vec p_{2} \]&lt;/p&gt;

&lt;p&gt;\[ \vec o + t \vec d = \vec p_{0} - b_{1}\vec p_{0} - b_{2}\vec p_{0} + b_{1}\vec p_{1} + b_{2}\vec p_{2} \]&lt;/p&gt;

&lt;p&gt;\[ \vec o - \vec p_{0} = -t\vec d - b_{1}\vec p_{0} - b_{2}\vec p_{0} + b_{1}\vec p_{1} + b_{2}\vec p_{2} \]&lt;/p&gt;

&lt;p&gt;\[ -\vec d t + (\vec p_{1}- \vec p_{0}) b_{1} + (\vec p_{2} - \vec p_{0}) b_{2} = \vec o - \vec p_{0} \]&lt;/p&gt;

&lt;p&gt;为了让后续的推导更简洁，需要设：&lt;/p&gt;

&lt;p&gt;\( \vec e_{1} = \vec p_{1} - \vec p_{0} \)&lt;/p&gt;

&lt;p&gt;\( \vec e_{2} = \vec p_{2} - \vec p_{0} \)&lt;/p&gt;

&lt;p&gt;\( \vec s = \vec o - \vec p_{0} \)&lt;/p&gt;

&lt;p&gt;因此，上面的线性方程(组)简化成：&lt;/p&gt;

&lt;p&gt;\[ -\vec d t + \vec e_{1} b_{1} + \vec e_{2} b_{2} = \vec s \]&lt;/p&gt;

&lt;p&gt;再进一步，把方程左边写成矩阵相乘的形式，参数和系数就更显而易见了：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} -\vec d&amp;amp; \vec e_{1}&amp;amp; \vec e_{2} \\ \end{matrix} \right]  \left[ \begin{matrix} t\\  b_{1}\\  b_{2}\\ \end{matrix} \right] = \vec s \]&lt;/p&gt;

&lt;h3&gt;Step3 解开问题方程&lt;/h3&gt;

&lt;p&gt;接下来使用大招——&lt;strong&gt;克拉默(Cramer)法则&lt;/strong&gt;，来解方程。（在我的&lt;a href=&quot;http://www.qiujiawei.com/linear-algebra/&quot;&gt;&amp;lt;复习向&amp;gt;线性代数之矩阵与行列式(1)&lt;/a&gt; 一文中有介绍）&lt;/p&gt;

&lt;p&gt;克拉默(Cramer)法则：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;若系数行列式 \( D\neq 0 \)，则方程组有唯一解，其解为：
\[ x_{j} = \dfrac {D_{j}} {D} \]&lt;/p&gt;

&lt;p&gt;\( D_{j} \)是将系数行列式D中第j列的元素\( a_{1j},a_{2j},\cdots a_{nj} \)对应地换成方程组右端的常数项\( b_{1j},b_{2j},\cdots b_{nj} \)，而其余各列保持不变得到的行列式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对应到上面的方程，系数行列式D等于：&lt;/p&gt;

&lt;p&gt;\[ D =    \left| \begin{matrix} -\vec d\  \vec e_{1}\  \vec e_{2} \\ \end{matrix} \right| \]&lt;/p&gt;

&lt;p&gt;而方程右边的常数项为\(\vec s\)。&lt;/p&gt;

&lt;p&gt;所以上面的方程的各个未知数的值为：&lt;/p&gt;

&lt;p&gt;\( t = \frac {    \left| \begin{matrix} \vec s\  \vec e_{1}\  \vec e_{2} \\ \end{matrix} \right| } {    \left| \begin{matrix} -\vec d\  \vec e_{1}\  \vec e_{2} \\ \end{matrix} \right| } \)&lt;/p&gt;

&lt;p&gt;\( b_{1} = \frac {    \left| \begin{matrix} -\vec d\  \vec s\  \vec e_{2} \\ \end{matrix} \right| } {    \left| \begin{matrix} -\vec d\  \vec e_{1}\  \vec e_{2} \\ \end{matrix} \right| } \)&lt;/p&gt;

&lt;p&gt;\( b_{2} = \frac {    \left| \begin{matrix} -\vec d\  \vec e_{1}\  \vec s \\ \end{matrix} \right| } {    \left| \begin{matrix} -\vec d\  \vec e_{1}\  \vec e_{2} \\ \end{matrix} \right| } \)&lt;/p&gt;

&lt;p&gt;将三个式子合并下：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} t\\  b_{1}\\  b_{2}\\ \end{matrix} \right] = \frac { 1 } {    \left| \begin{matrix} -\vec d\  \vec e_{1}\  \vec e_{2} \\ \end{matrix} \right| } \left[ \begin{matrix}    \left| \begin{matrix} \vec s\  \vec e_{1}\  \vec e_{2} \\ \end{matrix} \right|  \\    \left| \begin{matrix} -\vec d\  \vec s\  \vec e_{2} \\ \end{matrix} \right|  \\    \left| \begin{matrix} -\vec d\  \vec e_{1}\  \vec s \\ \end{matrix} \right|  \\  \end{matrix} \right]    \]&lt;/p&gt;

&lt;p&gt;然后再使用另一杀招——&lt;strong&gt;向量的混合积&lt;/strong&gt;&lt;a href=&quot;http://mathworld.wolfram.com/ScalarTripleProduct.html&quot;&gt;Scalar Triple Product&lt;/a&gt;，从而再次将上式简化。&lt;/p&gt;

&lt;p&gt;向量的混合积公式：&lt;/p&gt;

&lt;p&gt;\[ [\vec a,\vec b, \vec c] = \vec a\cdot (\vec b \times \vec c) \]&lt;/p&gt;

&lt;p&gt;\[ = \vec b\cdot (\vec c \times \vec a) = \vec b\cdot (-\vec a \times \vec c) \]&lt;/p&gt;

&lt;p&gt;\[ = \vec c\cdot (\vec a \times \vec b) \]&lt;/p&gt;

&lt;p&gt;\[ = det(\vec a \ \vec b \ \vec c) = |\vec a \ \vec b \ \vec c| \]&lt;/p&gt;

&lt;p&gt;因此有：&lt;/p&gt;

&lt;p&gt;\[ |-\vec d \ \vec e_{1} \ \vec e_{2}| = -(-\vec d) \times \vec e_{2})\cdot \vec e_{1} = (\vec d \times \vec e_{2})\cdot \vec e_{1} \]&lt;/p&gt;

&lt;p&gt;\[ |\vec s \ \vec e_{1} \ \vec e_{2}| = (\vec s \times \vec e_{1})\cdot \vec e_{2} \]&lt;/p&gt;

&lt;p&gt;\[ |-\vec d \ \vec s \ \vec e_{2}| = (\vec d \times \vec e_{2})\cdot \vec s \]&lt;/p&gt;

&lt;p&gt;\[ |-\vec d \ \vec e_{1} \ \vec s| = (\vec s \times \vec e_{1})\cdot \vec d \]&lt;/p&gt;

&lt;p&gt;再代入到前面的方程，得到：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} t\\  b_{1}\\  b_{2}\\ \end{matrix} \right] = \frac { 1 } { (\vec d \times \vec e_{2})\cdot \vec e_{1} }  \left[ \begin{matrix} (\vec s \times \vec e_{1})\cdot \vec e_{2}\\  (\vec d \times \vec e_{2})\cdot \vec s\\  (\vec s \times \vec e_{1})\cdot \vec d\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;再设：&lt;/p&gt;

&lt;p&gt;\[ \vec s_{1} = \vec d \times \vec e_{2} \]&lt;/p&gt;

&lt;p&gt;\[ \vec s_{2} = \vec s \times \vec e_{1} \]&lt;/p&gt;

&lt;p&gt;就得到最终的等式了：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} t\\  b_{1}\\  b_{2}\\ \end{matrix} \right] = \frac { 1 } { \vec s_{1} \cdot \vec e_{1} }  \left[ \begin{matrix} \vec s_{2}\cdot \vec e_{2}\\  \vec s_{1}\cdot \vec s\\  \vec s_{2}\cdot \vec d\\ \end{matrix} \right]  \]&lt;/p&gt;

&lt;p&gt;推导到了这里就结束了。现在来分析下这个最终等式的特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;\(\vec d 、\  \vec s 、\  \vec e_{1} 、\  \vec e_{2} \) 是需要先求出来的，不过也是非常容易计算的(向量加减法)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着就是算\( \vec s_{1} 、\   \vec s_{2} \)，无法避免的2次叉积运算。算完后，就得到了等式右边所有变量的值了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后就是4次向量点积运算，1次求倒数运算，3次乘法运算，就分别得到了\( t 、\ b_{1} 、\ b_{2} \)的值。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;在上面的推导过程中，用到了矩阵、行列式、向量叉积、向量混合积等诸多概念，只为了得到相交点的坐标，确实复杂了点。&lt;/p&gt;

&lt;p&gt;其中的&lt;strong&gt;向量的混合积&lt;/strong&gt;，可以参考以下网页来理解：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mathworld.wolfram.com/CrossProduct.html&quot;&gt;http://mathworld.wolfram.com/CrossProduct.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Triple_product&quot;&gt;https://en.wikipedia.org/wiki/Triple_product&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/triangle-intersect/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/triangle-intersect/</guid>
      </item>
    
      <item>
        <title>线性代数之平移、缩放、旋转矩阵</title>
        <description>&lt;!--more--&gt;

&lt;h2&gt;平移矩阵 Translate Matrix&lt;/h2&gt;

&lt;p&gt;\[ T =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;x\\  0&amp;amp;1&amp;amp;0&amp;amp;y\\  0&amp;amp;0&amp;amp;1&amp;amp;z\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h2&gt;缩放矩阵 Scale Matrix&lt;/h2&gt;

&lt;p&gt;\[ S =  \left[ \begin{matrix} x&amp;amp;0&amp;amp;0&amp;amp;0\\  0&amp;amp;y&amp;amp;0&amp;amp;0\\  0&amp;amp;0&amp;amp;z&amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h2&gt;旋转矩阵 Rotate Matrix&lt;/h2&gt;

&lt;h3&gt;绕(1,0,0)旋转\(\theta \)角度&lt;/h3&gt;

&lt;p&gt;\[ R_{(1,0,0)} =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\  0&amp;amp;cos\theta &amp;amp;sin\theta &amp;amp;0\\  0&amp;amp;-sin\theta &amp;amp;cos\theta &amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h3&gt;绕(0,1,0)旋转\(\theta \)角度&lt;/h3&gt;

&lt;p&gt;\[ R_{(0,1,0)} =  \left[ \begin{matrix} cos\theta&amp;amp;0&amp;amp;-sin\theta&amp;amp;0\\    0&amp;amp;1&amp;amp;0&amp;amp;0\\  sin\theta &amp;amp;0&amp;amp;cos\theta &amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h3&gt;绕(0,0,1)旋转\(\theta \)角度&lt;/h3&gt;

&lt;p&gt;\[ R_{(0,0,1)} =  \left[ \begin{matrix} cos\theta&amp;amp;sin\theta&amp;amp;0&amp;amp;0\\  -sin\theta &amp;amp;cos\theta &amp;amp;0&amp;amp;0\\   0&amp;amp;0&amp;amp;1&amp;amp;0\\   0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h3&gt;绕任意轴旋转\(\theta \)角度&lt;/h3&gt;

&lt;p&gt;设旋转轴为\(\vec n\)，这是一个单位化的方向向量。设被旋转的向量为\(\vec v\)，被旋转后是\(\vec v&amp;#39; \)。&lt;/p&gt;

&lt;p&gt;为了求出\(\vec v&amp;#39; \)，需要迂回地处理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将\(\vec v\) 分解为 \(\vec v = \vec v_{\perp }+\vec v_{\parallel } \) ，\( \vec v_{\parallel } \)指的是\(\vec v\)与\(\vec n\)平行的部分，\( \vec v_{\perp } \) 指的是\(\vec v\) 与\(\vec n\)垂直的部分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分解为两部分后，可以分别对这两个部分做旋转，然后再合并，所以有： \(\vec v&amp;#39; = \vec v&amp;#39;_{\perp }+\vec v&amp;#39;_{\parallel } \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;让 \( \vec v_{\parallel } \) 绕旋转轴\(\vec n\)旋转\(\theta \)角度，它依然保持不变，因为它和\(\vec n\)是同方向的向量，所以有 \( \vec v_{\parallel } = \vec v&amp;#39;_{\parallel } \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据上一点，可以得到： \(\vec v&amp;#39; = \vec v&amp;#39;_{\perp }+\vec v_{\parallel } \)。因此，问题简化为求\( \vec v&amp;#39;_{\perp } \)和\( \vec v_{\parallel } \)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分析\( \vec v_{\parallel } \)，可以发现它相当于是\(\vec v\)在\(\vec n\)上的投影，根据向量的点积公式：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ \vec A\cdot \vec B = |\vec A||\vec B|cos\alpha  \]&lt;/p&gt;

&lt;p&gt;代入\(\vec v\)、\(\vec n\)后，得到：\( \vec v\cdot \vec n = |\vec v||\vec n|cos\alpha = |\vec v|cos\alpha = |\vec v_{\parallel }| \)，即算出了\( \vec v_{\parallel } \)的长度，又因为\vec v_{\parallel } \)和\(\vec n\)方向一致、\(\vec n\)长度为1，所以有:&lt;/p&gt;

&lt;p&gt;\[ \vec v_{\parallel } = (\vec v\cdot \vec n) \vec n \]&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;上一步已经解决了\( \vec v_{\parallel } \)，剩下的就是求\( \vec v&amp;#39;_{\perp } \)。求\( \vec v&amp;#39;_{\perp } \)之前需要先求出\( \vec v_{\perp } \)，而显然\( \vec v_{\perp } = v - \vec v_{\parallel} \) &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着，需要计算一个新的向量\(\vec w \)，\( \vec w = \vec n \times \vec v_{\perp } \) （注意叉乘的顺序不能错），所以\(\vec w \)是一个垂直于\(  \vec n \)、\( \vec v_{\perp } \)所构成平面的向量。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把\( \vec v_{\perp }\)、\(\vec w \) 分别当做是\(  \vec n \)、\( \vec v_{\perp } \)平面的x、y轴(2D坐标系)，那么\( \vec v&amp;#39;_{\perp } \)的含义就是指\( \vec v_{\perp } \)在这个2D坐标系下旋转\(\theta \)度。从而得到等式：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\[ \vec v&amp;#39;_{\perp } =  cos\theta \vec v_{\perp } + sin\theta \vec w \]&lt;/p&gt;

&lt;p&gt;好了，所有变量都得到了，总结下最终的公式：&lt;/p&gt;

&lt;p&gt;\( \vec v_{\parallel } = (\vec v\cdot \vec n) \vec n \)&lt;/p&gt;

&lt;p&gt;\( \vec v_{\perp } = \vec v - \vec v_{\parallel} = \vec v -  (\vec v\cdot \vec n) \vec n \) &lt;/p&gt;

&lt;p&gt;\( \vec w = \vec n \times \vec v_{\perp } \) &lt;/p&gt;

&lt;p&gt;\( = \vec n \times (\vec v - \vec v_{\parallel}) \) &lt;/p&gt;

&lt;p&gt;\( = \vec n \times \vec v - \vec n \times \vec v_{\parallel}) \) &lt;/p&gt;

&lt;p&gt;\( = \vec n \times \vec v \) &lt;/p&gt;

&lt;p&gt;\( \vec v&amp;#39;_{\perp } =  cos\theta \vec v_{\perp } + sin\theta \vec w \)&lt;/p&gt;

&lt;p&gt;\( =  cos\theta (v - (\vec v\cdot \vec n) \vec n) + sin\theta (\vec n \times \vec v)  \)&lt;/p&gt;

&lt;p&gt;\( \vec v&amp;#39; = \vec v&amp;#39;_{\perp } + \vec v_{\parallel } \)&lt;/p&gt;

&lt;p&gt;\( = cos\theta (v - (\vec v\cdot \vec n) \vec n) + sin\theta (\vec n \times \vec v) + (\vec v\cdot \vec n) \vec n \)&lt;/p&gt;

&lt;p&gt;加粗并居中：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;\[ \vec v&amp;#39; = cos\theta (v - (\vec v\cdot \vec n) \vec n) + sin\theta (\vec n \times \vec v) + (\vec v\cdot \vec n) \vec n \]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这就是绕任意轴的旋转公式了。&lt;/p&gt;

&lt;p&gt;接下来是把这个公式转换成矩阵的形式。方法是，把\(v_{x} = (1,0,0) \)、\(v_{y} = (0,1,0) \)、\(v_{z} = (0,0,1) \)，分别代入上面的公式，分别得到：&lt;/p&gt;

&lt;p&gt;\[ v_{x}&amp;#39; =  \left[ \begin{matrix} n_{x}^{2}(1-cos\theta )+cos\theta \\ n_{x}n_{y}(1-cos\theta )+n_{z}sin\theta \\ n_{x}n_{z}(1-cos\theta )-n_{y}sin\theta \\ \end{matrix} \right] ^{T} \]&lt;/p&gt;

&lt;p&gt;\[ v_{y}&amp;#39; =  \left[ \begin{matrix} n_{x}n_{y}(1-cos\theta )-n_{z}sin\theta \\ n_{y}^{2}(1-cos\theta )+cos\theta \\ n_{y}n_{z}(1-cos\theta )+n_{x}sin\theta \\ \end{matrix} \right] ^{T} \]&lt;/p&gt;

&lt;p&gt;\[ v_{z}&amp;#39; =  \left[ \begin{matrix} n_{x}n_{z}(1-cos\theta )+n_{y}sin\theta \\ n_{y}n_{z}(1-cos\theta )-n_{x}sin\theta \\ n_{z}^{2}(1-cos\theta )+cos\theta \\ \end{matrix} \right] ^{T} \]&lt;/p&gt;

&lt;p&gt;最终的旋转矩阵为:&lt;/p&gt;

&lt;p&gt;\[ R(\vec n, \theta ) =  \left[ \begin{matrix} n_{x}^{2}(1-cos\theta )+cos\theta &amp;amp;  n_{x}n_{y}(1-cos\theta )+n_{z}sin\theta &amp;amp;  n_{x}n_{z}(1-cos\theta )-n_{y}sin\theta &amp;amp;0\\      n_{x}n_{y}(1-cos\theta )-n_{z}sin\theta &amp;amp;n_{y}^{2}(1-cos\theta )+cos\theta &amp;amp;n_{y}n_{z}(1-cos\theta )+n_{x}sin\theta &amp;amp;0\\     n_{x}n_{z}(1-cos\theta )+n_{y}sin\theta &amp;amp;n_{y}n_{z}(1-cos\theta )-n_{x}sin\theta &amp;amp;n_{z}^{2}(1-cos\theta )+cos\theta &amp;amp;0\\    0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-14/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-14/</guid>
      </item>
    
      <item>
        <title>线性代数之视角矩阵Lookat Matrix</title>
        <description>&lt;h1&gt;引言&lt;/h1&gt;

&lt;p&gt;我对视角矩阵的理解是这样子的，假设3维空间有一个观察者（摄像机），这个观察者必然有它的坐标位置、视角、焦点，根据这3个参数，可以建立一个正交化、规范化的坐标系（一个正交化、单位化的3x3矩阵），这个坐标系对应的矩阵就是Lookat矩阵。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;根据上面这个我自己创造的定义，可以知道，Lookat矩阵只和观察者的坐标、焦点、视角有关，和被观察的东西完全无关，也就是说，Lookat矩阵是independent的，这个性质的好处是，这个观察者的Lookat矩阵，可以应用到任意目标上。&lt;/p&gt;

&lt;p&gt;观察者的坐标、焦点、视角，可以进一步抽象。观察者坐标位置设为eye向量，焦点位置设为focal向量，视角呢，比较特殊，是设为一个up向量，含义是这个观察者的头顶朝向。&lt;/p&gt;

&lt;p&gt;可以想象成，观察者就是你自己，你站在地面上，盯着远处一个美女，可以是盯着她的腿、她的腰，都无妨。&lt;/p&gt;

&lt;p&gt;看的过程中，你可以往左侧着头看，也可以倒立着看，不会影响focal向量，因为你的眼睛还是能看见美女。&lt;/p&gt;

&lt;p&gt;但是当你低头时，情况就有些变化了。第一种情况：你对着美女弯腰90度，focal向量变成指向了地面上的某个点，up向量虽然还是沿着你头部的方向，不过因为弯腰90度的关系，已经不是朝着上方了(大约是指向了美女的方向)；第二种情况是，你只是微微低头(大于15度这样子)，眼睛还是能看到美女（低头15度的视野和完全直立时一致），不过，up向量被改变了，因为你的头转了15度。&lt;/p&gt;

&lt;p&gt;通过这个例子，可以知道，focal向量和up向量之间是存在联系的，而eye向量则和focal、up向量没有关系，eye向量决定的是你所在的位置。&lt;/p&gt;

&lt;p&gt;唠嗑到这里，下面进入数学环节。&lt;/p&gt;

&lt;h1&gt;推导&lt;/h1&gt;

&lt;p&gt;当eye、focal、up三个向量的值确定后，就可以构造Lookat矩阵了。&lt;/p&gt;

&lt;p&gt;(额外补充：focal向量一般是通过计算被观察位置center和观察者的位置eye的差值得到的，focal = center - eye)&lt;/p&gt;

&lt;p&gt;首先明确2点：一，Lookat矩阵是正交且规范化的；二，我们使用的是右手坐标系。&lt;/p&gt;

&lt;p&gt;这个Lookat矩阵，相当于是一个坐标系，那么可以设三个坐标轴的方向向量分别为\(\vec r\)、\(\vec u\)、\(\vec f\)，分别的含义是，观察者坐标系的right、up、forward方向。&lt;/p&gt;

&lt;p&gt;\(\vec f\)可以轻松得到：它的朝向是focal的反方向。为什么呢？很简单，focal是指从观察者位置到焦点位置的方向向量，又因为我们用的是右手坐标系，那么观察者坐标系的f轴朝向当然是focal的反方向了。&lt;/p&gt;

&lt;p&gt;\[\vec f = - \frac {\overrightarrow {focal} }{|\overrightarrow {focal}|} \]&lt;/p&gt;

&lt;p&gt;接着是\(\vec r\)。显然，\(\vec r\)指的方向是，focal和up所构成的平面的垂线的正方向，即focal和up的叉积。&lt;/p&gt;

&lt;p&gt;\[\vec r = \frac {\overrightarrow {focal} \times \overrightarrow {up}}{|\overrightarrow {focal} \times \overrightarrow {up}|} \]&lt;/p&gt;

&lt;p&gt;\(\vec r\)、\(\vec f\)都得到后，\(\vec u\)就简单了，因为\(\vec r\)、\(\vec f\)已经规范化、正交化了的，那么\(\vec u\)就是他们的叉积：&lt;/p&gt;

&lt;p&gt;\[\vec u = \vec f \times \vec r \]&lt;/p&gt;

&lt;p&gt;设Lookat矩阵为M，则M等于：&lt;/p&gt;

&lt;p&gt;\[ M =  \left[ \begin{matrix} r_{x}&amp;amp;r_{y}&amp;amp;r_{z}&amp;amp;0\\  u_{x}&amp;amp;u_{y}&amp;amp;u_{z}&amp;amp;0\\  f_{x}&amp;amp;f_{y}&amp;amp;f_{z}&amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;拿这个M和单位矩阵I对比下：&lt;/p&gt;

&lt;p&gt;\[ I =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;1&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;1&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;可以发现，单位矩阵I相当于是把观察者放在世界空间的原点。因为I的\(\vec r\)、\(\vec u\)、\(\vec f\)已经是规范化、正交化的，且和世界坐标系一致。&lt;/p&gt;

&lt;p&gt;所以上面的M可以理解为：M等于M乘以I。含义是，把世界坐标系变换到观察者坐标系。也即相当于调整了对world的观察角度。&lt;/p&gt;

&lt;p&gt;到了这里，事情还没完，因为这个M并不能体现出观察者的&lt;strong&gt;位置&lt;/strong&gt;，为什么呢？因为\(\vec r\)、\(\vec u\)、\(\vec f\)是规范化的向量，长度都为1，并不包含位置信息。&lt;/p&gt;

&lt;p&gt;和单位矩阵I对比的话就清楚了，单位矩阵I之所以不需要位置信息，是因为单位矩阵I已经隐含了一个信息：观察位置就在(0,0,0)。&lt;/p&gt;

&lt;p&gt;观察位置，上面已经定义过了，它就是eye向量。&lt;/p&gt;

&lt;p&gt;把观察者放到eye位置，反过来想，相当于是把被观察的东西偏移-eye的距离。实际上，我们正在构造的Lookat矩阵，不是要作用到观察者身上，而是要作用到被观察者（world）身上的。&lt;/p&gt;

&lt;p&gt;因此，现在可以根据eye向量构造一个移动矩阵T(Translate)了：&lt;/p&gt;

&lt;p&gt;\[ T =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;-eye_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;-eye_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;-eye_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;然后把M和T合并，即得到了Lookat矩阵：&lt;/p&gt;

&lt;p&gt;\[ Lookat = MT \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} r_{x}&amp;amp;r_{y}&amp;amp;r_{z}&amp;amp;0\\  u_{x}&amp;amp;u_{y}&amp;amp;u_{z}&amp;amp;0\\  f_{x}&amp;amp;f_{y}&amp;amp;f_{z}&amp;amp;0\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;-eye_{x}\\ 0&amp;amp;1&amp;amp;0&amp;amp;-eye_{y}\\ 0&amp;amp;0&amp;amp;1&amp;amp;-eye_{z}\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} r_{x}&amp;amp;r_{y}&amp;amp;r_{z}&amp;amp;-r_{x}eye_{x}-r_{y}eye_{y}-r_{z}eye_{z}\\  u_{x}&amp;amp;u_{y}&amp;amp;u_{z}&amp;amp;-u_{x}eye_{x}-u_{y}eye_{y}-u_{z}eye_{z}\\  f_{x}&amp;amp;f_{y}&amp;amp;f_{z}&amp;amp;-f_{x}eye_{x}-f_{y}eye_{y}-f_{z}eye_{z}\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;简化下：&lt;/p&gt;

&lt;p&gt;\[ Lookat =  \left[ \begin{matrix} r_{x}&amp;amp;r_{y}&amp;amp;r_{z}&amp;amp;-(\vec r\cdot \overrightarrow {eye})\\  u_{x}&amp;amp;u_{y}&amp;amp;u_{z}&amp;amp;-(\vec u\cdot \overrightarrow {eye})\\  f_{x}&amp;amp;f_{y}&amp;amp;f_{z}&amp;amp;-(\vec f\cdot \overrightarrow {eye})\\  0&amp;amp;0&amp;amp;0&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-13/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-13/</guid>
      </item>
    
      <item>
        <title>线性代数之透视矩阵Perspective Matrix</title>
        <description>&lt;p&gt;本文部分内容翻译自：&lt;a href=&quot;http://www.ogldev.org/www/tutorial12/tutorial12.html&quot;&gt;Tutorial 12: Perspective Projection&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文介绍的是OpenGL中的透视矩阵。&lt;/p&gt;

&lt;h1&gt;介绍&lt;/h1&gt;

&lt;p&gt;所谓的透视矩阵，指的是一个“降维”的转换过程。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;设想下一个在3维空间里的3D模型，它必然拥有一些顶点信息，设其中任意顶点的坐标为(x,y,z,1)（后面的1是齐次坐标的意思），当我们需要把这个模型投影到某个平面上时，它就从3维变成了2维（看过三体3的童鞋就容易理解了，这就是二向箔!），而顶点坐标(x,y,z,1)则变成(x&lt;code&gt;,y&lt;/code&gt;,d,?)。&lt;/p&gt;

&lt;p&gt;可以注意到，经过透视变换后的顶点，依然是四维的形式，只是含义变了，其中的(x&lt;code&gt;,y&lt;/code&gt;)分量指的是这个顶点在投影平面上的坐标(显然是因为投影平面相当于一个2维坐标系)。d指的是这个投影点的深度(depth)，d一般是规范化的，范围是[-1,1]。d的作用在下一个渲染阶段(Depth Test)大有用处。而后面的?，无法一言蔽之，下文会讲到这个问题。&lt;/p&gt;

&lt;h1&gt;视锥体 Frustum&lt;/h1&gt;

&lt;p&gt;视锥体，指的是一个有限的椎体空间，处于这个视锥体里的对象，才是“可见”的对象，可见的对象会被渲染到“视平面”上（三维到二维的投影）。视锥体有4个参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aspect ratio，简称ar，ar = 视平面width/视平面height&lt;/li&gt;
&lt;li&gt;（vertical）field of view，简称fov，指yz平面的视角大小，即下文的\( \alpha \)角。&lt;/li&gt;
&lt;li&gt;near Z Plane，简称near面，是一个平行于xy平面的面，世界坐标系下是一个浮点值，可以用来裁剪太靠近摄像机的物体&lt;/li&gt;
&lt;li&gt;far Z Plane，简称far面，含义类似near面，可以用来裁剪太远离摄像机的物体&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;视平面可以认为是视锥体的near面；far面相对来说并没有那么重要，因为我们知道人眼的“视锥体”是没有far面的（比如裸眼可以看到月亮星星，far面其实是无限远的），在图形学中，far面主要是用来裁剪太过遥远的物体、提高渲染效率的。&lt;/p&gt;

&lt;p&gt;下面这个是我找到的一个视锥体的演示程序，非常直观地展示了视锥体的作用：&lt;/p&gt;

&lt;div&gt;
  &lt;iframe class=&quot;webgl_example&quot; style=&quot;width: 400px; height: 600px;&quot; src=&quot;http://webglfundamentals.org/webgl/frustum-diagram.html&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://webglfundamentals.org/webgl/lessons/webgl-3d-perspective.html&quot;&gt;演示程序来源：http://webglfundamentals.org/webgl/lessons/webgl-3d-perspective.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从摄像机位置（一个点）观察视平面的话，是长这样子的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.3/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图片来自www.ogldev.org)&lt;/p&gt;

&lt;p&gt;y轴范围是[-1,1]，x轴范围是[-ar,ar]，因为ar = 视平面width/视平面height，其实也就是ar=屏幕width/屏幕height，因为大部分屏幕都是宽屏，所以ar的值一般是大于1的。当屏幕宽高一致时，视平面才是上面这幅图的样子。&lt;/p&gt;

&lt;p&gt;现在，换成侧视角来观察这个视锥体(yz平面)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.3/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(图片来自www.ogldev.org，有修改)&lt;/p&gt;

&lt;p&gt;红线是投影面(视平面)，绿色线是摄像机到投影面的向量d，\(\alpha \)角即是fov。注意，OpenGL在“世界坐标系”中，用的是右手坐标系，所以上图中，z轴的左边才是1、右边是-1。因此，向量d的长度是-d（要取反，不然会计算错误）。综上，可以得出：&lt;/p&gt;

&lt;p&gt;\[ tan(\frac {\alpha } { 2 } ) = \frac {1} {|\vec d|} \]&lt;/p&gt;

&lt;p&gt;\[  |\vec d| = -d = \frac {1} { tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;接下来是求某顶点\( (x,y,z,w) \)在投影面上的投影坐标\( (x_{p},y_{p},z_{p},w_{p}) \)。 看下面的侧视图，我们可以先求解\( y_{p} \)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2016.3/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;根据相似三角形定理，可以得到：&lt;/p&gt;

&lt;p&gt;\[ \frac {y_{p} } { |\vec d| } = \frac { y } { -z } \]&lt;/p&gt;

&lt;p&gt;\[ y_{p} = \frac { y * |\vec d| } { -z } = \frac { y } { -z * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;注意，这里的z需要取反，因为上面的等式里，\(y_{p}\)和y同符号，\(|\vec d|\)是正号，而z显然本身是负值，所以z要取反。&lt;/p&gt;

&lt;p&gt;同样的，x分量也可以用相同的公式求得：&lt;/p&gt;

&lt;p&gt;\[ \frac {x_{p} } { |\vec d| } = \frac { x } { -z } \]&lt;/p&gt;

&lt;p&gt;\[ x_{p} = \frac { x * |\vec d| } { -z } = \frac { x } { -z * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;此时要考虑到一个问题： \( y_{p} \)的范围是[-1,1]，而\( x_{p} \)是[-ar, ar]。为了让\( x_{p} \)和\( y_{p} \)一致，需要让\( x_{p} \)除以ar，从而得到：&lt;/p&gt;

&lt;p&gt;\[ x_{p} = \frac { x } { -z * ar * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;\[ y_{p} = \frac { y } { -z * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;到了这里，我们可以开始构造下透视矩阵了：&lt;/p&gt;

&lt;p&gt;\[ Perspective Matrix = M =  \left[ \begin{matrix} a&amp;amp;b&amp;amp;c&amp;amp;d\\ e&amp;amp;f&amp;amp;g&amp;amp;h\\ i&amp;amp;j&amp;amp;k&amp;amp;l\\ m&amp;amp;n&amp;amp;o&amp;amp;p\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;被转换的顶点的坐标(矩阵)是：&lt;/p&gt;

&lt;p&gt;\[ V =  \left[ \begin{matrix} x\\ y\\ z\\ w\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;转换后的投影点是:&lt;/p&gt;

&lt;p&gt;\[ V_{p} =  \left[ \begin{matrix} x_{p} \\ y_{p} \\ z_{p} \\ w_{p} \\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;转换过程:&lt;/p&gt;

&lt;p&gt;\[ MV = V_{p} \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} a&amp;amp;b&amp;amp;c&amp;amp;d\\ e&amp;amp;f&amp;amp;g&amp;amp;h\\ i&amp;amp;j&amp;amp;k&amp;amp;l\\ m&amp;amp;n&amp;amp;o&amp;amp;p\\ \end{matrix} \right]  \left[ \begin{matrix} x\\ y\\ z\\ w\\ \end{matrix} \right]  =  \left[ \begin{matrix} x_{p} \\ y_{p} \\ z_{p} \\ w_{p} \\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;从以上等式可以得到:&lt;/p&gt;

&lt;p&gt;\[ ax + by + cz + dw = x_{p} = \frac { x } {  -z * ar * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;这是M矩阵第一行和V的点积等式。求解这个等式的话，会发现可以让b=0、d=0，从而等式简化成:&lt;/p&gt;

&lt;p&gt;\[ ax + cz = \frac { x } { -z * ar * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;这样做后就有了个问题：找不到可以代入a、c的常量值。其中左边比较多余的cz项，如果可以干掉的话，意味着c必须等于0。这么做后，等式进而变成:&lt;/p&gt;

&lt;p&gt;\[ ax = \frac { x } { -z * ar * tan(\frac {\alpha } { 2 } ) } \]&lt;/p&gt;

&lt;p&gt;观察等式，可以发现等式右边有个多余的z。OpenGL中对这个问题的处理是，在变换过程中强(偷)制(偷)插入一个步骤：把矩阵相乘的结果值再统一除以-z。对，没错，确实是-z而不是z，负号的作用是把坐标从右手坐标系转换到左手坐标系，原因是NDC(Normalized Device Coord)坐标系是左手坐标系，即NDC的z轴的正方向是朝向屏幕里面的。这个除以-z的技巧被称为&lt;strong&gt;Perspective Divide&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这么做之后，事情就简单了，上面的等式可以推出：&lt;/p&gt;

&lt;p&gt;\[ a = \frac { 1 } { ar * tan(\frac {\alpha } { 2 } ) }  \]&lt;/p&gt;

&lt;p&gt;对于M矩阵的f，用同样的做法可以得到:&lt;/p&gt;

&lt;p&gt;\[ f = \frac { 1 } { tan(\frac {\alpha } { 2 } ) }   \]&lt;/p&gt;

&lt;p&gt;从而得到了M的前两行的值：&lt;/p&gt;

&lt;p&gt;\[ M =  \left[ \begin{matrix} \frac { 1 } { ar * tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;\frac { 1 } { tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0\\ i&amp;amp;j&amp;amp;k&amp;amp;l\\ m&amp;amp;n&amp;amp;o&amp;amp;p\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;到了这里，其实透视变换问题已经解决大半了，因为\(x_{p}\)和\(y_{p}\)都可以算了，并且可以规范化到[-1,1]范围。剩下的问题是\(z_{p}\)，即顶点的深度信息。&lt;/p&gt;

&lt;p&gt;前面提到的&lt;strong&gt;Perspective Divide&lt;/strong&gt;会导致一个问题：z分量在转换过程中会因为&lt;strong&gt;Perspective Divide&lt;/strong&gt;而导致变成-1。针对这个问题，OpenGL的解决方案是，把V的z值取反并复制覆盖到w上，从而把原始z值保存起来（也就是M矩阵的第四行所负责的事情），同时&lt;strong&gt;Perspective Divide&lt;/strong&gt;仅对x、y、z有效（跳过w）。&lt;/p&gt;

&lt;p&gt;因此，M的后两行也可以得到了：&lt;/p&gt;

&lt;p&gt;\[ M =  \left[ \begin{matrix} \frac { 1 } { ar * tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;\frac { 1 } { tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;-1&amp;amp;0\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;然而，事情还没有结束。现在用这个新的M去做透视变换后，得不到规范化的z分量。规范化的，可以使得后续的渲染步骤不需要知道near Z和far Z。为了完成这个事情，需要对M做改进，着手点就是row 3，全为0的第三行。&lt;/p&gt;

&lt;p&gt;再阐述一下问题：我们需要求出row3=(i,j,k,l)，使得row3和V做点积运算能得到规范化的\(z_{p}\)。用公式表示：&lt;/p&gt;

&lt;p&gt;\[z_{p} = Az + B , z_{p}\in [-1,1] \]&lt;/p&gt;

&lt;p&gt;再考虑上&lt;strong&gt;Perspective Divide&lt;/strong&gt;，上式变成：&lt;/p&gt;

&lt;p&gt;\[z_{p} = A + \frac {B}{-z} , z_{p}\in [-1,1] \]&lt;/p&gt;

&lt;p&gt;思路非常明确了：把公式中的A、B求出来，代入row3，就能解决问题。&lt;/p&gt;

&lt;p&gt;因为当z等于near Z时，\(z_{p}\)必然等于1；当z等于far Z时，\(z_{p}\)必然等于-1 (Note：这里用的是右手坐标系）。因此得到：&lt;/p&gt;

&lt;p&gt;\[ A + \frac {B}{-NearZ} = 1 \]&lt;/p&gt;

&lt;p&gt;\[ A = 1 - \frac {B}{-NearZ} = 1 + \frac {B}{NearZ}  \]&lt;/p&gt;

&lt;p&gt;接着：&lt;/p&gt;

&lt;p&gt;\[ A + \frac {B}{-FarZ} = -1 \]&lt;/p&gt;

&lt;p&gt;\[ 1 + \frac {B}{NearZ} - \frac {B}{FarZ} = -1 \]&lt;/p&gt;

&lt;p&gt;\[ \frac {B*FarZ - B*NearZ}{NearZ*FarZ} = -2 \]&lt;/p&gt;

&lt;p&gt;\[ B = \frac {-2*NearZ*FarZ}{FarZ - NearZ} = \frac {2*NearZ*FarZ}{NearZ - FarZ}  \]&lt;/p&gt;

&lt;p&gt;B解决了，求A：&lt;/p&gt;

&lt;p&gt;\[ A = 1 + \frac {B}{NearZ}  = 1 + \frac {2*FarZ*NearZ}{NearZ*(NearZ - FarZ)} \]&lt;/p&gt;

&lt;p&gt;\[ A = 1 + \frac {2*FarZ}{NearZ - FarZ}  \]&lt;/p&gt;

&lt;p&gt;\[ A =\frac {NearZ - FarZ + 2*FarZ}{NearZ - FarZ}\]&lt;/p&gt;

&lt;p&gt;\[ A = \frac {NearZ + FarZ}{NearZ - FarZ} \]&lt;/p&gt;

&lt;p&gt;有了A、B后，就可以求row3了:&lt;/p&gt;

&lt;p&gt;\[ ix +jy +kz +lw = Az + B \]&lt;/p&gt;

&lt;p&gt;显然，可让i = j = 0，那么上式变成:&lt;/p&gt;

&lt;p&gt;\[ kz + lw = Az + B \]&lt;/p&gt;

&lt;p&gt;因为V的w分量必然是1，所以可以得知：k = A，l = B。&lt;/p&gt;

&lt;p&gt;代入M，得到最终完善的M：&lt;/p&gt;

&lt;p&gt;\[ M =  \left[ \begin{matrix} \frac { 1 } { ar * tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0&amp;amp;0\\ 0&amp;amp;\frac { 1 } { tan(\frac {\alpha } { 2 } ) }&amp;amp;0&amp;amp;0\\ 0&amp;amp;0&amp;amp;\frac {NearZ + FarZ}{NearZ - FarZ}&amp;amp;\frac {2*FarZ*NearZ}{NearZ - FarZ}\\ 0&amp;amp;0&amp;amp;-1&amp;amp;0\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;再对比下superbible7中构造透视矩阵的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mat4&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;perspective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fovy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;radians&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fovy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.0f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mat4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细观察，发现有1处不同：这个函数构造的矩阵是列主导的矩阵。其中元素的取值和本文的推导完全一致！&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-12/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-12/</guid>
      </item>
    
      <item>
        <title>《OpenGL编程指南(第8版)》阅读笔记01</title>
        <description>&lt;h1&gt;Example源码Bug备忘&lt;/h1&gt;

&lt;h2&gt;第三章&lt;/h2&gt;

&lt;h3&gt;ch03_drawcommands&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;n&quot;&gt;glUniformMatrix4fv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;render_model_matrix_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model_matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应改为：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;n&quot;&gt;glUniformMatrix4fv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;render_model_matrix_loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model_matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原因：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);&lt;/p&gt;

&lt;p&gt;Parameters&lt;/p&gt;

&lt;p&gt;location&lt;/p&gt;

&lt;p&gt;Specifies the location of the uniform value to be modified.&lt;/p&gt;

&lt;p&gt;count&lt;/p&gt;

&lt;p&gt;Specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is &amp;gt; not an array of matrices, and 1 or more if it is an array of matrices.&lt;/p&gt;

&lt;p&gt;transpose&lt;/p&gt;

&lt;p&gt;Specifies whether to transpose the matrix as the values are loaded into the uniform variable. Must be GL_FALSE.&lt;/p&gt;

&lt;p&gt;value&lt;/p&gt;

&lt;p&gt;Specifies a pointer to an array of count values that will be used to update the specified uniform variable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为例子使用的是primitive_restart.vs.glsl顶点着色器，model_matrix不是数组，所以参数count应该为1。&lt;/p&gt;

&lt;p&gt;还发现了一句注释： // &amp;quot;model_matrix&amp;quot; is actually an array of 4 matrices&lt;/p&gt;

&lt;p&gt;不明白为什么model_matrix会是一个包含4个矩阵的数组。并且确实改成1后就能运行了。&lt;/p&gt;

&lt;p&gt;(后面发现有一个shader里面的model_matrix确实是一个长度4的数组...估计是混淆了吧)&lt;/p&gt;

&lt;p&gt;真是坑。&lt;/p&gt;

&lt;h3&gt;vmath&lt;/h3&gt;

&lt;p&gt;vmath::rotation 要改为 vmath::rotate
vmath::translation 要改为 vmath::translate&lt;/p&gt;

&lt;h3&gt;绝对路径....&lt;/h3&gt;

&lt;p&gt;ch03_instancing的Initialize函数里：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;    &lt;span class=&quot;c1&quot;&gt;// Load the object&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoadFromVBM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;C:/Vermilion-Book/trunk/Code/media/armadillo_low.vbm&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;太坑了。&lt;/p&gt;

&lt;h3&gt;把vs和fs写在cpp文件里&lt;/h3&gt;

&lt;p&gt;如果是为了演示如何手动编译shader，也不用放在多个example里吧。&lt;/p&gt;

&lt;h2&gt;第四章&lt;/h2&gt;

&lt;h3&gt;ch04_shadowmap的vbm.h和vbm.cpp是不对的，运行会出错&lt;/h3&gt;

&lt;p&gt;换成第三章的工程里的就OK了。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/openl-01/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/openl-01/</guid>
      </item>
    
      <item>
        <title>我的2015总结</title>
        <description>&lt;!--more--&gt;

&lt;h1&gt;Career&lt;/h1&gt;

&lt;p&gt;2015年是我career发生大改变的一年。&lt;/p&gt;

&lt;p&gt;毕业后我在某益工作了接近两年。在2015年春季，我选择了离去。&lt;/p&gt;

&lt;p&gt;为什么要走呢?说大了讲，是个人和公司价值观的不同，说小了讲，是对这种生活的厌倦。&lt;/p&gt;

&lt;p&gt;做这个决定并不轻松。家里人和女朋友其实是不喜欢我跳槽的，个中原因主要是收入。钱、时间、理想，这3个东西太难权衡，本文最后再分享下我对它们的思考。&lt;/p&gt;

&lt;p&gt;走的时候是4月份，走之前，我完成了项目的战斗系统的构建，算是有始有终；走之后，这项目也如预期一样，砍掉了。&lt;/p&gt;

&lt;p&gt;2年时间，参与的项目一个个地因为各种和我个人没有关系的原因而失败，深深体会到作为普通软件工程师的无力感。为了改变现状，我想我必须去做一些和以往不同的事情。如何实施？这是我2015年下旬的思考内容。&lt;/p&gt;

&lt;p&gt;2015下旬，我进入了一家创业公司：壕游戏。整个公司包括我只有10个人左右。目前，一切安好。&lt;/p&gt;

&lt;p&gt;虽然这是一家创业公司，但是没有当年刚加入某益时的那种压力。公司一切相对轻松、自由，每个员工都可以畅所欲言，即使是程序员也能对项目提出建议。这也是我认为的正确的企业文化之一。然而，这种轻松的氛围却容易导致员工的松懈。我下了决心换了工作，并不是为了放松、享乐，我是为了改变现状而离开某益。我不安，因周围的同学跑得太快，生怕懒惰而落下，且我也没有在20多岁就开始享乐的资本。&lt;/p&gt;

&lt;p&gt;所以，我接受了工作上的任何挑战。这半年时间，我给公司开发了一套游戏服务器系统，做各种小优化工具，解决各种疑难问题，并独立负责3个项目的开发(实际上有2个已经因为某些原因而搁置)。做的事情还算不少吧。我也顺利地从python阵营转入js阵营。js和c++将是我今后在编程上的两把重要兵器。&lt;/p&gt;

&lt;p&gt;新工作因为不用加班，给了我更多的时间做自己的事情，很多计划都得以实施，看书的时间变多，也有时间写blog、学英语。甚至还学会了做各种中式饭菜= =。&lt;/p&gt;

&lt;p&gt;这半年时间，我也对自己今后的career有了新的决策，以下是todolist(也是2016年的计划)：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;努力提高技术实力。我相信个人技术的提升，在达到一定程度时会对我的career有重大影响。打算在2016年逐步把以前半懂半不懂的东西都给研究清楚，包括图形学、机器学习等我感兴趣的学科的数学、算法基础知识。搞懂了原理后，要做什么开发都会更得心应手。具体做法是，看书、写代码实践。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写博客。作为engineer，怎么可以没有一个自己的技术博客呢。写博客这个事情，我觉得有不少好处：巩固学到的知识、方便日后复习知识、锻炼写作表达能力、方便个人marketing(目前还没有效果)。百利而无一害，除了打字比较费功夫(把娱乐节目砍掉就抵消了)。实际上，我写博客是从大二开始的，期间写写停停，陆陆续续换了几个博客系统，从cppblog第三方博客到github静态博客，然而毕业后因为工作繁忙，完全荒废了。辞职前，我开始捡回我“写博客的梦想”。辞旧迎新，我把旧的博客git整个删了(旧博文现在看来，太无聊了)，同时也因为那个博客的框架代码是大三时借鉴其他博主的代码弄出来的，不是自己的代码，难以维护。现在我改用jekyll-now来搭建博客，更简单易用。也因为2014年下半年的驻梦项目，我的web开发实力有了大大的提高，新博客在技术上也没什么隐患了。目前新博客已经持续写了半年。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提高英语能力。“听”会通过听有声书提高，“读”和“说”通过阅读英文文章(技术书、Quora等)、朗读英文小说来提高。我在EF的学习也即将步入尾声。总的来说，这段经历使得我对语言学习产生了更大的兴趣和自信，是一个好的转折点。但之后应该不会再花大钱在外语学习上了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;Life&lt;/h1&gt;

&lt;p&gt;2015年除了过年时去了杭州，由于工作上的不顺心(其实是没钱)，之后都没有外出旅行。2015开始，更重视的是积蓄的问题，因为我发现工作2年后，依然存不到多少钱，对建立家庭来说，远远不足。在中国白手起家想要做到安居乐业，有车有房，完全就是一个Hard难度的游戏。当然，游戏虽难，但仍有希望。&lt;/p&gt;

&lt;p&gt;2015年，家庭关系比较和谐，没出啥状况。和GF也还行，有波澜但终归和睦。2014年年底我们一起通宵打Minecraft，那时候她是一名见习医生；2015年年底我们一起通宵打Don&amp;#39;t Starve Together，这时候，她已经走在职业转型的道路上，即将成为一名美术生。也许以后我们会一起做独立游戏。可能这就是destiny吧。&lt;/p&gt;

&lt;p&gt;对于物质生活，我是有期待的，但是暂时无法提高，也就不勉强。其它不实际的期待也没有了，只但愿这副身子骨不散架，平平安安，就好。&lt;/p&gt;

&lt;p&gt;存钱的问题，其实就是买房结婚生孩子的问题，连这个问题都搞不定，事业就不算成功。2016年如无意外，也不能够解决这个问题。现在唯一能做的事情只是投资自己、好好学习。通过游戏开发以外的方法赚钱，也难。&lt;/p&gt;

&lt;h1&gt;My Philosophy Changed&lt;/h1&gt;

&lt;p&gt;最近和朋友分享过我的哲学观:一个我自己都认为不对的效益主义(utilitarianism)。凡事衡量、计算得失，择优而行。然而，这个方法不总是有效，因为有些事情，做不做，无法立即得到回报，相当于长远的、有一定风险的投资。譬如我可以花很多时间精力去广交朋友，做个人marketing，然而我无法确定这对我是不是一件好事。我现在的哲学观是：喜欢就做，不喜欢就不做。这可能无法得到最优解，但起码可以让我活得不像是个只会计算得失的机器。有时候想太多真的没用。&lt;/p&gt;

&lt;p&gt;至于钱、时间、理想，我是这样看的：没钱的时候不能一味追求理想，应该先求生存再求发展；没钱的时候可以用时间换钱(去打工，哪怕是派传单)；有钱的时候用钱买时间(譬如回家不坐火车坐飞机，买高配的机器提高开发效率节省时间)。也即是说，要根据当下条件，做相应的决策。&lt;/p&gt;

&lt;p&gt;所以我觉得我现在，是最适合追求理想的，因未成家，没有太多开销，时间基本都是自己的(有一定的时间)，同时收入也足够维持日常开销(有一定的钱)。怕是再过几年，再追求什么大理想，就更艰难了。&lt;/p&gt;

&lt;p&gt;珍惜当下。&lt;/p&gt;

&lt;p&gt;Goodbye 2015。&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/summarize/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/summarize/</guid>
      </item>
    
      <item>
        <title>曲线数学之B样条曲线B-Spline</title>
        <description>&lt;p&gt;上一篇文章已经介绍了贝塞尔曲线。本篇文章接着介绍B样条曲线。&lt;/p&gt;

&lt;p&gt;B样条曲线，简单来说，它是对贝塞尔曲线的一个补充。为什么这样说呢？是因为贝塞尔曲线某些情况下不实用：曲线上每个点受所有控制点影响，这会给调整曲线工作带来麻烦。可以想到的第一个优化是，把整个贝塞尔曲线变成多段贝塞尔子曲线的拼接。然而，这个方案也不好用，因为拼接工作很难做好，因为要拼接曲线显得“光滑”前提是保证相邻曲线之间的连续性。&lt;/p&gt;

&lt;p&gt;于是，老外发明了一个算法:&lt;a href=&quot;https://en.wikipedia.org/wiki/De_Boor%27s_algorithm&quot;&gt;De Boor&amp;#39;s algorithm&lt;/a&gt;，基于这个算法的曲线也被称为贝塞尔曲线的变种：B-Spline(B样条)曲线。为什么叫Spline曲线呢？我猜是因为Spline曲线在4个控制点的情况下，有个典型的形状：&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.12/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;是不是有点像一条脊椎(spine)？(跑题了= =)&lt;/p&gt;

&lt;p&gt;下文开始进入数学部分。&lt;/p&gt;

&lt;h1&gt;B-Spline的定义&lt;/h1&gt;

&lt;p&gt;B-Spline曲线我所知道的第一种估计也是最主要的定义：递归定义，其实是贝塞尔曲线的递归定义的一般化。先搬出贝塞尔的递归定义：&lt;/p&gt;

&lt;p&gt;\[ P_{i}^{k} =\begin {cases} P_{i}  【k=0】 \\  (1-t)P_{i}^{k-1}+tP_{i+1}^{k-1} 【k=1,2,\cdots ,n,i=0,1,\cdots ,n-k】 \end {cases}  \]&lt;/p&gt;

&lt;p&gt;而B-Spline是：&lt;/p&gt;

&lt;p&gt;\[ N_{i}^{n}(x) = \frac {x-u_{i}}{u_{i+n}-u_{i}}N_{i}^{n-1}(x) + \frac {u_{i+n+1} - x}{u_{i+n+1}-u_{i+1}}N_{i+1}^{n-1}(x) \]&lt;/p&gt;

&lt;p&gt;\[ N_{i}^{0}(x) =\begin {cases} 1  【x \in [ u_{i},u_{i+1} ) 】 \\ 0  【otherwise】 \end {cases} \]&lt;/p&gt;

&lt;p&gt;(怎么也能看出一丝相似吧。)&lt;/p&gt;

&lt;p&gt;从公式来看，似乎是变复杂了。然而其实现代码可以很简单，比如github上的这个js实现:&lt;a href=&quot;https://github.com/thibauts/b-spline&quot;&gt;https://github.com/thibauts/b-spline&lt;/a&gt;，它的B-Spline核心代码只有10行不到(OTL)。&lt;/p&gt;

&lt;p&gt;对于这条公式的剖析，我发现有人已经做得机好了：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/tuqu/article/details/4749586&quot;&gt;B-样条曲线教程B-spline Curves Notes目录&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/tuqu/article/details/5177405&quot;&gt;B-样条基函数：定义 B-spline Basis Functions: Definition&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;扒了下原文，原来是密西根理工大学的教学讲义: &lt;a href=&quot;http://www.cs.mtu.edu/%7Eshene/COURSES/cs3621/NOTES/&quot;&gt;http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果认真看完这些资料，基本该懂的都懂了。&lt;/p&gt;

&lt;p&gt;因为我自己来写B-Spline剖析肯定写不到这个深度，当然也没必要。所以我做了点别的事情：写了一个curve designer：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://voyagingmk.github.io/curvedesigner/&quot;&gt;curve designer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(这个东西基于zebra WebUI和上面那个bspline，顺便吐槽下，zebra没有看起来那么好用)&lt;/p&gt;

&lt;p&gt;目的是实现一个B样条曲线的可视化编辑器，通过改变参数来理解B样条的实际特性。这可比看公式看论文爽多了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.12/4.png&quot; alt=&quot;4.png&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/b-spline-1/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/b-spline-1/</guid>
      </item>
    
      <item>
        <title>曲线数学之贝塞尔曲线Bézier Curves</title>
        <description>&lt;p&gt;本文主要关注的是公式的推导。&lt;/p&gt;

&lt;p&gt;在讲贝塞尔曲线之前先复习下组合数学。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1&gt;组合数学&lt;/h1&gt;

&lt;h2&gt;排列 permutation&lt;/h2&gt;

&lt;p&gt;注意，排列的英文是permutation，这个词也就是线性代数里的“置换”。联想置换矩阵的概念，就可以近似理解“排列”的意义。&lt;/p&gt;

&lt;p&gt;permutation的公式是：&lt;/p&gt;

&lt;p&gt;\[ P(n,k) = P_{n}^{k} = \frac {n!}{(n-k)!} \]&lt;/p&gt;

&lt;p&gt;含义：从n个数取出某k个数总共有多少种排列。&lt;/p&gt;

&lt;p&gt;所以，排列是&lt;strong&gt;有顺序&lt;/strong&gt;的。&lt;/p&gt;

&lt;h2&gt;组合 combination&lt;/h2&gt;

&lt;p&gt;组合这个东西可以用“排列”来理解，比如对于某3个不同的数a、b、c，有\[ P_{3}^{3} = \frac {3!}{(3-3)!} = 6 \]种排列: abc、acb、bac、bca、cab、cba，然而，组合数只有一个，也就是[a、b、c]。&lt;/p&gt;

&lt;p&gt;所以，组合是&lt;strong&gt;没有顺序&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;combination的公式是：&lt;/p&gt;

&lt;p&gt;\[ C(n,k)  = C_{n}^{k} = \frac { P_{n}^{k} } { P_{k}^{k} } = \frac {n!}{k!(n-k)!} , 0 &amp;lt; k &amp;lt;= n\]&lt;/p&gt;

&lt;p&gt;性质1：&lt;/p&gt;

&lt;p&gt;\(  C_{n}^{k} = \frac {n!}{k!(n-k)!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{(n-(n-k))!(n-k)!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{(n-k)!(n-(n-k))!} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{n-k} \)&lt;/p&gt;

&lt;p&gt;性质2：&lt;/p&gt;

&lt;p&gt;\[  C_{n}^{k} = \frac {n!}{k!(n-k)!} = 0 【 k &amp;lt; 0 ， k &amp;gt; n】 \] &lt;/p&gt;

&lt;p&gt;(当k&lt;0或k&gt;n时，右边的式子会出现负数的阶乘。负数阶乘在组合数公式的计算中，可以认为等于0)&lt;/p&gt;

&lt;p&gt;combination很重要，比如说二项式定理里的展开式就用到了它：&lt;/p&gt;

&lt;p&gt;\[ (a+b)^{n} = \sum_{r=0}^{n}C_{n}^{r}a^{n-r}b^{r} \]&lt;/p&gt;

&lt;p&gt;combination还有一条公式要注意下：&lt;/p&gt;

&lt;p&gt;\[ C_{n}^{k} = C_{n-1}^{k-1} + C_{n-1}^{k} , 0 &amp;lt; k &amp;lt; n \]&lt;/p&gt;

&lt;p&gt;顺便给个简单证明：&lt;/p&gt;

&lt;p&gt;\( C_{n-1}^{k-1} + C_{n-1}^{k} = \)&lt;/p&gt;

&lt;p&gt;\( \frac {(n-1)!}{(n-1-(k-1))!(k-1)!} + \frac {(n-1)!}{(n-1-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {(n-1)!}{(n-k)!(k-1)!} + \frac {(n-1)!}{(n-1-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {k(n-1)!}{k(n-k)!(k-1)!} + \frac {(n-k)(n-1)!}{(n-k)(n-1-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {k(n-1)!}{(n-k)!k!} + \frac {(n-k)(n-1)!}{(n-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {k(n-1)!+(n-k)(n-1)!}{(n-k)!k!}  = \)&lt;/p&gt;

&lt;p&gt;\( \frac {n(n-1)!}{(n-k)!k!}  =  \frac {n!}{(n-k)!k!}  =   C_{n}^{k} \)&lt;/p&gt;

&lt;h1&gt;贝塞尔曲线&lt;/h1&gt;

&lt;h2&gt;定义&lt;/h2&gt;

&lt;p&gt;给定n个控制点\(P_{0},P_{1},\cdots ,P_{n}\)，贝塞尔曲线的公式如下：&lt;/p&gt;

&lt;p&gt;\[ P(t) = \sum_{i=0}^{n}P_{i}B_{i,n}(t) , t\in [0,1] \]&lt;/p&gt;

&lt;p&gt;其中的\( B_{i,n}(t) \)叫Bernstein polynomial，定义如下：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(t) = C_{n}^{i}t^{i}(1-t)^{n-i} = \frac {n!}{i!(n-i)!}t^{i}(1-t)^{n-i} 【i=0,1,\cdots ,n】 \]&lt;/p&gt;

&lt;h2&gt;Bézier曲线的特性&lt;/h2&gt;

&lt;p&gt;特性1：改变单个控制点会引起整条曲线的改变。&lt;/p&gt;

&lt;h2&gt;Bernstein polynomial的特性&lt;/h2&gt;

&lt;h4&gt;递归性&lt;/h4&gt;

&lt;p&gt;\[ B_{i,n}(t) = (1-t)B_{i,n-1}(t) + tB_{i-1,n-1}(t)   【i=0,1,\cdots ,n】 \]&lt;/p&gt;

&lt;p&gt;证明：&lt;/p&gt;

&lt;p&gt;\( B_{i,n}(t) \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{i}t^{i}(1-t)^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n-1}^{i-1} + C_{n-1}^{i})t^{i}(1-t)^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n-1}^{i-1}t^{i}(1-t)^{n-i} + C_{n-1}^{i}t^{i}(1-t)^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)C_{n-1}^{i}t^{i}(1-t)^{(n-1)-i} + tC_{n-1}^{i-1}t^{i-1}(1-t)^{(n-1)-(i-1)} \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)B_{i,n-1}(t) + tB_{i-1,n-1}(t) \)&lt;/p&gt;

&lt;h4&gt;归一性&lt;/h4&gt;

&lt;p&gt;\[ \sum_{i=0}^{n}B_{i,n}(t) \equiv 1   【t\in (0,1)】 \]&lt;/p&gt;

&lt;p&gt;证明：&lt;/p&gt;

&lt;p&gt;根据二项式定理有：&lt;/p&gt;

&lt;p&gt;\[ \sum_{i=0}^{n}B_{i,n}(t) \]
\[ = \sum_{i=0}^{n}C_{n}^{i}t^{i}(1-t)^{n-i} \]
\[ [(1-t)+t]^{n} \equiv 1  \]&lt;/p&gt;

&lt;h4&gt;Partition of Unity&lt;/h4&gt;

&lt;p&gt;\[ \sum_{i=0}^{n}B_{i,n}(t) = \sum_{i=0}^{n-1}B_{i,n-1}(t) = 1 \]&lt;/p&gt;

&lt;p&gt;证明:&lt;/p&gt;

&lt;p&gt;利用递归公式，有：&lt;/p&gt;

&lt;p&gt;\( \sum_{i=0}^{n}B_{i,n}(t) \)&lt;/p&gt;

&lt;p&gt;\( = \sum_{i=0}^{n}[(1-t)B_{i,n-1}(t) + tB_{i-1,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = \sum_{i=0}^{n}[(1-t)B_{i,n-1}(t)] + \sum_{i=0}^{n}[tB_{i-1,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)\sum_{i=0}^{n}[B_{i,n-1}(t)] + t\sum_{i=0}^{n}[B_{i-1,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)[\sum_{i=0}^{n-1}B_{i,n-1}(t) + B_{n,n-1}(t) ] + t[\sum_{i=1}^{n}B_{i-1,n-1}(t) + B_{-1,n-1}(t) ] \)&lt;/p&gt;

&lt;p&gt;因为:&lt;/p&gt;

&lt;p&gt;\[ B_{n,n-1}(t) = C_{n-1}^{n}t^{n}(1-t)^{n-1-n} = 0 \]&lt;/p&gt;

&lt;p&gt;\[ B_{-1,n-1}(t) = C_{n-1}^{-1}t^{-1}(1-t)^{(n-1)-(-1)} = 0 \]&lt;/p&gt;

&lt;p&gt;(这里利用了上文提到的组合数公式性质2)&lt;/p&gt;

&lt;p&gt;所以可简化为：&lt;/p&gt;

&lt;p&gt;\( \sum_{i=0}^{n}B_{i,n}(t) \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)[\sum_{i=0}^{n-1}B_{i,n-1}(t)] + t[\sum_{i=1}^{n}B_{i-1,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = (1-t)[\sum_{i=0}^{n-1}B_{i,n-1}(t)] + t[\sum_{i=0}^{n-1}B_{i,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = (1-t+t)[\sum_{i=0}^{n-1}B_{i,n-1}(t)] \)&lt;/p&gt;

&lt;p&gt;\( = \sum_{i=0}^{n-1}B_{i,n-1}(t) \)&lt;/p&gt;

&lt;h4&gt;对称性&lt;/h4&gt;

&lt;p&gt;\[ B_{i,n}(1 - t) = B_{n-i,n}(t) \]&lt;/p&gt;

&lt;p&gt;证明：&lt;/p&gt;

&lt;p&gt;由定义：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(t) = C_{n}^{i}t^{i}(1-t)^{n-i} \]&lt;/p&gt;

&lt;p&gt;有：&lt;/p&gt;

&lt;p&gt;\( B_{n-i,n}(t) = C_{n}^{n-i}t^{n-i}(1-t)^{n-(n-i)}  \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{n-i}t^{n-i}(1-t)^{i}  \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{i}t^{n-i}(1-t)^{i} \)&lt;/p&gt;

&lt;p&gt;\( B_{i,n}(1 - t) =  C_{n}^{i}(1 - t)^{i}(1-(1 - t))^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{i}(1 - t)^{i}t^{n-i} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{i}t^{n-i}(1-t)^{i} \)&lt;/p&gt;

&lt;p&gt;得证。&lt;/p&gt;

&lt;h4&gt;非负性&lt;/h4&gt;

&lt;p&gt;当 t = 0 时：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(0) = 0 , 【i &amp;gt; 0】\]&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(0) = 1 , 【i = 0】\]&lt;/p&gt;

&lt;p&gt;当 t = 1 时：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(0) = 0 , 【i &amp;gt; 0】\]&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(0) = 1 , 【i = 0】\]&lt;/p&gt;

&lt;p&gt;当 t= (0,1) 时：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(t) &amp;gt; 0 , 【i =0,1,2,\cdots ,n-1】\]&lt;/p&gt;

&lt;p&gt;证明：把数值代入定义公式就可以了。&lt;/p&gt;

&lt;h2&gt;Bernstein基(Bernstein Basis)到幂基(Power Basis)的转换&lt;/h2&gt;

&lt;p&gt;由二项式定理：&lt;/p&gt;

&lt;p&gt;\[ (a+b)^{n} = \sum_{r=0}^{n}C_{n}^{r}a^{n-r}b^{r} \]&lt;/p&gt;

&lt;p&gt;得到：&lt;/p&gt;

&lt;p&gt;\[ (1-t)^{n} = \sum_{r=0}^{n}C_{n}^{r}1^{n-r}(-t)^{r} = \sum_{r=0}^{n}C_{n}^{r}(-t)^{r}\]&lt;/p&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;p&gt;\[ B_{i,n}(t) = C_{n}^{i}t^{i}(1-t)^{n-i} \]&lt;/p&gt;

&lt;p&gt;\[ = C_{n}^{i}t^{i}\sum _{k=0}^{n-i}C_{n-i}^{k}(-t)^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = C_{n}^{i}t^{i}\sum _{k=0}^{n-i}C_{n-i}^{k}(-1)^{k}t^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=0}^{n-i}C_{n}^{i}t^{i}C_{n-i}^{k}(-1)^{k}t^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=0}^{n-i}C_{n}^{i}C_{n-i}^{k}(-1)^{k}t^{k+i} \]&lt;/p&gt;

&lt;p&gt;这时设g = k + i ，则有 k = g - i，i = g - k，上式变成：&lt;/p&gt;

&lt;p&gt;\[ = \sum _{g - i=0}^{n-(g-k)}C_{n}^{i}C_{n-i}^{g - i}(-1)^{g - i}t^{g} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{g=i}^{n-g+k}C_{n}^{i}C_{n-i}^{g - i}(-1)^{g - i}t^{g}\]&lt;/p&gt;

&lt;p&gt;把g换成k，上式变成：&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=i}^{n-k+k}C_{n}^{i}C_{n-i}^{k - i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=i}^{n}C_{n}^{i}C_{n-i}^{k - i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;其中\(C_{n}^{i}C_{n-i}^{k - i}\)可以进一步简化：&lt;/p&gt;

&lt;p&gt;\( C_{n}^{i} C_{n-i}^{k - i} \)
\( = \frac {n!}{i!(n-i)!} \frac {(n-i)!}{(k-i)!((n-i)-(k-i))!}  \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{i!(n-i)!} \frac {(n-i)!}{(k-i)!((n-k)!}  \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!(n-i)!}{i!(n-i)!(k-i)!((n-k)!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{i!(k-i)!((n-k)!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!k!}{i!(k-i)!((n-k)!k!} \)&lt;/p&gt;

&lt;p&gt;\( = \frac {n!}{k!(n-k)!} \frac {k!}{i!((k-i)!} \)&lt;/p&gt;

&lt;p&gt;\( = C_{n}^{k} C_{k}^{i} \)&lt;/p&gt;

&lt;p&gt;所以：&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=i}^{n}C_{n}^{i}C_{n-i}^{k - i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;\[ = \sum _{k=i}^{n}C_{n}^{k} C_{k}^{i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;综上:&lt;/p&gt;

&lt;p&gt;\[  B_{i,n}(t) = \sum _{k=i}^{n}C_{n}^{k} C_{k}^{i}(-1)^{k - i}t^{k} \]&lt;/p&gt;

&lt;p&gt;设\( b_{k,i} = C_{n}^{k} C_{k}^{i}(-1)^{k - i} \)&lt;/p&gt;

&lt;p&gt;则上式变成：&lt;/p&gt;

&lt;p&gt;\[  B_{i,n}(t) = \sum _{k=i}^{n}b_{k,i}t^{k} \]&lt;/p&gt;

&lt;p&gt;展开后：&lt;/p&gt;

&lt;p&gt;\[  B_{i,n}(t) = b_{i,i}t^{i} + b_{i+1,i}t^{i+1} + \cdots + b_{n,i}t^{n} \]&lt;/p&gt;

&lt;h1&gt;Bézier曲线的递推形式(de Casteljau算法)&lt;/h1&gt;

&lt;p&gt;前面讲的是Bézier曲线的曲线方程定义，现在介绍一个简单实用的算法:de Casteljau&amp;#39;s Algorithm。&lt;/p&gt;

&lt;p&gt;先分享我找到的一些演示程序：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://myst729.github.io/bezier-curve/&quot;&gt;http://myst729.github.io/bezier-curve/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jasondavies.com/animated-bezier/&quot;&gt;https://www.jasondavies.com/animated-bezier/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;以及油管上的:&lt;a href=&quot;https://www.youtube.com/watch?v=YATikPP2q70&quot;&gt;https://www.youtube.com/watch?v=YATikPP2q70&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;递推公式如下：&lt;/p&gt;

&lt;p&gt;\[ P_{i}^{k} =\begin {cases} P_{i}  【k=0】 \\  (1-t)P_{i}^{k-1}+tP_{i+1}^{k-1} 【k=1,2,\cdots ,n,i=0,1,\cdots ,n-k】 \end {cases}  \]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/2015.12/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;以上图为例演示下这条公式：&lt;/p&gt;

&lt;p&gt;因为有\( P_{0},P_{1},P_{2},P_{3} \)4个控制点，所以n的值是3(要减1)。&lt;/p&gt;

&lt;p&gt;然后求该贝塞尔曲线在 t = 1/2时的坐标点B(1/2)的步骤如下：&lt;/p&gt;

&lt;p&gt;k = 0时，\(i = 0,1,\cdots ,n-k = 0,1,2,3 \)，所以有:&lt;/p&gt;

&lt;p&gt;\( P_{i}^{k=0} = P_{i} \) &lt;/p&gt;

&lt;p&gt;\( P_{0}^{k=0} = P_{0} \)&lt;/p&gt;

&lt;p&gt;\( P_{1}^{k=0} = P_{1} \)&lt;/p&gt;

&lt;p&gt;\( P_{2}^{k=0} = P_{2} \)&lt;/p&gt;

&lt;p&gt;\( P_{3}^{k=0} = P_{3} \)&lt;/p&gt;

&lt;p&gt;k = 1时，\(i = 0,1,\cdots ,n-k = 0,1,2 \)，所以有:&lt;/p&gt;

&lt;p&gt;\( P_{i}^{k=1} = (1-t)P_{i}^{1-1}+tP_{i+1}^{1-1}  = (1-t)P_{i}^{0}+tP_{i+1}^{0} \)&lt;/p&gt;

&lt;p&gt;\( P_{0}^{k=1} = (1-t)P_{0}^{0}+tP_{1}^{0} = 0.5P_{0} + 0.5P_{1} = m_{0} \)&lt;/p&gt;

&lt;p&gt;\( P_{1}^{k=1} = (1-t)P_{1}^{0}+tP_{2}^{0} = 0.5P_{1} + 0.5P_{2} = m_{1} \)&lt;/p&gt;

&lt;p&gt;\( P_{2}^{k=1} = (1-t)P_{2}^{0}+tP_{3}^{0} = 0.5P_{2} + 0.5P_{3} = m_{2} \)&lt;/p&gt;

&lt;p&gt;k = 2时，\(i = 0,1,\cdots ,n-k = 0,1\)，所以有:&lt;/p&gt;

&lt;p&gt;\( P_{i}^{k=2} = (1-t)P_{i}^{1}+tP_{i+1}^{1} \)&lt;/p&gt;

&lt;p&gt;\( P_{0}^{k=2} = (1-t)P_{0}^{1}+tP_{1}^{1} = 0.5m_{0} + 0.5m_{1} = q_{0} \)&lt;/p&gt;

&lt;p&gt;\( P_{1}^{k=2} = (1-t)P_{1}^{1}+tP_{2}^{1} = 0.5m_{1} + 0.5m_{2} = q_{1} \)&lt;/p&gt;

&lt;p&gt;k = 3时，\(i = 0,1,\cdots ,n-k = 0\)，所以有:&lt;/p&gt;

&lt;p&gt;\( P_{i}^{k=3} = (1-t)P_{i}^{2}+tP_{i+1}^{2} \)&lt;/p&gt;

&lt;p&gt;\( P_{0}^{k=3} = (1-t)P_{0}^{2}+tP_{1}^{2} = 0.5q_{0} + 0.5q_{1} = B(1/2) \)&lt;/p&gt;

&lt;h1&gt;Bézier曲线的矩阵形式&lt;/h1&gt;

&lt;p&gt;由上上一节推导出来的2条式子：&lt;/p&gt;

&lt;p&gt;\[ b_{k,i} = C_{n}^{k} C_{k}^{i}(-1)^{k - i} \]&lt;/p&gt;

&lt;p&gt;\[  B_{i,n}(t) = \sum _{k=i}^{n}b_{k,i}t^{k} = b_{i,i}t^{i} + b_{i+1,i}t^{i+1} + \cdots + b_{n,i}t^{n} \]&lt;/p&gt;

&lt;p&gt;可以推导出矩阵：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} B_{0,n}(t)&amp;amp;B_{1,n}(t)&amp;amp;\cdots &amp;amp;B_{n,n}(t)\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} \sum _{k=0}^{n}b_{k,0}t^{k}&amp;amp;\sum _{k=1}^{n}b_{k,1}t^{k}&amp;amp;\cdots &amp;amp;\sum _{k=n}^{n}b_{k,n}t^{k}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} t^{0}&amp;amp;t^{1}&amp;amp;t^{2}&amp;amp;\cdots &amp;amp;t^{n}\\ \end{matrix} \right] \left[ \begin{matrix} b_{0,0}&amp;amp;0&amp;amp;0&amp;amp;\cdots &amp;amp;0\\  b_{1,0}&amp;amp;b_{1,1}&amp;amp;0&amp;amp;\cdots &amp;amp;0\\  b_{2,0}&amp;amp;b_{2,1}&amp;amp;b_{2,2}&amp;amp;\cdots &amp;amp;0\\  \vdots &amp;amp;\vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots \\  b_{n,0}&amp;amp;b_{n,1}&amp;amp;b_{n,2}&amp;amp;\cdots &amp;amp;b_{n,n}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;再由Bézier曲线的公式：&lt;/p&gt;

&lt;p&gt;\[ P(t) = \sum_{i=0}^{n}P_{i}B_{i,n}(t) , t\in [0,1] \]&lt;/p&gt;

&lt;p&gt;有：&lt;/p&gt;

&lt;p&gt;\[ P(t) =  \left[ \begin{matrix} t^{0}&amp;amp;t^{1}&amp;amp;t^{2}&amp;amp;\cdots &amp;amp;t^{n}\\ \end{matrix} \right] \left[ \begin{matrix} b_{0,0}&amp;amp;0&amp;amp;0&amp;amp;\cdots &amp;amp;0\\  b_{1,0}&amp;amp;b_{1,1}&amp;amp;0&amp;amp;\cdots &amp;amp;0\\  b_{2,0}&amp;amp;b_{2,1}&amp;amp;b_{2,2}&amp;amp;\cdots &amp;amp;0\\  \vdots &amp;amp;\vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots \\  b_{n,0}&amp;amp;b_{n,1}&amp;amp;b_{n,2}&amp;amp;\cdots &amp;amp;b_{n,n}\\ \end{matrix} \right]  \left[ \begin{matrix} P^{0}\\ P^{1}\\ P^{2}\\ \vdots \\ P^{n}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;注意，中间的矩阵B是常量(取决于阶数):&lt;/p&gt;

&lt;p&gt;n = 2时：&lt;/p&gt;

&lt;p&gt;\( b_{k,i} = C_{2}^{k} C_{k}^{i}(-1)^{k - i} \)&lt;/p&gt;

&lt;p&gt;\( b_{0,0} = C_{2}^{0} C_{0}^{0}(-1)^{0 - 0} =  1*1=1 \)&lt;/p&gt;

&lt;p&gt;\( b_{1,0} = C_{2}^{1} C_{1}^{0}(-1)^{1 - 0} =  2*1*(-1)=-2 \)&lt;/p&gt;

&lt;p&gt;\( b_{2,0} = C_{2}^{2} C_{2}^{0}(-1)^{2 - 0} =  1*1=1 \)&lt;/p&gt;

&lt;p&gt;\( b_{1,1} = C_{2}^{1} C_{1}^{1}(-1)^{1 - 1} =  2*1=2 \)&lt;/p&gt;

&lt;p&gt;\( b_{2,1} = C_{2}^{2} C_{2}^{1}(-1)^{2 - 1} =  1*2*(-1)=-2 \)&lt;/p&gt;

&lt;p&gt;\( b_{2,2} = C_{2}^{2} C_{2}^{2}(-1)^{2 - 2} =  1*1=1 \)&lt;/p&gt;

&lt;p&gt;\[ B =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0\\ -2&amp;amp;2&amp;amp;0\\ 1&amp;amp;-2&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;n = 3时：&lt;/p&gt;

&lt;p&gt;\[ B =  \left[ \begin{matrix} 1&amp;amp;0&amp;amp;0&amp;amp;0\\ -3&amp;amp;3&amp;amp;0&amp;amp;0\\ 3&amp;amp;-6&amp;amp;3&amp;amp;0\\ -1&amp;amp;3&amp;amp;-3&amp;amp;1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h2&gt;测试一下正确性&lt;/h2&gt;

&lt;p&gt;测试代码基于我正在开发中的&lt;a href=&quot;https://github.com/voyagingmk/renderer&quot;&gt;renderer&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;quot;transform.hpp&amp;quot;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;quot;geometry.hpp&amp;quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Matrix3x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;mf&quot;&gt;20.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;20.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//P0&lt;/span&gt;
        &lt;span class=&quot;mf&quot;&gt;770.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;30.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//P1&lt;/span&gt;
        &lt;span class=&quot;mf&quot;&gt;400.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;780.f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//P2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Matrix3x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Matrix3x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MxN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Matrix1x3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CImg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atXYZC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atXYZC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atXYZC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0001f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Matrix1x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Matrix1x3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TBP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TBP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TBP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atXYZC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;../images/2015.12/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/bezier-1/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/bezier-1/</guid>
      </item>
    
      <item>
        <title>线性代数之Cholesky分解</title>
        <description>&lt;p&gt;又到了矩阵分解时间。这次介绍的是&lt;strong&gt;Cholesky分解&lt;/strong&gt;。这个方法只适用于符合厄米特矩阵、正定矩阵定义的矩阵。&lt;/p&gt;

&lt;h2&gt;算法原理&lt;/h2&gt;

&lt;p&gt;设A是一个n阶厄米特正定矩阵(Hermitian positive-definite matrix)。&lt;/p&gt;

&lt;p&gt;Cholesky分解的目标是把A变成:&lt;/p&gt;

&lt;p&gt;\[ A = LL^{T} \]&lt;/p&gt;

&lt;p&gt;L是下三角矩阵。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;推导过程&lt;/h2&gt;

&lt;p&gt;因为A是对称的矩阵，所以设A为：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} a_{11}&amp;amp;A_{21}^{T}\\ A_{21}&amp;amp;A_{22}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;(注意：细心观察此式子可以发现\(A_{21}\)是一个列向量，\(A_{22}\)是一个n-1阶的方阵)&lt;/p&gt;

&lt;p&gt;设L：&lt;/p&gt;

&lt;p&gt;\[ L =  \left[ \begin{matrix} l_{11}&amp;amp;0\\ L_{21}&amp;amp;L_{22}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;则有:&lt;/p&gt;

&lt;p&gt;\[ L^{T} =  \left[ \begin{matrix} l_{11}&amp;amp;L_{21}^{T}\\ 0&amp;amp;L_{22}^{T}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;设\( A = LL^{T} \)，得到：&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} a_{11}&amp;amp;A_{21}^{T}\\ A_{21}&amp;amp;A_{22}\\ \end{matrix} \right] =  \left[ \begin{matrix} l_{11}&amp;amp;0\\ L_{21}&amp;amp;L_{22}\\ \end{matrix} \right] \left[ \begin{matrix} l_{11}&amp;amp;L_{21}^{T}\\ 0&amp;amp;L_{22}^{T}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ =  \left[ \begin{matrix} l_{11}^{2}&amp;amp;l_{11}L_{21}^{T}\\ l_{11}L_{21}&amp;amp;L_{21}L_{21}^{T}+L_{22}L_{22}^{T}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;其中，未知量是\( l_{11},L_{21},L_{22} \)，这3个未知量的求解公式是：&lt;/p&gt;

&lt;p&gt;\[ l_{11} = \sqrt {a_{11}} \]&lt;/p&gt;

&lt;p&gt;\[ L_{21} = \frac {1}{l_{11}}A_{21} \]&lt;/p&gt;

&lt;p&gt;\[ L_{22}L_{22}^{T} =  A_{22} - L_{21}L_{21}^{T} \]&lt;/p&gt;

&lt;p&gt;显然，\( l_{11},L_{21} \)是易求的，而\( L_{22} \)的求解救有意思了。&lt;/p&gt;

&lt;p&gt;观察可以发现，\( A_{22} - L_{21}L_{21}^{T} \)也很好求，\( A_{22} \)已知，\( L_{21}L_{21}^{T} \)是一个对角线矩阵，对角线上的元素只是一个平方，好求。&lt;/p&gt;

&lt;p&gt;那么设\(A_{22}&amp;#39; = A_{22} - L_{21}L_{21}^{T} \)，则剩下的问题就是求:&lt;/p&gt;

&lt;p&gt;\[ A_{22}&amp;#39; = L_{22}L_{22}^{T} \]&lt;/p&gt;

&lt;p&gt;啊，这不也是Cholesky分解！被分解的矩阵是A的右下角的n-1阶子方阵！&lt;/p&gt;

&lt;p&gt;所以这个算法具有递归性质。&lt;/p&gt;

&lt;p&gt;附上一个实例：&lt;/p&gt;

&lt;p&gt;设:&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} 25&amp;amp;15&amp;amp;-5\\ 15&amp;amp;18&amp;amp;0\\ -5&amp;amp;0&amp;amp;11\\ \end{matrix} \right] =  \left[ \begin{matrix} l_{11}&amp;amp;0&amp;amp;0\\ l_{21}&amp;amp;l_{22}&amp;amp;0\\ l_{31}&amp;amp;l_{32}&amp;amp;l_{33}\\ \end{matrix} \right] \left[ \begin{matrix} l_{11}&amp;amp;l_{21}&amp;amp;l_{31}\\ 0&amp;amp;l_{22}&amp;amp;l_{32}\\ 0&amp;amp;0&amp;amp;l_{33}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;根据上文的公式，有：&lt;/p&gt;

&lt;p&gt;\[ l_{11} = \sqrt { a_{11} } = 5 \]
\[ L_{21} = \frac {1}{l_{11}}A_{21} = \frac {1}{5} \left[ \begin{matrix} 15\\ -5\\ \end{matrix} \right] =  \left[ \begin{matrix} 3\\ -1\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[ A_{22} - L_{21}L_{21}^{T}  =  L_{22}L_{22}^{T} \]&lt;/p&gt;

&lt;p&gt;\[ A_{22} - L_{21}L_{21}^{T}  =  L_{22}L_{22}^{T} \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} 18&amp;amp;0\\ 0&amp;amp;11\\ \end{matrix} \right] -  \left[ \begin{matrix} 3\\ -1\\ \end{matrix} \right] \left[ \begin{matrix} 3&amp;amp;-1\\ \end{matrix} \right] =   \left[ \begin{matrix} l_{22}&amp;amp;0\\ l_{32}&amp;amp;l_{33}\\ \end{matrix} \right]   \left[ \begin{matrix} l_{22}&amp;amp;l_{32}\\ 0&amp;amp;l_{33}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;\[  \left[ \begin{matrix} 9&amp;amp;3\\ 3&amp;amp;10\\ \end{matrix} \right] =  \left[ \begin{matrix} l_{22}&amp;amp;0\\ l_{32}&amp;amp;l_{33}\\ \end{matrix} \right]   \left[ \begin{matrix} l_{22}&amp;amp;l_{32}\\ 0&amp;amp;l_{33}\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;p&gt;(注意，这里已经是n-1阶的Cholesky分解)&lt;/p&gt;

&lt;p&gt;\[ l_{22} = \sqrt { 9 } = 3 \]
\[ l_{32} = \frac {1}{3}3 = 1 \]
\[ 10 = l_{32}^{2} + l_{33}^{2} = 1 + l_{33}^{2} \]
\[ l_{33} = \sqrt {10 - 1} = 3 \]&lt;/p&gt;

&lt;p&gt;综上：&lt;/p&gt;

&lt;p&gt;\[ A =  \left[ \begin{matrix} 25&amp;amp;15&amp;amp;-5\\ 15&amp;amp;18&amp;amp;0\\ -5&amp;amp;0&amp;amp;11\\ \end{matrix} \right] =  \left[ \begin{matrix} 5&amp;amp;0&amp;amp;0\\ 3&amp;amp;3&amp;amp;0\\ -1&amp;amp;1&amp;amp;3\\ \end{matrix} \right] \left[ \begin{matrix} 5&amp;amp;3&amp;amp;-1\\ 0&amp;amp;3&amp;amp;1\\ 0&amp;amp;0&amp;amp;3\\ \end{matrix} \right] \]&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;
</description>
        <pubDate>Sat, 19 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://www.qiujiawei.com/linear-algebra-11/</link>
        <guid isPermaLink="true">http://www.qiujiawei.com/linear-algebra-11/</guid>
      </item>
    
  </channel>
</rss>