<!DOCTYPE html>
<html>
  <head>
    <title>redis5.0源码学习笔记（1） – Wyman的别致技术博客 – 恭喜你发现我的小站，撩我请加QQ：234707482、Wechat：_Wyman</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
    <meta name="baidu-site-verification" content="0OpfO1OtHA" />
    
    <meta name="description" content="Note：本文实际绑定的版本是branch5.0（2018-7-25）。

持续更新中。
" />
    <meta property="og:description" content="Note：本文实际绑定的版本是branch5.0（2018-7-25）。

持续更新中。
" />
    
    <meta name="author" content="Wyman的别致技术博客" />

    
    <meta property="og:title" content="redis5.0源码学习笔记（1）" />
    <meta property="twitter:title" content="redis5.0源码学习笔记（1）" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Wyman的别致技术博客 - 恭喜你发现我的小站，撩我请加QQ：234707482、Wechat：_Wyman" href="/feed.xml" />

    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-65954265-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/redis-1/',
		  'title': 'redis5.0源码学习笔记（1）'
		});
	</script>
	<!-- End Google Analytics -->
	<!-- Baidu Analytics -->
	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?0dc968591d8c64196a37eca9ca4f86b3";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
	<!-- End Baidu Analytics -->

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://www.qiujiawei.com/images/avatar.jpg" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Wyman的别致技术博客</a></h1>
            <p class="site-description">恭喜你发现我的小站，撩我请加QQ：234707482、Wechat：_Wyman</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<article class="post">
    <h1>redis5.0源码学习笔记（1）</h1>
    <h3>Tags: <a href="/tag/redis/" rel="tag">redis</a></h3>
    <div class="entry">
        <p>Note：本文实际绑定的版本是branch5.0（2018-7-25）。</p>

<p>持续更新中。</p>

<!--more-->

<h1>数据结构</h1>

<h2>SDS 简单动态字符串</h2>

<h3>基本特点</h3>

<ul>
<li>涉及字符串的存储基本都基于SDS，例如set nickname Luffy，就创建了nicknmae和Luffy2个SDS</li>
<li>不止用于字符串，还用于缓冲区：AOF缓冲区、客户端状态中的输入缓冲区</li>
<li>减少修改字符串长度时所需的内存重分配次数</li>
<li>杜绝缓冲区溢出问题</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ul>

<h3>源码位置</h3>

<ul>
<li>sds.h</li>
<li>sds.c</li>
</ul>

<h3>结构定义</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sds</span><span class="p">;</span>

<span class="cm">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span>
<span class="cm"> * However is here to document the layout of type 5 SDS strings. */</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr5</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, and 5 msb of string length */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr8</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* used */</span>
    <span class="kt">uint8_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* excluding the header and null terminator */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, 5 unused bits */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr16</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* used */</span>
    <span class="kt">uint16_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* excluding the header and null terminator */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, 5 unused bits */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr32</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* used */</span>
    <span class="kt">uint32_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* excluding the header and null terminator */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, 5 unused bits */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr64</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* used */</span>
    <span class="kt">uint64_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* excluding the header and null terminator */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 3 lsb of type, 5 unused bits */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li>sds被定义为5种，根据sds的len属性的bit数量划分：5、8、16、32、64bits，5bits的结构没有被使用。</li>
<li>紧凑对齐：<strong>attribute</strong> ((<strong>packed</strong>)) 告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。</li>
<li>char buf[]很有意思，这样子声明buf，是不会增大sizeof(sdshdr#T)的，因为编译器不知道buf的长度，默认0，而如果声明成指针，就会占4或8字节。</li>
<li>综上，5个sds结构的size分别为1、3、5、9、17</li>
<li>typedef char *sds，指向的是buf字段，如果要访问sdshdr的len、alloc、flags，是用宏SDS_HDR来定位sdshdr的首字节。</li>
<li>sds依然遵守C语言用&#39;\0&#39;（null terminator）结尾的习惯，使得sds可以使用C字符串函数库。</li>
<li>len相当于strlen(buf) - 1，记录实际使用了buf的多少字节</li>
<li>alloc记录buf的容量，不含&#39;\0&#39;</li>
<li>&#39;\0&#39;由sds自动处理，用户不会感知到&#39;\0&#39;；len、alloc也是</li>
<li>因为有len字段，获取sds长度时间复杂度为O(1)</li>
<li>len、alloc字段能防止缓冲区溢出</li>
<li>alloc - len = avail, avail有效地降低了频繁内存重分配的开销。这种策略叫空间预分配、惰性空间释放。</li>
</ul>

<h3>接口说明</h3>

<p>sds.h直接定义的简单接口：</p>

<ul>
<li>size_t sdslen(const sds s)：获得s的len字段</li>
<li>size_t sdsavail(const sds s)：返回这个s的空闲空间字节长度</li>
<li>sdssetlen(sds s, size_t newlen)：直接设置s的len字段（不验证上限的）</li>
<li>sdsinclen(sds s, size_t inc)：s的len增加inc（不验证上限的）</li>
<li>size_t sdsalloc(const sds s)：获得s的alloc字段（并不是分配一个sds）</li>
<li>sdssetalloc(sds s, size_t newlen)：直接设置s的alloc字段</li>
</ul>

<p>在sds.c定义的简单接口：</p>

<ul>
<li>int sdsHdrSize(char type)：根据SDS_TYPE_xx，返回对应的sdshdr结构的sizeof</li>
<li>char sdsReqType(size_t string_size)：根据给定大小，返回对应的sdshdr的类型SDS_TYPE_xx，策略是从小到大匹配</li>
<li>size_t sdsAllocSize(sds s)：等于sdsalloc(s) + 头部长度 + 1，即sds总共占了多少内存</li>
<li>void *sdsAllocPtr(sds s)：即得到s的sdshdr头部指针</li>
<li>sds sdsempty(void)：实际调用sdsnewlen(&quot;&quot;,0);</li>
<li>sds sdsnew(const char *init)：把C字符串转成sds</li>
<li>sds sdsdup(const sds s)：克隆一个sds</li>
</ul>

<p>核心接口：</p>

<ul>
<li>sds sdsnewlen(const void *init, size_t initlen)：创建一个新的sds对象，内容为init，len字段为initlen</li>
<li>void sdsfree(sds s)：销毁一个sds</li>
<li>void sdsupdatelen(sds s)：更新s的len为strlen的结果，如果sds某个字节被置0，就会导致strlen长度发生变化。</li>
<li>void sdsclear(sds s)：清空sds，但不释放sds内存</li>
<li>sds sdsMakeRoomFor(sds s, size_t addlen)：增大sds的alloc，但不影响已存内容和len字段，会返回新的sds(地址发生改变)</li>
<li>sds sdsRemoveFreeSpace(sds s)：缩小sds的alloc，使得没有avail空间（100%利用率），会返回新的sds</li>
<li>void sdsIncrLen(sds s, ssize_t incr)：和sdsinclen类似，区别在于加了assert防止超过上限，以及会把newlen字节置0</li>
<li>sds sdsgrowzero(sds s, size_t len)：oldlen增大到len，len - oldlen这段空间会自动置0</li>
<li>sds sdscatlen(sds s, const void *t, size_t len)：即concat操作</li>
<li>sds sdscat(sds s, const char *t)：用strlen(t)去调用sdscatlen</li>
<li>sds sdscatsds(sds s, const sds t)：concat2个sds</li>
<li>sds sdscpylen(sds s, const char *t, size_t len)：把t复制进sds</li>
<li>sds sdscpy(sds s, const char *t)：用strlen(t)去调用sdscpylen</li>
</ul>

<p>其他接口：</p>

<ul>
<li>int sdsll2str(char *s, long long value)：long long转成字符串并放进s缓冲区</li>
<li>int sdsull2str(char *s, unsigned long long v)：同上</li>
<li>sds sdsfromlonglong(long long value) ：long long转成sds</li>
<li>sds sdscatvprintf(sds s, const char *fmt, va_list ap) ：打印相关</li>
<li>sds sdscatprintf(sds s, const char *fmt, ...)：打印相关</li>
<li>sds sdscatfmt(sds s, char const *fmt, ...)：格式化相关</li>
<li>sds sdstrim(sds s, const char *cset) ：trim掉头尾连续字符串，用cset识别</li>
<li>void sdsrange(sds s, ssize_t start, ssize_t end)：返回s的子串</li>
<li>void sdstolower(sds s)：转小写</li>
<li>void sdstoupper(sds s)：转大写</li>
<li>int sdscmp(const sds s1, const sds s2)：比较两个sds</li>
<li>sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count)：用指定的sep字符串切割sds</li>
<li>void sdsfreesplitres(sds *tokens, int count)：sdssplitlen、sdssplitargs后要调用这个释放数组</li>
<li>sds sdscatrepr(sds s, const char *p, size_t len) ：concat p串，p会被转成escaped的串</li>
<li>int is_hex_digit(char c)：判断是不是hex字符</li>
<li>int hex_digit_to_int(char c)：hex字符转int</li>
<li>sds *sdssplitargs(const char *line, int *argc)：把用空格间隔的参数列表转成sds数组</li>
<li>sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) ：sdsmapchars(mystring, &quot;ho&quot;, &quot;01&quot;, 2)，&quot;hello&quot; -&gt; &quot;0ell1&quot;</li>
<li>sds sdsjoin(char **argv, int argc, char *sep)：join一组C字符串</li>
<li>sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen)：join一组SDS对象</li>
</ul>

<h2>adlist 泛型双向链表</h2>

<h3>基本特点</h3>

<ul>
<li>增加一个len字段用来记录链表长度，使得获取链表长度O(1)</li>
</ul>

<p>泛型原理：</p>

<ul>
<li>value字段用void*类型，使得可以存任意类型的对象</li>
<li>list结构里存了3个函数指针：dup、free、match，使得不同类型的list可以自定义节点的复制、销毁、匹配函数</li>
</ul>

<h3>源码位置</h3>

<ul>
<li>adlist.h</li>
<li>adlist.c</li>
</ul>

<h3>结构定义</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="cm">/* Node, List, and Iterator are the only data structures used currently. */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">listNode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">listNode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">listIter</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">direction</span><span class="p">;</span>
<span class="p">}</span> <span class="n">listIter</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">list</span><span class="p">;</span>
</code></pre></div>
<h3>接口说明</h3>

<ul>
<li>list *listCreate(void); 创建新的list对象</li>
<li>void listEmpty(list *list); 清空list里的所有元素</li>
<li>void listRelease(list *list); 调用了listEmpty(list)、zfree(list)</li>
<li>list *listAddNodeHead(list *list, void *value); 创建一个存value的node并插在链表头</li>
<li>list *listAddNodeTail(list *list, void *value);创建一个存value的node并插在链表尾</li>
<li>list *listInsertNode(list *list, listNode *old_node, void *value, int after); 创建一个存value的node并插在old_node的前或后</li>
<li>void listDelNode(list *list, listNode *node); 删node</li>
<li>listIter *listGetIterator(list *list, int direction); 创建迭代器</li>
<li>listNode *listNext(listIter *iter); 根据迭代方向步进1</li>
<li>void listReleaseIterator(listIter *iter);删迭代器</li>
<li>void listRewind(list *list, listIter *li); 重置迭代器到链表头</li>
<li>void listRewindTail(list *list, listIter *li);重置迭代器到链表尾</li>
<li>list *listDup(list *orig); 复制整个链表，会调用dup接口</li>
<li>listNode *listSearchKey(list *list, void *key); 找出包含key的节点，会调用match接口</li>
<li>listNode *listIndex(list *list, long index); 模拟数组下标操作</li>
<li>void listRotate(list *list); 把tail移到head</li>
<li>void listJoin(list *l, list *o); 把整个链表o插到l末尾，并empty掉o</li>
</ul>

<h2>dict 泛型字典</h2>

<h3>基本特点</h3>

<ul>
<li>字典基于散列表</li>
<li>每个dict有2个dictht，用来实现rehashing，即扩容操作</li>
<li>rehashing是渐进式的，不是在瞬间做完</li>
<li>键冲突的解决方案是chaining，于是每个dictEntry都有一个next指针，用来构成同哈希键链表</li>
<li>因为只有next指针，所以chain是单向的，为了加速插入性能，后加入的kv，会插到链表头而不是链表尾</li>
<li>rehash和chaining的特点，使得rehashing时，新的表项都插入到dt[1]，而dt用chaing没有容量限制，于是rehashing过程总能完成</li>
</ul>

<h3>源码位置</h3>

<ul>
<li>dict.h</li>
<li>dict.c</li>
<li>siphash.c</li>
</ul>

<h3>结构定义</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictEntry</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
        <span class="kt">int64_t</span> <span class="n">s64</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span>

<span class="c1">// dictType实现泛型，在server.c里有各种dictType的定义</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictType</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="p">(</span><span class="o">*</span><span class="n">hashFunction</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">keyDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">valDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">keyCompare</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">keyDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">valDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span> <span class="n">dictType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span> <span class="c1">// 表项</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span>
    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span>
    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">long</span> <span class="n">rehashidx</span><span class="p">;</span> <span class="cm">/* rehashing not in progress if rehashidx == -1 */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iterators</span><span class="p">;</span> <span class="cm">/* number of iterators currently running */</span>
<span class="p">}</span> <span class="n">dict</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictIterator</span> <span class="p">{</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">table</span><span class="p">,</span> <span class="n">safe</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">nextEntry</span><span class="p">;</span>
    <span class="cm">/* unsafe iterator fingerprint for misuse detection. */</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">fingerprint</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictIterator</span><span class="p">;</span>

<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="n">dictScanFunction</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="n">dictScanBucketFunction</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="n">dictEntry</span> <span class="o">**</span><span class="n">bucketref</span><span class="p">);</span>

<span class="cm">/* This is the initial size of every hash table */</span>
<span class="cp">#define DICT_HT_INITIAL_SIZE     4</span>
</code></pre></div>
<h3>关键逻辑</h3>

<h4>rehashing</h4>

<p>扩容和收缩是通过dictExpand。</p>

<p>dictExpand让一个dict扩大或缩小到size（实际是_dictNextPower(size)），前提条件是used数要小于size，不然就意味着新的size不足以容纳现有的元素。</p>

<p>dictExpand最终会设置d-&gt;ht[1] = n 和 d-&gt;rehashidx = 0; 启动rehashing程序。</p>

<p>之后，dict.c里有大量地方用dictIsRehashing宏，走不同的逻辑，处理rehashing。</p>

<p>rehashing的迭代接口是dictRehash，参数n表示此次要迭代多少步。</p>

<p>调用dictRehash的地方：</p>

<p>_dictRehashStep里调用dictRehash(d,1)
dictRehashMilliseconds里调用dictRehash(d,100)，超时了就结束迭代。dictRehashMilliseconds只在server.c里调用。</p>

<p>调用dictExpand的地方：</p>

<ul>
<li>dictResize：把dict缩小到used大小，使得空间利用率尽量靠近1。dictResize并不在dict.c调用，所以是由上层策略决定的，实际上是根据htNeedsResize，即ratio小于0.1时，就会开始收缩。</li>
<li>_dictKeyIndex：每次调用都会执行_dictExpandIfNeeded，如果used已经大于size且两者之比ratio大于5，就调用dictExpand开始扩容（说明有很多chain了）</li>
</ul>

<p>每次dictExpand，都会创建一个dictht，并分配空间：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="n">n</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">zcalloc</span><span class="p">(</span><span class="n">realsize</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dictEntry</span><span class="o">*</span><span class="p">));</span> <span class="c1">// realsize个桶</span>
</code></pre></div>
<p>dictRehash的rehashing完成时：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="cm">/* Check if we already rehashed the whole table... */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">_dictReset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<h4>缺省哈希函数：siphash</h4>

<p>缺省哈希函数是siphash，以前是murmurhash2。</p>

<p>跟踪dictType的hashFunction调用，最终会找到dict.c里的：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="kt">uint64_t</span> <span class="nf">siphash</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
<span class="kt">uint64_t</span> <span class="nf">siphash_nocase</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">inlen</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">k</span><span class="p">);</span>
</code></pre></div>
<p>这2个函数是在 siphash.c里定义的，siphash.c有且只有这2个函数。</p>

<p>k是dict_hash_function_seed，一个dict.c里的静态全局变量，在服务启动时初始化。</p>

<h2>zskiplist 跳跃表</h2>

<h3>基本特点</h3>

<ul>
<li>用来存放有序集合（zset）</li>
<li>集合元素不能重复，但分值score可以重复</li>
<li>最高level是64，旧版本是32（ZSKIPLIST_MAXLEVEL）</li>
</ul>

<h3>源码位置</h3>

<ul>
<li>server.h</li>
<li>t_zset.c</li>
</ul>

<h3>结构定义</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">ele</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">backward</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
<span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>
</code></pre></div>
<p>表头节点是特殊的，不存数据（ele、score无用）。</p>

<h3>资料</h3>

<p>精简的skiplist实现：</p>

<p><a href="https://github.com/begeekmyfriend/skiplist">https://github.com/begeekmyfriend/skiplist</a></p>

<h2>intset 整数集合</h2>

<h3>基本特点</h3>

<h2>- 用紧凑的数组结构来存放集合元素，访问效率很高</h2>

<h3>源码位置</h3>

<ul>
<li>intset.h</li>
<li>intset.c</li>
</ul>

<h3>结构定义</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">intset</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">encoding</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int8_t</span> <span class="n">contents</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">intset</span><span class="p">;</span>
</code></pre></div>
<h3>接口说明</h3>

<p>内部接口：</p>

<ul>
<li>uint8_t _intsetValueEncoding(int64_t v) 根据v的值范围，返回INTSET_ENC_INT64/INTSET_ENC_INT32/INTSET_ENC_INT16</li>
</ul>

<p>对外接口：</p>

<ul>
<li>intset *intsetNew(void); zmalloc一个intset，缺省编码是INTSET_ENC_INT16，contents为空</li>
<li>intset *intsetAdd(intset *is, int64_t value, uint8_t *success); 看下文。</li>
<li>intset *intsetRemove(intset *is, int64_t value, int *success);</li>
<li>uint8_t intsetFind(intset *is, int64_t value);</li>
<li>int64_t intsetRandom(intset *is);</li>
<li>uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);</li>
<li>uint32_t intsetLen(const intset *is);</li>
<li>size_t intsetBlobLen(intset *is);</li>
</ul>

<h3>关键逻辑</h3>

<h4>intsetAdd(intset *is, int64_t value, uint8_t *success);</h4>

<p>先获取value的编码，然后对比is的编码，如果value编码大于is的编码，那么转而执行intsetUpgradeAndAdd(is,value)，没有传入success是因为value肯定不在集合中，毕竟越界了；如果value编码小于等于is的编码，就要检查value是不是已经在集合中（调用intsetSearch(is,value,&amp;pos)），如果在，那么中止，如果不在，pos会设成value可以插入的位置，intsetResize这个is到length
 + 1，并判断pos是不是小于newlength - 1，是的话意味着插入位置后面还有元素，那么要把pos后的元素全体向右挪1（intsetMoveTail）。</p>

<p>最后，调用_intsetSet(is,pos,value)，把value放进pos位置，并更新is-&gt;length。</p>

<h1>参考资料：</h1>

<p><a href="https://blog.csdn.net/z69183787/article/details/81121779">https://blog.csdn.net/z69183787/article/details/81121779</a></p>

    </div>
    <div class="entry">
        (未经授权禁止转载)
    </div>
    <div class="date">
        Written on July 24, 2018
    </div>
    <p>博主将十分感谢对本文章的任意金额的打赏^_^</p>
    <img src="../images/dashang1.jpeg" />
    <img src="../images/dashang2.jpeg" />
    
    
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'qiujiawei';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</article>



    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:voyagingmk@gmail.com"><i class="svg-icon email"></i></a>


<a href="http://github.com/barryclark/jekyll-now"><i class="svg-icon github"></i></a>




<a href="http://twitter.com/voyagingmk"><i class="svg-icon twitter"></i></a>


        </footer>
      </div>
    </div>

  </body>
</html>
